// coverage:ignore-file
// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to libgit2
class Libgit2 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Libgit2(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Libgit2.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int clock() {
    return _clock();
  }

  late final _clockPtr =
      _lookup<ffi.NativeFunction<clock_t Function()>>('clock');
  late final _clock = _clockPtr.asFunction<int Function()>();

  int time(
    ffi.Pointer<time_t> __timer,
  ) {
    return _time(
      __timer,
    );
  }

  late final _timePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<time_t>)>>('time');
  late final _time = _timePtr.asFunction<int Function(ffi.Pointer<time_t>)>();

  double difftime(
    int __time1,
    int __time0,
  ) {
    return _difftime(
      __time1,
      __time0,
    );
  }

  late final _difftimePtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(time_t, time_t)>>(
          'difftime');
  late final _difftime = _difftimePtr.asFunction<double Function(int, int)>();

  int mktime(
    ffi.Pointer<tm> __tp,
  ) {
    return _mktime(
      __tp,
    );
  }

  late final _mktimePtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('mktime');
  late final _mktime = _mktimePtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int strftime(
    ffi.Pointer<ffi.Char> __s,
    int __maxsize,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<tm> __tp,
  ) {
    return _strftime(
      __s,
      __maxsize,
      __format,
      __tp,
    );
  }

  late final _strftimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>)>>('strftime');
  late final _strftime = _strftimePtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<tm>)>();

  int strftime_l(
    ffi.Pointer<ffi.Char> __s,
    int __maxsize,
    ffi.Pointer<ffi.Char> __format,
    ffi.Pointer<tm> __tp,
    locale_t __loc,
  ) {
    return _strftime_l(
      __s,
      __maxsize,
      __format,
      __tp,
      __loc,
    );
  }

  late final _strftime_lPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<ffi.Char>, ffi.Pointer<tm>, locale_t)>>('strftime_l');
  late final _strftime_l = _strftime_lPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>,
          ffi.Pointer<tm>, locale_t)>();

  ffi.Pointer<tm> gmtime(
    ffi.Pointer<time_t> __timer,
  ) {
    return _gmtime(
      __timer,
    );
  }

  late final _gmtimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>(
      'gmtime');
  late final _gmtime =
      _gmtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  ffi.Pointer<tm> localtime(
    ffi.Pointer<time_t> __timer,
  ) {
    return _localtime(
      __timer,
    );
  }

  late final _localtimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>>(
      'localtime');
  late final _localtime =
      _localtimePtr.asFunction<ffi.Pointer<tm> Function(ffi.Pointer<time_t>)>();

  ffi.Pointer<tm> gmtime_r(
    ffi.Pointer<time_t> __timer,
    ffi.Pointer<tm> __tp,
  ) {
    return _gmtime_r(
      __timer,
      __tp,
    );
  }

  late final _gmtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('gmtime_r');
  late final _gmtime_r = _gmtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  ffi.Pointer<tm> localtime_r(
    ffi.Pointer<time_t> __timer,
    ffi.Pointer<tm> __tp,
  ) {
    return _localtime_r(
      __timer,
      __tp,
    );
  }

  late final _localtime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<tm> Function(
              ffi.Pointer<time_t>, ffi.Pointer<tm>)>>('localtime_r');
  late final _localtime_r = _localtime_rPtr.asFunction<
      ffi.Pointer<tm> Function(ffi.Pointer<time_t>, ffi.Pointer<tm>)>();

  ffi.Pointer<ffi.Char> asctime(
    ffi.Pointer<tm> __tp,
  ) {
    return _asctime(
      __tp,
    );
  }

  late final _asctimePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>>(
      'asctime');
  late final _asctime =
      _asctimePtr.asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>)>();

  ffi.Pointer<ffi.Char> ctime(
    ffi.Pointer<time_t> __timer,
  ) {
    return _ctime(
      __timer,
    );
  }

  late final _ctimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>>('ctime');
  late final _ctime = _ctimePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<time_t>)>();

  ffi.Pointer<ffi.Char> asctime_r(
    ffi.Pointer<tm> __tp,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _asctime_r(
      __tp,
      __buf,
    );
  }

  late final _asctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>>('asctime_r');
  late final _asctime_r = _asctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<tm>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> ctime_r(
    ffi.Pointer<time_t> __timer,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _ctime_r(
      __timer,
      __buf,
    );
  }

  late final _ctime_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>>('ctime_r');
  late final _ctime_r = _ctime_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<time_t>, ffi.Pointer<ffi.Char>)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> ___tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('__tzname');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get __tzname => ___tzname.value;

  set __tzname(ffi.Pointer<ffi.Pointer<ffi.Char>> value) =>
      ___tzname.value = value;

  late final ffi.Pointer<ffi.Int> ___daylight = _lookup<ffi.Int>('__daylight');

  int get __daylight => ___daylight.value;

  set __daylight(int value) => ___daylight.value = value;

  late final ffi.Pointer<ffi.Long> ___timezone =
      _lookup<ffi.Long>('__timezone');

  int get __timezone => ___timezone.value;

  set __timezone(int value) => ___timezone.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Char>>> _tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Char>>>('tzname');

  ffi.Pointer<ffi.Pointer<ffi.Char>> get tzname => _tzname.value;

  set tzname(ffi.Pointer<ffi.Pointer<ffi.Char>> value) => _tzname.value = value;

  void tzset() {
    return _tzset();
  }

  late final _tzsetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('tzset');
  late final _tzset = _tzsetPtr.asFunction<void Function()>();

  late final ffi.Pointer<ffi.Int> _daylight = _lookup<ffi.Int>('daylight');

  int get daylight => _daylight.value;

  set daylight(int value) => _daylight.value = value;

  late final ffi.Pointer<ffi.Long> _timezone = _lookup<ffi.Long>('timezone');

  int get timezone => _timezone.value;

  set timezone(int value) => _timezone.value = value;

  int timegm(
    ffi.Pointer<tm> __tp,
  ) {
    return _timegm(
      __tp,
    );
  }

  late final _timegmPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>('timegm');
  late final _timegm = _timegmPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int timelocal(
    ffi.Pointer<tm> __tp,
  ) {
    return _timelocal(
      __tp,
    );
  }

  late final _timelocalPtr =
      _lookup<ffi.NativeFunction<time_t Function(ffi.Pointer<tm>)>>(
          'timelocal');
  late final _timelocal =
      _timelocalPtr.asFunction<int Function(ffi.Pointer<tm>)>();

  int dysize(
    int __year,
  ) {
    return _dysize(
      __year,
    );
  }

  late final _dysizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('dysize');
  late final _dysize = _dysizePtr.asFunction<int Function(int)>();

  int nanosleep(
    ffi.Pointer<timespec> __requested_time,
    ffi.Pointer<timespec> __remaining,
  ) {
    return _nanosleep(
      __requested_time,
      __remaining,
    );
  }

  late final _nanosleepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<timespec>, ffi.Pointer<timespec>)>>('nanosleep');
  late final _nanosleep = _nanosleepPtr
      .asFunction<int Function(ffi.Pointer<timespec>, ffi.Pointer<timespec>)>();

  int clock_getres(
    int __clock_id,
    ffi.Pointer<timespec> __res,
  ) {
    return _clock_getres(
      __clock_id,
      __res,
    );
  }

  late final _clock_getresPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Pointer<timespec>)>>('clock_getres');
  late final _clock_getres =
      _clock_getresPtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int clock_gettime(
    int __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_gettime(
      __clock_id,
      __tp,
    );
  }

  late final _clock_gettimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Pointer<timespec>)>>('clock_gettime');
  late final _clock_gettime =
      _clock_gettimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int clock_settime(
    int __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_settime(
      __clock_id,
      __tp,
    );
  }

  late final _clock_settimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Pointer<timespec>)>>('clock_settime');
  late final _clock_settime =
      _clock_settimePtr.asFunction<int Function(int, ffi.Pointer<timespec>)>();

  int clock_nanosleep(
    int __clock_id,
    int __flags,
    ffi.Pointer<timespec> __req,
    ffi.Pointer<timespec> __rem,
  ) {
    return _clock_nanosleep(
      __clock_id,
      __flags,
      __req,
      __rem,
    );
  }

  late final _clock_nanosleepPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Int, ffi.Pointer<timespec>,
              ffi.Pointer<timespec>)>>('clock_nanosleep');
  late final _clock_nanosleep = _clock_nanosleepPtr.asFunction<
      int Function(int, int, ffi.Pointer<timespec>, ffi.Pointer<timespec>)>();

  int clock_getcpuclockid(
    int __pid,
    ffi.Pointer<clockid_t> __clock_id,
  ) {
    return _clock_getcpuclockid(
      __pid,
      __clock_id,
    );
  }

  late final _clock_getcpuclockidPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(pid_t, ffi.Pointer<clockid_t>)>>(
      'clock_getcpuclockid');
  late final _clock_getcpuclockid = _clock_getcpuclockidPtr
      .asFunction<int Function(int, ffi.Pointer<clockid_t>)>();

  int timer_create(
    int __clock_id,
    ffi.Pointer<sigevent> __evp,
    ffi.Pointer<timer_t> __timerid,
  ) {
    return _timer_create(
      __clock_id,
      __evp,
      __timerid,
    );
  }

  late final _timer_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(clockid_t, ffi.Pointer<sigevent>,
              ffi.Pointer<timer_t>)>>('timer_create');
  late final _timer_create = _timer_createPtr.asFunction<
      int Function(int, ffi.Pointer<sigevent>, ffi.Pointer<timer_t>)>();

  int timer_delete(
    timer_t __timerid,
  ) {
    return _timer_delete(
      __timerid,
    );
  }

  late final _timer_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(timer_t)>>('timer_delete');
  late final _timer_delete =
      _timer_deletePtr.asFunction<int Function(timer_t)>();

  int timer_settime(
    timer_t __timerid,
    int __flags,
    ffi.Pointer<itimerspec> __value,
    ffi.Pointer<itimerspec> __ovalue,
  ) {
    return _timer_settime(
      __timerid,
      __flags,
      __value,
      __ovalue,
    );
  }

  late final _timer_settimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(timer_t, ffi.Int, ffi.Pointer<itimerspec>,
              ffi.Pointer<itimerspec>)>>('timer_settime');
  late final _timer_settime = _timer_settimePtr.asFunction<
      int Function(
          timer_t, int, ffi.Pointer<itimerspec>, ffi.Pointer<itimerspec>)>();

  int timer_gettime(
    timer_t __timerid,
    ffi.Pointer<itimerspec> __value,
  ) {
    return _timer_gettime(
      __timerid,
      __value,
    );
  }

  late final _timer_gettimePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(timer_t, ffi.Pointer<itimerspec>)>>('timer_gettime');
  late final _timer_gettime = _timer_gettimePtr
      .asFunction<int Function(timer_t, ffi.Pointer<itimerspec>)>();

  int timer_getoverrun(
    timer_t __timerid,
  ) {
    return _timer_getoverrun(
      __timerid,
    );
  }

  late final _timer_getoverrunPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(timer_t)>>(
          'timer_getoverrun');
  late final _timer_getoverrun =
      _timer_getoverrunPtr.asFunction<int Function(timer_t)>();

  int timespec_get(
    ffi.Pointer<timespec> __ts,
    int __base,
  ) {
    return _timespec_get(
      __ts,
      __base,
    );
  }

  late final _timespec_getPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<timespec>, ffi.Int)>>(
      'timespec_get');
  late final _timespec_get =
      _timespec_getPtr.asFunction<int Function(ffi.Pointer<timespec>, int)>();

  int __ctype_get_mb_cur_max() {
    return ___ctype_get_mb_cur_max();
  }

  late final ___ctype_get_mb_cur_maxPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function()>>(
          '__ctype_get_mb_cur_max');
  late final ___ctype_get_mb_cur_max =
      ___ctype_get_mb_cur_maxPtr.asFunction<int Function()>();

  double atof(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atof(
      __nptr,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoi(
      __nptr,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atol(
      __nptr,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> __nptr,
  ) {
    return _atoll(
      __nptr,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double strtod(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtod(
      __nptr,
      __endptr,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
  ) {
    return _strtof(
      __nptr,
      __endptr,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  ffi.Pointer<ffi.Char> l64a(
    int __n,
  ) {
    return _l64a(
      __n,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> __s,
  ) {
    return _a64l(
      __s,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int select(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timeval> __timeout,
  ) {
    return _select(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
    );
  }

  late final _selectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>>('select');
  late final _select = _selectPtr.asFunction<
      int Function(int, ffi.Pointer<fd_set>, ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>, ffi.Pointer<timeval>)>();

  int pselect(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timespec> __timeout,
    ffi.Pointer<__sigset_t> __sigmask,
  ) {
    return _pselect(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
      __sigmask,
    );
  }

  late final _pselectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<fd_set>,
              ffi.Pointer<timespec>,
              ffi.Pointer<__sigset_t>)>>('pselect');
  late final _pselect = _pselectPtr.asFunction<
      int Function(
          int,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<fd_set>,
          ffi.Pointer<timespec>,
          ffi.Pointer<__sigset_t>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  void srandom(
    int __seed,
  ) {
    return _srandom(
      __seed,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
  ) {
    return _initstate(
      __seed,
      __statebuf,
      __statelen,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> __statebuf,
  ) {
    return _setstate(
      __statebuf,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int random_r(
    ffi.Pointer<random_data> __buf,
    ffi.Pointer<ffi.Int32> __result,
  ) {
    return _random_r(
      __buf,
      __result,
    );
  }

  late final _random_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>>('random_r');
  late final _random_r = _random_rPtr.asFunction<
      int Function(ffi.Pointer<random_data>, ffi.Pointer<ffi.Int32>)>();

  int srandom_r(
    int __seed,
    ffi.Pointer<random_data> __buf,
  ) {
    return _srandom_r(
      __seed,
      __buf,
    );
  }

  late final _srandom_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.UnsignedInt, ffi.Pointer<random_data>)>>('srandom_r');
  late final _srandom_r =
      _srandom_rPtr.asFunction<int Function(int, ffi.Pointer<random_data>)>();

  int initstate_r(
    int __seed,
    ffi.Pointer<ffi.Char> __statebuf,
    int __statelen,
    ffi.Pointer<random_data> __buf,
  ) {
    return _initstate_r(
      __seed,
      __statebuf,
      __statelen,
      __buf,
    );
  }

  late final _initstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<random_data>)>>('initstate_r');
  late final _initstate_r = _initstate_rPtr.asFunction<
      int Function(
          int, ffi.Pointer<ffi.Char>, int, ffi.Pointer<random_data>)>();

  int setstate_r(
    ffi.Pointer<ffi.Char> __statebuf,
    ffi.Pointer<random_data> __buf,
  ) {
    return _setstate_r(
      __statebuf,
      __buf,
    );
  }

  late final _setstate_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>>('setstate_r');
  late final _setstate_r = _setstate_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<random_data>)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int __seed,
  ) {
    return _srand(
      __seed,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> __seed,
  ) {
    return _rand_r(
      __seed,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _erand48(
      __xsubi,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _nrand48(
      __xsubi,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
  ) {
    return _jrand48(
      __xsubi,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  void srand48(
    int __seedval,
  ) {
    return _srand48(
      __seedval,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
  ) {
    return _seed48(
      __seed16v,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> __param,
  ) {
    return _lcong48(
      __param,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int drand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _drand48_r(
      __buffer,
      __result,
    );
  }

  late final _drand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('drand48_r');
  late final _drand48_r = _drand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Double>)>();

  int erand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _erand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _erand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>,
              ffi.Pointer<ffi.Double>)>>('erand48_r');
  late final _erand48_r = _erand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Double>)>();

  int lrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _lrand48_r(
      __buffer,
      __result,
    );
  }

  late final _lrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('lrand48_r');
  late final _lrand48_r = _lrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int nrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _nrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _nrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('nrand48_r');
  late final _nrand48_r = _nrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int mrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _mrand48_r(
      __buffer,
      __result,
    );
  }

  late final _mrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('mrand48_r');
  late final _mrand48_r = _mrand48_rPtr.asFunction<
      int Function(ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>();

  int jrand48_r(
    ffi.Pointer<ffi.UnsignedShort> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Long> __result,
  ) {
    return _jrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _jrand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>, ffi.Pointer<ffi.Long>)>>('jrand48_r');
  late final _jrand48_r = _jrand48_rPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>,
          ffi.Pointer<ffi.Long>)>();

  int srand48_r(
    int __seedval,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _srand48_r(
      __seedval,
      __buffer,
    );
  }

  late final _srand48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Long, ffi.Pointer<drand48_data>)>>('srand48_r');
  late final _srand48_r =
      _srand48_rPtr.asFunction<int Function(int, ffi.Pointer<drand48_data>)>();

  int seed48_r(
    ffi.Pointer<ffi.UnsignedShort> __seed16v,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _seed48_r(
      __seed16v,
      __buffer,
    );
  }

  late final _seed48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('seed48_r');
  late final _seed48_r = _seed48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  int lcong48_r(
    ffi.Pointer<ffi.UnsignedShort> __param,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _lcong48_r(
      __param,
      __buffer,
    );
  }

  late final _lcong48_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedShort>,
              ffi.Pointer<drand48_data>)>>('lcong48_r');
  late final _lcong48_r = _lcong48_rPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.UnsignedShort>, ffi.Pointer<drand48_data>)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __nmemb,
    int __size,
  ) {
    return _calloc(
      __nmemb,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  void free(
    ffi.Pointer<ffi.Void> __ptr,
  ) {
    return _free(
      __ptr,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> reallocarray(
    ffi.Pointer<ffi.Void> __ptr,
    int __nmemb,
    int __size,
  ) {
    return _reallocarray(
      __ptr,
      __nmemb,
      __size,
    );
  }

  late final _reallocarrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('reallocarray');
  late final _reallocarray = _reallocarrayPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> reallocarray1(
    ffi.Pointer<ffi.Void> __ptr,
    int __nmemb,
    int __size,
  ) {
    return _reallocarray1(
      __ptr,
      __nmemb,
      __size,
    );
  }

  late final _reallocarray1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size)>>('reallocarray');
  late final _reallocarray1 = _reallocarray1Ptr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _atexit(
      __func,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> __func,
  ) {
    return _at_quick_exit(
      __func,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int on_exit(
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>>
        __func,
    ffi.Pointer<ffi.Void> __arg,
  ) {
    return _on_exit(
      __func,
      __arg,
    );
  }

  late final _on_exitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>>,
              ffi.Pointer<ffi.Void>)>>('on_exit');
  late final _on_exit = _on_exitPtr.asFunction<
      int Function(
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Void>)>>,
          ffi.Pointer<ffi.Void>)>();

  void exit(
    int __status,
  ) {
    return _exit(
      __status,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  void quick_exit(
    int __status,
  ) {
    return _quick_exit(
      __status,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  void _Exit(
    int __status,
  ) {
    return __Exit(
      __status,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _getenv(
      __name,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int putenv(
    ffi.Pointer<ffi.Char> __string,
  ) {
    return _putenv(
      __string,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __replace,
  ) {
    return _setenv(
      __name,
      __value,
      __replace,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> __name,
  ) {
    return _unsetenv(
      __name,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int clearenv() {
    return _clearenv();
  }

  late final _clearenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('clearenv');
  late final _clearenv = _clearenvPtr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mktemp(
      __template,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkstemp(
      __template,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mkstemps(
    ffi.Pointer<ffi.Char> __template,
    int __suffixlen,
  ) {
    return _mkstemps(
      __template,
      __suffixlen,
    );
  }

  late final _mkstempsPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Int)>>(
      'mkstemps');
  late final _mkstemps =
      _mkstempsPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> mkdtemp(
    ffi.Pointer<ffi.Char> __template,
  ) {
    return _mkdtemp(
      __template,
    );
  }

  late final _mkdtempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mkdtemp');
  late final _mkdtemp = _mkdtempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int system(
    ffi.Pointer<ffi.Char> __command,
  ) {
    return _system(
      __command,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __resolved,
  ) {
    return _realpath(
      __name,
      __resolved,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              __compar_fn_t)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    __compar_fn_t __compar,
  ) {
    return _qsort(
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size, ffi.Size,
              __compar_fn_t)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(ffi.Pointer<ffi.Void>, int, int, __compar_fn_t)>();

  int abs(
    int __x,
  ) {
    return _abs(
      __x,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int labs(
    int __x,
  ) {
    return _labs(
      __x,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  int llabs(
    int __x,
  ) {
    return _llabs(
      __x,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  div_t div(
    int __numer,
    int __denom,
  ) {
    return _div(
      __numer,
      __denom,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  ldiv_t ldiv(
    int __numer,
    int __denom,
  ) {
    return _ldiv(
      __numer,
      __denom,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  lldiv_t lldiv(
    int __numer,
    int __denom,
  ) {
    return _lldiv(
      __numer,
      __denom,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  ffi.Pointer<ffi.Char> ecvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _ecvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
  ) {
    return _fcvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Char> __buf,
  ) {
    return _gcvt(
      __value,
      __ndigit,
      __buf,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int ecvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _ecvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _ecvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('ecvt_r');
  late final _ecvt_r = _ecvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int fcvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int> __decpt,
    ffi.Pointer<ffi.Int> __sign,
    ffi.Pointer<ffi.Char> __buf,
    int __len,
  ) {
    return _fcvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _fcvt_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Double,
              ffi.Int,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('fcvt_r');
  late final _fcvt_r = _fcvt_rPtr.asFunction<
      int Function(double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
          ffi.Pointer<ffi.Char>, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> __pwc,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbtowc(
      __pwc,
      __s,
      __n,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> __s,
    int __wchar,
  ) {
    return _wctomb(
      __s,
      __wchar,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> __pwcs,
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mbstowcs(
      __pwcs,
      __s,
      __n,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> __s,
    ffi.Pointer<ffi.WChar> __pwcs,
    int __n,
  ) {
    return _wcstombs(
      __s,
      __pwcs,
      __n,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> __response,
  ) {
    return _rpmatch(
      __response,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> __optionp,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __tokens,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __valuep,
  ) {
    return _getsubopt(
      __optionp,
      __tokens,
      __valuep,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> __loadavg,
    int __nelem,
  ) {
    return _getloadavg(
      __loadavg,
      __nelem,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  int imaxabs(
    int __n,
  ) {
    return _imaxabs(
      __n,
    );
  }

  late final _imaxabsPtr =
      _lookup<ffi.NativeFunction<intmax_t Function(intmax_t)>>('imaxabs');
  late final _imaxabs = _imaxabsPtr.asFunction<int Function(int)>();

  imaxdiv_t imaxdiv(
    int __numer,
    int __denom,
  ) {
    return _imaxdiv(
      __numer,
      __denom,
    );
  }

  late final _imaxdivPtr =
      _lookup<ffi.NativeFunction<imaxdiv_t Function(intmax_t, intmax_t)>>(
          'imaxdiv');
  late final _imaxdiv = _imaxdivPtr.asFunction<imaxdiv_t Function(int, int)>();

  int strtoimax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoimax');
  late final _strtoimax = _strtoimaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoumax(
    ffi.Pointer<ffi.Char> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoumax');
  late final _strtoumax = _strtoumaxPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int wcstoimax(
    ffi.Pointer<__gwchar_t> __nptr,
    ffi.Pointer<ffi.Pointer<__gwchar_t>> __endptr,
    int __base,
  ) {
    return _wcstoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoimaxPtr = _lookup<
      ffi.NativeFunction<
          intmax_t Function(ffi.Pointer<__gwchar_t>,
              ffi.Pointer<ffi.Pointer<__gwchar_t>>, ffi.Int)>>('wcstoimax');
  late final _wcstoimax = _wcstoimaxPtr.asFunction<
      int Function(ffi.Pointer<__gwchar_t>,
          ffi.Pointer<ffi.Pointer<__gwchar_t>>, int)>();

  int wcstoumax(
    ffi.Pointer<__gwchar_t> __nptr,
    ffi.Pointer<ffi.Pointer<__gwchar_t>> __endptr,
    int __base,
  ) {
    return _wcstoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoumaxPtr = _lookup<
      ffi.NativeFunction<
          uintmax_t Function(ffi.Pointer<__gwchar_t>,
              ffi.Pointer<ffi.Pointer<__gwchar_t>>, ffi.Int)>>('wcstoumax');
  late final _wcstoumax = _wcstoumaxPtr.asFunction<
      int Function(ffi.Pointer<__gwchar_t>,
          ffi.Pointer<ffi.Pointer<__gwchar_t>>, int)>();

  /// Return the version of the libgit2 library
  /// being currently used.
  ///
  /// @param major Store the major version number
  /// @param minor Store the minor version number
  /// @param rev Store the revision (patch) number
  /// @return 0 on success or an error code on failure
  int git_libgit2_version(
    ffi.Pointer<ffi.Int> major,
    ffi.Pointer<ffi.Int> minor,
    ffi.Pointer<ffi.Int> rev,
  ) {
    return _git_libgit2_version(
      major,
      minor,
      rev,
    );
  }

  late final _git_libgit2_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Int>)>>('git_libgit2_version');
  late final _git_libgit2_version = _git_libgit2_versionPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  /// Return the prerelease state of the libgit2 library currently being
  /// used.  For nightly builds during active development, this will be
  /// "alpha".  Releases may have a "beta" or release candidate ("rc1",
  /// "rc2", etc) prerelease.  For a final release, this function returns
  /// NULL.
  ///
  /// @return the name of the prerelease state or NULL
  ffi.Pointer<ffi.Char> git_libgit2_prerelease() {
    return _git_libgit2_prerelease();
  }

  late final _git_libgit2_prereleasePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'git_libgit2_prerelease');
  late final _git_libgit2_prerelease =
      _git_libgit2_prereleasePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  /// Query compile time options for libgit2.
  ///
  /// @return A combination of GIT_FEATURE_* values.
  ///
  /// - GIT_FEATURE_THREADS
  /// Libgit2 was compiled with thread support. Note that thread support is
  /// still to be seen as a 'work in progress' - basic object lookups are
  /// believed to be threadsafe, but other operations may not be.
  ///
  /// - GIT_FEATURE_HTTPS
  /// Libgit2 supports the https:// protocol. This requires the openssl
  /// library to be found when compiling libgit2.
  ///
  /// - GIT_FEATURE_SSH
  /// Libgit2 supports the SSH protocol for network operations. This requires
  /// the libssh2 library to be found when compiling libgit2
  ///
  /// - GIT_FEATURE_NSEC
  /// Libgit2 supports the sub-second resolution in file modification times.
  int git_libgit2_features() {
    return _git_libgit2_features();
  }

  late final _git_libgit2_featuresPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('git_libgit2_features');
  late final _git_libgit2_features =
      _git_libgit2_featuresPtr.asFunction<int Function()>();

  /// Set or query a library global option
  ///
  /// Available options:
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_SIZE, size_t *):
  ///
  /// > Get the maximum mmap window size
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_SIZE, size_t):
  ///
  /// > Set the maximum mmap window size
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_MAPPED_LIMIT, size_t *):
  ///
  /// > Get the maximum memory that will be mapped in total by the library
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_MAPPED_LIMIT, size_t):
  ///
  /// > Set the maximum amount of memory that can be mapped at any time
  /// > by the library
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_FILE_LIMIT, size_t *):
  ///
  /// > Get the maximum number of files that will be mapped at any time by the
  /// > library
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_FILE_LIMIT, size_t):
  ///
  /// > Set the maximum number of files that can be mapped at any time
  /// > by the library. The default (0) is unlimited.
  ///
  /// * opts(GIT_OPT_GET_SEARCH_PATH, int level, git_buf *buf)
  ///
  /// > Get the search path for a given level of config data.  "level" must
  /// > be one of `GIT_CONFIG_LEVEL_SYSTEM`, `GIT_CONFIG_LEVEL_GLOBAL`,
  /// > `GIT_CONFIG_LEVEL_XDG`, or `GIT_CONFIG_LEVEL_PROGRAMDATA`.
  /// > The search path is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_SEARCH_PATH, int level, const char *path)
  ///
  /// > Set the search path for a level of config data.  The search path
  /// > applied to shared attributes and ignore files, too.
  /// >
  /// > - `path` lists directories delimited by GIT_PATH_LIST_SEPARATOR.
  /// >   Pass NULL to reset to the default (generally based on environment
  /// >   variables).  Use magic path `$PATH` to include the old value
  /// >   of the path (if you want to prepend or append, for instance).
  /// >
  /// > - `level` must be `GIT_CONFIG_LEVEL_SYSTEM`,
  /// >   `GIT_CONFIG_LEVEL_GLOBAL`, `GIT_CONFIG_LEVEL_XDG`, or
  /// >   `GIT_CONFIG_LEVEL_PROGRAMDATA`.
  ///
  /// * opts(GIT_OPT_SET_CACHE_OBJECT_LIMIT, git_object_t type, size_t size)
  ///
  /// > Set the maximum data size for the given type of object to be
  /// > considered eligible for caching in memory.  Setting to value to
  /// > zero means that that type of object will not be cached.
  /// > Defaults to 0 for GIT_OBJECT_BLOB (i.e. won't cache blobs) and 4k
  /// > for GIT_OBJECT_COMMIT, GIT_OBJECT_TREE, and GIT_OBJECT_TAG.
  ///
  /// * opts(GIT_OPT_SET_CACHE_MAX_SIZE, ssize_t max_storage_bytes)
  ///
  /// > Set the maximum total data size that will be cached in memory
  /// > across all repositories before libgit2 starts evicting objects
  /// > from the cache.  This is a soft limit, in that the library might
  /// > briefly exceed it, but will start aggressively evicting objects
  /// > from cache when that happens.  The default cache size is 256MB.
  ///
  /// * opts(GIT_OPT_ENABLE_CACHING, int enabled)
  ///
  /// > Enable or disable caching completely.
  /// >
  /// > Because caches are repository-specific, disabling the cache
  /// > cannot immediately clear all cached objects, but each cache will
  /// > be cleared on the next attempt to update anything in it.
  ///
  /// * opts(GIT_OPT_GET_CACHED_MEMORY, ssize_t *current, ssize_t *allowed)
  ///
  /// > Get the current bytes in cache and the maximum that would be
  /// > allowed in the cache.
  ///
  /// * opts(GIT_OPT_GET_TEMPLATE_PATH, git_buf *out)
  ///
  /// > Get the default template path.
  /// > The path is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_TEMPLATE_PATH, const char *path)
  ///
  /// > Set the default template path.
  /// >
  /// > - `path` directory of template.
  ///
  /// * opts(GIT_OPT_SET_SSL_CERT_LOCATIONS, const char *file, const char *path)
  ///
  /// > Set the SSL certificate-authority locations.
  /// >
  /// > - `file` is the location of a file containing several
  /// >   certificates concatenated together.
  /// > - `path` is the location of a directory holding several
  /// >   certificates, one per file.
  /// >
  /// > Either parameter may be `NULL`, but not both.
  ///
  /// * opts(GIT_OPT_SET_USER_AGENT, const char *user_agent)
  ///
  /// > Set the value of the User-Agent header.  This value will be
  /// > appended to "git/1.0", for compatibility with other git clients.
  /// >
  /// > - `user_agent` is the value that will be delivered as the
  /// >   User-Agent header on HTTP requests.
  ///
  /// * opts(GIT_OPT_SET_WINDOWS_SHAREMODE, unsigned long value)
  ///
  /// > Set the share mode used when opening files on Windows.
  /// > For more information, see the documentation for CreateFile.
  /// > The default is: FILE_SHARE_READ | FILE_SHARE_WRITE.  This is
  /// > ignored and unused on non-Windows platforms.
  ///
  /// * opts(GIT_OPT_GET_WINDOWS_SHAREMODE, unsigned long *value)
  ///
  /// > Get the share mode used when opening files on Windows.
  ///
  /// * opts(GIT_OPT_ENABLE_STRICT_OBJECT_CREATION, int enabled)
  ///
  /// > Enable strict input validation when creating new objects
  /// > to ensure that all inputs to the new objects are valid.  For
  /// > example, when this is enabled, the parent(s) and tree inputs
  /// > will be validated when creating a new commit.  This defaults
  /// > to enabled.
  ///
  /// * opts(GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION, int enabled)
  ///
  /// > Validate the target of a symbolic ref when creating it.  For
  /// > example, `foobar` is not a valid ref, therefore `foobar` is
  /// > not a valid target for a symbolic ref by default, whereas
  /// > `refs/heads/foobar` is.  Disabling this bypasses validation
  /// > so that an arbitrary strings such as `foobar` can be used
  /// > for a symbolic ref target.  This defaults to enabled.
  ///
  /// * opts(GIT_OPT_SET_SSL_CIPHERS, const char *ciphers)
  ///
  /// > Set the SSL ciphers use for HTTPS connections.
  /// >
  /// > - `ciphers` is the list of ciphers that are eanbled.
  ///
  /// * opts(GIT_OPT_GET_USER_AGENT, git_buf *out)
  ///
  /// > Get the value of the User-Agent header.
  /// > The User-Agent is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_ENABLE_OFS_DELTA, int enabled)
  ///
  /// > Enable or disable the use of "offset deltas" when creating packfiles,
  /// > and the negotiation of them when talking to a remote server.
  /// > Offset deltas store a delta base location as an offset into the
  /// > packfile from the current location, which provides a shorter encoding
  /// > and thus smaller resultant packfiles.
  /// > Packfiles containing offset deltas can still be read.
  /// > This defaults to enabled.
  ///
  /// * opts(GIT_OPT_ENABLE_FSYNC_GITDIR, int enabled)
  ///
  /// > Enable synchronized writes of files in the gitdir using `fsync`
  /// > (or the platform equivalent) to ensure that new object data
  /// > is written to permanent storage, not simply cached.  This
  /// > defaults to disabled.
  ///
  /// opts(GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION, int enabled)
  ///
  /// > Enable strict verification of object hashsums when reading
  /// > objects from disk. This may impact performance due to an
  /// > additional checksum calculation on each object. This defaults
  /// > to enabled.
  ///
  /// opts(GIT_OPT_SET_ALLOCATOR, git_allocator *allocator)
  ///
  /// > Set the memory allocator to a different memory allocator. This
  /// > allocator will then be used to make all memory allocations for
  /// > libgit2 operations.  If the given `allocator` is NULL, then the
  /// > system default will be restored.
  ///
  /// opts(GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY, int enabled)
  ///
  /// > Ensure that there are no unsaved changes in the index before
  /// > beginning any operation that reloads the index from disk (eg,
  /// > checkout).  If there are unsaved changes, the instruction will
  /// > fail.  (Using the FORCE flag to checkout will still overwrite
  /// > these changes.)
  ///
  /// opts(GIT_OPT_GET_PACK_MAX_OBJECTS, size_t *out)
  ///
  /// > Get the maximum number of objects libgit2 will allow in a pack
  /// > file when downloading a pack file from a remote. This can be
  /// > used to limit maximum memory usage when fetching from an untrusted
  /// > remote.
  ///
  /// opts(GIT_OPT_SET_PACK_MAX_OBJECTS, size_t objects)
  ///
  /// > Set the maximum number of objects libgit2 will allow in a pack
  /// > file when downloading a pack file from a remote.
  ///
  /// opts(GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS, int enabled)
  /// > This will cause .keep file existence checks to be skipped when
  /// > accessing packfiles, which can help performance with remote filesystems.
  ///
  /// opts(GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE, int enabled)
  /// > When connecting to a server using NTLM or Negotiate
  /// > authentication, use expect/continue when POSTing data.
  /// > This option is not available on Windows.
  ///
  /// opts(GIT_OPT_SET_ODB_PACKED_PRIORITY, int priority)
  /// > Override the default priority of the packed ODB backend which
  /// > is added when default backends are assigned to a repository
  ///
  /// opts(GIT_OPT_SET_ODB_LOOSE_PRIORITY, int priority)
  /// > Override the default priority of the loose ODB backend which
  /// > is added when default backends are assigned to a repository
  ///
  /// opts(GIT_OPT_GET_EXTENSIONS, git_strarray *out)
  /// > Returns the list of git extensions that are supported.  This
  /// > is the list of built-in extensions supported by libgit2 and
  /// > custom extensions that have been added with
  /// > `GIT_OPT_SET_EXTENSIONS`.  Extensions that have been negated
  /// > will not be returned.  The returned list should be released
  /// > with `git_strarray_dispose`.
  ///
  /// opts(GIT_OPT_SET_EXTENSIONS, const char **extensions, size_t len)
  /// > Set that the given git extensions are supported by the caller.
  /// > Extensions supported by libgit2 may be negated by prefixing
  /// > them with a `!`.  For example: setting extensions to
  /// > { "!noop", "newext" } indicates that the caller does not want
  /// > to support repositories with the `noop` extension but does want
  /// > to support repositories with the `newext` extension.
  ///
  /// opts(GIT_OPT_GET_OWNER_VALIDATION, int *enabled)
  /// > Gets the owner validation setting for repository
  /// > directories.
  ///
  /// opts(GIT_OPT_SET_OWNER_VALIDATION, int enabled)
  /// > Set that repository directories should be owned by the current
  /// > user. The default is to validate ownership.
  ///
  /// @param option Option key
  /// @param ... value to set the option
  /// @return 0 on success, <0 on failure
  int git_libgit2_opts(
    int option,
  ) {
    return _git_libgit2_opts(
      option,
    );
  }

  late final _git_libgit2_optsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>(
          'git_libgit2_opts');
  late final _git_libgit2_opts =
      _git_libgit2_optsPtr.asFunction<int Function(int)>();

  /// Free the memory referred to by the git_buf.
  ///
  /// Note that this does not free the `git_buf` itself, just the memory
  /// pointed to by `buffer->ptr`.
  ///
  /// @param buffer The buffer to deallocate
  void git_buf_dispose(
    ffi.Pointer<git_buf> buffer,
  ) {
    return _git_buf_dispose(
      buffer,
    );
  }

  late final _git_buf_disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_buf>)>>(
          'git_buf_dispose');
  late final _git_buf_dispose =
      _git_buf_disposePtr.asFunction<void Function(ffi.Pointer<git_buf>)>();

  /// Parse a hex formatted object id into a git_oid.
  ///
  /// @param out oid structure the result is written into.
  /// @param str input hex string; must be pointing at the start of
  /// the hex sequence and have at least the number of bytes
  /// needed for an oid encoded in hex (40 bytes).
  /// @return 0 or an error code
  int git_oid_fromstr(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _git_oid_fromstr(
      out,
      str,
    );
  }

  late final _git_oid_fromstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>>('git_oid_fromstr');
  late final _git_oid_fromstr = _git_oid_fromstrPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>();

  /// Parse a hex formatted null-terminated string into a git_oid.
  ///
  /// @param out oid structure the result is written into.
  /// @param str input hex string; must be null-terminated.
  /// @return 0 or an error code
  int git_oid_fromstrp(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _git_oid_fromstrp(
      out,
      str,
    );
  }

  late final _git_oid_fromstrpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_oid_fromstrp');
  late final _git_oid_fromstrp = _git_oid_fromstrpPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>();

  /// Parse N characters of a hex formatted object id into a git_oid.
  ///
  /// If N is odd, the last byte's high nibble will be read in and the
  /// low nibble set to zero.
  ///
  /// @param out oid structure the result is written into.
  /// @param str input hex string of at least size `length`
  /// @param length length of the input string
  /// @return 0 or an error code
  int git_oid_fromstrn(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Char> str,
    int length,
  ) {
    return _git_oid_fromstrn(
      out,
      str,
      length,
    );
  }

  late final _git_oid_fromstrnPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('git_oid_fromstrn');
  late final _git_oid_fromstrn = _git_oid_fromstrnPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>, int)>();

  /// Copy an already raw oid into a git_oid structure.
  ///
  /// @param out oid structure the result is written into.
  /// @param raw the raw input bytes to be copied.
  /// @return 0 on success or error code
  int git_oid_fromraw(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.UnsignedChar> raw,
  ) {
    return _git_oid_fromraw(
      out,
      raw,
    );
  }

  late final _git_oid_fromrawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.UnsignedChar>)>>('git_oid_fromraw');
  late final _git_oid_fromraw = _git_oid_fromrawPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.UnsignedChar>)>();

  /// Format a git_oid into a hex string.
  ///
  /// @param out output hex string; must be pointing at the start of
  /// the hex sequence and have at least the number of bytes
  /// needed for an oid encoded in hex (40 bytes). Only the
  /// oid digits are written; a '\\0' terminator must be added
  /// by the caller if it is required.
  /// @param id oid structure to format.
  /// @return 0 on success or error code
  int git_oid_fmt(
    ffi.Pointer<ffi.Char> out,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_fmt(
      out,
      id,
    );
  }

  late final _git_oid_fmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>)>>('git_oid_fmt');
  late final _git_oid_fmt = _git_oid_fmtPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>)>();

  /// Format a git_oid into a partial hex string.
  ///
  /// @param out output hex string; you say how many bytes to write.
  /// If the number of bytes is > GIT_OID_HEXSZ, extra bytes
  /// will be zeroed; if not, a '\0' terminator is NOT added.
  /// @param n number of characters to write into out string
  /// @param id oid structure to format.
  /// @return 0 on success or error code
  int git_oid_nfmt(
    ffi.Pointer<ffi.Char> out,
    int n,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_nfmt(
      out,
      n,
      id,
    );
  }

  late final _git_oid_nfmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<git_oid>)>>('git_oid_nfmt');
  late final _git_oid_nfmt = _git_oid_nfmtPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, ffi.Pointer<git_oid>)>();

  /// Format a git_oid into a loose-object path string.
  ///
  /// The resulting string is "aa/...", where "aa" is the first two
  /// hex digits of the oid and "..." is the remaining 38 digits.
  ///
  /// @param out output hex string; must be pointing at the start of
  /// the hex sequence and have at least the number of bytes
  /// needed for an oid encoded in hex (41 bytes). Only the
  /// oid digits are written; a '\\0' terminator must be added
  /// by the caller if it is required.
  /// @param id oid structure to format.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_oid_pathfmt(
    ffi.Pointer<ffi.Char> out,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_pathfmt(
      out,
      id,
    );
  }

  late final _git_oid_pathfmtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>)>>('git_oid_pathfmt');
  late final _git_oid_pathfmt = _git_oid_pathfmtPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>)>();

  /// Format a git_oid into a statically allocated c-string.
  ///
  /// The c-string is owned by the library and should not be freed
  /// by the user. If libgit2 is built with thread support, the string
  /// will be stored in TLS (i.e. one buffer per thread) to allow for
  /// concurrent calls of the function.
  ///
  /// @param oid The oid structure to format
  /// @return the c-string
  ffi.Pointer<ffi.Char> git_oid_tostr_s(
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_oid_tostr_s(
      oid,
    );
  }

  late final _git_oid_tostr_sPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_oid>)>>('git_oid_tostr_s');
  late final _git_oid_tostr_s = _git_oid_tostr_sPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_oid>)>();

  /// Format a git_oid into a buffer as a hex format c-string.
  ///
  /// If the buffer is smaller than GIT_OID_HEXSZ+1, then the resulting
  /// oid c-string will be truncated to n-1 characters (but will still be
  /// NUL-byte terminated).
  ///
  /// If there are any input parameter errors (out == NULL, n == 0, oid ==
  /// NULL), then a pointer to an empty string is returned, so that the
  /// return value can always be printed.
  ///
  /// @param out the buffer into which the oid string is output.
  /// @param n the size of the out buffer.
  /// @param id the oid structure to format.
  /// @return the out buffer pointer, assuming no input parameter
  /// errors, otherwise a pointer to an empty string.
  ffi.Pointer<ffi.Char> git_oid_tostr(
    ffi.Pointer<ffi.Char> out,
    int n,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_tostr(
      out,
      n,
      id,
    );
  }

  late final _git_oid_tostrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>, ffi.Size,
              ffi.Pointer<git_oid>)>>('git_oid_tostr');
  late final _git_oid_tostr = _git_oid_tostrPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<git_oid>)>();

  /// Copy an oid from one structure to another.
  ///
  /// @param out oid structure the result is written into.
  /// @param src oid structure to copy from.
  /// @return 0 on success or error code
  int git_oid_cpy(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_oid> src,
  ) {
    return _git_oid_cpy(
      out,
      src,
    );
  }

  late final _git_oid_cpyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>>('git_oid_cpy');
  late final _git_oid_cpy = _git_oid_cpyPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Compare two oid structures.
  ///
  /// @param a first oid structure.
  /// @param b second oid structure.
  /// @return <0, 0, >0 if a < b, a == b, a > b.
  int git_oid_cmp(
    ffi.Pointer<git_oid> a,
    ffi.Pointer<git_oid> b,
  ) {
    return _git_oid_cmp(
      a,
      b,
    );
  }

  late final _git_oid_cmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>>('git_oid_cmp');
  late final _git_oid_cmp = _git_oid_cmpPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Compare two oid structures for equality
  ///
  /// @param a first oid structure.
  /// @param b second oid structure.
  /// @return true if equal, false otherwise
  int git_oid_equal(
    ffi.Pointer<git_oid> a,
    ffi.Pointer<git_oid> b,
  ) {
    return _git_oid_equal(
      a,
      b,
    );
  }

  late final _git_oid_equalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>>('git_oid_equal');
  late final _git_oid_equal = _git_oid_equalPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Compare the first 'len' hexadecimal characters (packets of 4 bits)
  /// of two oid structures.
  ///
  /// @param a first oid structure.
  /// @param b second oid structure.
  /// @param len the number of hex chars to compare
  /// @return 0 in case of a match
  int git_oid_ncmp(
    ffi.Pointer<git_oid> a,
    ffi.Pointer<git_oid> b,
    int len,
  ) {
    return _git_oid_ncmp(
      a,
      b,
      len,
    );
  }

  late final _git_oid_ncmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>,
              ffi.Size)>>('git_oid_ncmp');
  late final _git_oid_ncmp = _git_oid_ncmpPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>, int)>();

  /// Check if an oid equals an hex formatted object id.
  ///
  /// @param id oid structure.
  /// @param str input hex string of an object id.
  /// @return 0 in case of a match, -1 otherwise.
  int git_oid_streq(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _git_oid_streq(
      id,
      str,
    );
  }

  late final _git_oid_streqPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>>('git_oid_streq');
  late final _git_oid_streq = _git_oid_streqPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>();

  /// Compare an oid to an hex formatted object id.
  ///
  /// @param id oid structure.
  /// @param str input hex string of an object id.
  /// @return -1 if str is not valid, <0 if id sorts before str,
  /// 0 if id matches str, >0 if id sorts after str.
  int git_oid_strcmp(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> str,
  ) {
    return _git_oid_strcmp(
      id,
      str,
    );
  }

  late final _git_oid_strcmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>>('git_oid_strcmp');
  late final _git_oid_strcmp = _git_oid_strcmpPtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>)>();

  /// Check is an oid is all zeros.
  ///
  /// @return 1 if all zeros, 0 otherwise.
  int git_oid_is_zero(
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_is_zero(
      id,
    );
  }

  late final _git_oid_is_zeroPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid>)>>(
          'git_oid_is_zero');
  late final _git_oid_is_zero =
      _git_oid_is_zeroPtr.asFunction<int Function(ffi.Pointer<git_oid>)>();

  /// Create a new OID shortener.
  ///
  /// The OID shortener is used to process a list of OIDs
  /// in text form and return the shortest length that would
  /// uniquely identify all of them.
  ///
  /// E.g. look at the result of `git log --abbrev`.
  ///
  /// @param min_length The minimal length for all identifiers,
  /// which will be used even if shorter OIDs would still
  /// be unique.
  /// @return a `git_oid_shorten` instance, NULL if OOM
  ffi.Pointer<git_oid_shorten> git_oid_shorten_new(
    int min_length,
  ) {
    return _git_oid_shorten_new(
      min_length,
    );
  }

  late final _git_oid_shorten_newPtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<git_oid_shorten> Function(ffi.Size)>>(
      'git_oid_shorten_new');
  late final _git_oid_shorten_new = _git_oid_shorten_newPtr
      .asFunction<ffi.Pointer<git_oid_shorten> Function(int)>();

  /// Add a new OID to set of shortened OIDs and calculate
  /// the minimal length to uniquely identify all the OIDs in
  /// the set.
  ///
  /// The OID is expected to be a 40-char hexadecimal string.
  /// The OID is owned by the user and will not be modified
  /// or freed.
  ///
  /// For performance reasons, there is a hard-limit of how many
  /// OIDs can be added to a single set (around ~32000, assuming
  /// a mostly randomized distribution), which should be enough
  /// for any kind of program, and keeps the algorithm fast and
  /// memory-efficient.
  ///
  /// Attempting to add more than those OIDs will result in a
  /// GIT_ERROR_INVALID error
  ///
  /// @param os a `git_oid_shorten` instance
  /// @param text_id an OID in text form
  /// @return the minimal length to uniquely identify all OIDs
  /// added so far to the set; or an error code (<0) if an
  /// error occurs.
  int git_oid_shorten_add(
    ffi.Pointer<git_oid_shorten> os,
    ffi.Pointer<ffi.Char> text_id,
  ) {
    return _git_oid_shorten_add(
      os,
      text_id,
    );
  }

  late final _git_oid_shorten_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid_shorten>,
              ffi.Pointer<ffi.Char>)>>('git_oid_shorten_add');
  late final _git_oid_shorten_add = _git_oid_shorten_addPtr.asFunction<
      int Function(ffi.Pointer<git_oid_shorten>, ffi.Pointer<ffi.Char>)>();

  /// Free an OID shortener instance
  ///
  /// @param os a `git_oid_shorten` instance
  void git_oid_shorten_free(
    ffi.Pointer<git_oid_shorten> os,
  ) {
    return _git_oid_shorten_free(
      os,
    );
  }

  late final _git_oid_shorten_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_oid_shorten>)>>(
      'git_oid_shorten_free');
  late final _git_oid_shorten_free = _git_oid_shorten_freePtr
      .asFunction<void Function(ffi.Pointer<git_oid_shorten>)>();

  /// Open a git repository.
  ///
  /// The 'path' argument must point to either a git repository
  /// folder, or an existing work dir.
  ///
  /// The method will automatically detect if 'path' is a normal
  /// or bare repository or fail is 'path' is neither.
  ///
  /// @param out pointer to the repo which will be opened
  /// @param path the path to the repository
  /// @return 0 or an error code
  int git_repository_open(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_repository_open(
      out,
      path,
    );
  }

  late final _git_repository_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>)>>('git_repository_open');
  late final _git_repository_open = _git_repository_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>, ffi.Pointer<ffi.Char>)>();

  /// Open working tree as a repository
  ///
  /// Open the working directory of the working tree as a normal
  /// repository that can then be worked on.
  ///
  /// @param out Output pointer containing opened repository
  /// @param wt Working tree to open
  /// @return 0 or an error code
  int git_repository_open_from_worktree(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_repository_open_from_worktree(
      out,
      wt,
    );
  }

  late final _git_repository_open_from_worktreePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_worktree>)>>('git_repository_open_from_worktree');
  late final _git_repository_open_from_worktree =
      _git_repository_open_from_worktreePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_worktree>)>();

  /// Create a "fake" repository to wrap an object database
  ///
  /// Create a repository object to wrap an object database to be used
  /// with the API when all you have is an object database. This doesn't
  /// have any paths associated with it, so use with care.
  ///
  /// @param out pointer to the repo
  /// @param odb the object database to wrap
  /// @return 0 or an error code
  int git_repository_wrap_odb(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_odb> odb,
  ) {
    return _git_repository_wrap_odb(
      out,
      odb,
    );
  }

  late final _git_repository_wrap_odbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_odb>)>>('git_repository_wrap_odb');
  late final _git_repository_wrap_odb = _git_repository_wrap_odbPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>, ffi.Pointer<git_odb>)>();

  /// Look for a git repository and copy its path in the given buffer.
  /// The lookup start from base_path and walk across parent directories
  /// if nothing has been found. The lookup ends when the first repository
  /// is found, or when reaching a directory referenced in ceiling_dirs
  /// or when the filesystem changes (in case across_fs is true).
  ///
  /// The method will automatically detect if the repository is bare
  /// (if there is a repository).
  ///
  /// @param out A pointer to a user-allocated git_buf which will contain
  /// the found path.
  ///
  /// @param start_path The base path where the lookup starts.
  ///
  /// @param across_fs If true, then the lookup will not stop when a
  /// filesystem device change is detected while exploring parent directories.
  ///
  /// @param ceiling_dirs A GIT_PATH_LIST_SEPARATOR separated list of
  /// absolute symbolic link free paths. The lookup will stop when any
  /// of this paths is reached. Note that the lookup always performs on
  /// start_path no matter start_path appears in ceiling_dirs ceiling_dirs
  /// might be NULL (which is equivalent to an empty string)
  ///
  /// @return 0 or an error code
  int git_repository_discover(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<ffi.Char> start_path,
    int across_fs,
    ffi.Pointer<ffi.Char> ceiling_dirs,
  ) {
    return _git_repository_discover(
      out,
      start_path,
      across_fs,
      ceiling_dirs,
    );
  }

  late final _git_repository_discoverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_repository_discover');
  late final _git_repository_discover = _git_repository_discoverPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>, int,
          ffi.Pointer<ffi.Char>)>();

  /// Find and open a repository with extended controls.
  ///
  /// @param out Pointer to the repo which will be opened.  This can
  /// actually be NULL if you only want to use the error code to
  /// see if a repo at this path could be opened.
  /// @param path Path to open as git repository.  If the flags
  /// permit "searching", then this can be a path to a subdirectory
  /// inside the working directory of the repository. May be NULL if
  /// flags is GIT_REPOSITORY_OPEN_FROM_ENV.
  /// @param flags A combination of the GIT_REPOSITORY_OPEN flags above.
  /// @param ceiling_dirs A GIT_PATH_LIST_SEPARATOR delimited list of path
  /// prefixes at which the search for a containing repository should
  /// terminate.
  /// @return 0 on success, GIT_ENOTFOUND if no repository could be found,
  /// or -1 if there was a repository but open failed for some reason
  /// (such as repo corruption or system errors).
  int git_repository_open_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> path,
    int flags,
    ffi.Pointer<ffi.Char> ceiling_dirs,
  ) {
    return _git_repository_open_ext(
      out,
      path,
      flags,
      ceiling_dirs,
    );
  }

  late final _git_repository_open_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Char>)>>('git_repository_open_ext');
  late final _git_repository_open_ext = _git_repository_open_extPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Open a bare repository on the serverside.
  ///
  /// This is a fast open for bare repositories that will come in handy
  /// if you're e.g. hosting git repositories and need to access them
  /// efficiently
  ///
  /// @param out Pointer to the repo which will be opened.
  /// @param bare_path Direct path to the bare repository
  /// @return 0 on success, or an error code
  int git_repository_open_bare(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> bare_path,
  ) {
    return _git_repository_open_bare(
      out,
      bare_path,
    );
  }

  late final _git_repository_open_barePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>)>>('git_repository_open_bare');
  late final _git_repository_open_bare =
      _git_repository_open_barePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>)>();

  /// Free a previously allocated repository
  ///
  /// Note that after a repository is free'd, all the objects it has spawned
  /// will still exist until they are manually closed by the user
  /// with `git_object_free`, but accessing any of the attributes of
  /// an object without a backing repository will result in undefined
  /// behavior
  ///
  /// @param repo repository handle to close. If NULL nothing occurs.
  void git_repository_free(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_free(
      repo,
    );
  }

  late final _git_repository_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_repository>)>>(
      'git_repository_free');
  late final _git_repository_free = _git_repository_freePtr
      .asFunction<void Function(ffi.Pointer<git_repository>)>();

  /// Creates a new Git repository in the given folder.
  ///
  /// TODO:
  /// - Reinit the repository
  ///
  /// @param out pointer to the repo which will be created or reinitialized
  /// @param path the path to the repository
  /// @param is_bare if true, a Git repository without a working directory is
  /// created at the pointed path. If false, provided path will be
  /// considered as the working directory into which the .git directory
  /// will be created.
  ///
  /// @return 0 or an error code
  int git_repository_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> path,
    int is_bare,
  ) {
    return _git_repository_init(
      out,
      path,
      is_bare,
    );
  }

  late final _git_repository_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>, ffi.UnsignedInt)>>('git_repository_init');
  late final _git_repository_init = _git_repository_initPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Initialize git_repository_init_options structure
  ///
  /// Initializes a `git_repository_init_options` with default values. Equivalent to
  /// creating an instance with `GIT_REPOSITORY_INIT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_repository_init_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REPOSITORY_INIT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_repository_init_options_init(
    ffi.Pointer<git_repository_init_options> opts,
    int version,
  ) {
    return _git_repository_init_options_init(
      opts,
      version,
    );
  }

  late final _git_repository_init_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository_init_options>,
              ffi.UnsignedInt)>>('git_repository_init_options_init');
  late final _git_repository_init_options_init =
      _git_repository_init_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_repository_init_options>, int)>();

  /// Create a new Git repository in the given folder with extended controls.
  ///
  /// This will initialize a new git repository (creating the repo_path
  /// if requested by flags) and working directory as needed.  It will
  /// auto-detect the case sensitivity of the file system and if the
  /// file system supports file mode bits correctly.
  ///
  /// @param out Pointer to the repo which will be created or reinitialized.
  /// @param repo_path The path to the repository.
  /// @param opts Pointer to git_repository_init_options struct.
  /// @return 0 or an error code on failure.
  int git_repository_init_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> repo_path,
    ffi.Pointer<git_repository_init_options> opts,
  ) {
    return _git_repository_init_ext(
      out,
      repo_path,
      opts,
    );
  }

  late final _git_repository_init_extPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_repository>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_repository_init_options>)>>(
      'git_repository_init_ext');
  late final _git_repository_init_ext = _git_repository_init_extPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_repository_init_options>)>();

  /// Retrieve and resolve the reference pointed at by HEAD.
  ///
  /// The returned `git_reference` will be owned by caller and
  /// `git_reference_free()` must be called when done with it to release the
  /// allocated memory and prevent a leak.
  ///
  /// @param out pointer to the reference which will be retrieved
  /// @param repo a repository object
  ///
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise
  int git_repository_head(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head(
      out,
      repo,
    );
  }

  late final _git_repository_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>)>>('git_repository_head');
  late final _git_repository_head = _git_repository_headPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>)>();

  /// Retrieve the referenced HEAD for the worktree
  ///
  /// @param out pointer to the reference which will be retrieved
  /// @param repo a repository object
  /// @param name name of the worktree to retrieve HEAD for
  /// @return 0 when successful, error-code otherwise
  int git_repository_head_for_worktree(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_repository_head_for_worktree(
      out,
      repo,
      name,
    );
  }

  late final _git_repository_head_for_worktreePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_repository_head_for_worktree');
  late final _git_repository_head_for_worktree =
      _git_repository_head_for_worktreePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Check if a repository's HEAD is detached
  ///
  /// A repository's HEAD is detached when it points directly to a commit
  /// instead of a branch.
  ///
  /// @param repo Repo to test
  /// @return 1 if HEAD is detached, 0 if it's not; error code if there
  /// was an error.
  int git_repository_head_detached(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head_detached(
      repo,
    );
  }

  late final _git_repository_head_detachedPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_head_detached');
  late final _git_repository_head_detached = _git_repository_head_detachedPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Check if a worktree's HEAD is detached
  ///
  /// A worktree's HEAD is detached when it points directly to a
  /// commit instead of a branch.
  ///
  /// @param repo a repository object
  /// @param name name of the worktree to retrieve HEAD for
  /// @return 1 if HEAD is detached, 0 if its not; error code if
  /// there was an error
  int git_repository_head_detached_for_worktree(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_repository_head_detached_for_worktree(
      repo,
      name,
    );
  }

  late final _git_repository_head_detached_for_worktreePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>>(
      'git_repository_head_detached_for_worktree');
  late final _git_repository_head_detached_for_worktree =
      _git_repository_head_detached_for_worktreePtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Check if the current branch is unborn
  ///
  /// An unborn branch is one named from HEAD but which doesn't exist in
  /// the refs namespace, because it doesn't have any commit to point to.
  ///
  /// @param repo Repo to test
  /// @return 1 if the current branch is unborn, 0 if it's not; error
  /// code if there was an error
  int git_repository_head_unborn(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head_unborn(
      repo,
    );
  }

  late final _git_repository_head_unbornPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_head_unborn');
  late final _git_repository_head_unborn = _git_repository_head_unbornPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Check if a repository is empty
  ///
  /// An empty repository has just been initialized and contains no references
  /// apart from HEAD, which must be pointing to the unborn master branch.
  ///
  /// @param repo Repo to test
  /// @return 1 if the repository is empty, 0 if it isn't, error code
  /// if the repository is corrupted
  int git_repository_is_empty(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_empty(
      repo,
    );
  }

  late final _git_repository_is_emptyPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_is_empty');
  late final _git_repository_is_empty = _git_repository_is_emptyPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Get the location of a specific repository file or directory
  ///
  /// This function will retrieve the path of a specific repository
  /// item. It will thereby honor things like the repository's
  /// common directory, gitdir, etc. In case a file path cannot
  /// exist for a given item (e.g. the working directory of a bare
  /// repository), GIT_ENOTFOUND is returned.
  ///
  /// @param out Buffer to store the path at
  /// @param repo Repository to get path for
  /// @param item The repository item for which to retrieve the path
  /// @return 0, GIT_ENOTFOUND if the path cannot exist or an error code
  int git_repository_item_path(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    int item,
  ) {
    return _git_repository_item_path(
      out,
      repo,
      item,
    );
  }

  late final _git_repository_item_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Int32)>>('git_repository_item_path');
  late final _git_repository_item_path =
      _git_repository_item_pathPtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>, ffi.Pointer<git_repository>, int)>();

  /// Get the path of this repository
  ///
  /// This is the path of the `.git` folder for normal repositories,
  /// or of the repository itself for bare repositories.
  ///
  /// @param repo A repository object
  /// @return the path to the repository
  ffi.Pointer<ffi.Char> git_repository_path(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_path(
      repo,
    );
  }

  late final _git_repository_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_repository>)>>('git_repository_path');
  late final _git_repository_path = _git_repository_pathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository>)>();

  /// Get the path of the working directory for this repository
  ///
  /// If the repository is bare, this function will always return
  /// NULL.
  ///
  /// @param repo A repository object
  /// @return the path to the working dir, if it exists
  ffi.Pointer<ffi.Char> git_repository_workdir(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_workdir(
      repo,
    );
  }

  late final _git_repository_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_repository>)>>('git_repository_workdir');
  late final _git_repository_workdir = _git_repository_workdirPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository>)>();

  /// Get the path of the shared common directory for this repository.
  ///
  /// If the repository is bare, it is the root directory for the repository.
  /// If the repository is a worktree, it is the parent repo's gitdir.
  /// Otherwise, it is the gitdir.
  ///
  /// @param repo A repository object
  /// @return the path to the common dir
  ffi.Pointer<ffi.Char> git_repository_commondir(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_commondir(
      repo,
    );
  }

  late final _git_repository_commondirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_repository>)>>('git_repository_commondir');
  late final _git_repository_commondir =
      _git_repository_commondirPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository>)>();

  /// Set the path to the working directory for this repository
  ///
  /// The working directory doesn't need to be the same one
  /// that contains the `.git` folder for this repository.
  ///
  /// If this repository is bare, setting its working directory
  /// will turn it into a normal repository, capable of performing
  /// all the common workdir operations (checkout, status, index
  /// manipulation, etc).
  ///
  /// @param repo A repository object
  /// @param workdir The path to a working directory
  /// @param update_gitlink Create/update gitlink in workdir and set config
  /// "core.worktree" (if workdir is not the parent of the .git directory)
  /// @return 0, or an error code
  int git_repository_set_workdir(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> workdir,
    int update_gitlink,
  ) {
    return _git_repository_set_workdir(
      repo,
      workdir,
      update_gitlink,
    );
  }

  late final _git_repository_set_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_repository_set_workdir');
  late final _git_repository_set_workdir =
      _git_repository_set_workdirPtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Check if a repository is bare
  ///
  /// @param repo Repo to test
  /// @return 1 if the repository is bare, 0 otherwise.
  int git_repository_is_bare(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_bare(
      repo,
    );
  }

  late final _git_repository_is_barePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_is_bare');
  late final _git_repository_is_bare = _git_repository_is_barePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Check if a repository is a linked work tree
  ///
  /// @param repo Repo to test
  /// @return 1 if the repository is a linked work tree, 0 otherwise.
  int git_repository_is_worktree(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_worktree(
      repo,
    );
  }

  late final _git_repository_is_worktreePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_is_worktree');
  late final _git_repository_is_worktree = _git_repository_is_worktreePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Get the configuration file for this repository.
  ///
  /// If a configuration file has not been set, the default
  /// config set for the repository will be returned, including
  /// global and system configurations (if they are available).
  ///
  /// The configuration file must be freed once it's no longer
  /// being used by the user.
  ///
  /// @param out Pointer to store the loaded configuration
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_config(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_config(
      out,
      repo,
    );
  }

  late final _git_repository_configPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_repository>)>>('git_repository_config');
  late final _git_repository_config = _git_repository_configPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_config>>, ffi.Pointer<git_repository>)>();

  /// Get a snapshot of the repository's configuration
  ///
  /// Convenience function to take a snapshot from the repository's
  /// configuration.  The contents of this snapshot will not change,
  /// even if the underlying config files are modified.
  ///
  /// The configuration file must be freed once it's no longer
  /// being used by the user.
  ///
  /// @param out Pointer to store the loaded configuration
  /// @param repo the repository
  /// @return 0, or an error code
  int git_repository_config_snapshot(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_config_snapshot(
      out,
      repo,
    );
  }

  late final _git_repository_config_snapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_repository>)>>('git_repository_config_snapshot');
  late final _git_repository_config_snapshot =
      _git_repository_config_snapshotPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_repository>)>();

  /// Get the Object Database for this repository.
  ///
  /// If a custom ODB has not been set, the default
  /// database for the repository will be returned (the one
  /// located in `.git/objects`).
  ///
  /// The ODB must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param out Pointer to store the loaded ODB
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_odb(
    ffi.Pointer<ffi.Pointer<git_odb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_odb(
      out,
      repo,
    );
  }

  late final _git_repository_odbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb>>,
              ffi.Pointer<git_repository>)>>('git_repository_odb');
  late final _git_repository_odb = _git_repository_odbPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_odb>>, ffi.Pointer<git_repository>)>();

  /// Get the Reference Database Backend for this repository.
  ///
  /// If a custom refsdb has not been set, the default database for
  /// the repository will be returned (the one that manipulates loose
  /// and packed references in the `.git` directory).
  ///
  /// The refdb must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param out Pointer to store the loaded refdb
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_refdb(
    ffi.Pointer<ffi.Pointer<git_refdb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_refdb(
      out,
      repo,
    );
  }

  late final _git_repository_refdbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb>>,
              ffi.Pointer<git_repository>)>>('git_repository_refdb');
  late final _git_repository_refdb = _git_repository_refdbPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_refdb>>, ffi.Pointer<git_repository>)>();

  /// Get the Index file for this repository.
  ///
  /// If a custom index has not been set, the default
  /// index for the repository will be returned (the one
  /// located in `.git/index`).
  ///
  /// The index must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param out Pointer to store the loaded index
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_index(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_index(
      out,
      repo,
    );
  }

  late final _git_repository_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>)>>('git_repository_index');
  late final _git_repository_index = _git_repository_indexPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>, ffi.Pointer<git_repository>)>();

  /// Retrieve git's prepared message
  ///
  /// Operations such as git revert/cherry-pick/merge with the -n option
  /// stop just short of creating a commit with the changes and save
  /// their prepared message in .git/MERGE_MSG so the next git-commit
  /// execution can present it to the user for them to amend if they
  /// wish.
  ///
  /// Use this function to get the contents of this file. Don't forget to
  /// remove the file after you create the commit.
  ///
  /// @param out git_buf to write data into
  /// @param repo Repository to read prepared message from
  /// @return 0, GIT_ENOTFOUND if no message exists or an error code
  int git_repository_message(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_message(
      out,
      repo,
    );
  }

  late final _git_repository_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>)>>('git_repository_message');
  late final _git_repository_message = _git_repository_messagePtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>)>();

  /// Remove git's prepared message.
  ///
  /// Remove the message that `git_repository_message` retrieves.
  ///
  /// @param repo Repository to remove prepared message from.
  /// @return 0 or an error code.
  int git_repository_message_remove(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_message_remove(
      repo,
    );
  }

  late final _git_repository_message_removePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_message_remove');
  late final _git_repository_message_remove = _git_repository_message_removePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Remove all the metadata associated with an ongoing command like merge,
  /// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
  ///
  /// @param repo A repository object
  /// @return 0 on success, or error
  int git_repository_state_cleanup(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state_cleanup(
      repo,
    );
  }

  late final _git_repository_state_cleanupPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_state_cleanup');
  late final _git_repository_state_cleanup = _git_repository_state_cleanupPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Invoke 'callback' for each entry in the given FETCH_HEAD file.
  ///
  /// Return a non-zero value from the callback to stop the loop.
  ///
  /// @param repo A repository object
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  /// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
  /// there is no FETCH_HEAD file, or other error code.
  int git_repository_fetchhead_foreach(
    ffi.Pointer<git_repository> repo,
    git_repository_fetchhead_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_repository_fetchhead_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_repository_fetchhead_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              git_repository_fetchhead_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_repository_fetchhead_foreach');
  late final _git_repository_fetchhead_foreach =
      _git_repository_fetchhead_foreachPtr.asFunction<
          int Function(ffi.Pointer<git_repository>,
              git_repository_fetchhead_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// If a merge is in progress, invoke 'callback' for each commit ID in the
  /// MERGE_HEAD file.
  ///
  /// Return a non-zero value from the callback to stop the loop.
  ///
  /// @param repo A repository object
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  /// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
  /// there is no MERGE_HEAD file, or other error code.
  int git_repository_mergehead_foreach(
    ffi.Pointer<git_repository> repo,
    git_repository_mergehead_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_repository_mergehead_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_repository_mergehead_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              git_repository_mergehead_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_repository_mergehead_foreach');
  late final _git_repository_mergehead_foreach =
      _git_repository_mergehead_foreachPtr.asFunction<
          int Function(ffi.Pointer<git_repository>,
              git_repository_mergehead_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Calculate hash of file using repository filtering rules.
  ///
  /// If you simply want to calculate the hash of a file on disk with no filters,
  /// you can just use the `git_odb_hashfile()` API.  However, if you want to
  /// hash a file in the repository and you want to apply filtering rules (e.g.
  /// crlf filters) before generating the SHA, then use this function.
  ///
  /// Note: if the repository has `core.safecrlf` set to fail and the
  /// filtering triggers that failure, then this function will return an
  /// error and not calculate the hash of the file.
  ///
  /// @param out Output value of calculated SHA
  /// @param repo Repository pointer
  /// @param path Path to file on disk whose contents should be hashed.  This
  /// may be an absolute path or a relative path, in which case it
  /// will be treated as a path within the working directory.
  /// @param type The object type to hash as (e.g. GIT_OBJECT_BLOB)
  /// @param as_path The path to use to look up filtering rules. If this is
  /// an empty string then no filters will be applied when
  /// calculating the hash. If this is `NULL` and the `path`
  /// parameter is a file within the repository's working
  /// directory, then the `path` will be used.
  /// @return 0 on success, or an error code
  int git_repository_hashfile(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
    int type,
    ffi.Pointer<ffi.Char> as_path,
  ) {
    return _git_repository_hashfile(
      out,
      repo,
      path,
      type,
      as_path,
    );
  }

  late final _git_repository_hashfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Pointer<ffi.Char>)>>('git_repository_hashfile');
  late final _git_repository_hashfile = _git_repository_hashfilePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>)>();

  /// Make the repository HEAD point to the specified reference.
  ///
  /// If the provided reference points to a Tree or a Blob, the HEAD is
  /// unaltered and -1 is returned.
  ///
  /// If the provided reference points to a branch, the HEAD will point
  /// to that branch, staying attached, or become attached if it isn't yet.
  /// If the branch doesn't exist yet, no error will be return. The HEAD
  /// will then be attached to an unborn branch.
  ///
  /// Otherwise, the HEAD will be detached and will directly point to
  /// the Commit.
  ///
  /// @param repo Repository pointer
  /// @param refname Canonical name of the reference the HEAD should point at
  /// @return 0 on success, or an error code
  int git_repository_set_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_repository_set_head(
      repo,
      refname,
    );
  }

  late final _git_repository_set_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_repository_set_head');
  late final _git_repository_set_head = _git_repository_set_headPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Make the repository HEAD directly point to the Commit.
  ///
  /// If the provided committish cannot be found in the repository, the HEAD
  /// is unaltered and GIT_ENOTFOUND is returned.
  ///
  /// If the provided committish cannot be peeled into a commit, the HEAD
  /// is unaltered and -1 is returned.
  ///
  /// Otherwise, the HEAD will eventually be detached and will directly point to
  /// the peeled Commit.
  ///
  /// @param repo Repository pointer
  /// @param committish Object id of the Commit the HEAD should point to
  /// @return 0 on success, or an error code
  int git_repository_set_head_detached(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> committish,
  ) {
    return _git_repository_set_head_detached(
      repo,
      committish,
    );
  }

  late final _git_repository_set_head_detachedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_repository_set_head_detached');
  late final _git_repository_set_head_detached =
      _git_repository_set_head_detachedPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Make the repository HEAD directly point to the Commit.
  ///
  /// This behaves like `git_repository_set_head_detached()` but takes an
  /// annotated commit, which lets you specify which extended sha syntax
  /// string was specified by a user, allowing for more exact reflog
  /// messages.
  ///
  /// See the documentation for `git_repository_set_head_detached()`.
  ///
  /// @see git_repository_set_head_detached
  int git_repository_set_head_detached_from_annotated(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_annotated_commit> committish,
  ) {
    return _git_repository_set_head_detached_from_annotated(
      repo,
      committish,
    );
  }

  late final _git_repository_set_head_detached_from_annotatedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_repository>,
                  ffi.Pointer<git_annotated_commit>)>>(
      'git_repository_set_head_detached_from_annotated');
  late final _git_repository_set_head_detached_from_annotated =
      _git_repository_set_head_detached_from_annotatedPtr.asFunction<
          int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_annotated_commit>)>();

  /// Detach the HEAD.
  ///
  /// If the HEAD is already detached and points to a Commit, 0 is returned.
  ///
  /// If the HEAD is already detached and points to a Tag, the HEAD is
  /// updated into making it point to the peeled Commit, and 0 is returned.
  ///
  /// If the HEAD is already detached and points to a non committish, the HEAD is
  /// unaltered, and -1 is returned.
  ///
  /// Otherwise, the HEAD will be detached and point to the peeled Commit.
  ///
  /// @param repo Repository pointer
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch or an error code
  int git_repository_detach_head(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_detach_head(
      repo,
    );
  }

  late final _git_repository_detach_headPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_detach_head');
  late final _git_repository_detach_head = _git_repository_detach_headPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Determines the status of a git repository - ie, whether an operation
  /// (merge, cherry-pick, etc) is in progress.
  ///
  /// @param repo Repository pointer
  /// @return The state of the repository
  int git_repository_state(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state(
      repo,
    );
  }

  late final _git_repository_statePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_state');
  late final _git_repository_state = _git_repository_statePtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Sets the active namespace for this Git Repository
  ///
  /// This namespace affects all reference operations for the repo.
  /// See `man gitnamespaces`
  ///
  /// @param repo The repo
  /// @param nmspace The namespace. This should not include the refs
  /// folder, e.g. to namespace all references under `refs/namespaces/foo/`,
  /// use `foo` as the namespace.
  /// @return 0 on success, -1 on error
  int git_repository_set_namespace(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> nmspace,
  ) {
    return _git_repository_set_namespace(
      repo,
      nmspace,
    );
  }

  late final _git_repository_set_namespacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_repository_set_namespace');
  late final _git_repository_set_namespace =
      _git_repository_set_namespacePtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Get the currently active namespace for this repository
  ///
  /// @param repo The repo
  /// @return the active namespace, or NULL if there isn't one
  ffi.Pointer<ffi.Char> git_repository_get_namespace(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_get_namespace(
      repo,
    );
  }

  late final _git_repository_get_namespacePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_repository>)>>('git_repository_get_namespace');
  late final _git_repository_get_namespace =
      _git_repository_get_namespacePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_repository>)>();

  /// Determine if the repository was a shallow clone
  ///
  /// @param repo The repository
  /// @return 1 if shallow, zero if not
  int git_repository_is_shallow(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_shallow(
      repo,
    );
  }

  late final _git_repository_is_shallowPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_repository_is_shallow');
  late final _git_repository_is_shallow = _git_repository_is_shallowPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Retrieve the configured identity to use for reflogs
  ///
  /// The memory is owned by the repository and must not be freed by the
  /// user.
  ///
  /// @param name where to store the pointer to the name
  /// @param email where to store the pointer to the email
  /// @param repo the repository
  /// @return 0 or an error code
  int git_repository_ident(
    ffi.Pointer<ffi.Pointer<ffi.Char>> name,
    ffi.Pointer<ffi.Pointer<ffi.Char>> email,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_ident(
      name,
      email,
      repo,
    );
  }

  late final _git_repository_identPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>)>>('git_repository_ident');
  late final _git_repository_ident = _git_repository_identPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<git_repository>)>();

  /// Set the identity to be used for writing reflogs
  ///
  /// If both are set, this name and email will be used to write to the
  /// reflog. Pass NULL to unset. When unset, the identity will be taken
  /// from the repository's configuration.
  ///
  /// @param repo the repository to configure
  /// @param name the name to use for the reflog entries
  /// @param email the email to use for the reflog entries
  /// @return 0 or an error code.
  int git_repository_set_ident(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> email,
  ) {
    return _git_repository_set_ident(
      repo,
      name,
      email,
    );
  }

  late final _git_repository_set_identPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_repository_set_ident');
  late final _git_repository_set_ident =
      _git_repository_set_identPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Creates a `git_annotated_commit` from the given reference.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given reference
  /// @param ref reference to use to lookup the git_annotated_commit
  /// @return 0 on success or error code
  int git_annotated_commit_from_ref(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_annotated_commit_from_ref(
      out,
      repo,
      ref,
    );
  }

  late final _git_annotated_commit_from_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_reference>)>>('git_annotated_commit_from_ref');
  late final _git_annotated_commit_from_ref =
      _git_annotated_commit_from_refPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_reference>)>();

  /// Creates a `git_annotated_commit` from the given fetch head data.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given commit
  /// @param branch_name name of the (remote) branch
  /// @param remote_url url of the remote
  /// @param id the commit object id of the remote branch
  /// @return 0 on success or error code
  int git_annotated_commit_from_fetchhead(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> branch_name,
    ffi.Pointer<ffi.Char> remote_url,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_annotated_commit_from_fetchhead(
      out,
      repo,
      branch_name,
      remote_url,
      id,
    );
  }

  late final _git_annotated_commit_from_fetchheadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>)>>('git_annotated_commit_from_fetchhead');
  late final _git_annotated_commit_from_fetchhead =
      _git_annotated_commit_from_fetchheadPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>)>();

  /// Creates a `git_annotated_commit` from the given commit id.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// An annotated commit contains information about how it was
  /// looked up, which may be useful for functions like merge or
  /// rebase to provide context to the operation.  For example,
  /// conflict files will include the name of the source or target
  /// branches being merged.  It is therefore preferable to use the
  /// most specific function (eg `git_annotated_commit_from_ref`)
  /// instead of this one when that data is known.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given commit
  /// @param id the commit object id to lookup
  /// @return 0 on success or error code
  int git_annotated_commit_lookup(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_annotated_commit_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_annotated_commit_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_annotated_commit_lookup');
  late final _git_annotated_commit_lookup =
      _git_annotated_commit_lookupPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Creates a `git_annotated_commit` from a revision string.
  ///
  /// See `man gitrevisions`, or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given commit
  /// @param revspec the extended sha syntax string to use to lookup the commit
  /// @return 0 on success or error code
  int git_annotated_commit_from_revspec(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> revspec,
  ) {
    return _git_annotated_commit_from_revspec(
      out,
      repo,
      revspec,
    );
  }

  late final _git_annotated_commit_from_revspecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_annotated_commit_from_revspec');
  late final _git_annotated_commit_from_revspec =
      _git_annotated_commit_from_revspecPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Gets the commit ID that the given `git_annotated_commit` refers to.
  ///
  /// @param commit the given annotated commit
  /// @return commit id
  ffi.Pointer<git_oid> git_annotated_commit_id(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_id(
      commit,
    );
  }

  late final _git_annotated_commit_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_annotated_commit>)>>('git_annotated_commit_id');
  late final _git_annotated_commit_id = _git_annotated_commit_idPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_annotated_commit>)>();

  /// Get the refname that the given `git_annotated_commit` refers to.
  ///
  /// @param commit the given annotated commit
  /// @return ref name.
  ffi.Pointer<ffi.Char> git_annotated_commit_ref(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_ref(
      commit,
    );
  }

  late final _git_annotated_commit_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_annotated_commit>)>>('git_annotated_commit_ref');
  late final _git_annotated_commit_ref =
      _git_annotated_commit_refPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_annotated_commit>)>();

  /// Frees a `git_annotated_commit`.
  ///
  /// @param commit annotated commit to free
  void git_annotated_commit_free(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_free(
      commit,
    );
  }

  late final _git_annotated_commit_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<git_annotated_commit>)>>('git_annotated_commit_free');
  late final _git_annotated_commit_free = _git_annotated_commit_freePtr
      .asFunction<void Function(ffi.Pointer<git_annotated_commit>)>();

  /// Lookup a reference to one of the objects in a repository.
  ///
  /// The generated reference is owned by the repository and
  /// should be closed with the `git_object_free` method
  /// instead of free'd manually.
  ///
  /// The 'type' parameter must match the type of the object
  /// in the odb; the method will fail otherwise.
  /// The special value 'GIT_OBJECT_ANY' may be passed to let
  /// the method guess the object's type.
  ///
  /// @param object pointer to the looked-up object
  /// @param repo the repository to look up the object
  /// @param id the unique identifier for the object
  /// @param type the type of the object
  /// @return 0 or an error code
  int git_object_lookup(
    ffi.Pointer<ffi.Pointer<git_object>> object,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int type,
  ) {
    return _git_object_lookup(
      object,
      repo,
      id,
      type,
    );
  }

  late final _git_object_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Int32)>>('git_object_lookup');
  late final _git_object_lookup = _git_object_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Lookup a reference to one of the objects in a repository,
  /// given a prefix of its identifier (short id).
  ///
  /// The object obtained will be so that its identifier
  /// matches the first 'len' hexadecimal characters
  /// (packets of 4 bits) of the given 'id'.
  /// 'len' must be at least GIT_OID_MINPREFIXLEN, and
  /// long enough to identify a unique object matching
  /// the prefix; otherwise the method will fail.
  ///
  /// The generated reference is owned by the repository and
  /// should be closed with the `git_object_free` method
  /// instead of free'd manually.
  ///
  /// The 'type' parameter must match the type of the object
  /// in the odb; the method will fail otherwise.
  /// The special value 'GIT_OBJECT_ANY' may be passed to let
  /// the method guess the object's type.
  ///
  /// @param object_out pointer where to store the looked-up object
  /// @param repo the repository to look up the object
  /// @param id a short identifier for the object
  /// @param len the length of the short identifier
  /// @param type the type of the object
  /// @return 0 or an error code
  int git_object_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_object>> object_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
    int type,
  ) {
    return _git_object_lookup_prefix(
      object_out,
      repo,
      id,
      len,
      type,
    );
  }

  late final _git_object_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size,
              ffi.Int32)>>('git_object_lookup_prefix');
  late final _git_object_lookup_prefix =
      _git_object_lookup_prefixPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int, int)>();

  /// Lookup an object that represents a tree entry.
  ///
  /// @param out buffer that receives a pointer to the object (which must be freed
  /// by the caller)
  /// @param treeish root object that can be peeled to a tree
  /// @param path relative path from the root object to the desired object
  /// @param type type of object desired
  /// @return 0 on success, or an error code
  int git_object_lookup_bypath(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_object> treeish,
    ffi.Pointer<ffi.Char> path,
    int type,
  ) {
    return _git_object_lookup_bypath(
      out,
      treeish,
      path,
      type,
    );
  }

  late final _git_object_lookup_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_object>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_object_lookup_bypath');
  late final _git_object_lookup_bypath =
      _git_object_lookup_bypathPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_object>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the id (SHA1) of a repository object
  ///
  /// @param obj the repository object
  /// @return the SHA1 id
  ffi.Pointer<git_oid> git_object_id(
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_id(
      obj,
    );
  }

  late final _git_object_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_object>)>>('git_object_id');
  late final _git_object_id = _git_object_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_object>)>();

  /// Get a short abbreviated OID string for the object
  ///
  /// This starts at the "core.abbrev" length (default 7 characters) and
  /// iteratively extends to a longer string if that length is ambiguous.
  /// The result will be unambiguous (at least until new objects are added to
  /// the repository).
  ///
  /// @param out Buffer to write string into
  /// @param obj The object to get an ID for
  /// @return 0 on success, <0 for error
  int git_object_short_id(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_short_id(
      out,
      obj,
    );
  }

  late final _git_object_short_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_object>)>>('git_object_short_id');
  late final _git_object_short_id = _git_object_short_idPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_object>)>();

  /// Get the object type of an object
  ///
  /// @param obj the repository object
  /// @return the object's type
  int git_object_type(
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_type(
      obj,
    );
  }

  late final _git_object_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_object>)>>(
          'git_object_type');
  late final _git_object_type =
      _git_object_typePtr.asFunction<int Function(ffi.Pointer<git_object>)>();

  /// Get the repository that owns this object
  ///
  /// Freeing or calling `git_repository_close` on the
  /// returned pointer will invalidate the actual object.
  ///
  /// Any other operation may be run on the repository without
  /// affecting the object.
  ///
  /// @param obj the object
  /// @return the repository who owns this object
  ffi.Pointer<git_repository> git_object_owner(
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_owner(
      obj,
    );
  }

  late final _git_object_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_object>)>>('git_object_owner');
  late final _git_object_owner = _git_object_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_object>)>();

  /// Close an open object
  ///
  /// This method instructs the library to close an existing
  /// object; note that git_objects are owned and cached by the repository
  /// so the object may or may not be freed after this library call,
  /// depending on how aggressive is the caching mechanism used
  /// by the repository.
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop using
  /// an object. Failure to do so will cause a memory leak.
  ///
  /// @param object the object to close
  void git_object_free(
    ffi.Pointer<git_object> object,
  ) {
    return _git_object_free(
      object,
    );
  }

  late final _git_object_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_object>)>>(
          'git_object_free');
  late final _git_object_free =
      _git_object_freePtr.asFunction<void Function(ffi.Pointer<git_object>)>();

  /// Convert an object type to its string representation.
  ///
  /// The result is a pointer to a string in static memory and
  /// should not be free()'ed.
  ///
  /// @param type object type to convert.
  /// @return the corresponding string representation.
  ffi.Pointer<ffi.Char> git_object_type2string(
    int type,
  ) {
    return _git_object_type2string(
      type,
    );
  }

  late final _git_object_type2stringPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'git_object_type2string');
  late final _git_object_type2string = _git_object_type2stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  /// Convert a string object type representation to it's git_object_t.
  ///
  /// @param str the string to convert.
  /// @return the corresponding git_object_t.
  int git_object_string2type(
    ffi.Pointer<ffi.Char> str,
  ) {
    return _git_object_string2type(
      str,
    );
  }

  late final _git_object_string2typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'git_object_string2type');
  late final _git_object_string2type = _git_object_string2typePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Determine if the given git_object_t is a valid loose object type.
  ///
  /// @param type object type to test.
  /// @return true if the type represents a valid loose object type,
  /// false otherwise.
  int git_object_typeisloose(
    int type,
  ) {
    return _git_object_typeisloose(
      type,
    );
  }

  late final _git_object_typeisloosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>(
          'git_object_typeisloose');
  late final _git_object_typeisloose =
      _git_object_typeisloosePtr.asFunction<int Function(int)>();

  /// Recursively peel an object until an object of the specified type is met.
  ///
  /// If the query cannot be satisfied due to the object model,
  /// GIT_EINVALIDSPEC will be returned (e.g. trying to peel a blob to a
  /// tree).
  ///
  /// If you pass `GIT_OBJECT_ANY` as the target type, then the object will
  /// be peeled until the type changes. A tag will be peeled until the
  /// referenced object is no longer a tag, and a commit will be peeled
  /// to a tree. Any other object type will return GIT_EINVALIDSPEC.
  ///
  /// If peeling a tag we discover an object which cannot be peeled to
  /// the target type due to the object model, GIT_EPEEL will be
  /// returned.
  ///
  /// You must free the returned object.
  ///
  /// @param peeled Pointer to the peeled git_object
  /// @param object The object to be processed
  /// @param target_type The type of the requested object (a GIT_OBJECT_ value)
  /// @return 0 on success, GIT_EINVALIDSPEC, GIT_EPEEL, or an error code
  int git_object_peel(
    ffi.Pointer<ffi.Pointer<git_object>> peeled,
    ffi.Pointer<git_object> object,
    int target_type,
  ) {
    return _git_object_peel(
      peeled,
      object,
      target_type,
    );
  }

  late final _git_object_peelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_object>, ffi.Int32)>>('git_object_peel');
  late final _git_object_peel = _git_object_peelPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_object>, int)>();

  /// Create an in-memory copy of a Git object. The copy must be
  /// explicitly free'd or it will leak.
  ///
  /// @param dest Pointer to store the copy of the object
  /// @param source Original object to copy
  /// @return 0 or an error code
  int git_object_dup(
    ffi.Pointer<ffi.Pointer<git_object>> dest,
    ffi.Pointer<git_object> source,
  ) {
    return _git_object_dup(
      dest,
      source,
    );
  }

  late final _git_object_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_object>)>>('git_object_dup');
  late final _git_object_dup = _git_object_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_object>>, ffi.Pointer<git_object>)>();

  /// Analyzes a buffer of raw object content and determines its validity.
  /// Tree, commit, and tag objects will be parsed and ensured that they
  /// are valid, parseable content.  (Blobs are always valid by definition.)
  /// An error message will be set with an informative message if the object
  /// is not valid.
  ///
  /// @warning This function is experimental and its signature may change in
  /// the future.
  ///
  /// @param valid Output pointer to set with validity of the object content
  /// @param buf The contents to validate
  /// @param len The length of the buffer
  /// @param type The type of the object in the buffer
  /// @return 0 on success or an error code
  int git_object_rawcontent_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> buf,
    int len,
    int type,
  ) {
    return _git_object_rawcontent_is_valid(
      valid,
      buf,
      len,
      type,
    );
  }

  late final _git_object_rawcontent_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>,
              ffi.Size, ffi.Int32)>>('git_object_rawcontent_is_valid');
  late final _git_object_rawcontent_is_valid =
      _git_object_rawcontent_is_validPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Lookup a tree object from the repository.
  ///
  /// @param out Pointer to the looked up tree
  /// @param repo The repo to use when locating the tree.
  /// @param id Identity of the tree to locate.
  /// @return 0 or an error code
  int git_tree_lookup(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tree_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_tree_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tree>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_tree_lookup');
  late final _git_tree_lookup = _git_tree_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tree>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Lookup a tree object from the repository,
  /// given a prefix of its identifier (short id).
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param out pointer to the looked up tree
  /// @param repo the repo to use when locating the tree.
  /// @param id identity of the tree to locate.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_tree_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_tree_lookup_prefix(
      out,
      repo,
      id,
      len,
    );
  }

  late final _git_tree_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tree>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_tree_lookup_prefix');
  late final _git_tree_lookup_prefix = _git_tree_lookup_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tree>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Close an open tree
  ///
  /// You can no longer use the git_tree pointer after this call.
  ///
  /// IMPORTANT: You MUST call this method when you stop using a tree to
  /// release memory. Failure to do so will cause a memory leak.
  ///
  /// @param tree The tree to close
  void git_tree_free(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_free(
      tree,
    );
  }

  late final _git_tree_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_tree>)>>(
          'git_tree_free');
  late final _git_tree_free =
      _git_tree_freePtr.asFunction<void Function(ffi.Pointer<git_tree>)>();

  /// Get the id of a tree.
  ///
  /// @param tree a previously loaded tree.
  /// @return object identity for the tree.
  ffi.Pointer<git_oid> git_tree_id(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_id(
      tree,
    );
  }

  late final _git_tree_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_tree>)>>('git_tree_id');
  late final _git_tree_id = _git_tree_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tree>)>();

  /// Get the repository that contains the tree.
  ///
  /// @param tree A previously loaded tree.
  /// @return Repository that contains this tree.
  ffi.Pointer<git_repository> git_tree_owner(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_owner(
      tree,
    );
  }

  late final _git_tree_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_tree>)>>('git_tree_owner');
  late final _git_tree_owner = _git_tree_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_tree>)>();

  /// Get the number of entries listed in a tree
  ///
  /// @param tree a previously loaded tree.
  /// @return the number of entries in the tree
  int git_tree_entrycount(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_entrycount(
      tree,
    );
  }

  late final _git_tree_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_tree>)>>(
          'git_tree_entrycount');
  late final _git_tree_entrycount =
      _git_tree_entrycountPtr.asFunction<int Function(ffi.Pointer<git_tree>)>();

  /// Lookup a tree entry by its filename
  ///
  /// This returns a git_tree_entry that is owned by the git_tree.  You don't
  /// have to free it, but you must not use it after the git_tree is released.
  ///
  /// @param tree a previously loaded tree.
  /// @param filename the filename of the desired entry
  /// @return the tree entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_tree_entry_byname(
    ffi.Pointer<git_tree> tree,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _git_tree_entry_byname(
      tree,
      filename,
    );
  }

  late final _git_tree_entry_bynamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_tree>,
              ffi.Pointer<ffi.Char>)>>('git_tree_entry_byname');
  late final _git_tree_entry_byname = _git_tree_entry_bynamePtr.asFunction<
      ffi.Pointer<git_tree_entry> Function(
          ffi.Pointer<git_tree>, ffi.Pointer<ffi.Char>)>();

  /// Lookup a tree entry by its position in the tree
  ///
  /// This returns a git_tree_entry that is owned by the git_tree.  You don't
  /// have to free it, but you must not use it after the git_tree is released.
  ///
  /// @param tree a previously loaded tree.
  /// @param idx the position in the entry list
  /// @return the tree entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_tree_entry_byindex(
    ffi.Pointer<git_tree> tree,
    int idx,
  ) {
    return _git_tree_entry_byindex(
      tree,
      idx,
    );
  }

  late final _git_tree_entry_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_tree_entry> Function(
              ffi.Pointer<git_tree>, ffi.Size)>>('git_tree_entry_byindex');
  late final _git_tree_entry_byindex = _git_tree_entry_byindexPtr.asFunction<
      ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_tree>, int)>();

  /// Lookup a tree entry by SHA value.
  ///
  /// This returns a git_tree_entry that is owned by the git_tree.  You don't
  /// have to free it, but you must not use it after the git_tree is released.
  ///
  /// Warning: this must examine every entry in the tree, so it is not fast.
  ///
  /// @param tree a previously loaded tree.
  /// @param id the sha being looked for
  /// @return the tree entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_tree_entry_byid(
    ffi.Pointer<git_tree> tree,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tree_entry_byid(
      tree,
      id,
    );
  }

  late final _git_tree_entry_byidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_tree>,
              ffi.Pointer<git_oid>)>>('git_tree_entry_byid');
  late final _git_tree_entry_byid = _git_tree_entry_byidPtr.asFunction<
      ffi.Pointer<git_tree_entry> Function(
          ffi.Pointer<git_tree>, ffi.Pointer<git_oid>)>();

  /// Retrieve a tree entry contained in a tree or in any of its subtrees,
  /// given its relative path.
  ///
  /// Unlike the other lookup functions, the returned tree entry is owned by
  /// the user and must be freed explicitly with `git_tree_entry_free()`.
  ///
  /// @param out Pointer where to store the tree entry
  /// @param root Previously loaded tree which is the root of the relative path
  /// @param path Path to the contained entry
  /// @return 0 on success; GIT_ENOTFOUND if the path does not exist
  int git_tree_entry_bypath(
    ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
    ffi.Pointer<git_tree> root,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_tree_entry_bypath(
      out,
      root,
      path,
    );
  }

  late final _git_tree_entry_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tree_entry>>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<ffi.Char>)>>('git_tree_entry_bypath');
  late final _git_tree_entry_bypath = _git_tree_entry_bypathPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tree_entry>>,
          ffi.Pointer<git_tree>, ffi.Pointer<ffi.Char>)>();

  /// Duplicate a tree entry
  ///
  /// Create a copy of a tree entry. The returned copy is owned by the user,
  /// and must be freed explicitly with `git_tree_entry_free()`.
  ///
  /// @param dest pointer where to store the copy
  /// @param source tree entry to duplicate
  /// @return 0 or an error code
  int git_tree_entry_dup(
    ffi.Pointer<ffi.Pointer<git_tree_entry>> dest,
    ffi.Pointer<git_tree_entry> source,
  ) {
    return _git_tree_entry_dup(
      dest,
      source,
    );
  }

  late final _git_tree_entry_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree_entry>>,
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_dup');
  late final _git_tree_entry_dup = _git_tree_entry_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tree_entry>>,
          ffi.Pointer<git_tree_entry>)>();

  /// Free a user-owned tree entry
  ///
  /// IMPORTANT: This function is only needed for tree entries owned by the
  /// user, such as the ones returned by `git_tree_entry_dup()` or
  /// `git_tree_entry_bypath()`.
  ///
  /// @param entry The entry to free
  void git_tree_entry_free(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_free(
      entry,
    );
  }

  late final _git_tree_entry_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_tree_entry>)>>(
      'git_tree_entry_free');
  late final _git_tree_entry_free = _git_tree_entry_freePtr
      .asFunction<void Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the filename of a tree entry
  ///
  /// @param entry a tree entry
  /// @return the name of the file
  ffi.Pointer<ffi.Char> git_tree_entry_name(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_name(
      entry,
    );
  }

  late final _git_tree_entry_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_name');
  late final _git_tree_entry_name = _git_tree_entry_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the id of the object pointed by the entry
  ///
  /// @param entry a tree entry
  /// @return the oid of the object
  ffi.Pointer<git_oid> git_tree_entry_id(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_id(
      entry,
    );
  }

  late final _git_tree_entry_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_id');
  late final _git_tree_entry_id = _git_tree_entry_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the type of the object pointed by the entry
  ///
  /// @param entry a tree entry
  /// @return the type of the pointed object
  int git_tree_entry_type(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_type(
      entry,
    );
  }

  late final _git_tree_entry_typePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_tree_entry>)>>(
      'git_tree_entry_type');
  late final _git_tree_entry_type = _git_tree_entry_typePtr
      .asFunction<int Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the UNIX file attributes of a tree entry
  ///
  /// @param entry a tree entry
  /// @return filemode as an integer
  int git_tree_entry_filemode(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_filemode(
      entry,
    );
  }

  late final _git_tree_entry_filemodePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_tree_entry>)>>(
      'git_tree_entry_filemode');
  late final _git_tree_entry_filemode = _git_tree_entry_filemodePtr
      .asFunction<int Function(ffi.Pointer<git_tree_entry>)>();

  /// Get the raw UNIX file attributes of a tree entry
  ///
  /// This function does not perform any normalization and is only useful
  /// if you need to be able to recreate the original tree object.
  ///
  /// @param entry a tree entry
  /// @return filemode as an integer
  int git_tree_entry_filemode_raw(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_filemode_raw(
      entry,
    );
  }

  late final _git_tree_entry_filemode_rawPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_tree_entry>)>>(
      'git_tree_entry_filemode_raw');
  late final _git_tree_entry_filemode_raw = _git_tree_entry_filemode_rawPtr
      .asFunction<int Function(ffi.Pointer<git_tree_entry>)>();

  /// Compare two tree entries
  ///
  /// @param e1 first tree entry
  /// @param e2 second tree entry
  /// @return <0 if e1 is before e2, 0 if e1 == e2, >0 if e1 is after e2
  int git_tree_entry_cmp(
    ffi.Pointer<git_tree_entry> e1,
    ffi.Pointer<git_tree_entry> e2,
  ) {
    return _git_tree_entry_cmp(
      e1,
      e2,
    );
  }

  late final _git_tree_entry_cmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_tree_entry>,
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_cmp');
  late final _git_tree_entry_cmp = _git_tree_entry_cmpPtr.asFunction<
      int Function(ffi.Pointer<git_tree_entry>, ffi.Pointer<git_tree_entry>)>();

  /// Convert a tree entry to the git_object it points to.
  ///
  /// You must call `git_object_free()` on the object when you are done with it.
  ///
  /// @param object_out pointer to the converted object
  /// @param repo repository where to lookup the pointed object
  /// @param entry a tree entry
  /// @return 0 or an error code
  int git_tree_entry_to_object(
    ffi.Pointer<ffi.Pointer<git_object>> object_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_to_object(
      object_out,
      repo,
      entry,
    );
  }

  late final _git_tree_entry_to_objectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree_entry>)>>('git_tree_entry_to_object');
  late final _git_tree_entry_to_object =
      _git_tree_entry_to_objectPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_tree_entry>)>();

  /// Create a new tree builder.
  ///
  /// The tree builder can be used to create or modify trees in memory and
  /// write them as tree objects to the database.
  ///
  /// If the `source` parameter is not NULL, the tree builder will be
  /// initialized with the entries of the given tree.
  ///
  /// If the `source` parameter is NULL, the tree builder will start with no
  /// entries and will have to be filled manually.
  ///
  /// @param out Pointer where to store the tree builder
  /// @param repo Repository in which to store the object
  /// @param source Source tree to initialize the builder (optional)
  /// @return 0 on success; error code otherwise
  int git_treebuilder_new(
    ffi.Pointer<ffi.Pointer<git_treebuilder>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> source,
  ) {
    return _git_treebuilder_new(
      out,
      repo,
      source,
    );
  }

  late final _git_treebuilder_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_treebuilder>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>)>>('git_treebuilder_new');
  late final _git_treebuilder_new = _git_treebuilder_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_treebuilder>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_tree>)>();

  /// Clear all the entries in the builder
  ///
  /// @param bld Builder to clear
  /// @return 0 on success; error code otherwise
  int git_treebuilder_clear(
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_clear(
      bld,
    );
  }

  late final _git_treebuilder_clearPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_treebuilder>)>>(
      'git_treebuilder_clear');
  late final _git_treebuilder_clear = _git_treebuilder_clearPtr
      .asFunction<int Function(ffi.Pointer<git_treebuilder>)>();

  /// Get the number of entries listed in a treebuilder
  ///
  /// @param bld a previously loaded treebuilder.
  /// @return the number of entries in the treebuilder
  int git_treebuilder_entrycount(
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_entrycount(
      bld,
    );
  }

  late final _git_treebuilder_entrycountPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_treebuilder>)>>(
      'git_treebuilder_entrycount');
  late final _git_treebuilder_entrycount = _git_treebuilder_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_treebuilder>)>();

  /// Free a tree builder
  ///
  /// This will clear all the entries and free to builder.
  /// Failing to free the builder after you're done using it
  /// will result in a memory leak
  ///
  /// @param bld Builder to free
  void git_treebuilder_free(
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_free(
      bld,
    );
  }

  late final _git_treebuilder_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_treebuilder>)>>(
      'git_treebuilder_free');
  late final _git_treebuilder_free = _git_treebuilder_freePtr
      .asFunction<void Function(ffi.Pointer<git_treebuilder>)>();

  /// Get an entry from the builder from its filename
  ///
  /// The returned entry is owned by the builder and should
  /// not be freed manually.
  ///
  /// @param bld Tree builder
  /// @param filename Name of the entry
  /// @return pointer to the entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_treebuilder_get(
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _git_treebuilder_get(
      bld,
      filename,
    );
  }

  late final _git_treebuilder_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_tree_entry> Function(ffi.Pointer<git_treebuilder>,
              ffi.Pointer<ffi.Char>)>>('git_treebuilder_get');
  late final _git_treebuilder_get = _git_treebuilder_getPtr.asFunction<
      ffi.Pointer<git_tree_entry> Function(
          ffi.Pointer<git_treebuilder>, ffi.Pointer<ffi.Char>)>();

  /// Add or update an entry to the builder
  ///
  /// Insert a new entry for `filename` in the builder with the
  /// given attributes.
  ///
  /// If an entry named `filename` already exists, its attributes
  /// will be updated with the given ones.
  ///
  /// The optional pointer `out` can be used to retrieve a pointer to the
  /// newly created/updated entry.  Pass NULL if you do not need it. The
  /// pointer may not be valid past the next operation in this
  /// builder. Duplicate the entry if you want to keep it.
  ///
  /// By default the entry that you are inserting will be checked for
  /// validity; that it exists in the object database and is of the
  /// correct type.  If you do not want this behavior, set the
  /// `GIT_OPT_ENABLE_STRICT_OBJECT_CREATION` library option to false.
  ///
  /// @param out Pointer to store the entry (optional)
  /// @param bld Tree builder
  /// @param filename Filename of the entry
  /// @param id SHA1 oid of the entry
  /// @param filemode Folder attributes of the entry. This parameter must
  /// be valued with one of the following entries: 0040000, 0100644,
  /// 0100755, 0120000 or 0160000.
  /// @return 0 or an error code
  int git_treebuilder_insert(
    ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.Char> filename,
    ffi.Pointer<git_oid> id,
    int filemode,
  ) {
    return _git_treebuilder_insert(
      out,
      bld,
      filename,
      id,
      filemode,
    );
  }

  late final _git_treebuilder_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tree_entry>>,
              ffi.Pointer<git_treebuilder>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Int32)>>('git_treebuilder_insert');
  late final _git_treebuilder_insert = _git_treebuilder_insertPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_tree_entry>>,
          ffi.Pointer<git_treebuilder>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_oid>,
          int)>();

  /// Remove an entry from the builder by its filename
  ///
  /// @param bld Tree builder
  /// @param filename Filename of the entry to remove
  /// @return 0 or an error code
  int git_treebuilder_remove(
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.Char> filename,
  ) {
    return _git_treebuilder_remove(
      bld,
      filename,
    );
  }

  late final _git_treebuilder_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_treebuilder>,
              ffi.Pointer<ffi.Char>)>>('git_treebuilder_remove');
  late final _git_treebuilder_remove = _git_treebuilder_removePtr.asFunction<
      int Function(ffi.Pointer<git_treebuilder>, ffi.Pointer<ffi.Char>)>();

  /// Selectively remove entries in the tree
  ///
  /// The `filter` callback will be called for each entry in the tree with a
  /// pointer to the entry and the provided `payload`; if the callback returns
  /// non-zero, the entry will be filtered (removed from the builder).
  ///
  /// @param bld Tree builder
  /// @param filter Callback to filter entries
  /// @param payload Extra data to pass to filter callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_treebuilder_filter(
    ffi.Pointer<git_treebuilder> bld,
    git_treebuilder_filter_cb filter,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_treebuilder_filter(
      bld,
      filter,
      payload,
    );
  }

  late final _git_treebuilder_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_treebuilder>,
              git_treebuilder_filter_cb,
              ffi.Pointer<ffi.Void>)>>('git_treebuilder_filter');
  late final _git_treebuilder_filter = _git_treebuilder_filterPtr.asFunction<
      int Function(ffi.Pointer<git_treebuilder>, git_treebuilder_filter_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Write the contents of the tree builder as a tree object
  ///
  /// The tree builder will be written to the given `repo`, and its
  /// identifying SHA1 hash will be stored in the `id` pointer.
  ///
  /// @param id Pointer to store the OID of the newly written tree
  /// @param bld Tree builder to write
  /// @return 0 or an error code
  int git_treebuilder_write(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_write(
      id,
      bld,
    );
  }

  late final _git_treebuilder_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<git_treebuilder>)>>('git_treebuilder_write');
  late final _git_treebuilder_write = _git_treebuilder_writePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_treebuilder>)>();

  /// Traverse the entries in a tree and its subtrees in post or pre order.
  ///
  /// The entries will be traversed in the specified order, children subtrees
  /// will be automatically loaded as required, and the `callback` will be
  /// called once per entry with the current (relative) root for the entry and
  /// the entry data itself.
  ///
  /// If the callback returns a positive value, the passed entry will be
  /// skipped on the traversal (in pre mode). A negative value stops the walk.
  ///
  /// @param tree The tree to walk
  /// @param mode Traversal mode (pre or post-order)
  /// @param callback Function to call on each tree entry
  /// @param payload Opaque pointer to be passed on each callback
  /// @return 0 or an error code
  int git_tree_walk(
    ffi.Pointer<git_tree> tree,
    int mode,
    git_treewalk_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_tree_walk(
      tree,
      mode,
      callback,
      payload,
    );
  }

  late final _git_tree_walkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_tree>, ffi.Int32, git_treewalk_cb,
              ffi.Pointer<ffi.Void>)>>('git_tree_walk');
  late final _git_tree_walk = _git_tree_walkPtr.asFunction<
      int Function(ffi.Pointer<git_tree>, int, git_treewalk_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Create an in-memory copy of a tree. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the tree
  /// @param source Original tree to copy
  /// @return 0
  int git_tree_dup(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_tree> source,
  ) {
    return _git_tree_dup(
      out,
      source,
    );
  }

  late final _git_tree_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree>>,
              ffi.Pointer<git_tree>)>>('git_tree_dup');
  late final _git_tree_dup = _git_tree_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_tree>>, ffi.Pointer<git_tree>)>();

  /// Create a tree based on another one with the specified modifications
  ///
  /// Given the `baseline` perform the changes described in the list of
  /// `updates` and create a new tree.
  ///
  /// This function is optimized for common file/directory addition, removal and
  /// replacement in trees. It is much more efficient than reading the tree into a
  /// `git_index` and modifying that, but in exchange it is not as flexible.
  ///
  /// Deleting and adding the same entry is undefined behaviour, changing
  /// a tree to a blob or viceversa is not supported.
  ///
  /// @param out id of the new tree
  /// @param repo the repository in which to create the tree, must be the
  /// same as for `baseline`
  /// @param baseline the tree to base these changes on
  /// @param nupdates the number of elements in the update list
  /// @param updates the list of updates to perform
  /// @return 0 or an error code
  int git_tree_create_updated(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> baseline,
    int nupdates,
    ffi.Pointer<git_tree_update> updates,
  ) {
    return _git_tree_create_updated(
      out,
      repo,
      baseline,
      nupdates,
      updates,
    );
  }

  late final _git_tree_create_updatedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Size,
              ffi.Pointer<git_tree_update>)>>('git_tree_create_updated');
  late final _git_tree_create_updated = _git_tree_create_updatedPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>, int, ffi.Pointer<git_tree_update>)>();

  /// Free the strings contained in a string array.  This method should
  /// be called on `git_strarray` objects that were provided by the
  /// library.  Not doing so, will result in a memory leak.
  ///
  /// This does not free the `git_strarray` itself, since the library will
  /// never allocate that object directly itself.
  ///
  /// @param array The git_strarray that contains strings to free
  void git_strarray_dispose(
    ffi.Pointer<git_strarray> array,
  ) {
    return _git_strarray_dispose(
      array,
    );
  }

  late final _git_strarray_disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_strarray>)>>(
          'git_strarray_dispose');
  late final _git_strarray_dispose = _git_strarray_disposePtr
      .asFunction<void Function(ffi.Pointer<git_strarray>)>();

  /// Copy a string array object from source to target.
  ///
  /// Note: target is overwritten and hence should be empty, otherwise its
  /// contents are leaked.  Call git_strarray_free() if necessary.
  ///
  /// @param tgt target
  /// @param src source
  /// @return 0 on success, < 0 on allocation failure
  int git_strarray_copy(
    ffi.Pointer<git_strarray> tgt,
    ffi.Pointer<git_strarray> src,
  ) {
    return _git_strarray_copy(
      tgt,
      src,
    );
  }

  late final _git_strarray_copyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_strarray>)>>('git_strarray_copy');
  late final _git_strarray_copy = _git_strarray_copyPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_strarray>)>();

  /// Lookup a reference by name in a repository.
  ///
  /// The returned reference must be freed by the user.
  ///
  /// The name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param out pointer to the looked-up reference
  /// @param repo the repository to look up the reference
  /// @param name the long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
  int git_reference_lookup(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reference_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_reference_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_lookup');
  late final _git_reference_lookup = _git_reference_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Lookup a reference by name and resolve immediately to OID.
  ///
  /// This function provides a quick way to resolve a reference name straight
  /// through to the object id that it refers to.  This avoids having to
  /// allocate or free any `git_reference` objects for simple situations.
  ///
  /// The name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param out Pointer to oid to be filled in
  /// @param repo The repository in which to look up the reference
  /// @param name The long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
  int git_reference_name_to_id(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reference_name_to_id(
      out,
      repo,
      name,
    );
  }

  late final _git_reference_name_to_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_name_to_id');
  late final _git_reference_name_to_id =
      _git_reference_name_to_idPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Lookup a reference by DWIMing its short name
  ///
  /// Apply the git precedence rules to the given shorthand to determine
  /// which reference the user is referring to.
  ///
  /// @param out pointer in which to store the reference
  /// @param repo the repository in which to look
  /// @param shorthand the short name for the reference
  /// @return 0 or an error code
  int git_reference_dwim(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> shorthand,
  ) {
    return _git_reference_dwim(
      out,
      repo,
      shorthand,
    );
  }

  late final _git_reference_dwimPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_dwim');
  late final _git_reference_dwim = _git_reference_dwimPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Conditionally create a new symbolic reference.
  ///
  /// A symbolic reference is a reference name that refers to another
  /// reference name.  If the other name moves, the symbolic name will move,
  /// too.  As a simple example, the "HEAD" reference might refer to
  /// "refs/heads/master" while on the "master" branch of a repository.
  ///
  /// The symbolic reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// It will return GIT_EMODIFIED if the reference's value at the time
  /// of updating does not match the one passed through `current_value`
  /// (i.e. if the ref has changed since the user read it).
  ///
  /// If `current_value` is all zeros, this function will return GIT_EMODIFIED
  /// if the ref already exists.
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param target The target of the reference
  /// @param force Overwrite existing references
  /// @param current_value The expected value of the reference when updating
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC, GIT_EMODIFIED or an error code
  int git_reference_symbolic_create_matching(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> target,
    int force,
    ffi.Pointer<ffi.Char> current_value,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_symbolic_create_matching(
      out,
      repo,
      name,
      target,
      force,
      current_value,
      log_message,
    );
  }

  late final _git_reference_symbolic_create_matchingPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_reference>>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Int,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>)>>(
      'git_reference_symbolic_create_matching');
  late final _git_reference_symbolic_create_matching =
      _git_reference_symbolic_create_matchingPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new symbolic reference.
  ///
  /// A symbolic reference is a reference name that refers to another
  /// reference name.  If the other name moves, the symbolic name will move,
  /// too.  As a simple example, the "HEAD" reference might refer to
  /// "refs/heads/master" while on the "master" branch of a repository.
  ///
  /// The symbolic reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param target The target of the reference
  /// @param force Overwrite existing references
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
  int git_reference_symbolic_create(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> target,
    int force,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_symbolic_create(
      out,
      repo,
      name,
      target,
      force,
      log_message,
    );
  }

  late final _git_reference_symbolic_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_reference_symbolic_create');
  late final _git_reference_symbolic_create =
      _git_reference_symbolic_createPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new direct reference.
  ///
  /// A direct reference (also called an object id reference) refers directly
  /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
  /// permanently refers to the object (although the reference itself can be
  /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
  /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.
  ///
  /// The direct reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param id The object id pointed to by the reference.
  /// @param force Overwrite existing references
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
  int git_reference_create(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_oid> id,
    int force,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_create(
      out,
      repo,
      name,
      id,
      force,
      log_message,
    );
  }

  late final _git_reference_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_reference_create');
  late final _git_reference_create = _git_reference_createPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_oid>,
          int,
          ffi.Pointer<ffi.Char>)>();

  /// Conditionally create new direct reference
  ///
  /// A direct reference (also called an object id reference) refers directly
  /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
  /// permanently refers to the object (although the reference itself can be
  /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
  /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.
  ///
  /// The direct reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// It will return GIT_EMODIFIED if the reference's value at the time
  /// of updating does not match the one passed through `current_id`
  /// (i.e. if the ref has changed since the user read it).
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param id The object id pointed to by the reference.
  /// @param force Overwrite existing references
  /// @param current_id The expected value of the reference at the time of update
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EMODIFIED if the value of the reference
  /// has changed, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
  int git_reference_create_matching(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_oid> id,
    int force,
    ffi.Pointer<git_oid> current_id,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_create_matching(
      out,
      repo,
      name,
      id,
      force,
      current_id,
      log_message,
    );
  }

  late final _git_reference_create_matchingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Int,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_reference_create_matching');
  late final _git_reference_create_matching =
      _git_reference_create_matchingPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              int,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the OID pointed to by a direct reference.
  ///
  /// Only available if the reference is direct (i.e. an object id reference,
  /// not a symbolic one).
  ///
  /// To find the OID of a symbolic ref, call `git_reference_resolve()` and
  /// then this function (or maybe use `git_reference_name_to_id()` to
  /// directly resolve a reference name all the way through to an OID).
  ///
  /// @param ref The reference
  /// @return a pointer to the oid if available, NULL otherwise
  ffi.Pointer<git_oid> git_reference_target(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_target(
      ref,
    );
  }

  late final _git_reference_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_reference>)>>('git_reference_target');
  late final _git_reference_target = _git_reference_targetPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_reference>)>();

  /// Return the peeled OID target of this reference.
  ///
  /// This peeled OID only applies to direct references that point to
  /// a hard Tag object: it is the result of peeling such Tag.
  ///
  /// @param ref The reference
  /// @return a pointer to the oid if available, NULL otherwise
  ffi.Pointer<git_oid> git_reference_target_peel(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_target_peel(
      ref,
    );
  }

  late final _git_reference_target_peelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_reference>)>>('git_reference_target_peel');
  late final _git_reference_target_peel = _git_reference_target_peelPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_reference>)>();

  /// Get full name to the reference pointed to by a symbolic reference.
  ///
  /// Only available if the reference is symbolic.
  ///
  /// @param ref The reference
  /// @return a pointer to the name if available, NULL otherwise
  ffi.Pointer<ffi.Char> git_reference_symbolic_target(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_symbolic_target(
      ref,
    );
  }

  late final _git_reference_symbolic_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_reference>)>>('git_reference_symbolic_target');
  late final _git_reference_symbolic_target = _git_reference_symbolic_targetPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference>)>();

  /// Get the type of a reference.
  ///
  /// Either direct (GIT_REFERENCE_DIRECT) or symbolic (GIT_REFERENCE_SYMBOLIC)
  ///
  /// @param ref The reference
  /// @return the type
  int git_reference_type(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_type(
      ref,
    );
  }

  late final _git_reference_typePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_reference>)>>(
      'git_reference_type');
  late final _git_reference_type = _git_reference_typePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Get the full name of a reference.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param ref The reference
  /// @return the full name for the ref
  ffi.Pointer<ffi.Char> git_reference_name(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_name(
      ref,
    );
  }

  late final _git_reference_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_reference>)>>('git_reference_name');
  late final _git_reference_name = _git_reference_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference>)>();

  /// Resolve a symbolic reference to a direct reference.
  ///
  /// This method iteratively peels a symbolic reference until it resolves to
  /// a direct reference to an OID.
  ///
  /// The peeled reference is returned in the `resolved_ref` argument, and
  /// must be freed manually once it's no longer needed.
  ///
  /// If a direct reference is passed as an argument, a copy of that
  /// reference is returned. This copy must be manually freed too.
  ///
  /// @param out Pointer to the peeled reference
  /// @param ref The reference
  /// @return 0 or an error code
  int git_reference_resolve(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_resolve(
      out,
      ref,
    );
  }

  late final _git_reference_resolvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>)>>('git_reference_resolve');
  late final _git_reference_resolve = _git_reference_resolvePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>)>();

  /// Get the repository where a reference resides.
  ///
  /// @param ref The reference
  /// @return a pointer to the repo
  ffi.Pointer<git_repository> git_reference_owner(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_owner(
      ref,
    );
  }

  late final _git_reference_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_reference>)>>('git_reference_owner');
  late final _git_reference_owner = _git_reference_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_reference>)>();

  /// Create a new reference with the same name as the given reference but a
  /// different symbolic target. The reference must be a symbolic reference,
  /// otherwise this will fail.
  ///
  /// The new reference will be written to disk, overwriting the given reference.
  ///
  /// The target name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// @param out Pointer to the newly created reference
  /// @param ref The reference
  /// @param target The new target for the reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  int git_reference_symbolic_set_target(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<ffi.Char> target,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_symbolic_set_target(
      out,
      ref,
      target,
      log_message,
    );
  }

  late final _git_reference_symbolic_set_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_reference_symbolic_set_target');
  late final _git_reference_symbolic_set_target =
      _git_reference_symbolic_set_targetPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Conditionally create a new reference with the same name as the given reference but a
  /// different OID target. The reference must be a direct reference, otherwise
  /// this will fail.
  ///
  /// The new reference will be written to disk, overwriting the given reference.
  ///
  /// @param out Pointer to the newly created reference
  /// @param ref The reference
  /// @param id The new target OID for the reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EMODIFIED if the value of the reference
  /// has changed since it was read, or an error code
  int git_reference_set_target(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_set_target(
      out,
      ref,
      id,
      log_message,
    );
  }

  late final _git_reference_set_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_reference_set_target');
  late final _git_reference_set_target =
      _git_reference_set_targetPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>();

  /// Rename an existing reference.
  ///
  /// This method works for both direct and symbolic references.
  ///
  /// The new name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// If the `force` flag is not enabled, and there's already
  /// a reference with the given name, the renaming will fail.
  ///
  /// IMPORTANT:
  /// The user needs to write a proper reflog entry if the
  /// reflog is enabled for the repository. We only rename
  /// the reflog if it exists.
  ///
  /// @param ref The reference to rename
  /// @param new_name The new name for the reference
  /// @param force Overwrite an existing reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_reference_rename(
    ffi.Pointer<ffi.Pointer<git_reference>> new_ref,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<ffi.Char> new_name,
    int force,
    ffi.Pointer<ffi.Char> log_message,
  ) {
    return _git_reference_rename(
      new_ref,
      ref,
      new_name,
      force,
      log_message,
    );
  }

  late final _git_reference_renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Pointer<ffi.Char>)>>('git_reference_rename');
  late final _git_reference_rename = _git_reference_renamePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>)>();

  /// Delete an existing reference.
  ///
  /// This method works for both direct and symbolic references.  The reference
  /// will be immediately removed on disk but the memory will not be freed.
  /// Callers must call `git_reference_free`.
  ///
  /// This function will return an error if the reference has changed
  /// from the time it was looked up.
  ///
  /// @param ref The reference to remove
  /// @return 0, GIT_EMODIFIED or an error code
  int git_reference_delete(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_delete(
      ref,
    );
  }

  late final _git_reference_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_delete');
  late final _git_reference_delete = _git_reference_deletePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Delete an existing reference by name
  ///
  /// This method removes the named reference from the repository without
  /// looking at its old value.
  ///
  /// @param name The reference to remove
  /// @return 0 or an error code
  int git_reference_remove(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reference_remove(
      repo,
      name,
    );
  }

  late final _git_reference_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_remove');
  late final _git_reference_remove = _git_reference_removePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Fill a list with all the references that can be found in a repository.
  ///
  /// The string array will be filled with the names of all references; these
  /// values are owned by the user and should be free'd manually when no
  /// longer needed, using `git_strarray_free()`.
  ///
  /// @param array Pointer to a git_strarray structure where
  /// the reference names will be stored
  /// @param repo Repository where to find the refs
  /// @return 0 or an error code
  int git_reference_list(
    ffi.Pointer<git_strarray> array,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_reference_list(
      array,
      repo,
    );
  }

  late final _git_reference_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>)>>('git_reference_list');
  late final _git_reference_list = _git_reference_listPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>)>();

  /// Perform a callback on each reference in the repository.
  ///
  /// The `callback` function will be called for each reference in the
  /// repository, receiving the reference object and the `payload` value
  /// passed to this method.  Returning a non-zero value from the callback
  /// will terminate the iteration.
  ///
  /// Note that the callback function is responsible to call `git_reference_free`
  /// on each reference passed to it.
  ///
  /// @param repo Repository where to find the refs
  /// @param callback Function which will be called for every listed ref
  /// @param payload Additional data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_reference_foreach(
    ffi.Pointer<git_repository> repo,
    git_reference_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_reference_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_reference_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              git_reference_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_reference_foreach');
  late final _git_reference_foreach = _git_reference_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, git_reference_foreach_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Perform a callback on the fully-qualified name of each reference.
  ///
  /// The `callback` function will be called for each reference in the
  /// repository, receiving the name of the reference and the `payload` value
  /// passed to this method.  Returning a non-zero value from the callback
  /// will terminate the iteration.
  ///
  /// @param repo Repository where to find the refs
  /// @param callback Function which will be called for every listed ref name
  /// @param payload Additional data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_reference_foreach_name(
    ffi.Pointer<git_repository> repo,
    git_reference_foreach_name_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_reference_foreach_name(
      repo,
      callback,
      payload,
    );
  }

  late final _git_reference_foreach_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              git_reference_foreach_name_cb,
              ffi.Pointer<ffi.Void>)>>('git_reference_foreach_name');
  late final _git_reference_foreach_name =
      _git_reference_foreach_namePtr.asFunction<
          int Function(ffi.Pointer<git_repository>,
              git_reference_foreach_name_cb, ffi.Pointer<ffi.Void>)>();

  /// Create a copy of an existing reference.
  ///
  /// Call `git_reference_free` to free the data.
  ///
  /// @param dest pointer where to store the copy
  /// @param source object to copy
  /// @return 0 or an error code
  int git_reference_dup(
    ffi.Pointer<ffi.Pointer<git_reference>> dest,
    ffi.Pointer<git_reference> source,
  ) {
    return _git_reference_dup(
      dest,
      source,
    );
  }

  late final _git_reference_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>)>>('git_reference_dup');
  late final _git_reference_dup = _git_reference_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>)>();

  /// Free the given reference.
  ///
  /// @param ref git_reference
  void git_reference_free(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_free(
      ref,
    );
  }

  late final _git_reference_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_reference>)>>(
      'git_reference_free');
  late final _git_reference_free = _git_reference_freePtr
      .asFunction<void Function(ffi.Pointer<git_reference>)>();

  /// Compare two references.
  ///
  /// @param ref1 The first git_reference
  /// @param ref2 The second git_reference
  /// @return 0 if the same, else a stable but meaningless ordering.
  int git_reference_cmp(
    ffi.Pointer<git_reference> ref1,
    ffi.Pointer<git_reference> ref2,
  ) {
    return _git_reference_cmp(
      ref1,
      ref2,
    );
  }

  late final _git_reference_cmpPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_reference>,
              ffi.Pointer<git_reference>)>>('git_reference_cmp');
  late final _git_reference_cmp = _git_reference_cmpPtr.asFunction<
      int Function(ffi.Pointer<git_reference>, ffi.Pointer<git_reference>)>();

  /// Create an iterator for the repo's references
  ///
  /// @param out pointer in which to store the iterator
  /// @param repo the repository
  /// @return 0 or an error code
  int git_reference_iterator_new(
    ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_reference_iterator_new(
      out,
      repo,
    );
  }

  late final _git_reference_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference_iterator>>,
              ffi.Pointer<git_repository>)>>('git_reference_iterator_new');
  late final _git_reference_iterator_new =
      _git_reference_iterator_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_reference_iterator>>,
              ffi.Pointer<git_repository>)>();

  /// Create an iterator for the repo's references that match the
  /// specified glob
  ///
  /// @param out pointer in which to store the iterator
  /// @param repo the repository
  /// @param glob the glob to match against the reference names
  /// @return 0 or an error code
  int git_reference_iterator_glob_new(
    ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> glob,
  ) {
    return _git_reference_iterator_glob_new(
      out,
      repo,
      glob,
    );
  }

  late final _git_reference_iterator_glob_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference_iterator>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_iterator_glob_new');
  late final _git_reference_iterator_glob_new =
      _git_reference_iterator_glob_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_reference_iterator>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Get the next reference
  ///
  /// @param out pointer in which to store the reference
  /// @param iter the iterator
  /// @return 0, GIT_ITEROVER if there are no more; or an error code
  int git_reference_next(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference_iterator> iter,
  ) {
    return _git_reference_next(
      out,
      iter,
    );
  }

  late final _git_reference_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference_iterator>)>>('git_reference_next');
  late final _git_reference_next = _git_reference_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference_iterator>)>();

  /// Get the next reference's name
  ///
  /// This function is provided for convenience in case only the names
  /// are interesting as it avoids the allocation of the `git_reference`
  /// object which `git_reference_next()` needs.
  ///
  /// @param out pointer in which to store the string
  /// @param iter the iterator
  /// @return 0, GIT_ITEROVER if there are no more; or an error code
  int git_reference_next_name(
    ffi.Pointer<ffi.Pointer<ffi.Char>> out,
    ffi.Pointer<git_reference_iterator> iter,
  ) {
    return _git_reference_next_name(
      out,
      iter,
    );
  }

  late final _git_reference_next_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_reference_iterator>)>>('git_reference_next_name');
  late final _git_reference_next_name = _git_reference_next_namePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_reference_iterator>)>();

  /// Free the iterator and its associated resources
  ///
  /// @param iter the iterator to free
  void git_reference_iterator_free(
    ffi.Pointer<git_reference_iterator> iter,
  ) {
    return _git_reference_iterator_free(
      iter,
    );
  }

  late final _git_reference_iterator_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_reference_iterator>)>>(
      'git_reference_iterator_free');
  late final _git_reference_iterator_free = _git_reference_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_reference_iterator>)>();

  /// Perform a callback on each reference in the repository whose name
  /// matches the given pattern.
  ///
  /// This function acts like `git_reference_foreach()` with an additional
  /// pattern match being applied to the reference name before issuing the
  /// callback function.  See that function for more information.
  ///
  /// The pattern is matched using fnmatch or "glob" style where a '*' matches
  /// any sequence of letters, a '?' matches any letter, and square brackets
  /// can be used to define character ranges (such as "[0-9]" for digits).
  ///
  /// @param repo Repository where to find the refs
  /// @param glob Pattern to match (fnmatch-style) against reference name.
  /// @param callback Function which will be called for every listed ref
  /// @param payload Additional data to pass to the callback
  /// @return 0 on success, GIT_EUSER on non-zero callback, or error code
  int git_reference_foreach_glob(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> glob,
    git_reference_foreach_name_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_reference_foreach_glob(
      repo,
      glob,
      callback,
      payload,
    );
  }

  late final _git_reference_foreach_globPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              git_reference_foreach_name_cb,
              ffi.Pointer<ffi.Void>)>>('git_reference_foreach_glob');
  late final _git_reference_foreach_glob =
      _git_reference_foreach_globPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              git_reference_foreach_name_cb, ffi.Pointer<ffi.Void>)>();

  /// Check if a reflog exists for the specified reference.
  ///
  /// @param repo the repository
  /// @param refname the reference's name
  /// @return 0 when no reflog can be found, 1 when it exists;
  /// otherwise an error code.
  int git_reference_has_log(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_reference_has_log(
      repo,
      refname,
    );
  }

  late final _git_reference_has_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_has_log');
  late final _git_reference_has_log = _git_reference_has_logPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Ensure there is a reflog for a particular reference.
  ///
  /// Make sure that successive updates to the reference will append to
  /// its log.
  ///
  /// @param repo the repository
  /// @param refname the reference's name
  /// @return 0 or an error code.
  int git_reference_ensure_log(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_reference_ensure_log(
      repo,
      refname,
    );
  }

  late final _git_reference_ensure_logPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reference_ensure_log');
  late final _git_reference_ensure_log =
      _git_reference_ensure_logPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Check if a reference is a local branch.
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/heads
  /// namespace; 0 otherwise.
  int git_reference_is_branch(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_branch(
      ref,
    );
  }

  late final _git_reference_is_branchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_is_branch');
  late final _git_reference_is_branch = _git_reference_is_branchPtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Check if a reference is a remote tracking branch
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/remotes
  /// namespace; 0 otherwise.
  int git_reference_is_remote(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_remote(
      ref,
    );
  }

  late final _git_reference_is_remotePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_is_remote');
  late final _git_reference_is_remote = _git_reference_is_remotePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Check if a reference is a tag
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/tags
  /// namespace; 0 otherwise.
  int git_reference_is_tag(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_tag(
      ref,
    );
  }

  late final _git_reference_is_tagPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_is_tag');
  late final _git_reference_is_tag = _git_reference_is_tagPtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Check if a reference is a note
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/notes
  /// namespace; 0 otherwise.
  int git_reference_is_note(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_note(
      ref,
    );
  }

  late final _git_reference_is_notePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_reference_is_note');
  late final _git_reference_is_note = _git_reference_is_notePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Normalize reference name and check validity.
  ///
  /// This will normalize the reference name by removing any leading slash
  /// '/' characters and collapsing runs of adjacent slashes between name
  /// components into a single slash.
  ///
  /// Once normalized, if the reference name is valid, it will be returned in
  /// the user allocated buffer.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param buffer_out User allocated buffer to store normalized name
  /// @param buffer_size Size of buffer_out
  /// @param name Reference name to be checked.
  /// @param flags Flags to constrain name validation rules - see the
  /// GIT_REFERENCE_FORMAT constants above.
  /// @return 0 on success, GIT_EBUFS if buffer is too small, GIT_EINVALIDSPEC
  /// or an error code.
  int git_reference_normalize_name(
    ffi.Pointer<ffi.Char> buffer_out,
    int buffer_size,
    ffi.Pointer<ffi.Char> name,
    int flags,
  ) {
    return _git_reference_normalize_name(
      buffer_out,
      buffer_size,
      name,
      flags,
    );
  }

  late final _git_reference_normalize_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt)>>('git_reference_normalize_name');
  late final _git_reference_normalize_name =
      _git_reference_normalize_namePtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Char>, int, ffi.Pointer<ffi.Char>, int)>();

  /// Recursively peel reference until object of the specified type is found.
  ///
  /// The retrieved `peeled` object is owned by the repository
  /// and should be closed with the `git_object_free` method.
  ///
  /// If you pass `GIT_OBJECT_ANY` as the target type, then the object
  /// will be peeled until a non-tag object is met.
  ///
  /// @param out Pointer to the peeled git_object
  /// @param ref The reference to be processed
  /// @param type The type of the requested object (GIT_OBJECT_COMMIT,
  /// GIT_OBJECT_TAG, GIT_OBJECT_TREE, GIT_OBJECT_BLOB or GIT_OBJECT_ANY).
  /// @return 0 on success, GIT_EAMBIGUOUS, GIT_ENOTFOUND or an error code
  int git_reference_peel(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_reference> ref,
    int type,
  ) {
    return _git_reference_peel(
      out,
      ref,
      type,
    );
  }

  late final _git_reference_peelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_reference>, ffi.Int32)>>('git_reference_peel');
  late final _git_reference_peel = _git_reference_peelPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_reference>, int)>();

  /// Ensure the reference name is well-formed.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// @param valid output pointer to set with validity of given reference name
  /// @param refname name to be checked.
  /// @return 0 on success or an error code
  int git_reference_name_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_reference_name_is_valid(
      valid,
      refname,
    );
  }

  late final _git_reference_name_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_reference_name_is_valid');
  late final _git_reference_name_is_valid = _git_reference_name_is_validPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Get the reference's short name
  ///
  /// This will transform the reference name into a name "human-readable"
  /// version. If no shortname is appropriate, it will return the full
  /// name.
  ///
  /// The memory is owned by the reference and must not be freed.
  ///
  /// @param ref a reference
  /// @return the human-readable version of the name
  ffi.Pointer<ffi.Char> git_reference_shorthand(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_shorthand(
      ref,
    );
  }

  late final _git_reference_shorthandPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_reference>)>>('git_reference_shorthand');
  late final _git_reference_shorthand = _git_reference_shorthandPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reference>)>();

  /// Initialize git_diff_options structure
  ///
  /// Initializes a `git_diff_options` with default values. Equivalent to creating
  /// an instance with GIT_DIFF_OPTIONS_INIT.
  ///
  /// @param opts The `git_diff_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_options_init(
    ffi.Pointer<git_diff_options> opts,
    int version,
  ) {
    return _git_diff_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_options>,
              ffi.UnsignedInt)>>('git_diff_options_init');
  late final _git_diff_options_init = _git_diff_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_diff_options>, int)>();

  /// Initialize git_diff_find_options structure
  ///
  /// Initializes a `git_diff_find_options` with default values. Equivalent to creating
  /// an instance with GIT_DIFF_FIND_OPTIONS_INIT.
  ///
  /// @param opts The `git_diff_find_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_FIND_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_find_options_init(
    ffi.Pointer<git_diff_find_options> opts,
    int version,
  ) {
    return _git_diff_find_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_find_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_find_options>,
              ffi.UnsignedInt)>>('git_diff_find_options_init');
  late final _git_diff_find_options_init = _git_diff_find_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_diff_find_options>, int)>();

  /// Deallocate a diff.
  ///
  /// @param diff The previously created diff; cannot be used after free.
  void git_diff_free(
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_free(
      diff,
    );
  }

  late final _git_diff_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_diff>)>>(
          'git_diff_free');
  late final _git_diff_free =
      _git_diff_freePtr.asFunction<void Function(ffi.Pointer<git_diff>)>();

  /// Create a diff with the difference between two tree objects.
  ///
  /// This is equivalent to `git diff <old-tree> <new-tree>`
  ///
  /// The first tree will be used for the "old_file" side of the delta and the
  /// second tree will be used for the "new_file" side of the delta.  You can
  /// pass NULL to indicate an empty tree, although it is an error to pass
  /// NULL for both the `old_tree` and `new_tree`.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository containing the trees.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param new_tree A git_tree object to diff to, or NULL for empty tree.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_tree_to_tree(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_tree> new_tree,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_tree(
      diff,
      repo,
      old_tree,
      new_tree,
      opts,
    );
  }

  late final _git_diff_tree_to_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff_options>)>>('git_diff_tree_to_tree');
  late final _git_diff_tree_to_tree = _git_diff_tree_to_treePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_diff>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_diff_options>)>();

  /// Create a diff between a tree and repository index.
  ///
  /// This is equivalent to `git diff --cached <treeish>` or if you pass
  /// the HEAD tree, then like `git diff --cached`.
  ///
  /// The tree you pass will be used for the "old_file" side of the delta, and
  /// the index will be used for the "new_file" side of the delta.
  ///
  /// If you pass NULL for the index, then the existing index of the `repo`
  /// will be used.  In this case, the index will be refreshed from disk
  /// (if it has changed) before the diff is generated.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository containing the tree and index.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param index The index to diff with; repo index used if NULL.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_tree_to_index(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_index(
      diff,
      repo,
      old_tree,
      index,
      opts,
    );
  }

  late final _git_diff_tree_to_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_diff_options>)>>('git_diff_tree_to_index');
  late final _git_diff_tree_to_index = _git_diff_tree_to_indexPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_diff>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_index>,
          ffi.Pointer<git_diff_options>)>();

  /// Create a diff between the repository index and the workdir directory.
  ///
  /// This matches the `git diff` command.  See the note below on
  /// `git_diff_tree_to_workdir` for a discussion of the difference between
  /// `git diff` and `git diff HEAD` and how to emulate a `git diff <treeish>`
  /// using libgit2.
  ///
  /// The index will be used for the "old_file" side of the delta, and the
  /// working directory will be used for the "new_file" side of the delta.
  ///
  /// If you pass NULL for the index, then the existing index of the `repo`
  /// will be used.  In this case, the index will be refreshed from disk
  /// (if it has changed) before the diff is generated.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository.
  /// @param index The index to diff from; repo index used if NULL.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_index_to_workdir(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_index_to_workdir(
      diff,
      repo,
      index,
      opts,
    );
  }

  late final _git_diff_index_to_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_diff_options>)>>('git_diff_index_to_workdir');
  late final _git_diff_index_to_workdir =
      _git_diff_index_to_workdirPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_diff_options>)>();

  /// Create a diff between a tree and the working directory.
  ///
  /// The tree you provide will be used for the "old_file" side of the delta,
  /// and the working directory will be used for the "new_file" side.
  ///
  /// This is not the same as `git diff <treeish>` or `git diff-index
  /// <treeish>`.  Those commands use information from the index, whereas this
  /// function strictly returns the differences between the tree and the files
  /// in the working directory, regardless of the state of the index.  Use
  /// `git_diff_tree_to_workdir_with_index` to emulate those commands.
  ///
  /// To see difference between this and `git_diff_tree_to_workdir_with_index`,
  /// consider the example of a staged file deletion where the file has then
  /// been put back into the working dir and further modified.  The
  /// tree-to-workdir diff for that file is 'modified', but `git diff` would
  /// show status 'deleted' since there is a staged delete.
  ///
  /// @param diff A pointer to a git_diff pointer that will be allocated.
  /// @param repo The repository containing the tree.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_tree_to_workdir(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_workdir(
      diff,
      repo,
      old_tree,
      opts,
    );
  }

  late final _git_diff_tree_to_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff_options>)>>('git_diff_tree_to_workdir');
  late final _git_diff_tree_to_workdir =
      _git_diff_tree_to_workdirPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff_options>)>();

  /// Create a diff between a tree and the working directory using index data
  /// to account for staged deletes, tracked files, etc.
  ///
  /// This emulates `git diff <tree>` by diffing the tree to the index and
  /// the index to the working directory and blending the results into a
  /// single diff that includes staged deleted, etc.
  ///
  /// @param diff A pointer to a git_diff pointer that will be allocated.
  /// @param repo The repository containing the tree.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_tree_to_workdir_with_index(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_workdir_with_index(
      diff,
      repo,
      old_tree,
      opts,
    );
  }

  late final _git_diff_tree_to_workdir_with_indexPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_diff>>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<git_tree>,
                  ffi.Pointer<git_diff_options>)>>(
      'git_diff_tree_to_workdir_with_index');
  late final _git_diff_tree_to_workdir_with_index =
      _git_diff_tree_to_workdir_with_indexPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff_options>)>();

  /// Create a diff with the difference between two index objects.
  ///
  /// The first index will be used for the "old_file" side of the delta and the
  /// second index will be used for the "new_file" side of the delta.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository containing the indexes.
  /// @param old_index A git_index object to diff from.
  /// @param new_index A git_index object to diff to.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code.
  int git_diff_index_to_index(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> old_index,
    ffi.Pointer<git_index> new_index,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_index_to_index(
      diff,
      repo,
      old_index,
      new_index,
      opts,
    );
  }

  late final _git_diff_index_to_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_index>,
              ffi.Pointer<git_diff_options>)>>('git_diff_index_to_index');
  late final _git_diff_index_to_index = _git_diff_index_to_indexPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_diff>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_index>,
          ffi.Pointer<git_index>,
          ffi.Pointer<git_diff_options>)>();

  /// Merge one diff into another.
  ///
  /// This merges items from the "from" list into the "onto" list.  The
  /// resulting diff will have all items that appear in either list.
  /// If an item appears in both lists, then it will be "merged" to appear
  /// as if the old version was from the "onto" list and the new version
  /// is from the "from" list (with the exception that if the item has a
  /// pending DELETE in the middle, then it will show as deleted).
  ///
  /// @param onto Diff to merge into.
  /// @param from Diff to merge.
  /// @return 0 or an error code.
  int git_diff_merge(
    ffi.Pointer<git_diff> onto,
    ffi.Pointer<git_diff> from,
  ) {
    return _git_diff_merge(
      onto,
      from,
    );
  }

  late final _git_diff_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_diff>, ffi.Pointer<git_diff>)>>('git_diff_merge');
  late final _git_diff_merge = _git_diff_mergePtr
      .asFunction<int Function(ffi.Pointer<git_diff>, ffi.Pointer<git_diff>)>();

  /// Transform a diff marking file renames, copies, etc.
  ///
  /// This modifies a diff in place, replacing old entries that look
  /// like renames or copies with new entries reflecting those changes.
  /// This also will, if requested, break modified files into add/remove
  /// pairs if the amount of change is above a threshold.
  ///
  /// @param diff diff to run detection algorithms on
  /// @param options Control how detection should be run, NULL for defaults
  /// @return 0 on success, -1 on failure
  int git_diff_find_similar(
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_diff_find_options> options,
  ) {
    return _git_diff_find_similar(
      diff,
      options,
    );
  }

  late final _git_diff_find_similarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff>,
              ffi.Pointer<git_diff_find_options>)>>('git_diff_find_similar');
  late final _git_diff_find_similar = _git_diff_find_similarPtr.asFunction<
      int Function(
          ffi.Pointer<git_diff>, ffi.Pointer<git_diff_find_options>)>();

  /// Query how many diff records are there in a diff.
  ///
  /// @param diff A git_diff generated by one of the above functions
  /// @return Count of number of deltas in the list
  int git_diff_num_deltas(
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_num_deltas(
      diff,
    );
  }

  late final _git_diff_num_deltasPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_diff>)>>(
          'git_diff_num_deltas');
  late final _git_diff_num_deltas =
      _git_diff_num_deltasPtr.asFunction<int Function(ffi.Pointer<git_diff>)>();

  /// Query how many diff deltas are there in a diff filtered by type.
  ///
  /// This works just like `git_diff_num_deltas()` with an extra parameter
  /// that is a `git_delta_t` and returns just the count of how many deltas
  /// match that particular type.
  ///
  /// @param diff A git_diff generated by one of the above functions
  /// @param type A git_delta_t value to filter the count
  /// @return Count of number of deltas matching delta_t type
  int git_diff_num_deltas_of_type(
    ffi.Pointer<git_diff> diff,
    int type,
  ) {
    return _git_diff_num_deltas_of_type(
      diff,
      type,
    );
  }

  late final _git_diff_num_deltas_of_typePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<git_diff>,
              ffi.Int32)>>('git_diff_num_deltas_of_type');
  late final _git_diff_num_deltas_of_type = _git_diff_num_deltas_of_typePtr
      .asFunction<int Function(ffi.Pointer<git_diff>, int)>();

  /// Return the diff delta for an entry in the diff list.
  ///
  /// The `git_diff_delta` pointer points to internal data and you do not
  /// have to release it when you are done with it.  It will go away when
  /// the * `git_diff` (or any associated `git_patch`) goes away.
  ///
  /// Note that the flags on the delta related to whether it has binary
  /// content or not may not be set if there are no attributes set for the
  /// file and there has been no reason to load the file data at this point.
  /// For now, if you need those flags to be up to date, your only option is
  /// to either use `git_diff_foreach` or create a `git_patch`.
  ///
  /// @param diff Diff list object
  /// @param idx Index into diff list
  /// @return Pointer to git_diff_delta (or NULL if `idx` out of range)
  ffi.Pointer<git_diff_delta> git_diff_get_delta(
    ffi.Pointer<git_diff> diff,
    int idx,
  ) {
    return _git_diff_get_delta(
      diff,
      idx,
    );
  }

  late final _git_diff_get_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_diff_delta> Function(
              ffi.Pointer<git_diff>, ffi.Size)>>('git_diff_get_delta');
  late final _git_diff_get_delta = _git_diff_get_deltaPtr.asFunction<
      ffi.Pointer<git_diff_delta> Function(ffi.Pointer<git_diff>, int)>();

  /// Check if deltas are sorted case sensitively or insensitively.
  ///
  /// @param diff diff to check
  /// @return 0 if case sensitive, 1 if case is ignored
  int git_diff_is_sorted_icase(
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_is_sorted_icase(
      diff,
    );
  }

  late final _git_diff_is_sorted_icasePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_diff>)>>(
          'git_diff_is_sorted_icase');
  late final _git_diff_is_sorted_icase = _git_diff_is_sorted_icasePtr
      .asFunction<int Function(ffi.Pointer<git_diff>)>();

  /// Loop over all deltas in a diff issuing callbacks.
  ///
  /// This will iterate through all of the files described in a diff.  You
  /// should provide a file callback to learn about each file.
  ///
  /// The "hunk" and "line" callbacks are optional, and the text diff of the
  /// files will only be calculated if they are not NULL.  Of course, these
  /// callbacks will not be invoked for binary files on the diff or for
  /// files whose only changed is a file mode change.
  ///
  /// Returning a non-zero value from any of the callbacks will terminate
  /// the iteration and return the value to the user.
  ///
  /// @param diff A git_diff generated by one of the above functions.
  /// @param file_cb Callback function to make per file in the diff.
  /// @param binary_cb Optional callback to make for binary files.
  /// @param hunk_cb Optional callback to make per hunk of text diff.  This
  /// callback is called to describe a range of lines in the
  /// diff.  It will not be issued for binary files.
  /// @param line_cb Optional callback to make per line of diff text.  This
  /// same callback will be made for context lines, added, and
  /// removed lines, and even for a deleted trailing newline.
  /// @param payload Reference pointer that will be passed to your callbacks.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_foreach(
    ffi.Pointer<git_diff> diff,
    git_diff_file_cb file_cb,
    git_diff_binary_cb binary_cb,
    git_diff_hunk_cb hunk_cb,
    git_diff_line_cb line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_foreach(
      diff,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_diff>,
              git_diff_file_cb,
              git_diff_binary_cb,
              git_diff_hunk_cb,
              git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_diff_foreach');
  late final _git_diff_foreach = _git_diff_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_diff>, git_diff_file_cb, git_diff_binary_cb,
          git_diff_hunk_cb, git_diff_line_cb, ffi.Pointer<ffi.Void>)>();

  /// Look up the single character abbreviation for a delta status code.
  ///
  /// When you run `git diff --name-status` it uses single letter codes in
  /// the output such as 'A' for added, 'D' for deleted, 'M' for modified,
  /// etc.  This function converts a git_delta_t value into these letters for
  /// your own purposes.  GIT_DELTA_UNTRACKED will return a space (i.e. ' ').
  ///
  /// @param status The git_delta_t value to look up
  /// @return The single character label for that code
  int git_diff_status_char(
    int status,
  ) {
    return _git_diff_status_char(
      status,
    );
  }

  late final _git_diff_status_charPtr =
      _lookup<ffi.NativeFunction<ffi.Char Function(ffi.Int32)>>(
          'git_diff_status_char');
  late final _git_diff_status_char =
      _git_diff_status_charPtr.asFunction<int Function(int)>();

  /// Iterate over a diff generating formatted text output.
  ///
  /// Returning a non-zero value from the callbacks will terminate the
  /// iteration and return the non-zero value to the caller.
  ///
  /// @param diff A git_diff generated by one of the above functions.
  /// @param format A git_diff_format_t value to pick the text format.
  /// @param print_cb Callback to make per line of diff text.
  /// @param payload Reference pointer that will be passed to your callback.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_print(
    ffi.Pointer<git_diff> diff,
    int format,
    git_diff_line_cb print_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_print(
      diff,
      format,
      print_cb,
      payload,
    );
  }

  late final _git_diff_printPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff>, ffi.Int32, git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_diff_print');
  late final _git_diff_print = _git_diff_printPtr.asFunction<
      int Function(ffi.Pointer<git_diff>, int, git_diff_line_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Produce the complete formatted text output from a diff into a
  /// buffer.
  ///
  /// @param out A pointer to a user-allocated git_buf that will
  /// contain the diff text
  /// @param diff A git_diff generated by one of the above functions.
  /// @param format A git_diff_format_t value to pick the text format.
  /// @return 0 on success or error code
  int git_diff_to_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff> diff,
    int format,
  ) {
    return _git_diff_to_buf(
      out,
      diff,
      format,
    );
  }

  late final _git_diff_to_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_diff>,
              ffi.Int32)>>('git_diff_to_buf');
  late final _git_diff_to_buf = _git_diff_to_bufPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_diff>, int)>();

  /// Directly run a diff on two blobs.
  ///
  /// Compared to a file, a blob lacks some contextual information. As such,
  /// the `git_diff_file` given to the callback will have some fake data; i.e.
  /// `mode` will be 0 and `path` will be NULL.
  ///
  /// NULL is allowed for either `old_blob` or `new_blob` and will be treated
  /// as an empty blob, with the `oid` set to NULL in the `git_diff_file` data.
  /// Passing NULL for both blobs is a noop; no callbacks will be made at all.
  ///
  /// We do run a binary content check on the blob content and if either blob
  /// looks like binary data, the `git_diff_delta` binary attribute will be set
  /// to 1 and no call to the hunk_cb nor line_cb will be made (unless you pass
  /// `GIT_DIFF_FORCE_TEXT` of course).
  ///
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param new_blob Blob for new side of diff, or NULL for empty blob
  /// @param new_as_path Treat new blob as if it had this filename; can be NULL
  /// @param options Options for diff, or NULL for default options
  /// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
  /// @param binary_cb Callback for binary files; can be NULL
  /// @param hunk_cb Callback for each hunk in diff; can be NULL
  /// @param line_cb Callback for each line in diff; can be NULL
  /// @param payload Payload passed to each callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_blobs(
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<git_blob> new_blob,
    ffi.Pointer<ffi.Char> new_as_path,
    ffi.Pointer<git_diff_options> options,
    git_diff_file_cb file_cb,
    git_diff_binary_cb binary_cb,
    git_diff_hunk_cb hunk_cb,
    git_diff_line_cb line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_blobs(
      old_blob,
      old_as_path,
      new_blob,
      new_as_path,
      options,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_blobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>,
              git_diff_file_cb,
              git_diff_binary_cb,
              git_diff_hunk_cb,
              git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_diff_blobs');
  late final _git_diff_blobs = _git_diff_blobsPtr.asFunction<
      int Function(
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>,
          git_diff_file_cb,
          git_diff_binary_cb,
          git_diff_hunk_cb,
          git_diff_line_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Directly run a diff between a blob and a buffer.
  ///
  /// As with `git_diff_blobs`, comparing a blob and buffer lacks some context,
  /// so the `git_diff_file` parameters to the callbacks will be faked a la the
  /// rules for `git_diff_blobs()`.
  ///
  /// Passing NULL for `old_blob` will be treated as an empty blob (i.e. the
  /// `file_cb` will be invoked with GIT_DELTA_ADDED and the diff will be the
  /// entire content of the buffer added).  Passing NULL to the buffer will do
  /// the reverse, with GIT_DELTA_REMOVED and blob content removed.
  ///
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param buffer Raw data for new side of diff, or NULL for empty
  /// @param buffer_len Length of raw data for new side of diff
  /// @param buffer_as_path Treat buffer as if it had this filename; can be NULL
  /// @param options Options for diff, or NULL for default options
  /// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
  /// @param binary_cb Callback for binary files; can be NULL
  /// @param hunk_cb Callback for each hunk in diff; can be NULL
  /// @param line_cb Callback for each line in diff; can be NULL
  /// @param payload Payload passed to each callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_blob_to_buffer(
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<ffi.Char> buffer,
    int buffer_len,
    ffi.Pointer<ffi.Char> buffer_as_path,
    ffi.Pointer<git_diff_options> options,
    git_diff_file_cb file_cb,
    git_diff_binary_cb binary_cb,
    git_diff_hunk_cb hunk_cb,
    git_diff_line_cb line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_blob_to_buffer(
      old_blob,
      old_as_path,
      buffer,
      buffer_len,
      buffer_as_path,
      options,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_blob_to_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>,
              git_diff_file_cb,
              git_diff_binary_cb,
              git_diff_hunk_cb,
              git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_diff_blob_to_buffer');
  late final _git_diff_blob_to_buffer = _git_diff_blob_to_bufferPtr.asFunction<
      int Function(
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>,
          git_diff_file_cb,
          git_diff_binary_cb,
          git_diff_hunk_cb,
          git_diff_line_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Directly run a diff between two buffers.
  ///
  /// Even more than with `git_diff_blobs`, comparing two buffer lacks
  /// context, so the `git_diff_file` parameters to the callbacks will be
  /// faked a la the rules for `git_diff_blobs()`.
  ///
  /// @param old_buffer Raw data for old side of diff, or NULL for empty
  /// @param old_len Length of the raw data for old side of the diff
  /// @param old_as_path Treat old buffer as if it had this filename; can be NULL
  /// @param new_buffer Raw data for new side of diff, or NULL for empty
  /// @param new_len Length of raw data for new side of diff
  /// @param new_as_path Treat buffer as if it had this filename; can be NULL
  /// @param options Options for diff, or NULL for default options
  /// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
  /// @param binary_cb Callback for binary files; can be NULL
  /// @param hunk_cb Callback for each hunk in diff; can be NULL
  /// @param line_cb Callback for each line in diff; can be NULL
  /// @param payload Payload passed to each callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_buffers(
    ffi.Pointer<ffi.Void> old_buffer,
    int old_len,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<ffi.Void> new_buffer,
    int new_len,
    ffi.Pointer<ffi.Char> new_as_path,
    ffi.Pointer<git_diff_options> options,
    git_diff_file_cb file_cb,
    git_diff_binary_cb binary_cb,
    git_diff_hunk_cb hunk_cb,
    git_diff_line_cb line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_buffers(
      old_buffer,
      old_len,
      old_as_path,
      new_buffer,
      new_len,
      new_as_path,
      options,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_buffersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>,
              git_diff_file_cb,
              git_diff_binary_cb,
              git_diff_hunk_cb,
              git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_diff_buffers');
  late final _git_diff_buffers = _git_diff_buffersPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>,
          git_diff_file_cb,
          git_diff_binary_cb,
          git_diff_hunk_cb,
          git_diff_line_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Read the contents of a git patch file into a `git_diff` object.
  ///
  /// The diff object produced is similar to the one that would be
  /// produced if you actually produced it computationally by comparing
  /// two trees, however there may be subtle differences.  For example,
  /// a patch file likely contains abbreviated object IDs, so the
  /// object IDs in a `git_diff_delta` produced by this function will
  /// also be abbreviated.
  ///
  /// This function will only read patch files created by a git
  /// implementation, it will not read unified diffs produced by
  /// the `diff` program, nor any other types of patch files.
  ///
  /// @param out A pointer to a git_diff pointer that will be allocated.
  /// @param content The contents of a patch file
  /// @param content_len The length of the patch file contents
  /// @return 0 or an error code
  int git_diff_from_buffer(
    ffi.Pointer<ffi.Pointer<git_diff>> out,
    ffi.Pointer<ffi.Char> content,
    int content_len,
  ) {
    return _git_diff_from_buffer(
      out,
      content,
      content_len,
    );
  }

  late final _git_diff_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff>>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('git_diff_from_buffer');
  late final _git_diff_from_buffer = _git_diff_from_bufferPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_diff>>, ffi.Pointer<ffi.Char>, int)>();

  /// Accumulate diff statistics for all patches.
  ///
  /// @param out Structure containing the diff statistics.
  /// @param diff A git_diff generated by one of the above functions.
  /// @return 0 on success; non-zero on error
  int git_diff_get_stats(
    ffi.Pointer<ffi.Pointer<git_diff_stats>> out,
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_get_stats(
      out,
      diff,
    );
  }

  late final _git_diff_get_statsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_diff_stats>>,
              ffi.Pointer<git_diff>)>>('git_diff_get_stats');
  late final _git_diff_get_stats = _git_diff_get_statsPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_diff_stats>>, ffi.Pointer<git_diff>)>();

  /// Get the total number of files changed in a diff
  ///
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @return total number of files changed in the diff
  int git_diff_stats_files_changed(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_files_changed(
      stats,
    );
  }

  late final _git_diff_stats_files_changedPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_diff_stats>)>>(
      'git_diff_stats_files_changed');
  late final _git_diff_stats_files_changed = _git_diff_stats_files_changedPtr
      .asFunction<int Function(ffi.Pointer<git_diff_stats>)>();

  /// Get the total number of insertions in a diff
  ///
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @return total number of insertions in the diff
  int git_diff_stats_insertions(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_insertions(
      stats,
    );
  }

  late final _git_diff_stats_insertionsPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_diff_stats>)>>(
      'git_diff_stats_insertions');
  late final _git_diff_stats_insertions = _git_diff_stats_insertionsPtr
      .asFunction<int Function(ffi.Pointer<git_diff_stats>)>();

  /// Get the total number of deletions in a diff
  ///
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @return total number of deletions in the diff
  int git_diff_stats_deletions(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_deletions(
      stats,
    );
  }

  late final _git_diff_stats_deletionsPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_diff_stats>)>>(
      'git_diff_stats_deletions');
  late final _git_diff_stats_deletions = _git_diff_stats_deletionsPtr
      .asFunction<int Function(ffi.Pointer<git_diff_stats>)>();

  /// Print diff statistics to a `git_buf`.
  ///
  /// @param out buffer to store the formatted diff statistics in.
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @param format Formatting option.
  /// @param width Target width for output (only affects GIT_DIFF_STATS_FULL)
  /// @return 0 on success; non-zero on error
  int git_diff_stats_to_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff_stats> stats,
    int format,
    int width,
  ) {
    return _git_diff_stats_to_buf(
      out,
      stats,
      format,
      width,
    );
  }

  late final _git_diff_stats_to_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_diff_stats>,
              ffi.Int32, ffi.Size)>>('git_diff_stats_to_buf');
  late final _git_diff_stats_to_buf = _git_diff_stats_to_bufPtr.asFunction<
      int Function(
          ffi.Pointer<git_buf>, ffi.Pointer<git_diff_stats>, int, int)>();

  /// Deallocate a `git_diff_stats`.
  ///
  /// @param stats The previously created statistics object;
  /// cannot be used after free.
  void git_diff_stats_free(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_free(
      stats,
    );
  }

  late final _git_diff_stats_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_diff_stats>)>>(
      'git_diff_stats_free');
  late final _git_diff_stats_free = _git_diff_stats_freePtr
      .asFunction<void Function(ffi.Pointer<git_diff_stats>)>();

  /// Initialize git_diff_patchid_options structure
  ///
  /// Initializes a `git_diff_patchid_options` with default values. Equivalent to
  /// creating an instance with `GIT_DIFF_PATCHID_OPTIONS_INIT`.
  ///
  /// @param opts The `git_diff_patchid_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_PATCHID_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_patchid_options_init(
    ffi.Pointer<git_diff_patchid_options> opts,
    int version,
  ) {
    return _git_diff_patchid_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_patchid_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_patchid_options>,
              ffi.UnsignedInt)>>('git_diff_patchid_options_init');
  late final _git_diff_patchid_options_init = _git_diff_patchid_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_diff_patchid_options>, int)>();

  /// Calculate the patch ID for the given patch.
  ///
  /// Calculate a stable patch ID for the given patch by summing the
  /// hash of the file diffs, ignoring whitespace and line numbers.
  /// This can be used to derive whether two diffs are the same with
  /// a high probability.
  ///
  /// Currently, this function only calculates stable patch IDs, as
  /// defined in git-patch-id(1), and should in fact generate the
  /// same IDs as the upstream git project does.
  ///
  /// @param out Pointer where the calculated patch ID should be stored
  /// @param diff The diff to calculate the ID for
  /// @param opts Options for how to calculate the patch ID. This is
  /// intended for future changes, as currently no options are
  /// available.
  /// @return 0 on success, an error code otherwise.
  int git_diff_patchid(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_diff_patchid_options> opts,
  ) {
    return _git_diff_patchid(
      out,
      diff,
      opts,
    );
  }

  late final _git_diff_patchidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_diff>,
              ffi.Pointer<git_diff_patchid_options>)>>('git_diff_patchid');
  late final _git_diff_patchid = _git_diff_patchidPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_diff>,
          ffi.Pointer<git_diff_patchid_options>)>();

  /// Initialize git_apply_options structure
  ///
  /// Initialize a `git_apply_options` with default values. Equivalent to creating
  /// an instance with GIT_APPLY_OPTIONS_INIT.
  ///
  /// @param opts The `git_apply_options` struct to initialize.
  /// @param version The struct version; pass `GIT_APPLY_OPTIONS_VERSION`
  /// @return 0 on success or -1 on failure.
  int git_apply_options_init(
    ffi.Pointer<git_apply_options> opts,
    int version,
  ) {
    return _git_apply_options_init(
      opts,
      version,
    );
  }

  late final _git_apply_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_apply_options>,
              ffi.UnsignedInt)>>('git_apply_options_init');
  late final _git_apply_options_init = _git_apply_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_apply_options>, int)>();

  /// Apply a `git_diff` to a `git_tree`, and return the resulting image
  /// as an index.
  ///
  /// @param out the postimage of the application
  /// @param repo the repository to apply
  /// @param preimage the tree to apply the diff to
  /// @param diff the diff to apply
  /// @param options the options for the apply (or null for defaults)
  /// @return 0 or an error code
  int git_apply_to_tree(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> preimage,
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_apply_options> options,
  ) {
    return _git_apply_to_tree(
      out,
      repo,
      preimage,
      diff,
      options,
    );
  }

  late final _git_apply_to_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_diff>,
              ffi.Pointer<git_apply_options>)>>('git_apply_to_tree');
  late final _git_apply_to_tree = _git_apply_to_treePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_diff>,
          ffi.Pointer<git_apply_options>)>();

  /// Apply a `git_diff` to the given repository, making changes directly
  /// in the working directory, the index, or both.
  ///
  /// @param repo the repository to apply to
  /// @param diff the diff to apply
  /// @param location the location to apply (workdir, index or both)
  /// @param options the options for the apply (or null for defaults)
  /// @return 0 or an error code
  int git_apply(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_diff> diff,
    int location,
    ffi.Pointer<git_apply_options> options,
  ) {
    return _git_apply(
      repo,
      diff,
      location,
      options,
    );
  }

  late final _git_applyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_diff>,
              ffi.Int32, ffi.Pointer<git_apply_options>)>>('git_apply');
  late final _git_apply = _git_applyPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_diff>, int,
          ffi.Pointer<git_apply_options>)>();

  /// Return the value type for a given attribute.
  ///
  /// This can be either `TRUE`, `FALSE`, `UNSPECIFIED` (if the attribute
  /// was not set at all), or `VALUE`, if the attribute was set to an
  /// actual string.
  ///
  /// If the attribute has a `VALUE` string, it can be accessed normally
  /// as a NULL-terminated C string.
  ///
  /// @param attr The attribute
  /// @return the value type for the attribute
  int git_attr_value(
    ffi.Pointer<ffi.Char> attr,
  ) {
    return _git_attr_value(
      attr,
    );
  }

  late final _git_attr_valuePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'git_attr_value');
  late final _git_attr_value =
      _git_attr_valuePtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Look up the value of one git attribute for path.
  ///
  /// @param value_out Output of the value of the attribute.  Use the GIT_ATTR_...
  /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
  /// use the string value for attributes set to a value.  You
  /// should NOT modify or free this value.
  /// @param repo The repository containing the path.
  /// @param flags A combination of GIT_ATTR_CHECK... flags.
  /// @param path The path to check for attributes.  Relative paths are
  /// interpreted relative to the repo root.  The file does
  /// not have to exist, but if it does not, then it will be
  /// treated as a plain file (not a directory).
  /// @param name The name of the attribute to look up.
  /// @return 0 or an error code.
  int git_attr_get(
    ffi.Pointer<ffi.Pointer<ffi.Char>> value_out,
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_attr_get(
      value_out,
      repo,
      flags,
      path,
      name,
    );
  }

  late final _git_attr_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_attr_get');
  late final _git_attr_get = _git_attr_getPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_repository>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Look up the value of one git attribute for path with extended options.
  ///
  /// @param value_out Output of the value of the attribute.  Use the GIT_ATTR_...
  /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
  /// use the string value for attributes set to a value.  You
  /// should NOT modify or free this value.
  /// @param repo The repository containing the path.
  /// @param opts The `git_attr_options` to use when querying these attributes.
  /// @param path The path to check for attributes.  Relative paths are
  /// interpreted relative to the repo root.  The file does
  /// not have to exist, but if it does not, then it will be
  /// treated as a plain file (not a directory).
  /// @param name The name of the attribute to look up.
  /// @return 0 or an error code.
  int git_attr_get_ext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> value_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_attr_options> opts,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_attr_get_ext(
      value_out,
      repo,
      opts,
      path,
      name,
    );
  }

  late final _git_attr_get_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_attr_options>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_attr_get_ext');
  late final _git_attr_get_ext = _git_attr_get_extPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_attr_options>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Look up a list of git attributes for path.
  ///
  /// Use this if you have a known list of attributes that you want to
  /// look up in a single call.  This is somewhat more efficient than
  /// calling `git_attr_get()` multiple times.
  ///
  /// For example, you might write:
  ///
  /// const char *attrs[] = { "crlf", "diff", "foo" };
  /// const char **values[3];
  /// git_attr_get_many(values, repo, 0, "my/fun/file.c", 3, attrs);
  ///
  /// Then you could loop through the 3 values to get the settings for
  /// the three attributes you asked about.
  ///
  /// @param values_out An array of num_attr entries that will have string
  /// pointers written into it for the values of the attributes.
  /// You should not modify or free the values that are written
  /// into this array (although of course, you should free the
  /// array itself if you allocated it).
  /// @param repo The repository containing the path.
  /// @param flags A combination of GIT_ATTR_CHECK... flags.
  /// @param path The path inside the repo to check attributes.  This
  /// does not have to exist, but if it does not, then
  /// it will be treated as a plain file (i.e. not a directory).
  /// @param num_attr The number of attributes being looked up
  /// @param names An array of num_attr strings containing attribute names.
  /// @return 0 or an error code.
  int git_attr_get_many(
    ffi.Pointer<ffi.Pointer<ffi.Char>> values_out,
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<ffi.Char> path,
    int num_attr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> names,
  ) {
    return _git_attr_get_many(
      values_out,
      repo,
      flags,
      path,
      num_attr,
      names,
    );
  }

  late final _git_attr_get_manyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('git_attr_get_many');
  late final _git_attr_get_many = _git_attr_get_manyPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_repository>,
          int,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Look up a list of git attributes for path with extended options.
  ///
  /// @param values_out An array of num_attr entries that will have string
  /// pointers written into it for the values of the attributes.
  /// You should not modify or free the values that are written
  /// into this array (although of course, you should free the
  /// array itself if you allocated it).
  /// @param repo The repository containing the path.
  /// @param opts The `git_attr_options` to use when querying these attributes.
  /// @param path The path inside the repo to check attributes.  This
  /// does not have to exist, but if it does not, then
  /// it will be treated as a plain file (i.e. not a directory).
  /// @param num_attr The number of attributes being looked up
  /// @param names An array of num_attr strings containing attribute names.
  /// @return 0 or an error code.
  int git_attr_get_many_ext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> values_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_attr_options> opts,
    ffi.Pointer<ffi.Char> path,
    int num_attr,
    ffi.Pointer<ffi.Pointer<ffi.Char>> names,
  ) {
    return _git_attr_get_many_ext(
      values_out,
      repo,
      opts,
      path,
      num_attr,
      names,
    );
  }

  late final _git_attr_get_many_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_attr_options>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('git_attr_get_many_ext');
  late final _git_attr_get_many_ext = _git_attr_get_many_extPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_attr_options>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  /// Loop over all the git attributes for a path.
  ///
  /// @param repo The repository containing the path.
  /// @param flags A combination of GIT_ATTR_CHECK... flags.
  /// @param path Path inside the repo to check attributes.  This does not have
  /// to exist, but if it does not, then it will be treated as a
  /// plain file (i.e. not a directory).
  /// @param callback Function to invoke on each attribute name and value.
  /// See git_attr_foreach_cb.
  /// @param payload Passed on as extra parameter to callback function.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_attr_foreach(
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<ffi.Char> path,
    git_attr_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_attr_foreach(
      repo,
      flags,
      path,
      callback,
      payload,
    );
  }

  late final _git_attr_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Uint32,
              ffi.Pointer<ffi.Char>,
              git_attr_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_attr_foreach');
  late final _git_attr_foreach = _git_attr_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, int, ffi.Pointer<ffi.Char>,
          git_attr_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Loop over all the git attributes for a path with extended options.
  ///
  /// @param repo The repository containing the path.
  /// @param opts The `git_attr_options` to use when querying these attributes.
  /// @param path Path inside the repo to check attributes.  This does not have
  /// to exist, but if it does not, then it will be treated as a
  /// plain file (i.e. not a directory).
  /// @param callback Function to invoke on each attribute name and value.
  /// See git_attr_foreach_cb.
  /// @param payload Passed on as extra parameter to callback function.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_attr_foreach_ext(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_attr_options> opts,
    ffi.Pointer<ffi.Char> path,
    git_attr_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_attr_foreach_ext(
      repo,
      opts,
      path,
      callback,
      payload,
    );
  }

  late final _git_attr_foreach_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_attr_options>,
              ffi.Pointer<ffi.Char>,
              git_attr_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_attr_foreach_ext');
  late final _git_attr_foreach_ext = _git_attr_foreach_extPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_attr_options>,
          ffi.Pointer<ffi.Char>, git_attr_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Flush the gitattributes cache.
  ///
  /// Call this if you have reason to believe that the attributes files on
  /// disk no longer match the cached contents of memory.  This will cause
  /// the attributes files to be reloaded the next time that an attribute
  /// access function is called.
  ///
  /// @param repo The repository containing the gitattributes cache
  /// @return 0 on success, or an error code
  int git_attr_cache_flush(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_attr_cache_flush(
      repo,
    );
  }

  late final _git_attr_cache_flushPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_attr_cache_flush');
  late final _git_attr_cache_flush = _git_attr_cache_flushPtr
      .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Add a macro definition.
  ///
  /// Macros will automatically be loaded from the top level `.gitattributes`
  /// file of the repository (plus the built-in "binary" macro).  This
  /// function allows you to add others.  For example, to add the default
  /// macro, you would call:
  ///
  /// git_attr_add_macro(repo, "binary", "-diff -crlf");
  ///
  /// @param repo The repository to add the macro in.
  /// @param name The name of the macro.
  /// @param values The value for the macro.
  /// @return 0 or an error code.
  int git_attr_add_macro(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> values,
  ) {
    return _git_attr_add_macro(
      repo,
      name,
      values,
    );
  }

  late final _git_attr_add_macroPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_attr_add_macro');
  late final _git_attr_add_macro = _git_attr_add_macroPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Lookup a blob object from a repository.
  ///
  /// @param blob pointer to the looked up blob
  /// @param repo the repo to use when locating the blob.
  /// @param id identity of the blob to locate.
  /// @return 0 or an error code
  int git_blob_lookup(
    ffi.Pointer<ffi.Pointer<git_blob>> blob,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_blob_lookup(
      blob,
      repo,
      id,
    );
  }

  late final _git_blob_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_blob>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_blob_lookup');
  late final _git_blob_lookup = _git_blob_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_blob>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Lookup a blob object from a repository,
  /// given a prefix of its identifier (short id).
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param blob pointer to the looked up blob
  /// @param repo the repo to use when locating the blob.
  /// @param id identity of the blob to locate.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_blob_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_blob>> blob,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_blob_lookup_prefix(
      blob,
      repo,
      id,
      len,
    );
  }

  late final _git_blob_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_blob>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_blob_lookup_prefix');
  late final _git_blob_lookup_prefix = _git_blob_lookup_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_blob>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Close an open blob
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a blob. Failure to do so will cause a memory leak.
  ///
  /// @param blob the blob to close
  void git_blob_free(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_free(
      blob,
    );
  }

  late final _git_blob_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_blob>)>>(
          'git_blob_free');
  late final _git_blob_free =
      _git_blob_freePtr.asFunction<void Function(ffi.Pointer<git_blob>)>();

  /// Get the id of a blob.
  ///
  /// @param blob a previously loaded blob.
  /// @return SHA1 hash for this blob.
  ffi.Pointer<git_oid> git_blob_id(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_id(
      blob,
    );
  }

  late final _git_blob_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_blob>)>>('git_blob_id');
  late final _git_blob_id = _git_blob_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_blob>)>();

  /// Get the repository that contains the blob.
  ///
  /// @param blob A previously loaded blob.
  /// @return Repository that contains this blob.
  ffi.Pointer<git_repository> git_blob_owner(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_owner(
      blob,
    );
  }

  late final _git_blob_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_blob>)>>('git_blob_owner');
  late final _git_blob_owner = _git_blob_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_blob>)>();

  /// Get a read-only buffer with the raw content of a blob.
  ///
  /// A pointer to the raw content of a blob is returned;
  /// this pointer is owned internally by the object and shall
  /// not be free'd. The pointer may be invalidated at a later
  /// time.
  ///
  /// @param blob pointer to the blob
  /// @return the pointer, or NULL on error
  ffi.Pointer<ffi.Void> git_blob_rawcontent(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_rawcontent(
      blob,
    );
  }

  late final _git_blob_rawcontentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<git_blob>)>>('git_blob_rawcontent');
  late final _git_blob_rawcontent = _git_blob_rawcontentPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_blob>)>();

  /// Get the size in bytes of the contents of a blob
  ///
  /// @param blob pointer to the blob
  /// @return size on bytes
  int git_blob_rawsize(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_rawsize(
      blob,
    );
  }

  late final _git_blob_rawsizePtr = _lookup<
      ffi.NativeFunction<
          git_object_size_t Function(
              ffi.Pointer<git_blob>)>>('git_blob_rawsize');
  late final _git_blob_rawsize =
      _git_blob_rawsizePtr.asFunction<int Function(ffi.Pointer<git_blob>)>();

  /// Initialize git_blob_filter_options structure
  ///
  /// Initializes a `git_blob_filter_options` with default values. Equivalent
  /// to creating an instance with `GIT_BLOB_FILTER_OPTIONS_INIT`.
  ///
  /// @param opts The `git_blob_filter_options` struct to initialize.
  /// @param version The struct version; pass `GIT_BLOB_FILTER_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_blob_filter_options_init(
    ffi.Pointer<git_blob_filter_options> opts,
    int version,
  ) {
    return _git_blob_filter_options_init(
      opts,
      version,
    );
  }

  late final _git_blob_filter_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_blob_filter_options>,
              ffi.UnsignedInt)>>('git_blob_filter_options_init');
  late final _git_blob_filter_options_init = _git_blob_filter_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_blob_filter_options>, int)>();

  /// Get a buffer with the filtered content of a blob.
  ///
  /// This applies filters as if the blob was being checked out to the
  /// working directory under the specified filename.  This may apply
  /// CRLF filtering or other types of changes depending on the file
  /// attributes set for the blob and the content detected in it.
  ///
  /// The output is written into a `git_buf` which the caller must free
  /// when done (via `git_buf_dispose`).
  ///
  /// If no filters need to be applied, then the `out` buffer will just
  /// be populated with a pointer to the raw content of the blob.  In
  /// that case, be careful to *not* free the blob until done with the
  /// buffer or copy it into memory you own.
  ///
  /// @param out The git_buf to be filled in
  /// @param blob Pointer to the blob
  /// @param as_path Path used for file attribute lookups, etc.
  /// @param opts Options to use for filtering the blob
  /// @return 0 on success or an error code
  int git_blob_filter(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Char> as_path,
    ffi.Pointer<git_blob_filter_options> opts,
  ) {
    return _git_blob_filter(
      out,
      blob,
      as_path,
      opts,
    );
  }

  late final _git_blob_filterPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_blob_filter_options>)>>('git_blob_filter');
  late final _git_blob_filter = _git_blob_filterPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_blob_filter_options>)>();

  /// Read a file from the working folder of a repository
  /// and write it to the Object Database as a loose blob
  ///
  /// @param id return the id of the written blob
  /// @param repo repository where the blob will be written.
  /// this repository cannot be bare
  /// @param relative_path file from which the blob will be created,
  /// relative to the repository's working dir
  /// @return 0 or an error code
  int git_blob_create_from_workdir(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> relative_path,
  ) {
    return _git_blob_create_from_workdir(
      id,
      repo,
      relative_path,
    );
  }

  late final _git_blob_create_from_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_blob_create_from_workdir');
  late final _git_blob_create_from_workdir =
      _git_blob_create_from_workdirPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Read a file from the filesystem and write its content
  /// to the Object Database as a loose blob
  ///
  /// @param id return the id of the written blob
  /// @param repo repository where the blob will be written.
  /// this repository can be bare or not
  /// @param path file from which the blob will be created
  /// @return 0 or an error code
  int git_blob_create_from_disk(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_blob_create_from_disk(
      id,
      repo,
      path,
    );
  }

  late final _git_blob_create_from_diskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_blob_create_from_disk');
  late final _git_blob_create_from_disk =
      _git_blob_create_from_diskPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a stream to write a new blob into the object db
  ///
  /// This function may need to buffer the data on disk and will in
  /// general not be the right choice if you know the size of the data
  /// to write. If you have data in memory, use
  /// `git_blob_create_from_buffer()`. If you do not, but know the size of
  /// the contents (and don't want/need to perform filtering), use
  /// `git_odb_open_wstream()`.
  ///
  /// Don't close this stream yourself but pass it to
  /// `git_blob_create_from_stream_commit()` to commit the write to the
  /// object db and get the object id.
  ///
  /// If the `hintpath` parameter is filled, it will be used to determine
  /// what git filters should be applied to the object before it is written
  /// to the object database.
  ///
  /// @param out the stream into which to write
  /// @param repo Repository where the blob will be written.
  /// This repository can be bare or not.
  /// @param hintpath If not NULL, will be used to select data filters
  /// to apply onto the content of the blob to be created.
  /// @return 0 or error code
  int git_blob_create_from_stream(
    ffi.Pointer<ffi.Pointer<git_writestream>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> hintpath,
  ) {
    return _git_blob_create_from_stream(
      out,
      repo,
      hintpath,
    );
  }

  late final _git_blob_create_from_streamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_writestream>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_blob_create_from_stream');
  late final _git_blob_create_from_stream =
      _git_blob_create_from_streamPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_writestream>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Close the stream and write the blob to the object db
  ///
  /// The stream will be closed and freed.
  ///
  /// @param out the id of the new blob
  /// @param stream the stream to close
  /// @return 0 or an error code
  int git_blob_create_from_stream_commit(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_writestream> stream,
  ) {
    return _git_blob_create_from_stream_commit(
      out,
      stream,
    );
  }

  late final _git_blob_create_from_stream_commitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_oid>, ffi.Pointer<git_writestream>)>>(
      'git_blob_create_from_stream_commit');
  late final _git_blob_create_from_stream_commit =
      _git_blob_create_from_stream_commitPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_writestream>)>();

  /// Write an in-memory buffer to the ODB as a blob
  ///
  /// @param id return the id of the written blob
  /// @param repo repository where the blob will be written
  /// @param buffer data to be written into the blob
  /// @param len length of the data
  /// @return 0 or an error code
  int git_blob_create_from_buffer(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_blob_create_from_buffer(
      id,
      repo,
      buffer,
      len,
    );
  }

  late final _git_blob_create_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('git_blob_create_from_buffer');
  late final _git_blob_create_from_buffer =
      _git_blob_create_from_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Void>, int)>();

  /// Determine if the blob content is most certainly binary or not.
  ///
  /// The heuristic used to guess if a file is binary is taken from core git:
  /// Searching for NUL bytes and looking for a reasonable ratio of printable
  /// to non-printable characters among the first 8000 bytes.
  ///
  /// @param blob The blob which content should be analyzed
  /// @return 1 if the content of the blob is detected
  /// as binary; 0 otherwise.
  int git_blob_is_binary(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_is_binary(
      blob,
    );
  }

  late final _git_blob_is_binaryPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_blob>)>>(
          'git_blob_is_binary');
  late final _git_blob_is_binary =
      _git_blob_is_binaryPtr.asFunction<int Function(ffi.Pointer<git_blob>)>();

  /// Determine if the given content is most certainly binary or not;
  /// this is the same mechanism used by `git_blob_is_binary` but only
  /// looking at raw data.
  ///
  /// @param data The blob data which content should be analyzed
  /// @param len The length of the data
  /// @return 1 if the content of the blob is detected
  /// as binary; 0 otherwise.
  int git_blob_data_is_binary(
    ffi.Pointer<ffi.Char> data,
    int len,
  ) {
    return _git_blob_data_is_binary(
      data,
      len,
    );
  }

  late final _git_blob_data_is_binaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Size)>>('git_blob_data_is_binary');
  late final _git_blob_data_is_binary = _git_blob_data_is_binaryPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  /// Create an in-memory copy of a blob. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the object
  /// @param source Original object to copy
  /// @return 0.
  int git_blob_dup(
    ffi.Pointer<ffi.Pointer<git_blob>> out,
    ffi.Pointer<git_blob> source,
  ) {
    return _git_blob_dup(
      out,
      source,
    );
  }

  late final _git_blob_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_blob>>,
              ffi.Pointer<git_blob>)>>('git_blob_dup');
  late final _git_blob_dup = _git_blob_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_blob>>, ffi.Pointer<git_blob>)>();

  /// Initialize git_blame_options structure
  ///
  /// Initializes a `git_blame_options` with default values. Equivalent to creating
  /// an instance with GIT_BLAME_OPTIONS_INIT.
  ///
  /// @param opts The `git_blame_options` struct to initialize.
  /// @param version The struct version; pass `GIT_BLAME_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_blame_options_init(
    ffi.Pointer<git_blame_options> opts,
    int version,
  ) {
    return _git_blame_options_init(
      opts,
      version,
    );
  }

  late final _git_blame_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_blame_options>,
              ffi.UnsignedInt)>>('git_blame_options_init');
  late final _git_blame_options_init = _git_blame_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_blame_options>, int)>();

  /// Gets the number of hunks that exist in the blame structure.
  ///
  /// @param blame The blame structure to query.
  /// @return The number of hunks.
  int git_blame_get_hunk_count(
    ffi.Pointer<git_blame> blame,
  ) {
    return _git_blame_get_hunk_count(
      blame,
    );
  }

  late final _git_blame_get_hunk_countPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Pointer<git_blame>)>>(
          'git_blame_get_hunk_count');
  late final _git_blame_get_hunk_count = _git_blame_get_hunk_countPtr
      .asFunction<int Function(ffi.Pointer<git_blame>)>();

  /// Gets the blame hunk at the given index.
  ///
  /// @param blame the blame structure to query
  /// @param index index of the hunk to retrieve
  /// @return the hunk at the given index, or NULL on error
  ffi.Pointer<git_blame_hunk> git_blame_get_hunk_byindex(
    ffi.Pointer<git_blame> blame,
    int index,
  ) {
    return _git_blame_get_hunk_byindex(
      blame,
      index,
    );
  }

  late final _git_blame_get_hunk_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame>,
              ffi.Uint32)>>('git_blame_get_hunk_byindex');
  late final _git_blame_get_hunk_byindex =
      _git_blame_get_hunk_byindexPtr.asFunction<
          ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame>, int)>();

  /// Gets the hunk that relates to the given line number in the newest commit.
  ///
  /// @param blame the blame structure to query
  /// @param lineno the (1-based) line number to find a hunk for
  /// @return the hunk that contains the given line, or NULL on error
  ffi.Pointer<git_blame_hunk> git_blame_get_hunk_byline(
    ffi.Pointer<git_blame> blame,
    int lineno,
  ) {
    return _git_blame_get_hunk_byline(
      blame,
      lineno,
    );
  }

  late final _git_blame_get_hunk_bylinePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_blame_hunk> Function(
              ffi.Pointer<git_blame>, ffi.Size)>>('git_blame_get_hunk_byline');
  late final _git_blame_get_hunk_byline =
      _git_blame_get_hunk_bylinePtr.asFunction<
          ffi.Pointer<git_blame_hunk> Function(ffi.Pointer<git_blame>, int)>();

  /// Get the blame for a single file.
  ///
  /// @param out pointer that will receive the blame object
  /// @param repo repository whose history is to be walked
  /// @param path path to file to consider
  /// @param options options for the blame operation.  If NULL, this is treated as
  /// though GIT_BLAME_OPTIONS_INIT were passed.
  /// @return 0 on success, or an error code. (use git_error_last for information
  /// about the error.)
  int git_blame_file(
    ffi.Pointer<ffi.Pointer<git_blame>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<git_blame_options> options,
  ) {
    return _git_blame_file(
      out,
      repo,
      path,
      options,
    );
  }

  late final _git_blame_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_blame>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_blame_options>)>>('git_blame_file');
  late final _git_blame_file = _git_blame_filePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_blame>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_blame_options>)>();

  /// Get blame data for a file that has been modified in memory. The `reference`
  /// parameter is a pre-calculated blame for the in-odb history of the file. This
  /// means that once a file blame is completed (which can be expensive), updating
  /// the buffer blame is very fast.
  ///
  /// Lines that differ between the buffer and the committed version are marked as
  /// having a zero OID for their final_commit_id.
  ///
  /// @param out pointer that will receive the resulting blame data
  /// @param reference cached blame from the history of the file (usually the output
  /// from git_blame_file)
  /// @param buffer the (possibly) modified contents of the file
  /// @param buffer_len number of valid bytes in the buffer
  /// @return 0 on success, or an error code. (use git_error_last for information
  /// about the error)
  int git_blame_buffer(
    ffi.Pointer<ffi.Pointer<git_blame>> out,
    ffi.Pointer<git_blame> reference,
    ffi.Pointer<ffi.Char> buffer,
    int buffer_len,
  ) {
    return _git_blame_buffer(
      out,
      reference,
      buffer,
      buffer_len,
    );
  }

  late final _git_blame_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_blame>>,
              ffi.Pointer<git_blame>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('git_blame_buffer');
  late final _git_blame_buffer = _git_blame_bufferPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_blame>>, ffi.Pointer<git_blame>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Free memory allocated by git_blame_file or git_blame_buffer.
  ///
  /// @param blame the blame structure to free
  void git_blame_free(
    ffi.Pointer<git_blame> blame,
  ) {
    return _git_blame_free(
      blame,
    );
  }

  late final _git_blame_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_blame>)>>(
          'git_blame_free');
  late final _git_blame_free =
      _git_blame_freePtr.asFunction<void Function(ffi.Pointer<git_blame>)>();

  /// Create a new branch pointing at a target commit
  ///
  /// A new direct reference will be created pointing to
  /// this target commit. If `force` is true and a reference
  /// already exists with the given name, it'll be replaced.
  ///
  /// The returned reference must be freed by the user.
  ///
  /// The branch name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out Pointer where to store the underlying reference.
  ///
  /// @param repo the repository to create the branch in.
  ///
  /// @param branch_name Name for the branch; this name is
  /// validated for consistency. It should also not conflict with
  /// an already existing branch name.
  ///
  /// @param target Commit to which this branch should point. This object
  /// must belong to the given `repo`.
  ///
  /// @param force Overwrite existing branch.
  ///
  /// @return 0, GIT_EINVALIDSPEC or an error code.
  /// A proper reference is written in the refs/heads namespace
  /// pointing to the provided target commit.
  int git_branch_create(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> branch_name,
    ffi.Pointer<git_commit> target,
    int force,
  ) {
    return _git_branch_create(
      out,
      repo,
      branch_name,
      target,
      force,
    );
  }

  late final _git_branch_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_commit>,
              ffi.Int)>>('git_branch_create');
  late final _git_branch_create = _git_branch_createPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_commit>,
          int)>();

  /// Create a new branch pointing at a target commit
  ///
  /// This behaves like `git_branch_create()` but takes an annotated
  /// commit, which lets you specify which extended sha syntax string was
  /// specified by a user, allowing for more exact reflog messages.
  ///
  /// See the documentation for `git_branch_create()`.
  ///
  /// @see git_branch_create
  int git_branch_create_from_annotated(
    ffi.Pointer<ffi.Pointer<git_reference>> ref_out,
    ffi.Pointer<git_repository> repository,
    ffi.Pointer<ffi.Char> branch_name,
    ffi.Pointer<git_annotated_commit> commit,
    int force,
  ) {
    return _git_branch_create_from_annotated(
      ref_out,
      repository,
      branch_name,
      commit,
      force,
    );
  }

  late final _git_branch_create_from_annotatedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_annotated_commit>,
              ffi.Int)>>('git_branch_create_from_annotated');
  late final _git_branch_create_from_annotated =
      _git_branch_create_from_annotatedPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_annotated_commit>,
              int)>();

  /// Delete an existing branch reference.
  ///
  /// Note that if the deletion succeeds, the reference object will not
  /// be valid anymore, and should be freed immediately by the user using
  /// `git_reference_free()`.
  ///
  /// @param branch A valid reference representing a branch
  /// @return 0 on success, or an error code.
  int git_branch_delete(
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_delete(
      branch,
    );
  }

  late final _git_branch_deletePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_branch_delete');
  late final _git_branch_delete = _git_branch_deletePtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Create an iterator which loops over the requested branches.
  ///
  /// @param out the iterator
  /// @param repo Repository where to find the branches.
  /// @param list_flags Filtering flags for the branch
  /// listing. Valid values are GIT_BRANCH_LOCAL, GIT_BRANCH_REMOTE
  /// or GIT_BRANCH_ALL.
  ///
  /// @return 0 on success  or an error code
  int git_branch_iterator_new(
    ffi.Pointer<ffi.Pointer<git_branch_iterator>> out,
    ffi.Pointer<git_repository> repo,
    int list_flags,
  ) {
    return _git_branch_iterator_new(
      out,
      repo,
      list_flags,
    );
  }

  late final _git_branch_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_branch_iterator>>,
              ffi.Pointer<git_repository>,
              ffi.Int32)>>('git_branch_iterator_new');
  late final _git_branch_iterator_new = _git_branch_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_branch_iterator>>,
          ffi.Pointer<git_repository>, int)>();

  /// Retrieve the next branch from the iterator
  ///
  /// @param out the reference
  /// @param out_type the type of branch (local or remote-tracking)
  /// @param iter the branch iterator
  /// @return 0 on success, GIT_ITEROVER if there are no more branches or an error code.
  int git_branch_next(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<ffi.Int32> out_type,
    ffi.Pointer<git_branch_iterator> iter,
  ) {
    return _git_branch_next(
      out,
      out_type,
      iter,
    );
  }

  late final _git_branch_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<git_branch_iterator>)>>('git_branch_next');
  late final _git_branch_next = _git_branch_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<ffi.Int32>, ffi.Pointer<git_branch_iterator>)>();

  /// Free a branch iterator
  ///
  /// @param iter the iterator to free
  void git_branch_iterator_free(
    ffi.Pointer<git_branch_iterator> iter,
  ) {
    return _git_branch_iterator_free(
      iter,
    );
  }

  late final _git_branch_iterator_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<git_branch_iterator>)>>('git_branch_iterator_free');
  late final _git_branch_iterator_free = _git_branch_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_branch_iterator>)>();

  /// Move/rename an existing local branch reference.
  ///
  /// The new branch name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// Note that if the move succeeds, the old reference object will not
  /// be valid anymore, and should be freed immediately by the user using
  /// `git_reference_free()`.
  ///
  /// @param out New reference object for the updated name.
  ///
  /// @param branch Current underlying reference of the branch.
  ///
  /// @param new_branch_name Target name of the branch once the move
  /// is performed; this name is validated for consistency.
  ///
  /// @param force Overwrite existing branch.
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code.
  int git_branch_move(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> branch,
    ffi.Pointer<ffi.Char> new_branch_name,
    int force,
  ) {
    return _git_branch_move(
      out,
      branch,
      new_branch_name,
      force,
    );
  }

  late final _git_branch_movePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_branch_move');
  late final _git_branch_move = _git_branch_movePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>, ffi.Pointer<ffi.Char>, int)>();

  /// Lookup a branch by its name in a repository.
  ///
  /// The generated reference must be freed by the user.
  /// The branch name will be checked for validity.
  ///
  /// @see git_tag_create for rules about valid names.
  ///
  /// @param out pointer to the looked-up branch reference
  /// @param repo the repository to look up the branch
  /// @param branch_name Name of the branch to be looked-up;
  /// this name is validated for consistency.
  /// @param branch_type Type of the considered branch. This should
  /// be valued with either GIT_BRANCH_LOCAL or GIT_BRANCH_REMOTE.
  ///
  /// @return 0 on success; GIT_ENOTFOUND when no matching branch
  /// exists, GIT_EINVALIDSPEC, otherwise an error code.
  int git_branch_lookup(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> branch_name,
    int branch_type,
  ) {
    return _git_branch_lookup(
      out,
      repo,
      branch_name,
      branch_type,
    );
  }

  late final _git_branch_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_branch_lookup');
  late final _git_branch_lookup = _git_branch_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the branch name
  ///
  /// Given a reference object, this will check that it really is a branch (ie.
  /// it lives under "refs/heads/" or "refs/remotes/"), and return the branch part
  /// of it.
  ///
  /// @param out Pointer to the abbreviated reference name.
  /// Owned by ref, do not free.
  ///
  /// @param ref A reference object, ideally pointing to a branch
  ///
  /// @return 0 on success; GIT_EINVALID if the reference isn't either a local or
  /// remote branch, otherwise an error code.
  int git_branch_name(
    ffi.Pointer<ffi.Pointer<ffi.Char>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_branch_name(
      out,
      ref,
    );
  }

  late final _git_branch_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_reference>)>>('git_branch_name');
  late final _git_branch_name = _git_branch_namePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<git_reference>)>();

  /// Get the upstream of a branch
  ///
  /// Given a reference, this will return a new reference object corresponding
  /// to its remote tracking branch. The reference must be a local branch.
  ///
  /// @see git_branch_upstream_name for details on the resolution.
  ///
  /// @param out Pointer where to store the retrieved reference.
  /// @param branch Current underlying reference of the branch.
  ///
  /// @return 0 on success; GIT_ENOTFOUND when no remote tracking
  /// reference exists, otherwise an error code.
  int git_branch_upstream(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_upstream(
      out,
      branch,
    );
  }

  late final _git_branch_upstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_reference>)>>('git_branch_upstream');
  late final _git_branch_upstream = _git_branch_upstreamPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_reference>)>();

  /// Set a branch's upstream branch
  ///
  /// This will update the configuration to set the branch named `branch_name` as the upstream of `branch`.
  /// Pass a NULL name to unset the upstream information.
  ///
  /// @note the actual tracking reference must have been already created for the
  /// operation to succeed.
  ///
  /// @param branch the branch to configure
  /// @param branch_name remote-tracking or local branch to set as upstream.
  ///
  /// @return 0 on success; GIT_ENOTFOUND if there's no branch named `branch_name`
  /// or an error code
  int git_branch_set_upstream(
    ffi.Pointer<git_reference> branch,
    ffi.Pointer<ffi.Char> branch_name,
  ) {
    return _git_branch_set_upstream(
      branch,
      branch_name,
    );
  }

  late final _git_branch_set_upstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Char>)>>('git_branch_set_upstream');
  late final _git_branch_set_upstream = _git_branch_set_upstreamPtr.asFunction<
      int Function(ffi.Pointer<git_reference>, ffi.Pointer<ffi.Char>)>();

  /// Get the upstream name of a branch
  ///
  /// Given a local branch, this will return its remote-tracking branch information,
  /// as a full reference name, ie. "feature/nice" would become
  /// "refs/remote/origin/feature/nice", depending on that branch's configuration.
  ///
  /// @param out the buffer into which the name will be written.
  /// @param repo the repository where the branches live.
  /// @param refname reference name of the local branch.
  ///
  /// @return 0 on success, GIT_ENOTFOUND when no remote tracking reference exists,
  /// or an error code.
  int git_branch_upstream_name(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_branch_upstream_name(
      out,
      repo,
      refname,
    );
  }

  late final _git_branch_upstream_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_branch_upstream_name');
  late final _git_branch_upstream_name =
      _git_branch_upstream_namePtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Determine if HEAD points to the given branch
  ///
  /// @param branch A reference to a local branch.
  ///
  /// @return 1 if HEAD points at the branch, 0 if it isn't, or a negative value
  /// as an error code.
  int git_branch_is_head(
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_is_head(
      branch,
    );
  }

  late final _git_branch_is_headPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_branch_is_head');
  late final _git_branch_is_head = _git_branch_is_headPtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Determine if any HEAD points to the current branch
  ///
  /// This will iterate over all known linked repositories (usually in the form of
  /// worktrees) and report whether any HEAD is pointing at the current branch.
  ///
  /// @param branch A reference to a local branch.
  ///
  /// @return 1 if branch is checked out, 0 if it isn't, an error code otherwise.
  int git_branch_is_checked_out(
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_is_checked_out(
      branch,
    );
  }

  late final _git_branch_is_checked_outPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reference>)>>(
          'git_branch_is_checked_out');
  late final _git_branch_is_checked_out = _git_branch_is_checked_outPtr
      .asFunction<int Function(ffi.Pointer<git_reference>)>();

  /// Find the remote name of a remote-tracking branch
  ///
  /// This will return the name of the remote whose fetch refspec is matching
  /// the given branch. E.g. given a branch "refs/remotes/test/master", it will
  /// extract the "test" part. If refspecs from multiple remotes match,
  /// the function will return GIT_EAMBIGUOUS.
  ///
  /// @param out The buffer into which the name will be written.
  /// @param repo The repository where the branch lives.
  /// @param refname complete name of the remote tracking branch.
  ///
  /// @return 0 on success, GIT_ENOTFOUND when no matching remote was found,
  /// GIT_EAMBIGUOUS when the branch maps to several remotes,
  /// otherwise an error code.
  int git_branch_remote_name(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_branch_remote_name(
      out,
      repo,
      refname,
    );
  }

  late final _git_branch_remote_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_branch_remote_name');
  late final _git_branch_remote_name = _git_branch_remote_namePtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>)>();

  /// Retrieve the upstream remote of a local branch
  ///
  /// This will return the currently configured "branch.*.remote" for a given
  /// branch. This branch must be local.
  ///
  /// @param buf the buffer into which to write the name
  /// @param repo the repository in which to look
  /// @param refname the full name of the branch
  /// @return 0 or an error code
  int git_branch_upstream_remote(
    ffi.Pointer<git_buf> buf,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_branch_upstream_remote(
      buf,
      repo,
      refname,
    );
  }

  late final _git_branch_upstream_remotePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_branch_upstream_remote');
  late final _git_branch_upstream_remote =
      _git_branch_upstream_remotePtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Retrieve the upstream merge of a local branch
  ///
  /// This will return the currently configured "branch.*.merge" for a given
  /// branch. This branch must be local.
  ///
  /// @param buf the buffer into which to write the name
  /// @param repo the repository in which to look
  /// @param refname the full name of the branch
  /// @return 0 or an error code
  int git_branch_upstream_merge(
    ffi.Pointer<git_buf> buf,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_branch_upstream_merge(
      buf,
      repo,
      refname,
    );
  }

  late final _git_branch_upstream_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_branch_upstream_merge');
  late final _git_branch_upstream_merge =
      _git_branch_upstream_mergePtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Determine whether a branch name is valid, meaning that (when prefixed
  /// with `refs/heads/`) that it is a valid reference name, and that any
  /// additional branch name restrictions are imposed (eg, it cannot start
  /// with a `-`).
  ///
  /// @param valid output pointer to set with validity of given branch name
  /// @param name a branch name to test
  /// @return 0 on success or an error code
  int git_branch_name_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_branch_name_is_valid(
      valid,
      name,
    );
  }

  late final _git_branch_name_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_branch_name_is_valid');
  late final _git_branch_name_is_valid = _git_branch_name_is_validPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Initialize git_checkout_options structure
  ///
  /// Initializes a `git_checkout_options` with default values. Equivalent to creating
  /// an instance with GIT_CHECKOUT_OPTIONS_INIT.
  ///
  /// @param opts The `git_checkout_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CHECKOUT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_checkout_options_init(
    ffi.Pointer<git_checkout_options> opts,
    int version,
  ) {
    return _git_checkout_options_init(
      opts,
      version,
    );
  }

  late final _git_checkout_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_checkout_options>,
              ffi.UnsignedInt)>>('git_checkout_options_init');
  late final _git_checkout_options_init = _git_checkout_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_checkout_options>, int)>();

  /// Updates files in the index and the working tree to match the content of
  /// the commit pointed at by HEAD.
  ///
  /// Note that this is _not_ the correct mechanism used to switch branches;
  /// do not change your `HEAD` and then call this method, that would leave
  /// you with checkout conflicts since your working directory would then
  /// appear to be dirty.  Instead, checkout the target of the branch and
  /// then update `HEAD` using `git_repository_set_head` to point to the
  /// branch you checked out.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, GIT_EUNBORNBRANCH if HEAD points to a non
  /// existing branch, non-zero value returned by `notify_cb`, or
  /// other error code < 0 (use git_error_last for error details)
  int git_checkout_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _git_checkout_head(
      repo,
      opts,
    );
  }

  late final _git_checkout_headPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<git_checkout_options>)>>('git_checkout_head');
  late final _git_checkout_head = _git_checkout_headPtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>, ffi.Pointer<git_checkout_options>)>();

  /// Updates files in the working tree to match the content of the index.
  ///
  /// @param repo repository into which to check out (must be non-bare)
  /// @param index index to be checked out (or NULL to use repository index)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, non-zero return value from `notify_cb`, or error
  /// code < 0 (use git_error_last for error details)
  int git_checkout_index(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _git_checkout_index(
      repo,
      index,
      opts,
    );
  }

  late final _git_checkout_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_index>,
              ffi.Pointer<git_checkout_options>)>>('git_checkout_index');
  late final _git_checkout_index = _git_checkout_indexPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_index>,
          ffi.Pointer<git_checkout_options>)>();

  /// Updates files in the index and working tree to match the content of the
  /// tree pointed at by the treeish.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param treeish a commit, tag or tree which content will be used to update
  /// the working directory (or NULL to use HEAD)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, non-zero return value from `notify_cb`, or error
  /// code < 0 (use git_error_last for error details)
  int git_checkout_tree(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> treeish,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _git_checkout_tree(
      repo,
      treeish,
      opts,
    );
  }

  late final _git_checkout_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
              ffi.Pointer<git_checkout_options>)>>('git_checkout_tree');
  late final _git_checkout_tree = _git_checkout_treePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
          ffi.Pointer<git_checkout_options>)>();

  /// Free the object IDs contained in an oid_array.  This method should
  /// be called on `git_oidarray` objects that were provided by the
  /// library.  Not doing so will result in a memory leak.
  ///
  /// This does not free the `git_oidarray` itself, since the library will
  /// never allocate that object directly itself.
  ///
  /// @param array git_oidarray from which to free oid data
  void git_oidarray_dispose(
    ffi.Pointer<git_oidarray> array,
  ) {
    return _git_oidarray_dispose(
      array,
    );
  }

  late final _git_oidarray_disposePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_oidarray>)>>(
          'git_oidarray_dispose');
  late final _git_oidarray_dispose = _git_oidarray_disposePtr
      .asFunction<void Function(ffi.Pointer<git_oidarray>)>();

  /// Initializes a `git_indexer_options` with default values. Equivalent to
  /// creating an instance with GIT_INDEXER_OPTIONS_INIT.
  ///
  /// @param opts the `git_indexer_options` struct to initialize.
  /// @param version Version of struct; pass `GIT_INDEXER_OPTIONS_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_indexer_options_init(
    ffi.Pointer<git_indexer_options> opts,
    int version,
  ) {
    return _git_indexer_options_init(
      opts,
      version,
    );
  }

  late final _git_indexer_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_indexer_options>,
              ffi.UnsignedInt)>>('git_indexer_options_init');
  late final _git_indexer_options_init = _git_indexer_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_indexer_options>, int)>();

  /// Create a new indexer instance
  ///
  /// @param out where to store the indexer instance
  /// @param path to the directory where the packfile should be stored
  /// @param mode permissions to use creating packfile or 0 for defaults
  /// @param odb object database from which to read base objects when
  /// fixing thin packs. Pass NULL if no thin pack is expected (an error
  /// will be returned if there are bases missing)
  /// @param opts Optional structure containing additional options. See
  /// `git_indexer_options` above.
  /// @return 0 or an error code.
  int git_indexer_new(
    ffi.Pointer<ffi.Pointer<git_indexer>> out,
    ffi.Pointer<ffi.Char> path,
    int mode,
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_indexer_options> opts,
  ) {
    return _git_indexer_new(
      out,
      path,
      mode,
      odb,
      opts,
    );
  }

  late final _git_indexer_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_indexer>>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<git_odb>,
              ffi.Pointer<git_indexer_options>)>>('git_indexer_new');
  late final _git_indexer_new = _git_indexer_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_indexer>>, ffi.Pointer<ffi.Char>,
          int, ffi.Pointer<git_odb>, ffi.Pointer<git_indexer_options>)>();

  /// Add data to the indexer
  ///
  /// @param idx the indexer
  /// @param data the data to add
  /// @param size the size of the data in bytes
  /// @param stats stat storage
  /// @return 0 or an error code.
  int git_indexer_append(
    ffi.Pointer<git_indexer> idx,
    ffi.Pointer<ffi.Void> data,
    int size,
    ffi.Pointer<git_indexer_progress> stats,
  ) {
    return _git_indexer_append(
      idx,
      data,
      size,
      stats,
    );
  }

  late final _git_indexer_appendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_indexer>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<git_indexer_progress>)>>('git_indexer_append');
  late final _git_indexer_append = _git_indexer_appendPtr.asFunction<
      int Function(ffi.Pointer<git_indexer>, ffi.Pointer<ffi.Void>, int,
          ffi.Pointer<git_indexer_progress>)>();

  /// Finalize the pack and index
  ///
  /// Resolve any pending deltas and write out the index file
  ///
  /// @param idx the indexer
  /// @param stats Stat storage.
  /// @return 0 or an error code.
  int git_indexer_commit(
    ffi.Pointer<git_indexer> idx,
    ffi.Pointer<git_indexer_progress> stats,
  ) {
    return _git_indexer_commit(
      idx,
      stats,
    );
  }

  late final _git_indexer_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_indexer>,
              ffi.Pointer<git_indexer_progress>)>>('git_indexer_commit');
  late final _git_indexer_commit = _git_indexer_commitPtr.asFunction<
      int Function(
          ffi.Pointer<git_indexer>, ffi.Pointer<git_indexer_progress>)>();

  /// Get the packfile's hash
  ///
  /// A packfile's name is derived from the sorted hashing of all object
  /// names. This is only correct after the index has been finalized.
  ///
  /// @deprecated use git_indexer_name
  /// @param idx the indexer instance
  /// @return the packfile's hash
  ffi.Pointer<git_oid> git_indexer_hash(
    ffi.Pointer<git_indexer> idx,
  ) {
    return _git_indexer_hash(
      idx,
    );
  }

  late final _git_indexer_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_indexer>)>>('git_indexer_hash');
  late final _git_indexer_hash = _git_indexer_hashPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_indexer>)>();

  /// Get the unique name for the resulting packfile.
  ///
  /// The packfile's name is derived from the packfile's content.
  /// This is only correct after the index has been finalized.
  ///
  /// @param idx the indexer instance
  /// @return a NUL terminated string for the packfile name
  ffi.Pointer<ffi.Char> git_indexer_name(
    ffi.Pointer<git_indexer> idx,
  ) {
    return _git_indexer_name(
      idx,
    );
  }

  late final _git_indexer_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_indexer>)>>('git_indexer_name');
  late final _git_indexer_name = _git_indexer_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_indexer>)>();

  /// Free the indexer and its resources
  ///
  /// @param idx the indexer to free
  void git_indexer_free(
    ffi.Pointer<git_indexer> idx,
  ) {
    return _git_indexer_free(
      idx,
    );
  }

  late final _git_indexer_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_indexer>)>>(
          'git_indexer_free');
  late final _git_indexer_free = _git_indexer_freePtr
      .asFunction<void Function(ffi.Pointer<git_indexer>)>();

  /// Create a new bare Git index object as a memory representation
  /// of the Git index file in 'index_path', without a repository
  /// to back it.
  ///
  /// Since there is no ODB or working directory behind this index,
  /// any Index methods which rely on these (e.g. index_add_bypath)
  /// will fail with the GIT_ERROR error code.
  ///
  /// If you need to access the index of an actual repository,
  /// use the `git_repository_index` wrapper.
  ///
  /// The index must be freed once it's no longer in use.
  ///
  /// @param out the pointer for the new index
  /// @param index_path the path to the index file in disk
  /// @return 0 or an error code
  int git_index_open(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<ffi.Char> index_path,
  ) {
    return _git_index_open(
      out,
      index_path,
    );
  }

  late final _git_index_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<ffi.Char>)>>('git_index_open');
  late final _git_index_open = _git_index_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>, ffi.Pointer<ffi.Char>)>();

  /// Create an in-memory index object.
  ///
  /// This index object cannot be read/written to the filesystem,
  /// but may be used to perform in-memory index operations.
  ///
  /// The index must be freed once it's no longer in use.
  ///
  /// @param out the pointer for the new index
  /// @return 0 or an error code
  int git_index_new(
    ffi.Pointer<ffi.Pointer<git_index>> out,
  ) {
    return _git_index_new(
      out,
    );
  }

  late final _git_index_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>)>>('git_index_new');
  late final _git_index_new = _git_index_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_index>>)>();

  /// Free an existing index object.
  ///
  /// @param index an existing index object
  void git_index_free(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_free(
      index,
    );
  }

  late final _git_index_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_index>)>>(
          'git_index_free');
  late final _git_index_free =
      _git_index_freePtr.asFunction<void Function(ffi.Pointer<git_index>)>();

  /// Get the repository this index relates to
  ///
  /// @param index The index
  /// @return A pointer to the repository
  ffi.Pointer<git_repository> git_index_owner(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_owner(
      index,
    );
  }

  late final _git_index_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_index>)>>('git_index_owner');
  late final _git_index_owner = _git_index_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_index>)>();

  /// Read index capabilities flags.
  ///
  /// @param index An existing index object
  /// @return A combination of GIT_INDEX_CAPABILITY values
  int git_index_caps(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_caps(
      index,
    );
  }

  late final _git_index_capsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_caps');
  late final _git_index_caps =
      _git_index_capsPtr.asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Set index capabilities flags.
  ///
  /// If you pass `GIT_INDEX_CAPABILITY_FROM_OWNER` for the caps, then
  /// capabilities will be read from the config of the owner object,
  /// looking at `core.ignorecase`, `core.filemode`, `core.symlinks`.
  ///
  /// @param index An existing index object
  /// @param caps A combination of GIT_INDEX_CAPABILITY values
  /// @return 0 on success, -1 on failure
  int git_index_set_caps(
    ffi.Pointer<git_index> index,
    int caps,
  ) {
    return _git_index_set_caps(
      index,
      caps,
    );
  }

  late final _git_index_set_capsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>, ffi.Int)>>('git_index_set_caps');
  late final _git_index_set_caps = _git_index_set_capsPtr
      .asFunction<int Function(ffi.Pointer<git_index>, int)>();

  /// Get index on-disk version.
  ///
  /// Valid return values are 2, 3, or 4.  If 3 is returned, an index
  /// with version 2 may be written instead, if the extension data in
  /// version 3 is not necessary.
  ///
  /// @param index An existing index object
  /// @return the index version
  int git_index_version(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_version(
      index,
    );
  }

  late final _git_index_versionPtr = _lookup<
          ffi.NativeFunction<ffi.UnsignedInt Function(ffi.Pointer<git_index>)>>(
      'git_index_version');
  late final _git_index_version =
      _git_index_versionPtr.asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Set index on-disk version.
  ///
  /// Valid values are 2, 3, or 4.  If 2 is given, git_index_write may
  /// write an index with version 3 instead, if necessary to accurately
  /// represent the index.
  ///
  /// @param index An existing index object
  /// @param version The new version number
  /// @return 0 on success, -1 on failure
  int git_index_set_version(
    ffi.Pointer<git_index> index,
    int version,
  ) {
    return _git_index_set_version(
      index,
      version,
    );
  }

  late final _git_index_set_versionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.UnsignedInt)>>('git_index_set_version');
  late final _git_index_set_version = _git_index_set_versionPtr
      .asFunction<int Function(ffi.Pointer<git_index>, int)>();

  /// Update the contents of an existing index object in memory by reading
  /// from the hard disk.
  ///
  /// If `force` is true, this performs a "hard" read that discards in-memory
  /// changes and always reloads the on-disk index data.  If there is no
  /// on-disk version, the index will be cleared.
  ///
  /// If `force` is false, this does a "soft" read that reloads the index
  /// data from disk only if it has changed since the last time it was
  /// loaded.  Purely in-memory index data will be untouched.  Be aware: if
  /// there are changes on disk, unwritten in-memory changes are discarded.
  ///
  /// @param index an existing index object
  /// @param force if true, always reload, vs. only read if file has changed
  /// @return 0 or an error code
  int git_index_read(
    ffi.Pointer<git_index> index,
    int force,
  ) {
    return _git_index_read(
      index,
      force,
    );
  }

  late final _git_index_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>, ffi.Int)>>('git_index_read');
  late final _git_index_read = _git_index_readPtr
      .asFunction<int Function(ffi.Pointer<git_index>, int)>();

  /// Write an existing index object from memory back to disk
  /// using an atomic file lock.
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int git_index_write(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_write(
      index,
    );
  }

  late final _git_index_writePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_write');
  late final _git_index_write =
      _git_index_writePtr.asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Get the full path to the index file on disk.
  ///
  /// @param index an existing index object
  /// @return path to index file or NULL for in-memory index
  ffi.Pointer<ffi.Char> git_index_path(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_path(
      index,
    );
  }

  late final _git_index_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_index>)>>('git_index_path');
  late final _git_index_path = _git_index_pathPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_index>)>();

  /// Get the checksum of the index
  ///
  /// This checksum is the SHA-1 hash over the index file (except the
  /// last 20 bytes which are the checksum itself). In cases where the
  /// index does not exist on-disk, it will be zeroed out.
  ///
  /// @deprecated this function is deprecated with no replacement
  /// @param index an existing index object
  /// @return a pointer to the checksum of the index
  ffi.Pointer<git_oid> git_index_checksum(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_checksum(
      index,
    );
  }

  late final _git_index_checksumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_index>)>>('git_index_checksum');
  late final _git_index_checksum = _git_index_checksumPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_index>)>();

  /// Read a tree into the index file with stats
  ///
  /// The current index contents will be replaced by the specified tree.
  ///
  /// @param index an existing index object
  /// @param tree tree to read
  /// @return 0 or an error code
  int git_index_read_tree(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_index_read_tree(
      index,
      tree,
    );
  }

  late final _git_index_read_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<git_tree>)>>('git_index_read_tree');
  late final _git_index_read_tree = _git_index_read_treePtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_tree>)>();

  /// Write the index as a tree
  ///
  /// This method will scan the index and write a representation
  /// of its current state back to disk; it recursively creates
  /// tree objects for each of the subtrees stored in the index,
  /// but only returns the OID of the root tree. This is the OID
  /// that can be used e.g. to create a commit.
  ///
  /// The index instance cannot be bare, and needs to be associated
  /// to an existing repository.
  ///
  /// The index must not contain any file in conflict.
  ///
  /// @param out Pointer where to store the OID of the written tree
  /// @param index Index to write
  /// @return 0 on success, GIT_EUNMERGED when the index is not clean
  /// or an error code
  int git_index_write_tree(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_write_tree(
      out,
      index,
    );
  }

  late final _git_index_write_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<git_index>)>>('git_index_write_tree');
  late final _git_index_write_tree = _git_index_write_treePtr
      .asFunction<int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_index>)>();

  /// Write the index as a tree to the given repository
  ///
  /// This method will do the same as `git_index_write_tree`, but
  /// letting the user choose the repository where the tree will
  /// be written.
  ///
  /// The index must not contain any file in conflict.
  ///
  /// @param out Pointer where to store OID of the written tree
  /// @param index Index to write
  /// @param repo Repository where to write the tree
  /// @return 0 on success, GIT_EUNMERGED when the index is not clean
  /// or an error code
  int git_index_write_tree_to(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_index_write_tree_to(
      out,
      index,
      repo,
    );
  }

  late final _git_index_write_tree_toPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_index>,
              ffi.Pointer<git_repository>)>>('git_index_write_tree_to');
  late final _git_index_write_tree_to = _git_index_write_tree_toPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_index>,
          ffi.Pointer<git_repository>)>();

  /// Get the count of entries currently in the index
  ///
  /// @param index an existing index object
  /// @return integer of count of current entries
  int git_index_entrycount(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_entrycount(
      index,
    );
  }

  late final _git_index_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_index>)>>(
          'git_index_entrycount');
  late final _git_index_entrycount = _git_index_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Clear the contents (all the entries) of an index object.
  ///
  /// This clears the index object in memory; changes must be explicitly
  /// written to disk for them to take effect persistently.
  ///
  /// @param index an existing index object
  /// @return 0 on success, error code < 0 on failure
  int git_index_clear(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_clear(
      index,
    );
  }

  late final _git_index_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_clear');
  late final _git_index_clear =
      _git_index_clearPtr.asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Get a pointer to one of the entries in the index
  ///
  /// The entry is not modifiable and should not be freed.  Because the
  /// `git_index_entry` struct is a publicly defined struct, you should
  /// be able to make your own permanent copy of the data if necessary.
  ///
  /// @param index an existing index object
  /// @param n the position of the entry
  /// @return a pointer to the entry; NULL if out of bounds
  ffi.Pointer<git_index_entry> git_index_get_byindex(
    ffi.Pointer<git_index> index,
    int n,
  ) {
    return _git_index_get_byindex(
      index,
      n,
    );
  }

  late final _git_index_get_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_index_entry> Function(
              ffi.Pointer<git_index>, ffi.Size)>>('git_index_get_byindex');
  late final _git_index_get_byindex = _git_index_get_byindexPtr.asFunction<
      ffi.Pointer<git_index_entry> Function(ffi.Pointer<git_index>, int)>();

  /// Get a pointer to one of the entries in the index
  ///
  /// The entry is not modifiable and should not be freed.  Because the
  /// `git_index_entry` struct is a publicly defined struct, you should
  /// be able to make your own permanent copy of the data if necessary.
  ///
  /// @param index an existing index object
  /// @param path path to search
  /// @param stage stage to search
  /// @return a pointer to the entry; NULL if it was not found
  ffi.Pointer<git_index_entry> git_index_get_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
    int stage,
  ) {
    return _git_index_get_bypath(
      index,
      path,
      stage,
    );
  }

  late final _git_index_get_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_index_entry> Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('git_index_get_bypath');
  late final _git_index_get_bypath = _git_index_get_bypathPtr.asFunction<
      ffi.Pointer<git_index_entry> Function(
          ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>, int)>();

  /// Remove an entry from the index
  ///
  /// @param index an existing index object
  /// @param path path to search
  /// @param stage stage to search
  /// @return 0 or an error code
  int git_index_remove(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
    int stage,
  ) {
    return _git_index_remove(
      index,
      path,
      stage,
    );
  }

  late final _git_index_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_index_remove');
  late final _git_index_remove = _git_index_removePtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>, int)>();

  /// Remove all entries from the index under a given directory
  ///
  /// @param index an existing index object
  /// @param dir container directory path
  /// @param stage stage to search
  /// @return 0 or an error code
  int git_index_remove_directory(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> dir,
    int stage,
  ) {
    return _git_index_remove_directory(
      index,
      dir,
      stage,
    );
  }

  late final _git_index_remove_directoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_index_remove_directory');
  late final _git_index_remove_directory =
      _git_index_remove_directoryPtr.asFunction<
          int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>, int)>();

  /// Add or update an index entry from an in-memory struct
  ///
  /// If a previous index entry exists that has the same path and stage
  /// as the given 'source_entry', it will be replaced.  Otherwise, the
  /// 'source_entry' will be added.
  ///
  /// A full copy (including the 'path' string) of the given
  /// 'source_entry' will be inserted on the index.
  ///
  /// @param index an existing index object
  /// @param source_entry new entry object
  /// @return 0 or an error code
  int git_index_add(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> source_entry,
  ) {
    return _git_index_add(
      index,
      source_entry,
    );
  }

  late final _git_index_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<git_index_entry>)>>('git_index_add');
  late final _git_index_add = _git_index_addPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>)>();

  /// Return the stage number from a git index entry
  ///
  /// This entry is calculated from the entry's flag attribute like this:
  ///
  /// (entry->flags & GIT_INDEX_ENTRY_STAGEMASK) >> GIT_INDEX_ENTRY_STAGESHIFT
  ///
  /// @param entry The entry
  /// @return the stage number
  int git_index_entry_stage(
    ffi.Pointer<git_index_entry> entry,
  ) {
    return _git_index_entry_stage(
      entry,
    );
  }

  late final _git_index_entry_stagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index_entry>)>>(
      'git_index_entry_stage');
  late final _git_index_entry_stage = _git_index_entry_stagePtr
      .asFunction<int Function(ffi.Pointer<git_index_entry>)>();

  /// Return whether the given index entry is a conflict (has a high stage
  /// entry).  This is simply shorthand for `git_index_entry_stage > 0`.
  ///
  /// @param entry The entry
  /// @return 1 if the entry is a conflict entry, 0 otherwise
  int git_index_entry_is_conflict(
    ffi.Pointer<git_index_entry> entry,
  ) {
    return _git_index_entry_is_conflict(
      entry,
    );
  }

  late final _git_index_entry_is_conflictPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index_entry>)>>(
      'git_index_entry_is_conflict');
  late final _git_index_entry_is_conflict = _git_index_entry_is_conflictPtr
      .asFunction<int Function(ffi.Pointer<git_index_entry>)>();

  /// Create an iterator that will return every entry contained in the
  /// index at the time of creation.  Entries are returned in order,
  /// sorted by path.  This iterator is backed by a snapshot that allows
  /// callers to modify the index while iterating without affecting the
  /// iterator.
  ///
  /// @param iterator_out The newly created iterator
  /// @param index The index to iterate
  /// @return 0 or an error code.
  int git_index_iterator_new(
    ffi.Pointer<ffi.Pointer<git_index_iterator>> iterator_out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_iterator_new(
      iterator_out,
      index,
    );
  }

  late final _git_index_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index_iterator>>,
              ffi.Pointer<git_index>)>>('git_index_iterator_new');
  late final _git_index_iterator_new = _git_index_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_index_iterator>>,
          ffi.Pointer<git_index>)>();

  /// Return the next index entry in-order from the iterator.
  ///
  /// @param out Pointer to store the index entry in
  /// @param iterator The iterator
  /// @return 0, GIT_ITEROVER on iteration completion or an error code
  int git_index_iterator_next(
    ffi.Pointer<ffi.Pointer<git_index_entry>> out,
    ffi.Pointer<git_index_iterator> iterator,
  ) {
    return _git_index_iterator_next(
      out,
      iterator,
    );
  }

  late final _git_index_iterator_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index_entry>>,
              ffi.Pointer<git_index_iterator>)>>('git_index_iterator_next');
  late final _git_index_iterator_next = _git_index_iterator_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<git_index_iterator>)>();

  /// Free the index iterator
  ///
  /// @param iterator The iterator to free
  void git_index_iterator_free(
    ffi.Pointer<git_index_iterator> iterator,
  ) {
    return _git_index_iterator_free(
      iterator,
    );
  }

  late final _git_index_iterator_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<git_index_iterator>)>>('git_index_iterator_free');
  late final _git_index_iterator_free = _git_index_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_index_iterator>)>();

  /// Add or update an index entry from a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder and must be readable.
  ///
  /// This method will fail in bare index instances.
  ///
  /// This forces the file to be added to the index, not looking
  /// at gitignore rules.  Those rules can be evaluated through
  /// the git_status APIs (in status.h) before calling this.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to add
  /// @return 0 or an error code
  int git_index_add_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_add_bypath(
      index,
      path,
    );
  }

  late final _git_index_add_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_add_bypath');
  late final _git_index_add_bypath = _git_index_add_bypathPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>)>();

  /// Add or update an index entry from a buffer in memory
  ///
  /// This method will create a blob in the repository that owns the
  /// index and then add the index entry to the index.  The `path` of the
  /// entry represents the position of the blob relative to the
  /// repository's root folder.
  ///
  /// If a previous index entry exists that has the same path as the
  /// given 'entry', it will be replaced.  Otherwise, the 'entry' will be
  /// added.
  ///
  /// This forces the file to be added to the index, not looking
  /// at gitignore rules.  Those rules can be evaluated through
  /// the git_status APIs (in status.h) before calling this.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param entry filename to add
  /// @param buffer data to be written into the blob
  /// @param len length of the data
  /// @return 0 or an error code
  int git_index_add_from_buffer(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> entry,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_index_add_from_buffer(
      index,
      entry,
      buffer,
      len,
    );
  }

  late final _git_index_add_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('git_index_add_from_buffer');
  late final _git_index_add_from_buffer =
      _git_index_add_from_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>,
              ffi.Pointer<ffi.Void>, int)>();

  /// Remove an index entry corresponding to a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder.  It may exist.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to remove
  /// @return 0 or an error code
  int git_index_remove_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_remove_bypath(
      index,
      path,
    );
  }

  late final _git_index_remove_bypathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_remove_bypath');
  late final _git_index_remove_bypath = _git_index_remove_bypathPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>)>();

  /// Add or update index entries matching files in the working directory.
  ///
  /// This method will fail in bare index instances.
  ///
  /// The `pathspec` is a list of file names or shell glob patterns that will
  /// be matched against files in the repository's working directory.  Each
  /// file that matches will be added to the index (either updating an
  /// existing entry or adding a new entry).  You can disable glob expansion
  /// and force exact matching with the `GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH`
  /// flag.
  ///
  /// Files that are ignored will be skipped (unlike `git_index_add_bypath`).
  /// If a file is already tracked in the index, then it *will* be updated
  /// even if it is ignored.  Pass the `GIT_INDEX_ADD_FORCE` flag to skip
  /// the checking of ignore rules.
  ///
  /// To emulate `git add -A` and generate an error if the pathspec contains
  /// the exact path of an ignored file (when not using FORCE), add the
  /// `GIT_INDEX_ADD_CHECK_PATHSPEC` flag.  This checks that each entry
  /// in the `pathspec` that is an exact match to a filename on disk is
  /// either not ignored or already in the index.  If this check fails, the
  /// function will return GIT_EINVALIDSPEC.
  ///
  /// To emulate `git add -A` with the "dry-run" option, just use a callback
  /// function that always returns a positive value.  See below for details.
  ///
  /// If any files are currently the result of a merge conflict, those files
  /// will no longer be marked as conflicting.  The data about the conflicts
  /// will be moved to the "resolve undo" (REUC) section.
  ///
  /// If you provide a callback function, it will be invoked on each matching
  /// item in the working directory immediately *before* it is added to /
  /// updated in the index.  Returning zero will add the item to the index,
  /// greater than zero will skip the item, and less than zero will abort the
  /// scan and return that value to the caller.
  ///
  /// @param index an existing index object
  /// @param pathspec array of path patterns
  /// @param flags combination of git_index_add_option_t flags
  /// @param callback notification callback for each added/updated path (also
  /// gets index of matching pathspec entry); can be NULL;
  /// return 0 to add, >0 to skip, <0 to abort scan.
  /// @param payload payload passed through to callback function
  /// @return 0 on success, negative callback return value, or error code
  int git_index_add_all(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_strarray> pathspec,
    int flags,
    git_index_matched_path_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_index_add_all(
      index,
      pathspec,
      flags,
      callback,
      payload,
    );
  }

  late final _git_index_add_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<git_strarray>,
              ffi.UnsignedInt,
              git_index_matched_path_cb,
              ffi.Pointer<ffi.Void>)>>('git_index_add_all');
  late final _git_index_add_all = _git_index_add_allPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_strarray>, int,
          git_index_matched_path_cb, ffi.Pointer<ffi.Void>)>();

  /// Remove all matching index entries.
  ///
  /// If you provide a callback function, it will be invoked on each matching
  /// item in the index immediately *before* it is removed.  Return 0 to
  /// remove the item, > 0 to skip the item, and < 0 to abort the scan.
  ///
  /// @param index An existing index object
  /// @param pathspec array of path patterns
  /// @param callback notification callback for each removed path (also
  /// gets index of matching pathspec entry); can be NULL;
  /// return 0 to add, >0 to skip, <0 to abort scan.
  /// @param payload payload passed through to callback function
  /// @return 0 on success, negative callback return value, or error code
  int git_index_remove_all(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_strarray> pathspec,
    git_index_matched_path_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_index_remove_all(
      index,
      pathspec,
      callback,
      payload,
    );
  }

  late final _git_index_remove_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<git_strarray>,
              git_index_matched_path_cb,
              ffi.Pointer<ffi.Void>)>>('git_index_remove_all');
  late final _git_index_remove_all = _git_index_remove_allPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_strarray>,
          git_index_matched_path_cb, ffi.Pointer<ffi.Void>)>();

  /// Update all index entries to match the working directory
  ///
  /// This method will fail in bare index instances.
  ///
  /// This scans the existing index entries and synchronizes them with the
  /// working directory, deleting them if the corresponding working directory
  /// file no longer exists otherwise updating the information (including
  /// adding the latest version of file to the ODB if needed).
  ///
  /// If you provide a callback function, it will be invoked on each matching
  /// item in the index immediately *before* it is updated (either refreshed
  /// or removed depending on working directory state).  Return 0 to proceed
  /// with updating the item, > 0 to skip the item, and < 0 to abort the scan.
  ///
  /// @param index An existing index object
  /// @param pathspec array of path patterns
  /// @param callback notification callback for each updated path (also
  /// gets index of matching pathspec entry); can be NULL;
  /// return 0 to add, >0 to skip, <0 to abort scan.
  /// @param payload payload passed through to callback function
  /// @return 0 on success, negative callback return value, or error code
  int git_index_update_all(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_strarray> pathspec,
    git_index_matched_path_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_index_update_all(
      index,
      pathspec,
      callback,
      payload,
    );
  }

  late final _git_index_update_allPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<git_strarray>,
              git_index_matched_path_cb,
              ffi.Pointer<ffi.Void>)>>('git_index_update_all');
  late final _git_index_update_all = _git_index_update_allPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_strarray>,
          git_index_matched_path_cb, ffi.Pointer<ffi.Void>)>();

  /// Find the first position of any entries which point to given
  /// path in the Git index.
  ///
  /// @param at_pos the address to which the position of the index entry is written (optional)
  /// @param index an existing index object
  /// @param path path to search
  /// @return 0 or an error code
  int git_index_find(
    ffi.Pointer<ffi.Size> at_pos,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_find(
      at_pos,
      index,
      path,
    );
  }

  late final _git_index_findPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_find');
  late final _git_index_find = _git_index_findPtr.asFunction<
      int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
          ffi.Pointer<ffi.Char>)>();

  /// Find the first position of any entries matching a prefix. To find the first position
  /// of a path inside a given folder, suffix the prefix with a '/'.
  ///
  /// @param at_pos the address to which the position of the index entry is written (optional)
  /// @param index an existing index object
  /// @param prefix the prefix to search for
  /// @return 0 or an error code
  int git_index_find_prefix(
    ffi.Pointer<ffi.Size> at_pos,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> prefix,
  ) {
    return _git_index_find_prefix(
      at_pos,
      index,
      prefix,
    );
  }

  late final _git_index_find_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_find_prefix');
  late final _git_index_find_prefix = _git_index_find_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<git_index>,
          ffi.Pointer<ffi.Char>)>();

  /// Add or update index entries to represent a conflict.  Any staged
  /// entries that exist at the given paths will be removed.
  ///
  /// The entries are the entries from the tree included in the merge.  Any
  /// entry may be null to indicate that that file was not present in the
  /// trees during the merge.  For example, ancestor_entry may be NULL to
  /// indicate that a file was added in both branches and must be resolved.
  ///
  /// @param index an existing index object
  /// @param ancestor_entry the entry data for the ancestor of the conflict
  /// @param our_entry the entry data for our side of the merge conflict
  /// @param their_entry the entry data for their side of the merge conflict
  /// @return 0 or an error code
  int git_index_conflict_add(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> ancestor_entry,
    ffi.Pointer<git_index_entry> our_entry,
    ffi.Pointer<git_index_entry> their_entry,
  ) {
    return _git_index_conflict_add(
      index,
      ancestor_entry,
      our_entry,
      their_entry,
    );
  }

  late final _git_index_conflict_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_index>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_index_entry>)>>('git_index_conflict_add');
  late final _git_index_conflict_add = _git_index_conflict_addPtr.asFunction<
      int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>,
          ffi.Pointer<git_index_entry>, ffi.Pointer<git_index_entry>)>();

  /// Get the index entries that represent a conflict of a single file.
  ///
  /// The entries are not modifiable and should not be freed.  Because the
  /// `git_index_entry` struct is a publicly defined struct, you should
  /// be able to make your own permanent copy of the data if necessary.
  ///
  /// @param ancestor_out Pointer to store the ancestor entry
  /// @param our_out Pointer to store the our entry
  /// @param their_out Pointer to store the their entry
  /// @param index an existing index object
  /// @param path path to search
  /// @return 0 or an error code
  int git_index_conflict_get(
    ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_conflict_get(
      ancestor_out,
      our_out,
      their_out,
      index,
      path,
    );
  }

  late final _git_index_conflict_getPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index_entry>>,
              ffi.Pointer<ffi.Pointer<git_index_entry>>,
              ffi.Pointer<ffi.Pointer<git_index_entry>>,
              ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_conflict_get');
  late final _git_index_conflict_get = _git_index_conflict_getPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<git_index>,
          ffi.Pointer<ffi.Char>)>();

  /// Removes the index entries that represent a conflict of a single file.
  ///
  /// @param index an existing index object
  /// @param path path to remove conflicts for
  /// @return 0 or an error code
  int git_index_conflict_remove(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_index_conflict_remove(
      index,
      path,
    );
  }

  late final _git_index_conflict_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>,
              ffi.Pointer<ffi.Char>)>>('git_index_conflict_remove');
  late final _git_index_conflict_remove =
      _git_index_conflict_removePtr.asFunction<
          int Function(ffi.Pointer<git_index>, ffi.Pointer<ffi.Char>)>();

  /// Remove all conflicts in the index (entries with a stage greater than 0).
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int git_index_conflict_cleanup(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_conflict_cleanup(
      index,
    );
  }

  late final _git_index_conflict_cleanupPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_conflict_cleanup');
  late final _git_index_conflict_cleanup = _git_index_conflict_cleanupPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Determine if the index contains entries representing file conflicts.
  ///
  /// @param index An existing index object.
  /// @return 1 if at least one conflict is found, 0 otherwise.
  int git_index_has_conflicts(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_has_conflicts(
      index,
    );
  }

  late final _git_index_has_conflictsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_index>)>>(
          'git_index_has_conflicts');
  late final _git_index_has_conflicts = _git_index_has_conflictsPtr
      .asFunction<int Function(ffi.Pointer<git_index>)>();

  /// Create an iterator for the conflicts in the index.
  ///
  /// The index must not be modified while iterating; the results are undefined.
  ///
  /// @param iterator_out The newly created conflict iterator
  /// @param index The index to scan
  /// @return 0 or an error code
  int git_index_conflict_iterator_new(
    ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>> iterator_out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_conflict_iterator_new(
      iterator_out,
      index,
    );
  }

  late final _git_index_conflict_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>>,
              ffi.Pointer<git_index>)>>('git_index_conflict_iterator_new');
  late final _git_index_conflict_iterator_new =
      _git_index_conflict_iterator_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>>,
              ffi.Pointer<git_index>)>();

  /// Returns the current conflict (ancestor, ours and theirs entry) and
  /// advance the iterator internally to the next value.
  ///
  /// @param ancestor_out Pointer to store the ancestor side of the conflict
  /// @param our_out Pointer to store our side of the conflict
  /// @param their_out Pointer to store their side of the conflict
  /// @param iterator The conflict iterator.
  /// @return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
  /// (negative value)
  int git_index_conflict_next(
    ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
    ffi.Pointer<git_index_conflict_iterator> iterator,
  ) {
    return _git_index_conflict_next(
      ancestor_out,
      our_out,
      their_out,
      iterator,
    );
  }

  late final _git_index_conflict_nextPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_index_entry>>,
                  ffi.Pointer<ffi.Pointer<git_index_entry>>,
                  ffi.Pointer<ffi.Pointer<git_index_entry>>,
                  ffi.Pointer<git_index_conflict_iterator>)>>(
      'git_index_conflict_next');
  late final _git_index_conflict_next = _git_index_conflict_nextPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<ffi.Pointer<git_index_entry>>,
          ffi.Pointer<git_index_conflict_iterator>)>();

  /// Frees a `git_index_conflict_iterator`.
  ///
  /// @param iterator pointer to the iterator
  void git_index_conflict_iterator_free(
    ffi.Pointer<git_index_conflict_iterator> iterator,
  ) {
    return _git_index_conflict_iterator_free(
      iterator,
    );
  }

  late final _git_index_conflict_iterator_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_index_conflict_iterator>)>>(
      'git_index_conflict_iterator_free');
  late final _git_index_conflict_iterator_free =
      _git_index_conflict_iterator_freePtr.asFunction<
          void Function(ffi.Pointer<git_index_conflict_iterator>)>();

  /// Initializes a `git_merge_file_input` with default values. Equivalent to
  /// creating an instance with GIT_MERGE_FILE_INPUT_INIT.
  ///
  /// @param opts the `git_merge_file_input` instance to initialize.
  /// @param version the version of the struct; you should pass
  /// `GIT_MERGE_FILE_INPUT_VERSION` here.
  /// @return Zero on success; -1 on failure.
  int git_merge_file_input_init(
    ffi.Pointer<git_merge_file_input> opts,
    int version,
  ) {
    return _git_merge_file_input_init(
      opts,
      version,
    );
  }

  late final _git_merge_file_input_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_merge_file_input>,
              ffi.UnsignedInt)>>('git_merge_file_input_init');
  late final _git_merge_file_input_init = _git_merge_file_input_initPtr
      .asFunction<int Function(ffi.Pointer<git_merge_file_input>, int)>();

  /// Initialize git_merge_file_options structure
  ///
  /// Initializes a `git_merge_file_options` with default values. Equivalent to
  /// creating an instance with `GIT_MERGE_FILE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_merge_file_options` struct to initialize.
  /// @param version The struct version; pass `GIT_MERGE_FILE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_merge_file_options_init(
    ffi.Pointer<git_merge_file_options> opts,
    int version,
  ) {
    return _git_merge_file_options_init(
      opts,
      version,
    );
  }

  late final _git_merge_file_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_merge_file_options>,
              ffi.UnsignedInt)>>('git_merge_file_options_init');
  late final _git_merge_file_options_init = _git_merge_file_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_merge_file_options>, int)>();

  /// Initialize git_merge_options structure
  ///
  /// Initializes a `git_merge_options` with default values. Equivalent to
  /// creating an instance with `GIT_MERGE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_merge_options` struct to initialize.
  /// @param version The struct version; pass `GIT_MERGE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_merge_options_init(
    ffi.Pointer<git_merge_options> opts,
    int version,
  ) {
    return _git_merge_options_init(
      opts,
      version,
    );
  }

  late final _git_merge_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_merge_options>,
              ffi.UnsignedInt)>>('git_merge_options_init');
  late final _git_merge_options_init = _git_merge_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_merge_options>, int)>();

  /// Analyzes the given branch(es) and determines the opportunities for
  /// merging them into the HEAD of the repository.
  ///
  /// @param analysis_out analysis enumeration that the result is written into
  /// @param preference_out One of the `git_merge_preference_t` flag.
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @return 0 on success or error code
  int git_merge_analysis(
    ffi.Pointer<ffi.Int32> analysis_out,
    ffi.Pointer<ffi.Int32> preference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
  ) {
    return _git_merge_analysis(
      analysis_out,
      preference_out,
      repo,
      their_heads,
      their_heads_len,
    );
  }

  late final _git_merge_analysisPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Size)>>('git_merge_analysis');
  late final _git_merge_analysis = _git_merge_analysisPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
          int)>();

  /// Analyzes the given branch(es) and determines the opportunities for
  /// merging them into a reference.
  ///
  /// @param analysis_out analysis enumeration that the result is written into
  /// @param preference_out One of the `git_merge_preference_t` flag.
  /// @param repo the repository to merge
  /// @param our_ref the reference to perform the analysis from
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @return 0 on success or error code
  int git_merge_analysis_for_ref(
    ffi.Pointer<ffi.Int32> analysis_out,
    ffi.Pointer<ffi.Int32> preference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_reference> our_ref,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
  ) {
    return _git_merge_analysis_for_ref(
      analysis_out,
      preference_out,
      repo,
      our_ref,
      their_heads,
      their_heads_len,
    );
  }

  late final _git_merge_analysis_for_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Size)>>('git_merge_analysis_for_ref');
  late final _git_merge_analysis_for_ref =
      _git_merge_analysis_for_refPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_reference>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              int)>();

  /// Find a merge base between two commits
  ///
  /// @param out the OID of a merge base between 'one' and 'two'
  /// @param repo the repository where the commits exist
  /// @param one one of the commits
  /// @param two the other commit
  /// @return 0 on success, GIT_ENOTFOUND if not found or error code
  int git_merge_base(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> one,
    ffi.Pointer<git_oid> two,
  ) {
    return _git_merge_base(
      out,
      repo,
      one,
      two,
    );
  }

  late final _git_merge_basePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>>('git_merge_base');
  late final _git_merge_base = _git_merge_basePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
          ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Find merge bases between two commits
  ///
  /// @param out array in which to store the resulting ids
  /// @param repo the repository where the commits exist
  /// @param one one of the commits
  /// @param two the other commit
  /// @return 0 on success, GIT_ENOTFOUND if not found or error code
  int git_merge_bases(
    ffi.Pointer<git_oidarray> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> one,
    ffi.Pointer<git_oid> two,
  ) {
    return _git_merge_bases(
      out,
      repo,
      one,
      two,
    );
  }

  late final _git_merge_basesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oidarray>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>)>>('git_merge_bases');
  late final _git_merge_bases = _git_merge_basesPtr.asFunction<
      int Function(ffi.Pointer<git_oidarray>, ffi.Pointer<git_repository>,
          ffi.Pointer<git_oid>, ffi.Pointer<git_oid>)>();

  /// Find a merge base given a list of commits
  ///
  /// @param out the OID of a merge base considering all the commits
  /// @param repo the repository where the commits exist
  /// @param length The number of commits in the provided `input_array`
  /// @param input_array oids of the commits
  /// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
  int git_merge_base_many(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    int length,
    ffi.Pointer<git_oid> input_array,
  ) {
    return _git_merge_base_many(
      out,
      repo,
      length,
      input_array,
    );
  }

  late final _git_merge_base_manyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Size, ffi.Pointer<git_oid>)>>('git_merge_base_many');
  late final _git_merge_base_many = _git_merge_base_manyPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_oid>)>();

  /// Find all merge bases given a list of commits
  ///
  /// @param out array in which to store the resulting ids
  /// @param repo the repository where the commits exist
  /// @param length The number of commits in the provided `input_array`
  /// @param input_array oids of the commits
  /// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
  int git_merge_bases_many(
    ffi.Pointer<git_oidarray> out,
    ffi.Pointer<git_repository> repo,
    int length,
    ffi.Pointer<git_oid> input_array,
  ) {
    return _git_merge_bases_many(
      out,
      repo,
      length,
      input_array,
    );
  }

  late final _git_merge_bases_manyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oidarray>,
              ffi.Pointer<git_repository>,
              ffi.Size,
              ffi.Pointer<git_oid>)>>('git_merge_bases_many');
  late final _git_merge_bases_many = _git_merge_bases_manyPtr.asFunction<
      int Function(ffi.Pointer<git_oidarray>, ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_oid>)>();

  /// Find a merge base in preparation for an octopus merge
  ///
  /// @param out the OID of a merge base considering all the commits
  /// @param repo the repository where the commits exist
  /// @param length The number of commits in the provided `input_array`
  /// @param input_array oids of the commits
  /// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
  int git_merge_base_octopus(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    int length,
    ffi.Pointer<git_oid> input_array,
  ) {
    return _git_merge_base_octopus(
      out,
      repo,
      length,
      input_array,
    );
  }

  late final _git_merge_base_octopusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Size, ffi.Pointer<git_oid>)>>('git_merge_base_octopus');
  late final _git_merge_base_octopus = _git_merge_base_octopusPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_oid>)>();

  /// Merge two files as they exist in the in-memory data structures, using
  /// the given common ancestor as the baseline, producing a
  /// `git_merge_file_result` that reflects the merge result.  The
  /// `git_merge_file_result` must be freed with `git_merge_file_result_free`.
  ///
  /// Note that this function does not reference a repository and any
  /// configuration must be passed as `git_merge_file_options`.
  ///
  /// @param out The git_merge_file_result to be filled in
  /// @param ancestor The contents of the ancestor file
  /// @param ours The contents of the file in "our" side
  /// @param theirs The contents of the file in "their" side
  /// @param opts The merge file options or `NULL` for defaults
  /// @return 0 on success or error code
  int git_merge_file(
    ffi.Pointer<git_merge_file_result> out,
    ffi.Pointer<git_merge_file_input> ancestor,
    ffi.Pointer<git_merge_file_input> ours,
    ffi.Pointer<git_merge_file_input> theirs,
    ffi.Pointer<git_merge_file_options> opts,
  ) {
    return _git_merge_file(
      out,
      ancestor,
      ours,
      theirs,
      opts,
    );
  }

  late final _git_merge_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_merge_file_result>,
              ffi.Pointer<git_merge_file_input>,
              ffi.Pointer<git_merge_file_input>,
              ffi.Pointer<git_merge_file_input>,
              ffi.Pointer<git_merge_file_options>)>>('git_merge_file');
  late final _git_merge_file = _git_merge_filePtr.asFunction<
      int Function(
          ffi.Pointer<git_merge_file_result>,
          ffi.Pointer<git_merge_file_input>,
          ffi.Pointer<git_merge_file_input>,
          ffi.Pointer<git_merge_file_input>,
          ffi.Pointer<git_merge_file_options>)>();

  /// Merge two files as they exist in the index, using the given common
  /// ancestor as the baseline, producing a `git_merge_file_result` that
  /// reflects the merge result.  The `git_merge_file_result` must be freed with
  /// `git_merge_file_result_free`.
  ///
  /// @param out The git_merge_file_result to be filled in
  /// @param repo The repository
  /// @param ancestor The index entry for the ancestor file (stage level 1)
  /// @param ours The index entry for our file (stage level 2)
  /// @param theirs The index entry for their file (stage level 3)
  /// @param opts The merge file options or NULL
  /// @return 0 on success or error code
  int git_merge_file_from_index(
    ffi.Pointer<git_merge_file_result> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index_entry> ancestor,
    ffi.Pointer<git_index_entry> ours,
    ffi.Pointer<git_index_entry> theirs,
    ffi.Pointer<git_merge_file_options> opts,
  ) {
    return _git_merge_file_from_index(
      out,
      repo,
      ancestor,
      ours,
      theirs,
      opts,
    );
  }

  late final _git_merge_file_from_indexPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_merge_file_result>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<git_index_entry>,
                  ffi.Pointer<git_index_entry>,
                  ffi.Pointer<git_index_entry>,
                  ffi.Pointer<git_merge_file_options>)>>(
      'git_merge_file_from_index');
  late final _git_merge_file_from_index =
      _git_merge_file_from_indexPtr.asFunction<
          int Function(
              ffi.Pointer<git_merge_file_result>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_index_entry>,
              ffi.Pointer<git_merge_file_options>)>();

  /// Frees a `git_merge_file_result`.
  ///
  /// @param result The result to free or `NULL`
  void git_merge_file_result_free(
    ffi.Pointer<git_merge_file_result> result,
  ) {
    return _git_merge_file_result_free(
      result,
    );
  }

  late final _git_merge_file_result_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_merge_file_result>)>>(
      'git_merge_file_result_free');
  late final _git_merge_file_result_free = _git_merge_file_result_freePtr
      .asFunction<void Function(ffi.Pointer<git_merge_file_result>)>();

  /// Merge two trees, producing a `git_index` that reflects the result of
  /// the merge.  The index may be written as-is to the working directory
  /// or checked out.  If the index is to be converted to a tree, the caller
  /// should resolve any conflicts that arose as part of the merge.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo repository that contains the given trees
  /// @param ancestor_tree the common ancestor between the trees (or null if none)
  /// @param our_tree the tree that reflects the destination tree
  /// @param their_tree the tree to merge in to `our_tree`
  /// @param opts the merge tree options (or null for defaults)
  /// @return 0 on success or error code
  int git_merge_trees(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> ancestor_tree,
    ffi.Pointer<git_tree> our_tree,
    ffi.Pointer<git_tree> their_tree,
    ffi.Pointer<git_merge_options> opts,
  ) {
    return _git_merge_trees(
      out,
      repo,
      ancestor_tree,
      our_tree,
      their_tree,
      opts,
    );
  }

  late final _git_merge_treesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_tree>,
              ffi.Pointer<git_merge_options>)>>('git_merge_trees');
  late final _git_merge_trees = _git_merge_treesPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_tree>,
          ffi.Pointer<git_merge_options>)>();

  /// Merge two commits, producing a `git_index` that reflects the result of
  /// the merge.  The index may be written as-is to the working directory
  /// or checked out.  If the index is to be converted to a tree, the caller
  /// should resolve any conflicts that arose as part of the merge.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo repository that contains the given trees
  /// @param our_commit the commit that reflects the destination tree
  /// @param their_commit the commit to merge in to `our_commit`
  /// @param opts the merge tree options (or null for defaults)
  /// @return 0 on success or error code
  int git_merge_commits(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> our_commit,
    ffi.Pointer<git_commit> their_commit,
    ffi.Pointer<git_merge_options> opts,
  ) {
    return _git_merge_commits(
      out,
      repo,
      our_commit,
      their_commit,
      opts,
    );
  }

  late final _git_merge_commitsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_merge_options>)>>('git_merge_commits');
  late final _git_merge_commits = _git_merge_commitsPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_merge_options>)>();

  /// Merges the given commit(s) into HEAD, writing the results into the working
  /// directory.  Any changes are staged for commit and any conflicts are written
  /// to the index.  Callers should inspect the repository's index after this
  /// completes, resolve any conflicts and prepare a commit.
  ///
  /// For compatibility with git, the repository is put into a merging
  /// state. Once the commit is done (or if the user wishes to abort),
  /// you should clear this state by calling
  /// `git_repository_state_cleanup()`.
  ///
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @param merge_opts merge options
  /// @param checkout_opts checkout options
  /// @return 0 on success or error code
  int git_merge(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
    ffi.Pointer<git_merge_options> merge_opts,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _git_merge(
      repo,
      their_heads,
      their_heads_len,
      merge_opts,
      checkout_opts,
    );
  }

  late final _git_mergePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
              ffi.Size,
              ffi.Pointer<git_merge_options>,
              ffi.Pointer<git_checkout_options>)>>('git_merge');
  late final _git_merge = _git_mergePtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Pointer<git_annotated_commit>>,
          int,
          ffi.Pointer<git_merge_options>,
          ffi.Pointer<git_checkout_options>)>();

  /// Initialize git_cherrypick_options structure
  ///
  /// Initializes a `git_cherrypick_options` with default values. Equivalent to creating
  /// an instance with GIT_CHERRYPICK_OPTIONS_INIT.
  ///
  /// @param opts The `git_cherrypick_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CHERRYPICK_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_cherrypick_options_init(
    ffi.Pointer<git_cherrypick_options> opts,
    int version,
  ) {
    return _git_cherrypick_options_init(
      opts,
      version,
    );
  }

  late final _git_cherrypick_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_cherrypick_options>,
              ffi.UnsignedInt)>>('git_cherrypick_options_init');
  late final _git_cherrypick_options_init = _git_cherrypick_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_cherrypick_options>, int)>();

  /// Cherry-picks the given commit against the given "our" commit, producing an
  /// index that reflects the result of the cherry-pick.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo the repository that contains the given commits
  /// @param cherrypick_commit the commit to cherry-pick
  /// @param our_commit the commit to cherry-pick against (eg, HEAD)
  /// @param mainline the parent of the `cherrypick_commit`, if it is a merge
  /// @param merge_options the merge options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_cherrypick_commit(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> cherrypick_commit,
    ffi.Pointer<git_commit> our_commit,
    int mainline,
    ffi.Pointer<git_merge_options> merge_options,
  ) {
    return _git_cherrypick_commit(
      out,
      repo,
      cherrypick_commit,
      our_commit,
      mainline,
      merge_options,
    );
  }

  late final _git_cherrypick_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_commit>,
              ffi.UnsignedInt,
              ffi.Pointer<git_merge_options>)>>('git_cherrypick_commit');
  late final _git_cherrypick_commit = _git_cherrypick_commitPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_commit>,
          int,
          ffi.Pointer<git_merge_options>)>();

  /// Cherry-pick the given commit, producing changes in the index and working directory.
  ///
  /// @param repo the repository to cherry-pick
  /// @param commit the commit to cherry-pick
  /// @param cherrypick_options the cherry-pick options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_cherrypick(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_cherrypick_options> cherrypick_options,
  ) {
    return _git_cherrypick(
      repo,
      commit,
      cherrypick_options,
    );
  }

  late final _git_cherrypickPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_commit>,
              ffi.Pointer<git_cherrypick_options>)>>('git_cherrypick');
  late final _git_cherrypick = _git_cherrypickPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_commit>,
          ffi.Pointer<git_cherrypick_options>)>();

  /// Parse a given refspec string
  ///
  /// @param refspec a pointer to hold the refspec handle
  /// @param input the refspec string
  /// @param is_fetch is this a refspec for a fetch
  /// @return 0 if the refspec string could be parsed, -1 otherwise
  int git_refspec_parse(
    ffi.Pointer<ffi.Pointer<git_refspec>> refspec,
    ffi.Pointer<ffi.Char> input,
    int is_fetch,
  ) {
    return _git_refspec_parse(
      refspec,
      input,
      is_fetch,
    );
  }

  late final _git_refspec_parsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refspec>>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('git_refspec_parse');
  late final _git_refspec_parse = _git_refspec_parsePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_refspec>>, ffi.Pointer<ffi.Char>, int)>();

  /// Free a refspec object which has been created by git_refspec_parse
  ///
  /// @param refspec the refspec object
  void git_refspec_free(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_free(
      refspec,
    );
  }

  late final _git_refspec_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_refspec>)>>(
          'git_refspec_free');
  late final _git_refspec_free = _git_refspec_freePtr
      .asFunction<void Function(ffi.Pointer<git_refspec>)>();

  /// Get the source specifier
  ///
  /// @param refspec the refspec
  /// @return the refspec's source specifier
  ffi.Pointer<ffi.Char> git_refspec_src(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_src(
      refspec,
    );
  }

  late final _git_refspec_srcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_refspec>)>>('git_refspec_src');
  late final _git_refspec_src = _git_refspec_srcPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_refspec>)>();

  /// Get the destination specifier
  ///
  /// @param refspec the refspec
  /// @return the refspec's destination specifier
  ffi.Pointer<ffi.Char> git_refspec_dst(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_dst(
      refspec,
    );
  }

  late final _git_refspec_dstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_refspec>)>>('git_refspec_dst');
  late final _git_refspec_dst = _git_refspec_dstPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_refspec>)>();

  /// Get the refspec's string
  ///
  /// @param refspec the refspec
  /// @returns the refspec's original string
  ffi.Pointer<ffi.Char> git_refspec_string(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_string(
      refspec,
    );
  }

  late final _git_refspec_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_refspec>)>>('git_refspec_string');
  late final _git_refspec_string = _git_refspec_stringPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_refspec>)>();

  /// Get the force update setting
  ///
  /// @param refspec the refspec
  /// @return 1 if force update has been set, 0 otherwise
  int git_refspec_force(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_force(
      refspec,
    );
  }

  late final _git_refspec_forcePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_refspec>)>>(
          'git_refspec_force');
  late final _git_refspec_force = _git_refspec_forcePtr
      .asFunction<int Function(ffi.Pointer<git_refspec>)>();

  /// Get the refspec's direction.
  ///
  /// @param spec refspec
  /// @return GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
  int git_refspec_direction(
    ffi.Pointer<git_refspec> spec,
  ) {
    return _git_refspec_direction(
      spec,
    );
  }

  late final _git_refspec_directionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_refspec>)>>(
          'git_refspec_direction');
  late final _git_refspec_direction = _git_refspec_directionPtr
      .asFunction<int Function(ffi.Pointer<git_refspec>)>();

  /// Check if a refspec's source descriptor matches a reference
  ///
  /// @param refspec the refspec
  /// @param refname the name of the reference to check
  /// @return 1 if the refspec matches, 0 otherwise
  int git_refspec_src_matches(
    ffi.Pointer<git_refspec> refspec,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_refspec_src_matches(
      refspec,
      refname,
    );
  }

  late final _git_refspec_src_matchesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refspec>,
              ffi.Pointer<ffi.Char>)>>('git_refspec_src_matches');
  late final _git_refspec_src_matches = _git_refspec_src_matchesPtr.asFunction<
      int Function(ffi.Pointer<git_refspec>, ffi.Pointer<ffi.Char>)>();

  /// Check if a refspec's destination descriptor matches a reference
  ///
  /// @param refspec the refspec
  /// @param refname the name of the reference to check
  /// @return 1 if the refspec matches, 0 otherwise
  int git_refspec_dst_matches(
    ffi.Pointer<git_refspec> refspec,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_refspec_dst_matches(
      refspec,
      refname,
    );
  }

  late final _git_refspec_dst_matchesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_refspec>,
              ffi.Pointer<ffi.Char>)>>('git_refspec_dst_matches');
  late final _git_refspec_dst_matches = _git_refspec_dst_matchesPtr.asFunction<
      int Function(ffi.Pointer<git_refspec>, ffi.Pointer<ffi.Char>)>();

  /// Transform a reference to its target following the refspec's rules
  ///
  /// @param out where to store the target name
  /// @param spec the refspec
  /// @param name the name of the reference to transform
  /// @return 0, GIT_EBUFS or another error
  int git_refspec_transform(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_refspec> spec,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_refspec_transform(
      out,
      spec,
      name,
    );
  }

  late final _git_refspec_transformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_refspec>,
              ffi.Pointer<ffi.Char>)>>('git_refspec_transform');
  late final _git_refspec_transform = _git_refspec_transformPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_refspec>,
          ffi.Pointer<ffi.Char>)>();

  /// Transform a target reference to its source reference following the refspec's rules
  ///
  /// @param out where to store the source reference name
  /// @param spec the refspec
  /// @param name the name of the reference to transform
  /// @return 0, GIT_EBUFS or another error
  int git_refspec_rtransform(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_refspec> spec,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_refspec_rtransform(
      out,
      spec,
      name,
    );
  }

  late final _git_refspec_rtransformPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_refspec>,
              ffi.Pointer<ffi.Char>)>>('git_refspec_rtransform');
  late final _git_refspec_rtransform = _git_refspec_rtransformPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_refspec>,
          ffi.Pointer<ffi.Char>)>();

  /// Free a credential.
  ///
  /// This is only necessary if you own the object; that is, if you are a
  /// transport.
  ///
  /// @param cred the object to free
  void git_credential_free(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_credential_free(
      cred,
    );
  }

  late final _git_credential_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_credential>)>>(
      'git_credential_free');
  late final _git_credential_free = _git_credential_freePtr
      .asFunction<void Function(ffi.Pointer<git_credential>)>();

  /// Check whether a credential object contains username information.
  ///
  /// @param cred object to check
  /// @return 1 if the credential object has non-NULL username, 0 otherwise
  int git_credential_has_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_credential_has_username(
      cred,
    );
  }

  late final _git_credential_has_usernamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_credential>)>>(
      'git_credential_has_username');
  late final _git_credential_has_username = _git_credential_has_usernamePtr
      .asFunction<int Function(ffi.Pointer<git_credential>)>();

  /// Return the username associated with a credential object.
  ///
  /// @param cred object to check
  /// @return the credential username, or NULL if not applicable
  ffi.Pointer<ffi.Char> git_credential_get_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_credential_get_username(
      cred,
    );
  }

  late final _git_credential_get_usernamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_credential>)>>('git_credential_get_username');
  late final _git_credential_get_username =
      _git_credential_get_usernamePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_credential>)>();

  /// Create a new plain-text username and password credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username The username of the credential.
  /// @param password The password of the credential.
  /// @return 0 for success or an error code for failure
  int git_credential_userpass_plaintext_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> password,
  ) {
    return _git_credential_userpass_plaintext_new(
      out,
      username,
      password,
    );
  }

  late final _git_credential_userpass_plaintext_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_credential_userpass_plaintext_new');
  late final _git_credential_userpass_plaintext_new =
      _git_credential_userpass_plaintext_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Create a "default" credential usable for Negotiate mechanisms like NTLM
  /// or Kerberos authentication.
  ///
  /// @param out The newly created credential object.
  /// @return 0 for success or an error code for failure
  int git_credential_default_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
  ) {
    return _git_credential_default_new(
      out,
    );
  }

  late final _git_credential_default_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>>)>>(
      'git_credential_default_new');
  late final _git_credential_default_new = _git_credential_default_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_credential>>)>();

  /// Create a credential to specify a username.
  ///
  /// This is used with ssh authentication to query for the username if
  /// none is specified in the url.
  ///
  /// @param out The newly created credential object.
  /// @param username The username to authenticate with
  /// @return 0 for success or an error code for failure
  int git_credential_username_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
  ) {
    return _git_credential_username_new(
      out,
      username,
    );
  }

  late final _git_credential_username_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>>('git_credential_username_new');
  late final _git_credential_username_new =
      _git_credential_username_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new passphrase-protected ssh key credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate
  /// @param publickey The path to the public key of the credential.
  /// @param privatekey The path to the private key of the credential.
  /// @param passphrase The passphrase of the credential.
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_key_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    ffi.Pointer<ffi.Char> privatekey,
    ffi.Pointer<ffi.Char> passphrase,
  ) {
    return _git_credential_ssh_key_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_credential_ssh_key_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_credential_ssh_key_new');
  late final _git_credential_ssh_key_new =
      _git_credential_ssh_key_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new ssh key credential object reading the keys from memory.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate.
  /// @param publickey The public key of the credential.
  /// @param privatekey The private key of the credential.
  /// @param passphrase The passphrase of the credential.
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_key_memory_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    ffi.Pointer<ffi.Char> privatekey,
    ffi.Pointer<ffi.Char> passphrase,
  ) {
    return _git_credential_ssh_key_memory_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_credential_ssh_key_memory_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_credential_ssh_key_memory_new');
  late final _git_credential_ssh_key_memory_new =
      _git_credential_ssh_key_memory_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new ssh keyboard-interactive based credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username Username to use to authenticate.
  /// @param prompt_callback The callback method used for prompts.
  /// @param payload Additional data to pass to the callback.
  /// @return 0 for success or an error code for failure.
  int git_credential_ssh_interactive_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    git_credential_ssh_interactive_cb prompt_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_credential_ssh_interactive_new(
      out,
      username,
      prompt_callback,
      payload,
    );
  }

  late final _git_credential_ssh_interactive_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              git_credential_ssh_interactive_cb,
              ffi.Pointer<ffi.Void>)>>('git_credential_ssh_interactive_new');
  late final _git_credential_ssh_interactive_new =
      _git_credential_ssh_interactive_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              git_credential_ssh_interactive_cb,
              ffi.Pointer<ffi.Void>)>();

  /// Create a new ssh key credential object used for querying an ssh-agent.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_key_from_agent(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
  ) {
    return _git_credential_ssh_key_from_agent(
      out,
      username,
    );
  }

  late final _git_credential_ssh_key_from_agentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>>('git_credential_ssh_key_from_agent');
  late final _git_credential_ssh_key_from_agent =
      _git_credential_ssh_key_from_agentPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>();

  /// Create an ssh key credential with a custom signing function.
  ///
  /// This lets you use your own function to sign the challenge.
  ///
  /// This function and its credential type is provided for completeness
  /// and wraps `libssh2_userauth_publickey()`, which is undocumented.
  ///
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate
  /// @param publickey The bytes of the public key.
  /// @param publickey_len The length of the public key in bytes.
  /// @param sign_callback The callback method to sign the data during the challenge.
  /// @param payload Additional data to pass to the callback.
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_custom_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    int publickey_len,
    git_credential_sign_cb sign_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_credential_ssh_custom_new(
      out,
      username,
      publickey,
      publickey_len,
      sign_callback,
      payload,
    );
  }

  late final _git_credential_ssh_custom_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              git_credential_sign_cb,
              ffi.Pointer<ffi.Void>)>>('git_credential_ssh_custom_new');
  late final _git_credential_ssh_custom_new =
      _git_credential_ssh_custom_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              int,
              git_credential_sign_cb,
              ffi.Pointer<ffi.Void>)>();

  /// Initialize a new packbuilder
  ///
  /// @param out The new packbuilder object
  /// @param repo The repository
  ///
  /// @return 0 or an error code
  int git_packbuilder_new(
    ffi.Pointer<ffi.Pointer<git_packbuilder>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_packbuilder_new(
      out,
      repo,
    );
  }

  late final _git_packbuilder_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_packbuilder>>,
              ffi.Pointer<git_repository>)>>('git_packbuilder_new');
  late final _git_packbuilder_new = _git_packbuilder_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_packbuilder>>,
          ffi.Pointer<git_repository>)>();

  /// Set number of threads to spawn
  ///
  /// By default, libgit2 won't spawn any threads at all;
  /// when set to 0, libgit2 will autodetect the number of
  /// CPUs.
  ///
  /// @param pb The packbuilder
  /// @param n Number of threads to spawn
  /// @return number of actual threads to be used
  int git_packbuilder_set_threads(
    ffi.Pointer<git_packbuilder> pb,
    int n,
  ) {
    return _git_packbuilder_set_threads(
      pb,
      n,
    );
  }

  late final _git_packbuilder_set_threadsPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(ffi.Pointer<git_packbuilder>,
              ffi.UnsignedInt)>>('git_packbuilder_set_threads');
  late final _git_packbuilder_set_threads = _git_packbuilder_set_threadsPtr
      .asFunction<int Function(ffi.Pointer<git_packbuilder>, int)>();

  /// Insert a single object
  ///
  /// For an optimal pack it's mandatory to insert objects in recency order,
  /// commits followed by trees and blobs.
  ///
  /// @param pb The packbuilder
  /// @param id The oid of the commit
  /// @param name The name; might be NULL
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_packbuilder_insert(
      pb,
      id,
      name,
    );
  }

  late final _git_packbuilder_insertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_packbuilder_insert');
  late final _git_packbuilder_insert = _git_packbuilder_insertPtr.asFunction<
      int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>,
          ffi.Pointer<ffi.Char>)>();

  /// Insert a root tree object
  ///
  /// This will add the tree as well as all referenced trees and blobs.
  ///
  /// @param pb The packbuilder
  /// @param id The oid of the root tree
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert_tree(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_packbuilder_insert_tree(
      pb,
      id,
    );
  }

  late final _git_packbuilder_insert_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>,
              ffi.Pointer<git_oid>)>>('git_packbuilder_insert_tree');
  late final _git_packbuilder_insert_tree =
      _git_packbuilder_insert_treePtr.asFunction<
          int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>)>();

  /// Insert a commit object
  ///
  /// This will add a commit as well as the completed referenced tree.
  ///
  /// @param pb The packbuilder
  /// @param id The oid of the commit
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert_commit(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_packbuilder_insert_commit(
      pb,
      id,
    );
  }

  late final _git_packbuilder_insert_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>,
              ffi.Pointer<git_oid>)>>('git_packbuilder_insert_commit');
  late final _git_packbuilder_insert_commit =
      _git_packbuilder_insert_commitPtr.asFunction<
          int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>)>();

  /// Insert objects as given by the walk
  ///
  /// Those commits and all objects they reference will be inserted into
  /// the packbuilder.
  ///
  /// @param pb the packbuilder
  /// @param walk the revwalk to use to fill the packbuilder
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert_walk(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_packbuilder_insert_walk(
      pb,
      walk,
    );
  }

  late final _git_packbuilder_insert_walkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>,
              ffi.Pointer<git_revwalk>)>>('git_packbuilder_insert_walk');
  late final _git_packbuilder_insert_walk =
      _git_packbuilder_insert_walkPtr.asFunction<
          int Function(
              ffi.Pointer<git_packbuilder>, ffi.Pointer<git_revwalk>)>();

  /// Recursively insert an object and its referenced objects
  ///
  /// Insert the object as well as any object it references.
  ///
  /// @param pb the packbuilder
  /// @param id the id of the root object to insert
  /// @param name optional name for the object
  /// @return 0 or an error code
  int git_packbuilder_insert_recur(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_packbuilder_insert_recur(
      pb,
      id,
      name,
    );
  }

  late final _git_packbuilder_insert_recurPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_packbuilder_insert_recur');
  late final _git_packbuilder_insert_recur =
      _git_packbuilder_insert_recurPtr.asFunction<
          int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>();

  /// Write the contents of the packfile to an in-memory buffer
  ///
  /// The contents of the buffer will become a valid packfile, even though there
  /// will be no attached index
  ///
  /// @param buf Buffer where to write the packfile
  /// @param pb The packbuilder
  /// @return 0 or an error code
  int git_packbuilder_write_buf(
    ffi.Pointer<git_buf> buf,
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_write_buf(
      buf,
      pb,
    );
  }

  late final _git_packbuilder_write_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_packbuilder>)>>('git_packbuilder_write_buf');
  late final _git_packbuilder_write_buf =
      _git_packbuilder_write_bufPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_packbuilder>)>();

  /// Write the new pack and corresponding index file to path.
  ///
  /// @param pb The packbuilder
  /// @param path Path to the directory where the packfile and index should be stored, or NULL for default location
  /// @param mode permissions to use creating a packfile or 0 for defaults
  /// @param progress_cb function to call with progress information from the indexer (optional)
  /// @param progress_cb_payload payload for the progress callback (optional)
  ///
  /// @return 0 or an error code
  int git_packbuilder_write(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<ffi.Char> path,
    int mode,
    git_indexer_progress_cb progress_cb,
    ffi.Pointer<ffi.Void> progress_cb_payload,
  ) {
    return _git_packbuilder_write(
      pb,
      path,
      mode,
      progress_cb,
      progress_cb_payload,
    );
  }

  late final _git_packbuilder_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_packbuilder>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              git_indexer_progress_cb,
              ffi.Pointer<ffi.Void>)>>('git_packbuilder_write');
  late final _git_packbuilder_write = _git_packbuilder_writePtr.asFunction<
      int Function(ffi.Pointer<git_packbuilder>, ffi.Pointer<ffi.Char>, int,
          git_indexer_progress_cb, ffi.Pointer<ffi.Void>)>();

  /// Get the packfile's hash
  ///
  /// A packfile's name is derived from the sorted hashing of all object
  /// names. This is only correct after the packfile has been written.
  ///
  /// @deprecated use git_packbuilder_name
  /// @param pb The packbuilder object
  /// @return 0 or an error code
  ffi.Pointer<git_oid> git_packbuilder_hash(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_hash(
      pb,
    );
  }

  late final _git_packbuilder_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_packbuilder>)>>('git_packbuilder_hash');
  late final _git_packbuilder_hash = _git_packbuilder_hashPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_packbuilder>)>();

  /// Get the unique name for the resulting packfile.
  ///
  /// The packfile's name is derived from the packfile's content.
  /// This is only correct after the packfile has been written.
  ///
  /// @param pb the packbuilder instance
  /// @return a NUL terminated string for the packfile name
  ffi.Pointer<ffi.Char> git_packbuilder_name(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_name(
      pb,
    );
  }

  late final _git_packbuilder_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_packbuilder>)>>('git_packbuilder_name');
  late final _git_packbuilder_name = _git_packbuilder_namePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_packbuilder>)>();

  /// Create the new pack and pass each object to the callback
  ///
  /// @param pb the packbuilder
  /// @param cb the callback to call with each packed object's buffer
  /// @param payload the callback's data
  /// @return 0 or an error code
  int git_packbuilder_foreach(
    ffi.Pointer<git_packbuilder> pb,
    git_packbuilder_foreach_cb cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_packbuilder_foreach(
      pb,
      cb,
      payload,
    );
  }

  late final _git_packbuilder_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_packbuilder>,
              git_packbuilder_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_packbuilder_foreach');
  late final _git_packbuilder_foreach = _git_packbuilder_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_packbuilder>, git_packbuilder_foreach_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Get the total number of objects the packbuilder will write out
  ///
  /// @param pb the packbuilder
  /// @return the number of objects in the packfile
  int git_packbuilder_object_count(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_object_count(
      pb,
    );
  }

  late final _git_packbuilder_object_countPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_packbuilder>)>>(
      'git_packbuilder_object_count');
  late final _git_packbuilder_object_count = _git_packbuilder_object_countPtr
      .asFunction<int Function(ffi.Pointer<git_packbuilder>)>();

  /// Get the number of objects the packbuilder has already written out
  ///
  /// @param pb the packbuilder
  /// @return the number of objects which have already been written
  int git_packbuilder_written(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_written(
      pb,
    );
  }

  late final _git_packbuilder_writtenPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_packbuilder>)>>(
      'git_packbuilder_written');
  late final _git_packbuilder_written = _git_packbuilder_writtenPtr
      .asFunction<int Function(ffi.Pointer<git_packbuilder>)>();

  /// Set the callbacks for a packbuilder
  ///
  /// @param pb The packbuilder object
  /// @param progress_cb Function to call with progress information during
  /// pack building. Be aware that this is called inline with pack building
  /// operations, so performance may be affected.
  /// @param progress_cb_payload Payload for progress callback.
  /// @return 0 or an error code
  int git_packbuilder_set_callbacks(
    ffi.Pointer<git_packbuilder> pb,
    git_packbuilder_progress progress_cb,
    ffi.Pointer<ffi.Void> progress_cb_payload,
  ) {
    return _git_packbuilder_set_callbacks(
      pb,
      progress_cb,
      progress_cb_payload,
    );
  }

  late final _git_packbuilder_set_callbacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_packbuilder>,
              git_packbuilder_progress,
              ffi.Pointer<ffi.Void>)>>('git_packbuilder_set_callbacks');
  late final _git_packbuilder_set_callbacks =
      _git_packbuilder_set_callbacksPtr.asFunction<
          int Function(ffi.Pointer<git_packbuilder>, git_packbuilder_progress,
              ffi.Pointer<ffi.Void>)>();

  /// Free the packbuilder and all associated data
  ///
  /// @param pb The packbuilder
  void git_packbuilder_free(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_free(
      pb,
    );
  }

  late final _git_packbuilder_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_packbuilder>)>>(
      'git_packbuilder_free');
  late final _git_packbuilder_free = _git_packbuilder_freePtr
      .asFunction<void Function(ffi.Pointer<git_packbuilder>)>();

  /// Initialize git_proxy_options structure
  ///
  /// Initializes a `git_proxy_options` with default values. Equivalent to
  /// creating an instance with `GIT_PROXY_OPTIONS_INIT`.
  ///
  /// @param opts The `git_proxy_options` struct to initialize.
  /// @param version The struct version; pass `GIT_PROXY_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_proxy_options_init(
    ffi.Pointer<git_proxy_options> opts,
    int version,
  ) {
    return _git_proxy_options_init(
      opts,
      version,
    );
  }

  late final _git_proxy_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_proxy_options>,
              ffi.UnsignedInt)>>('git_proxy_options_init');
  late final _git_proxy_options_init = _git_proxy_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_proxy_options>, int)>();

  /// Add a remote with the default fetch refspec to the repository's configuration.
  ///
  /// @param out the resulting remote
  /// @param repo the repository in which to create the remote
  /// @param name the remote's name
  /// @param url the remote's url
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_create(
      out,
      repo,
      name,
      url,
    );
  }

  late final _git_remote_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_create');
  late final _git_remote_create = _git_remote_createPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_remote>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Initialize git_remote_create_options structure
  ///
  /// Initializes a `git_remote_create_options` with default values. Equivalent to
  /// creating an instance with `GIT_REMOTE_CREATE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_remote_create_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REMOTE_CREATE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_remote_create_options_init(
    ffi.Pointer<git_remote_create_options> opts,
    int version,
  ) {
    return _git_remote_create_options_init(
      opts,
      version,
    );
  }

  late final _git_remote_create_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote_create_options>,
              ffi.UnsignedInt)>>('git_remote_create_options_init');
  late final _git_remote_create_options_init =
      _git_remote_create_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_remote_create_options>, int)>();

  /// Create a remote, with options.
  ///
  /// This function allows more fine-grained control over the remote creation.
  ///
  /// Passing NULL as the opts argument will result in a detached remote.
  ///
  /// @param out the resulting remote
  /// @param url the remote's url
  /// @param opts the remote creation options
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create_with_opts(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<git_remote_create_options> opts,
  ) {
    return _git_remote_create_with_opts(
      out,
      url,
      opts,
    );
  }

  late final _git_remote_create_with_optsPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_remote>>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_remote_create_options>)>>(
      'git_remote_create_with_opts');
  late final _git_remote_create_with_opts =
      _git_remote_create_with_optsPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<git_remote_create_options>)>();

  /// Add a remote with the provided fetch refspec (or default if NULL) to the repository's
  /// configuration.
  ///
  /// @param out the resulting remote
  /// @param repo the repository in which to create the remote
  /// @param name the remote's name
  /// @param url the remote's url
  /// @param fetch the remote fetch value
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create_with_fetchspec(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> fetch,
  ) {
    return _git_remote_create_with_fetchspec(
      out,
      repo,
      name,
      url,
      fetch,
    );
  }

  late final _git_remote_create_with_fetchspecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_create_with_fetchspec');
  late final _git_remote_create_with_fetchspec =
      _git_remote_create_with_fetchspecPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create an anonymous remote
  ///
  /// Create a remote with the given url in-memory. You can use this when
  /// you have a URL instead of a remote's name.
  ///
  /// @param out pointer to the new remote objects
  /// @param repo the associated repository
  /// @param url the remote repository's URL
  /// @return 0 or an error code
  int git_remote_create_anonymous(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_create_anonymous(
      out,
      repo,
      url,
    );
  }

  late final _git_remote_create_anonymousPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_remote_create_anonymous');
  late final _git_remote_create_anonymous =
      _git_remote_create_anonymousPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Create a remote without a connected local repo
  ///
  /// Create a remote with the given url in-memory. You can use this when
  /// you have a URL instead of a remote's name.
  ///
  /// Contrasted with git_remote_create_anonymous, a detached remote
  /// will not consider any repo configuration values (such as insteadof url
  /// substitutions).
  ///
  /// @param out pointer to the new remote objects
  /// @param url the remote repository's URL
  /// @return 0 or an error code
  int git_remote_create_detached(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_create_detached(
      out,
      url,
    );
  }

  late final _git_remote_create_detachedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<ffi.Char>)>>('git_remote_create_detached');
  late final _git_remote_create_detached =
      _git_remote_create_detachedPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>, ffi.Pointer<ffi.Char>)>();

  /// Get the information for a particular remote
  ///
  /// The name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out pointer to the new remote object
  /// @param repo the associated repository
  /// @param name the remote's name
  /// @return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code
  int git_remote_lookup(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_remote_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_remote_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_remote_lookup');
  late final _git_remote_lookup = _git_remote_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Create a copy of an existing remote.  All internal strings are also
  /// duplicated. Callbacks are not duplicated.
  ///
  /// Call `git_remote_free` to free the data.
  ///
  /// @param dest pointer where to store the copy
  /// @param source object to copy
  /// @return 0 or an error code
  int git_remote_dup(
    ffi.Pointer<ffi.Pointer<git_remote>> dest,
    ffi.Pointer<git_remote> source,
  ) {
    return _git_remote_dup(
      dest,
      source,
    );
  }

  late final _git_remote_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_remote>>,
              ffi.Pointer<git_remote>)>>('git_remote_dup');
  late final _git_remote_dup = _git_remote_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_remote>>, ffi.Pointer<git_remote>)>();

  /// Get the remote's repository
  ///
  /// @param remote the remote
  /// @return a pointer to the repository
  ffi.Pointer<git_repository> git_remote_owner(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_owner(
      remote,
    );
  }

  late final _git_remote_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_remote>)>>('git_remote_owner');
  late final _git_remote_owner = _git_remote_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_remote>)>();

  /// Get the remote's name
  ///
  /// @param remote the remote
  /// @return a pointer to the name or NULL for in-memory remotes
  ffi.Pointer<ffi.Char> git_remote_name(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_name(
      remote,
    );
  }

  late final _git_remote_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_remote>)>>('git_remote_name');
  late final _git_remote_name = _git_remote_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote>)>();

  /// Get the remote's url
  ///
  /// If url.*.insteadOf has been configured for this URL, it will
  /// return the modified URL.  If `git_remote_set_instance_pushurl`
  /// has been called for this remote, then that URL will be returned.
  ///
  /// @param remote the remote
  /// @return a pointer to the url
  ffi.Pointer<ffi.Char> git_remote_url(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_url(
      remote,
    );
  }

  late final _git_remote_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_remote>)>>('git_remote_url');
  late final _git_remote_url = _git_remote_urlPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote>)>();

  /// Get the remote's url for pushing.
  ///
  /// If url.*.pushInsteadOf has been configured for this URL, it
  /// will return the modified URL.  If `git_remote_set_instance_pushurl`
  /// has been called for this remote, then that URL will be returned.
  ///
  /// @param remote the remote
  /// @return a pointer to the url or NULL if no special url for pushing is set
  ffi.Pointer<ffi.Char> git_remote_pushurl(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_pushurl(
      remote,
    );
  }

  late final _git_remote_pushurlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_remote>)>>('git_remote_pushurl');
  late final _git_remote_pushurl = _git_remote_pushurlPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_remote>)>();

  /// Set the remote's url in the configuration
  ///
  /// Remote objects already in memory will not be affected. This assumes
  /// the common case of a single-url remote and will otherwise return an error.
  ///
  /// @param repo the repository in which to perform the change
  /// @param remote the remote's name
  /// @param url the url to set
  /// @return 0 or an error value
  int git_remote_set_url(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_set_url(
      repo,
      remote,
      url,
    );
  }

  late final _git_remote_set_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_set_url');
  late final _git_remote_set_url = _git_remote_set_urlPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Set the remote's url for pushing in the configuration.
  ///
  /// Remote objects already in memory will not be affected. This assumes
  /// the common case of a single-url remote and will otherwise return an error.
  ///
  ///
  /// @param repo the repository in which to perform the change
  /// @param remote the remote's name
  /// @param url the url to set
  /// @return 0, or an error code
  int git_remote_set_pushurl(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_set_pushurl(
      repo,
      remote,
      url,
    );
  }

  late final _git_remote_set_pushurlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_set_pushurl');
  late final _git_remote_set_pushurl = _git_remote_set_pushurlPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Set the url for this particular url instance.  The URL in the
  /// configuration will be ignored, and will not be changed.
  ///
  /// @param remote the remote's name
  /// @param url the url to set
  /// @return 0 or an error value
  int git_remote_set_instance_url(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_set_instance_url(
      remote,
      url,
    );
  }

  late final _git_remote_set_instance_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>,
              ffi.Pointer<ffi.Char>)>>('git_remote_set_instance_url');
  late final _git_remote_set_instance_url =
      _git_remote_set_instance_urlPtr.asFunction<
          int Function(ffi.Pointer<git_remote>, ffi.Pointer<ffi.Char>)>();

  /// Set the push url for this particular url instance.  The URL in the
  /// configuration will be ignored, and will not be changed.
  ///
  /// @param remote the remote's name
  /// @param url the url to set
  /// @return 0 or an error value
  int git_remote_set_instance_pushurl(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_remote_set_instance_pushurl(
      remote,
      url,
    );
  }

  late final _git_remote_set_instance_pushurlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>,
              ffi.Pointer<ffi.Char>)>>('git_remote_set_instance_pushurl');
  late final _git_remote_set_instance_pushurl =
      _git_remote_set_instance_pushurlPtr.asFunction<
          int Function(ffi.Pointer<git_remote>, ffi.Pointer<ffi.Char>)>();

  /// Add a fetch refspec to the remote's configuration
  ///
  /// Add the given refspec to the fetch list in the configuration. No
  /// loaded remote instances will be affected.
  ///
  /// @param repo the repository in which to change the configuration
  /// @param remote the name of the remote to change
  /// @param refspec the new fetch refspec
  /// @return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value
  int git_remote_add_fetch(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> refspec,
  ) {
    return _git_remote_add_fetch(
      repo,
      remote,
      refspec,
    );
  }

  late final _git_remote_add_fetchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_add_fetch');
  late final _git_remote_add_fetch = _git_remote_add_fetchPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the remote's list of fetch refspecs
  ///
  /// The memory is owned by the user and should be freed with
  /// `git_strarray_free`.
  ///
  /// @param array pointer to the array in which to store the strings
  /// @param remote the remote to query
  /// @return 0 or an error code.
  int git_remote_get_fetch_refspecs(
    ffi.Pointer<git_strarray> array,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_get_fetch_refspecs(
      array,
      remote,
    );
  }

  late final _git_remote_get_fetch_refspecsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_remote>)>>('git_remote_get_fetch_refspecs');
  late final _git_remote_get_fetch_refspecs =
      _git_remote_get_fetch_refspecsPtr.asFunction<
          int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_remote>)>();

  /// Add a push refspec to the remote's configuration
  ///
  /// Add the given refspec to the push list in the configuration. No
  /// loaded remote instances will be affected.
  ///
  /// @param repo the repository in which to change the configuration
  /// @param remote the name of the remote to change
  /// @param refspec the new push refspec
  /// @return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value
  int git_remote_add_push(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    ffi.Pointer<ffi.Char> refspec,
  ) {
    return _git_remote_add_push(
      repo,
      remote,
      refspec,
    );
  }

  late final _git_remote_add_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_add_push');
  late final _git_remote_add_push = _git_remote_add_pushPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the remote's list of push refspecs
  ///
  /// The memory is owned by the user and should be freed with
  /// `git_strarray_free`.
  ///
  /// @param array pointer to the array in which to store the strings
  /// @param remote the remote to query
  /// @return 0 or an error code.
  int git_remote_get_push_refspecs(
    ffi.Pointer<git_strarray> array,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_get_push_refspecs(
      array,
      remote,
    );
  }

  late final _git_remote_get_push_refspecsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_remote>)>>('git_remote_get_push_refspecs');
  late final _git_remote_get_push_refspecs =
      _git_remote_get_push_refspecsPtr.asFunction<
          int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_remote>)>();

  /// Get the number of refspecs for a remote
  ///
  /// @param remote the remote
  /// @return the amount of refspecs configured in this remote
  int git_remote_refspec_count(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_refspec_count(
      remote,
    );
  }

  late final _git_remote_refspec_countPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_remote>)>>(
          'git_remote_refspec_count');
  late final _git_remote_refspec_count = _git_remote_refspec_countPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Get a refspec from the remote
  ///
  /// @param remote the remote to query
  /// @param n the refspec to get
  /// @return the nth refspec
  ffi.Pointer<git_refspec> git_remote_get_refspec(
    ffi.Pointer<git_remote> remote,
    int n,
  ) {
    return _git_remote_get_refspec(
      remote,
      n,
    );
  }

  late final _git_remote_get_refspecPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_refspec> Function(
              ffi.Pointer<git_remote>, ffi.Size)>>('git_remote_get_refspec');
  late final _git_remote_get_refspec = _git_remote_get_refspecPtr.asFunction<
      ffi.Pointer<git_refspec> Function(ffi.Pointer<git_remote>, int)>();

  /// Get the remote repository's reference advertisement list
  ///
  /// Get the list of references with which the server responds to a new
  /// connection.
  ///
  /// The remote (or more exactly its transport) must have connected to
  /// the remote repository. This list is available as soon as the
  /// connection to the remote is initiated and it remains available
  /// after disconnecting.
  ///
  /// The memory belongs to the remote. The pointer will be valid as long
  /// as a new connection is not initiated, but it is recommended that
  /// you make a copy in order to make use of the data.
  ///
  /// @param out pointer to the array
  /// @param size the number of remote heads
  /// @param remote the remote
  /// @return 0 on success, or an error code
  int git_remote_ls(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>> out,
    ffi.Pointer<ffi.Size> size,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_ls(
      out,
      size,
      remote,
    );
  }

  late final _git_remote_lsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<git_remote>)>>('git_remote_ls');
  late final _git_remote_ls = _git_remote_lsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>>,
          ffi.Pointer<ffi.Size>, ffi.Pointer<git_remote>)>();

  /// Check whether the remote is connected
  ///
  /// Check whether the remote's underlying transport is connected to the
  /// remote host.
  ///
  /// @param remote the remote
  /// @return 1 if it's connected, 0 otherwise.
  int git_remote_connected(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_connected(
      remote,
    );
  }

  late final _git_remote_connectedPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_remote>)>>(
          'git_remote_connected');
  late final _git_remote_connected = _git_remote_connectedPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Cancel the operation
  ///
  /// At certain points in its operation, the network code checks whether
  /// the operation has been cancelled and if so stops the operation.
  ///
  /// @param remote the remote
  /// @return 0 on success, or an error code
  int git_remote_stop(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_stop(
      remote,
    );
  }

  late final _git_remote_stopPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_remote>)>>(
          'git_remote_stop');
  late final _git_remote_stop =
      _git_remote_stopPtr.asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Disconnect from the remote
  ///
  /// Close the connection to the remote.
  ///
  /// @param remote the remote to disconnect from
  /// @return 0 on success, or an error code
  int git_remote_disconnect(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_disconnect(
      remote,
    );
  }

  late final _git_remote_disconnectPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_remote>)>>(
          'git_remote_disconnect');
  late final _git_remote_disconnect = _git_remote_disconnectPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Free the memory associated with a remote
  ///
  /// This also disconnects from the remote, if the connection
  /// has not been closed yet (using git_remote_disconnect).
  ///
  /// @param remote the remote to free
  void git_remote_free(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_free(
      remote,
    );
  }

  late final _git_remote_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_remote>)>>(
          'git_remote_free');
  late final _git_remote_free =
      _git_remote_freePtr.asFunction<void Function(ffi.Pointer<git_remote>)>();

  /// Get a list of the configured remotes for a repo
  ///
  /// The string array must be freed by the user.
  ///
  /// @param out a string array which receives the names of the remotes
  /// @param repo the repository to query
  /// @return 0 or an error code
  int git_remote_list(
    ffi.Pointer<git_strarray> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_remote_list(
      out,
      repo,
    );
  }

  late final _git_remote_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>)>>('git_remote_list');
  late final _git_remote_list = _git_remote_listPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>)>();

  /// Initializes a `git_remote_callbacks` with default values. Equivalent to
  /// creating an instance with GIT_REMOTE_CALLBACKS_INIT.
  ///
  /// @param opts the `git_remote_callbacks` struct to initialize
  /// @param version Version of struct; pass `GIT_REMOTE_CALLBACKS_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_remote_init_callbacks(
    ffi.Pointer<git_remote_callbacks> opts,
    int version,
  ) {
    return _git_remote_init_callbacks(
      opts,
      version,
    );
  }

  late final _git_remote_init_callbacksPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote_callbacks>,
              ffi.UnsignedInt)>>('git_remote_init_callbacks');
  late final _git_remote_init_callbacks = _git_remote_init_callbacksPtr
      .asFunction<int Function(ffi.Pointer<git_remote_callbacks>, int)>();

  /// Initialize git_fetch_options structure
  ///
  /// Initializes a `git_fetch_options` with default values. Equivalent to
  /// creating an instance with `GIT_FETCH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_fetch_options` struct to initialize.
  /// @param version The struct version; pass `GIT_FETCH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_fetch_options_init(
    ffi.Pointer<git_fetch_options> opts,
    int version,
  ) {
    return _git_fetch_options_init(
      opts,
      version,
    );
  }

  late final _git_fetch_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_fetch_options>,
              ffi.UnsignedInt)>>('git_fetch_options_init');
  late final _git_fetch_options_init = _git_fetch_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_fetch_options>, int)>();

  /// Initialize git_push_options structure
  ///
  /// Initializes a `git_push_options` with default values. Equivalent to
  /// creating an instance with `GIT_PUSH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_push_options` struct to initialize.
  /// @param version The struct version; pass `GIT_PUSH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_push_options_init(
    ffi.Pointer<git_push_options> opts,
    int version,
  ) {
    return _git_push_options_init(
      opts,
      version,
    );
  }

  late final _git_push_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_push_options>,
              ffi.UnsignedInt)>>('git_push_options_init');
  late final _git_push_options_init = _git_push_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_push_options>, int)>();

  /// Initialize git_remote_connect_options structure.
  ///
  /// Initializes a `git_remote_connect_options` with default values.
  /// Equivalent to creating an instance with
  /// `GIT_REMOTE_CONNECT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_remote_connect_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REMOTE_CONNECT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_remote_connect_options_init(
    ffi.Pointer<git_remote_connect_options> opts,
    int version,
  ) {
    return _git_remote_connect_options_init(
      opts,
      version,
    );
  }

  late final _git_remote_connect_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote_connect_options>,
              ffi.UnsignedInt)>>('git_remote_connect_options_init');
  late final _git_remote_connect_options_init =
      _git_remote_connect_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_remote_connect_options>, int)>();

  /// Open a connection to a remote.
  ///
  /// The transport is selected based on the URL; the direction argument
  /// is due to a limitation of the git protocol which starts up a
  /// specific binary which can only do the one or the other.
  ///
  /// @param remote the remote to connect to
  /// @param direction GIT_DIRECTION_FETCH if you want to fetch or
  /// GIT_DIRECTION_PUSH if you want to push
  /// @param callbacks the callbacks to use for this connection
  /// @param proxy_opts proxy settings
  /// @param custom_headers extra HTTP headers to use in this connection
  /// @return 0 or an error code
  int git_remote_connect(
    ffi.Pointer<git_remote> remote,
    int direction,
    ffi.Pointer<git_remote_callbacks> callbacks,
    ffi.Pointer<git_proxy_options> proxy_opts,
    ffi.Pointer<git_strarray> custom_headers,
  ) {
    return _git_remote_connect(
      remote,
      direction,
      callbacks,
      proxy_opts,
      custom_headers,
    );
  }

  late final _git_remote_connectPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_remote>,
              ffi.Int32,
              ffi.Pointer<git_remote_callbacks>,
              ffi.Pointer<git_proxy_options>,
              ffi.Pointer<git_strarray>)>>('git_remote_connect');
  late final _git_remote_connect = _git_remote_connectPtr.asFunction<
      int Function(
          ffi.Pointer<git_remote>,
          int,
          ffi.Pointer<git_remote_callbacks>,
          ffi.Pointer<git_proxy_options>,
          ffi.Pointer<git_strarray>)>();

  /// Open a connection to a remote with extended options.
  ///
  /// The transport is selected based on the URL; the direction argument
  /// is due to a limitation of the git protocol which starts up a
  /// specific binary which can only do the one or the other.
  ///
  /// The given options structure will form the defaults for connection
  /// options and callback setup.  Callers may override these defaults
  /// by specifying `git_fetch_options` or `git_push_options` in
  /// subsequent calls.
  ///
  /// @param remote the remote to connect to
  /// @param direction GIT_DIRECTION_FETCH if you want to fetch or
  /// GIT_DIRECTION_PUSH if you want to push
  /// @param opts the remote connection options
  /// @return 0 or an error code
  int git_remote_connect_ext(
    ffi.Pointer<git_remote> remote,
    int direction,
    ffi.Pointer<git_remote_connect_options> opts,
  ) {
    return _git_remote_connect_ext(
      remote,
      direction,
      opts,
    );
  }

  late final _git_remote_connect_extPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_remote>, ffi.Int32,
                  ffi.Pointer<git_remote_connect_options>)>>(
      'git_remote_connect_ext');
  late final _git_remote_connect_ext = _git_remote_connect_extPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, int,
          ffi.Pointer<git_remote_connect_options>)>();

  /// Download and index the packfile.
  ///
  /// Connect to the remote if it hasn't been done yet, negotiate with
  /// the remote git which objects are missing, download and index the
  /// packfile.
  ///
  /// The .idx file will be created and both it and the packfile with be
  /// renamed to their final name.
  ///
  /// If options are specified and this remote is already connected then
  /// the existing remote connection options will be discarded and the
  /// remote will now use the new options.
  ///
  /// @param remote the remote
  /// @param refspecs the refspecs to use for this negotiation and
  /// download. Use NULL or an empty array to use the base refspecs
  /// @param opts the options to use for this fetch or NULL
  /// @return 0 or an error code
  int git_remote_download(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_fetch_options> opts,
  ) {
    return _git_remote_download(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_downloadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
              ffi.Pointer<git_fetch_options>)>>('git_remote_download');
  late final _git_remote_download = _git_remote_downloadPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_fetch_options>)>();

  /// Create a packfile and send it to the server
  ///
  /// Connect to the remote if it hasn't been done yet, negotiate with
  /// the remote git which objects are missing, create a packfile with
  /// the missing objects and send it.
  ///
  /// If options are specified and this remote is already connected then
  /// the existing remote connection options will be discarded and the
  /// remote will now use the new options.
  ///
  /// @param remote the remote
  /// @param refspecs the refspecs to use for this negotiation and
  /// upload. Use NULL or an empty array to use the base refspecs
  /// @param opts the options to use for this push
  /// @return 0 or an error code
  int git_remote_upload(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_push_options> opts,
  ) {
    return _git_remote_upload(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_uploadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
              ffi.Pointer<git_push_options>)>>('git_remote_upload');
  late final _git_remote_upload = _git_remote_uploadPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_push_options>)>();

  /// Update the tips to the new state.
  ///
  /// If callbacks are not specified then the callbacks specified to
  /// `git_remote_connect` will be used (if it was called).
  ///
  /// @param remote the remote to update
  /// @param reflog_message The message to insert into the reflogs. If
  /// NULL and fetching, the default is "fetch <name>", where <name> is
  /// the name of the remote (or its url, for in-memory remotes). This
  /// parameter is ignored when pushing.
  /// @param callbacks  pointer to the callback structure to use or NULL
  /// @param update_fetchhead whether to write to FETCH_HEAD. Pass 1 to behave like git.
  /// @param download_tags what the behaviour for downloading tags is for this fetch. This is
  /// ignored for push. This must be the same value passed to `git_remote_download()`.
  /// @return 0 or an error code
  int git_remote_update_tips(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_remote_callbacks> callbacks,
    int update_fetchhead,
    int download_tags,
    ffi.Pointer<ffi.Char> reflog_message,
  ) {
    return _git_remote_update_tips(
      remote,
      callbacks,
      update_fetchhead,
      download_tags,
      reflog_message,
    );
  }

  late final _git_remote_update_tipsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_remote>,
              ffi.Pointer<git_remote_callbacks>,
              ffi.Int,
              ffi.Int32,
              ffi.Pointer<ffi.Char>)>>('git_remote_update_tips');
  late final _git_remote_update_tips = _git_remote_update_tipsPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_remote_callbacks>,
          int, int, ffi.Pointer<ffi.Char>)>();

  /// Download new data and update tips.
  ///
  /// Convenience function to connect to a remote, download the data,
  /// disconnect and update the remote-tracking branches.
  ///
  /// If options are specified and this remote is already connected then
  /// the existing remote connection options will be discarded and the
  /// remote will now use the new options.
  ///
  /// @param remote the remote to fetch from
  /// @param refspecs the refspecs to use for this fetch. Pass NULL or an
  /// empty array to use the base refspecs.
  /// @param opts options to use for this fetch or NULL
  /// @param reflog_message The message to insert into the reflogs. If NULL, the
  /// default is "fetch"
  /// @return 0 or an error code
  int git_remote_fetch(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_fetch_options> opts,
    ffi.Pointer<ffi.Char> reflog_message,
  ) {
    return _git_remote_fetch(
      remote,
      refspecs,
      opts,
      reflog_message,
    );
  }

  late final _git_remote_fetchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_remote>,
              ffi.Pointer<git_strarray>,
              ffi.Pointer<git_fetch_options>,
              ffi.Pointer<ffi.Char>)>>('git_remote_fetch');
  late final _git_remote_fetch = _git_remote_fetchPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_fetch_options>, ffi.Pointer<ffi.Char>)>();

  /// Prune tracking refs that are no longer present on remote.
  ///
  /// If callbacks are not specified then the callbacks specified to
  /// `git_remote_connect` will be used (if it was called).
  ///
  /// @param remote the remote to prune
  /// @param callbacks callbacks to use for this prune
  /// @return 0 or an error code
  int git_remote_prune(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_remote_callbacks> callbacks,
  ) {
    return _git_remote_prune(
      remote,
      callbacks,
    );
  }

  late final _git_remote_prunePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>,
              ffi.Pointer<git_remote_callbacks>)>>('git_remote_prune');
  late final _git_remote_prune = _git_remote_prunePtr.asFunction<
      int Function(
          ffi.Pointer<git_remote>, ffi.Pointer<git_remote_callbacks>)>();

  /// Perform a push.
  ///
  /// If options are specified and this remote is already connected then
  /// the existing remote connection options will be discarded and the
  /// remote will now use the new options.
  ///
  /// @param remote the remote to push to
  /// @param refspecs the refspecs to use for pushing. If NULL or an empty
  /// array, the configured refspecs will be used
  /// @param opts options to use for this push
  /// @return 0 or an error code.
  int git_remote_push(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_push_options> opts,
  ) {
    return _git_remote_push(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
              ffi.Pointer<git_push_options>)>>('git_remote_push');
  late final _git_remote_push = _git_remote_pushPtr.asFunction<
      int Function(ffi.Pointer<git_remote>, ffi.Pointer<git_strarray>,
          ffi.Pointer<git_push_options>)>();

  /// Get the statistics structure that is filled in by the fetch operation.
  ffi.Pointer<git_indexer_progress> git_remote_stats(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_stats(
      remote,
    );
  }

  late final _git_remote_statsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_indexer_progress> Function(
              ffi.Pointer<git_remote>)>>('git_remote_stats');
  late final _git_remote_stats = _git_remote_statsPtr.asFunction<
      ffi.Pointer<git_indexer_progress> Function(ffi.Pointer<git_remote>)>();

  /// Retrieve the tag auto-follow setting
  ///
  /// @param remote the remote to query
  /// @return the auto-follow setting
  int git_remote_autotag(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_autotag(
      remote,
    );
  }

  late final _git_remote_autotagPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_remote>)>>(
          'git_remote_autotag');
  late final _git_remote_autotag = _git_remote_autotagPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Set the remote's tag following setting.
  ///
  /// The change will be made in the configuration. No loaded remotes
  /// will be affected.
  ///
  /// @param repo the repository in which to make the change
  /// @param remote the name of the remote
  /// @param value the new value to take.
  /// @return 0, or an error code.
  int git_remote_set_autotag(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> remote,
    int value,
  ) {
    return _git_remote_set_autotag(
      repo,
      remote,
      value,
    );
  }

  late final _git_remote_set_autotagPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_remote_set_autotag');
  late final _git_remote_set_autotag = _git_remote_set_autotagPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Retrieve the ref-prune setting
  ///
  /// @param remote the remote to query
  /// @return the ref-prune setting
  int git_remote_prune_refs(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_prune_refs(
      remote,
    );
  }

  late final _git_remote_prune_refsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_remote>)>>(
          'git_remote_prune_refs');
  late final _git_remote_prune_refs = _git_remote_prune_refsPtr
      .asFunction<int Function(ffi.Pointer<git_remote>)>();

  /// Give the remote a new name
  ///
  /// All remote-tracking branches and configuration settings
  /// for the remote are updated.
  ///
  /// The new name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// No loaded instances of a the remote with the old name will change
  /// their name or their list of refspecs.
  ///
  /// @param problems non-default refspecs cannot be renamed and will be
  /// stored here for further processing by the caller. Always free this
  /// strarray on successful return.
  /// @param repo the repository in which to rename
  /// @param name the current name of the remote
  /// @param new_name the new name the remote should bear
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_rename(
    ffi.Pointer<git_strarray> problems,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> new_name,
  ) {
    return _git_remote_rename(
      problems,
      repo,
      name,
      new_name,
    );
  }

  late final _git_remote_renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_remote_rename');
  late final _git_remote_rename = _git_remote_renamePtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Ensure the remote name is well-formed.
  ///
  /// @param valid output pointer to set with validity of given remote name
  /// @param remote_name name to be checked.
  /// @return 0 on success or an error code
  int git_remote_name_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> remote_name,
  ) {
    return _git_remote_name_is_valid(
      valid,
      remote_name,
    );
  }

  late final _git_remote_name_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_remote_name_is_valid');
  late final _git_remote_name_is_valid = _git_remote_name_is_validPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Delete an existing persisted remote.
  ///
  /// All remote-tracking branches and configuration settings
  /// for the remote will be removed.
  ///
  /// @param repo the repository in which to act
  /// @param name the name of the remote to delete
  /// @return 0 on success, or an error code.
  int git_remote_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_remote_delete(
      repo,
      name,
    );
  }

  late final _git_remote_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_remote_delete');
  late final _git_remote_delete = _git_remote_deletePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Retrieve the name of the remote's default branch
  ///
  /// The default branch of a repository is the branch which HEAD points
  /// to. If the remote does not support reporting this information
  /// directly, it performs the guess as git does; that is, if there are
  /// multiple branches which point to the same commit, the first one is
  /// chosen. If the master branch is a candidate, it wins.
  ///
  /// This function must only be called after connecting.
  ///
  /// @param out the buffer in which to store the reference name
  /// @param remote the remote
  /// @return 0, GIT_ENOTFOUND if the remote does not have any references
  /// or none of them point to HEAD's commit, or an error message.
  int git_remote_default_branch(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_default_branch(
      out,
      remote,
    );
  }

  late final _git_remote_default_branchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_remote>)>>('git_remote_default_branch');
  late final _git_remote_default_branch =
      _git_remote_default_branchPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_remote>)>();

  /// Initialize git_clone_options structure
  ///
  /// Initializes a `git_clone_options` with default values. Equivalent to creating
  /// an instance with GIT_CLONE_OPTIONS_INIT.
  ///
  /// @param opts The `git_clone_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CLONE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_clone_options_init(
    ffi.Pointer<git_clone_options> opts,
    int version,
  ) {
    return _git_clone_options_init(
      opts,
      version,
    );
  }

  late final _git_clone_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_clone_options>,
              ffi.UnsignedInt)>>('git_clone_options_init');
  late final _git_clone_options_init = _git_clone_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_clone_options>, int)>();

  /// Clone a remote repository.
  ///
  /// By default this creates its repository and initial remote to match
  /// git's defaults. You can use the options in the callback to
  /// customize how these are created.
  ///
  /// @param out pointer that will receive the resulting repository object
  /// @param url the remote repository to clone
  /// @param local_path local directory to clone to
  /// @param options configuration options for the clone.  If NULL, the
  /// function works as though GIT_OPTIONS_INIT were passed.
  /// @return 0 on success, any non-zero return value from a callback
  /// function, or a negative value to indicate an error (use
  /// `git_error_last` for a detailed error message)
  int git_clone(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> local_path,
    ffi.Pointer<git_clone_options> options,
  ) {
    return _git_clone(
      out,
      url,
      local_path,
      options,
    );
  }

  late final _git_clonePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_clone_options>)>>('git_clone');
  late final _git_clone = _git_clonePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_clone_options>)>();

  /// Lookup a commit object from a repository.
  ///
  /// The returned object should be released with `git_commit_free` when no
  /// longer needed.
  ///
  /// @param commit pointer to the looked up commit
  /// @param repo the repo to use when locating the commit.
  /// @param id identity of the commit to locate. If the object is
  /// an annotated tag it will be peeled back to the commit.
  /// @return 0 or an error code
  int git_commit_lookup(
    ffi.Pointer<ffi.Pointer<git_commit>> commit,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_commit_lookup(
      commit,
      repo,
      id,
    );
  }

  late final _git_commit_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_commit_lookup');
  late final _git_commit_lookup = _git_commit_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Lookup a commit object from a repository, given a prefix of its
  /// identifier (short id).
  ///
  /// The returned object should be released with `git_commit_free` when no
  /// longer needed.
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param commit pointer to the looked up commit
  /// @param repo the repo to use when locating the commit.
  /// @param id identity of the commit to locate. If the object is
  /// an annotated tag it will be peeled back to the commit.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_commit_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_commit>> commit,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_commit_lookup_prefix(
      commit,
      repo,
      id,
      len,
    );
  }

  late final _git_commit_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_commit_lookup_prefix');
  late final _git_commit_lookup_prefix =
      _git_commit_lookup_prefixPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Close an open commit
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a commit. Failure to do so will cause a memory leak.
  ///
  /// @param commit the commit to close
  void git_commit_free(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_free(
      commit,
    );
  }

  late final _git_commit_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_commit>)>>(
          'git_commit_free');
  late final _git_commit_free =
      _git_commit_freePtr.asFunction<void Function(ffi.Pointer<git_commit>)>();

  /// Get the id of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return object identity for the commit.
  ffi.Pointer<git_oid> git_commit_id(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_id(
      commit,
    );
  }

  late final _git_commit_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_commit>)>>('git_commit_id');
  late final _git_commit_id = _git_commit_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>)>();

  /// Get the repository that contains the commit.
  ///
  /// @param commit A previously loaded commit.
  /// @return Repository that contains this commit.
  ffi.Pointer<git_repository> git_commit_owner(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_owner(
      commit,
    );
  }

  late final _git_commit_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_commit>)>>('git_commit_owner');
  late final _git_commit_owner = _git_commit_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_commit>)>();

  /// Get the encoding for the message of a commit,
  /// as a string representing a standard encoding name.
  ///
  /// The encoding may be NULL if the `encoding` header
  /// in the commit is missing; in that case UTF-8 is assumed.
  ///
  /// @param commit a previously loaded commit.
  /// @return NULL, or the encoding
  ffi.Pointer<ffi.Char> git_commit_message_encoding(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_message_encoding(
      commit,
    );
  }

  late final _git_commit_message_encodingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_message_encoding');
  late final _git_commit_message_encoding = _git_commit_message_encodingPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the full message of a commit.
  ///
  /// The returned message will be slightly prettified by removing any
  /// potential leading newlines.
  ///
  /// @param commit a previously loaded commit.
  /// @return the message of a commit
  ffi.Pointer<ffi.Char> git_commit_message(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_message(
      commit,
    );
  }

  late final _git_commit_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_message');
  late final _git_commit_message = _git_commit_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the full raw message of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the raw message of a commit
  ffi.Pointer<ffi.Char> git_commit_message_raw(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_message_raw(
      commit,
    );
  }

  late final _git_commit_message_rawPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_message_raw');
  late final _git_commit_message_raw = _git_commit_message_rawPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the short "summary" of the git commit message.
  ///
  /// The returned message is the summary of the commit, comprising the
  /// first paragraph of the message with whitespace trimmed and squashed.
  ///
  /// @param commit a previously loaded commit.
  /// @return the summary of a commit or NULL on error
  ffi.Pointer<ffi.Char> git_commit_summary(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_summary(
      commit,
    );
  }

  late final _git_commit_summaryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_summary');
  late final _git_commit_summary = _git_commit_summaryPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the long "body" of the git commit message.
  ///
  /// The returned message is the body of the commit, comprising
  /// everything but the first paragraph of the message. Leading and
  /// trailing whitespaces are trimmed.
  ///
  /// @param commit a previously loaded commit.
  /// @return the body of a commit or NULL when no the message only
  /// consists of a summary
  ffi.Pointer<ffi.Char> git_commit_body(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_body(
      commit,
    );
  }

  late final _git_commit_bodyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_body');
  late final _git_commit_body = _git_commit_bodyPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the commit time (i.e. committer time) of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the time of a commit
  int git_commit_time(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_time(
      commit,
    );
  }

  late final _git_commit_timePtr =
      _lookup<ffi.NativeFunction<git_time_t Function(ffi.Pointer<git_commit>)>>(
          'git_commit_time');
  late final _git_commit_time =
      _git_commit_timePtr.asFunction<int Function(ffi.Pointer<git_commit>)>();

  /// Get the commit timezone offset (i.e. committer's preferred timezone) of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return positive or negative timezone offset, in minutes from UTC
  int git_commit_time_offset(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_time_offset(
      commit,
    );
  }

  late final _git_commit_time_offsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_commit>)>>(
          'git_commit_time_offset');
  late final _git_commit_time_offset = _git_commit_time_offsetPtr
      .asFunction<int Function(ffi.Pointer<git_commit>)>();

  /// Get the committer of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the committer of a commit
  ffi.Pointer<git_signature> git_commit_committer(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_committer(
      commit,
    );
  }

  late final _git_commit_committerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_commit>)>>('git_commit_committer');
  late final _git_commit_committer = _git_commit_committerPtr.asFunction<
      ffi.Pointer<git_signature> Function(ffi.Pointer<git_commit>)>();

  /// Get the author of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the author of a commit
  ffi.Pointer<git_signature> git_commit_author(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_author(
      commit,
    );
  }

  late final _git_commit_authorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_commit>)>>('git_commit_author');
  late final _git_commit_author = _git_commit_authorPtr.asFunction<
      ffi.Pointer<git_signature> Function(ffi.Pointer<git_commit>)>();

  /// Get the committer of a commit, using the mailmap to map names and email
  /// addresses to canonical real names and email addresses.
  ///
  /// Call `git_signature_free` to free the signature.
  ///
  /// @param out a pointer to store the resolved signature.
  /// @param commit a previously loaded commit.
  /// @param mailmap the mailmap to resolve with. (may be NULL)
  /// @return 0 or an error code
  int git_commit_committer_with_mailmap(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_mailmap> mailmap,
  ) {
    return _git_commit_committer_with_mailmap(
      out,
      commit,
      mailmap,
    );
  }

  late final _git_commit_committer_with_mailmapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_mailmap>)>>('git_commit_committer_with_mailmap');
  late final _git_commit_committer_with_mailmap =
      _git_commit_committer_with_mailmapPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_commit>, ffi.Pointer<git_mailmap>)>();

  /// Get the author of a commit, using the mailmap to map names and email
  /// addresses to canonical real names and email addresses.
  ///
  /// Call `git_signature_free` to free the signature.
  ///
  /// @param out a pointer to store the resolved signature.
  /// @param commit a previously loaded commit.
  /// @param mailmap the mailmap to resolve with. (may be NULL)
  /// @return 0 or an error code
  int git_commit_author_with_mailmap(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_mailmap> mailmap,
  ) {
    return _git_commit_author_with_mailmap(
      out,
      commit,
      mailmap,
    );
  }

  late final _git_commit_author_with_mailmapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_mailmap>)>>('git_commit_author_with_mailmap');
  late final _git_commit_author_with_mailmap =
      _git_commit_author_with_mailmapPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_commit>, ffi.Pointer<git_mailmap>)>();

  /// Get the full raw text of the commit header.
  ///
  /// @param commit a previously loaded commit
  /// @return the header text of the commit
  ffi.Pointer<ffi.Char> git_commit_raw_header(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_raw_header(
      commit,
    );
  }

  late final _git_commit_raw_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_commit>)>>('git_commit_raw_header');
  late final _git_commit_raw_header = _git_commit_raw_headerPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_commit>)>();

  /// Get the tree pointed to by a commit.
  ///
  /// @param tree_out pointer where to store the tree object
  /// @param commit a previously loaded commit.
  /// @return 0 or an error code
  int git_commit_tree(
    ffi.Pointer<ffi.Pointer<git_tree>> tree_out,
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_tree(
      tree_out,
      commit,
    );
  }

  late final _git_commit_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tree>>,
              ffi.Pointer<git_commit>)>>('git_commit_tree');
  late final _git_commit_tree = _git_commit_treePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_tree>>, ffi.Pointer<git_commit>)>();

  /// Get the id of the tree pointed to by a commit. This differs from
  /// `git_commit_tree` in that no attempts are made to fetch an object
  /// from the ODB.
  ///
  /// @param commit a previously loaded commit.
  /// @return the id of tree pointed to by commit.
  ffi.Pointer<git_oid> git_commit_tree_id(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_tree_id(
      commit,
    );
  }

  late final _git_commit_tree_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_commit>)>>('git_commit_tree_id');
  late final _git_commit_tree_id = _git_commit_tree_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>)>();

  /// Get the number of parents of this commit
  ///
  /// @param commit a previously loaded commit.
  /// @return integer of count of parents
  int git_commit_parentcount(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_parentcount(
      commit,
    );
  }

  late final _git_commit_parentcountPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<git_commit>)>>('git_commit_parentcount');
  late final _git_commit_parentcount = _git_commit_parentcountPtr
      .asFunction<int Function(ffi.Pointer<git_commit>)>();

  /// Get the specified parent of the commit.
  ///
  /// @param out Pointer where to store the parent commit
  /// @param commit a previously loaded commit.
  /// @param n the position of the parent (from 0 to `parentcount`)
  /// @return 0 or an error code
  int git_commit_parent(
    ffi.Pointer<ffi.Pointer<git_commit>> out,
    ffi.Pointer<git_commit> commit,
    int n,
  ) {
    return _git_commit_parent(
      out,
      commit,
      n,
    );
  }

  late final _git_commit_parentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_commit>, ffi.UnsignedInt)>>('git_commit_parent');
  late final _git_commit_parent = _git_commit_parentPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
          ffi.Pointer<git_commit>, int)>();

  /// Get the oid of a specified parent for a commit. This is different from
  /// `git_commit_parent`, which will attempt to load the parent commit from
  /// the ODB.
  ///
  /// @param commit a previously loaded commit.
  /// @param n the position of the parent (from 0 to `parentcount`)
  /// @return the id of the parent, NULL on error.
  ffi.Pointer<git_oid> git_commit_parent_id(
    ffi.Pointer<git_commit> commit,
    int n,
  ) {
    return _git_commit_parent_id(
      commit,
      n,
    );
  }

  late final _git_commit_parent_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>,
              ffi.UnsignedInt)>>('git_commit_parent_id');
  late final _git_commit_parent_id = _git_commit_parent_idPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_commit>, int)>();

  /// Get the commit object that is the <n>th generation ancestor
  /// of the named commit object, following only the first parents.
  /// The returned commit has to be freed by the caller.
  ///
  /// Passing `0` as the generation number returns another instance of the
  /// base commit itself.
  ///
  /// @param ancestor Pointer where to store the ancestor commit
  /// @param commit a previously loaded commit.
  /// @param n the requested generation
  /// @return 0 on success; GIT_ENOTFOUND if no matching ancestor exists
  /// or an error code
  int git_commit_nth_gen_ancestor(
    ffi.Pointer<ffi.Pointer<git_commit>> ancestor,
    ffi.Pointer<git_commit> commit,
    int n,
  ) {
    return _git_commit_nth_gen_ancestor(
      ancestor,
      commit,
      n,
    );
  }

  late final _git_commit_nth_gen_ancestorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_commit>,
              ffi.UnsignedInt)>>('git_commit_nth_gen_ancestor');
  late final _git_commit_nth_gen_ancestor =
      _git_commit_nth_gen_ancestorPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_commit>, int)>();

  /// Get an arbitrary header field
  ///
  /// @param out the buffer to fill; existing content will be
  /// overwritten
  /// @param commit the commit to look in
  /// @param field the header field to return
  /// @return 0 on succeess, GIT_ENOTFOUND if the field does not exist,
  /// or an error code
  int git_commit_header_field(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<ffi.Char> field,
  ) {
    return _git_commit_header_field(
      out,
      commit,
      field,
    );
  }

  late final _git_commit_header_fieldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_commit>,
              ffi.Pointer<ffi.Char>)>>('git_commit_header_field');
  late final _git_commit_header_field = _git_commit_header_fieldPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_commit>,
          ffi.Pointer<ffi.Char>)>();

  /// Extract the signature from a commit
  ///
  /// If the id is not for a commit, the error class will be
  /// `GIT_ERROR_INVALID`. If the commit does not have a signature, the
  /// error class will be `GIT_ERROR_OBJECT`.
  ///
  /// @param signature the signature block; existing content will be
  /// overwritten
  /// @param signed_data signed data; this is the commit contents minus the signature block;
  /// existing content will be overwritten
  /// @param repo the repository in which the commit exists
  /// @param commit_id the commit from which to extract the data
  /// @param field the name of the header field containing the signature
  /// block; pass `NULL` to extract the default 'gpgsig'
  /// @return 0 on success, GIT_ENOTFOUND if the id is not for a commit
  /// or the commit does not have a signature.
  int git_commit_extract_signature(
    ffi.Pointer<git_buf> signature,
    ffi.Pointer<git_buf> signed_data,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> commit_id,
    ffi.Pointer<ffi.Char> field,
  ) {
    return _git_commit_extract_signature(
      signature,
      signed_data,
      repo,
      commit_id,
      field,
    );
  }

  late final _git_commit_extract_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>>('git_commit_extract_signature');
  late final _git_commit_extract_signature =
      _git_commit_extract_signaturePtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>)>();

  /// Create new commit in the repository from a list of `git_object` pointers
  ///
  /// The message will **not** be cleaned up automatically. You can do that
  /// with the `git_message_prettify()` function.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  ///
  /// @param repo Repository where to store the commit
  ///
  /// @param update_ref If not NULL, name of the reference that
  /// will be updated to point to this commit. If the reference
  /// is not direct, it will be resolved to a direct reference.
  /// Use "HEAD" to update the HEAD of the current branch and
  /// make it point to this commit. If the reference doesn't
  /// exist yet, it will be created. If it does exist, the first
  /// parent must be the tip of this branch.
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @param parents Array of `parent_count` pointers to `git_commit`
  /// objects that will be used as the parents for this commit. This
  /// array may be NULL if `parent_count` is 0 (root commit). All the
  /// given commits must be owned by the `repo`.
  ///
  /// @return 0 or an error code
  /// The created commit will be written to the Object Database and
  /// the given reference will be updated to point to it
  int git_commit_create(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
  ) {
    return _git_commit_create(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
      parents,
    );
  }

  late final _git_commit_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_tree>,
              ffi.Size,
              ffi.Pointer<ffi.Pointer<git_commit>>)>>('git_commit_create');
  late final _git_commit_create = _git_commit_createPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_tree>,
          int,
          ffi.Pointer<ffi.Pointer<git_commit>>)>();

  /// Create new commit in the repository using a variable argument list.
  ///
  /// The message will **not** be cleaned up automatically. You can do that
  /// with the `git_message_prettify()` function.
  ///
  /// The parents for the commit are specified as a variable list of pointers
  /// to `const git_commit *`. Note that this is a convenience method which may
  /// not be safe to export for certain languages or compilers
  ///
  /// All other parameters remain the same as `git_commit_create()`.
  ///
  /// @see git_commit_create
  int git_commit_create_v(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
  ) {
    return _git_commit_create_v(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
    );
  }

  late final _git_commit_create_vPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_tree>,
              ffi.Size)>>('git_commit_create_v');
  late final _git_commit_create_v = _git_commit_create_vPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_tree>,
          int)>();

  /// Amend an existing commit by replacing only non-NULL values.
  ///
  /// This creates a new commit that is exactly the same as the old commit,
  /// except that any non-NULL values will be updated.  The new commit has
  /// the same parents as the old commit.
  ///
  /// The `update_ref` value works as in the regular `git_commit_create()`,
  /// updating the ref to point to the newly rewritten commit.  If you want
  /// to amend a commit that is not currently the tip of the branch and then
  /// rewrite the following commits to reach a ref, pass this as NULL and
  /// update the rest of the commit chain and ref separately.
  ///
  /// Unlike `git_commit_create()`, the `author`, `committer`, `message`,
  /// `message_encoding`, and `tree` parameters can be NULL in which case this
  /// will use the values from the original `commit_to_amend`.
  ///
  /// All parameters have the same meanings as in `git_commit_create()`.
  ///
  /// @see git_commit_create
  int git_commit_amend(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_commit> commit_to_amend,
    ffi.Pointer<ffi.Char> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_commit_amend(
      id,
      commit_to_amend,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
    );
  }

  late final _git_commit_amendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_tree>)>>('git_commit_amend');
  late final _git_commit_amend = _git_commit_amendPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_tree>)>();

  /// Create a commit and write it into a buffer
  ///
  /// Create a commit as with `git_commit_create()` but instead of
  /// writing it to the objectdb, write the contents of the object into a
  /// buffer.
  ///
  /// @param out the buffer into which to write the commit object content
  ///
  /// @param repo Repository where the referenced tree and parents live
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @param parents Array of `parent_count` pointers to `git_commit`
  /// objects that will be used as the parents for this commit. This
  /// array may be NULL if `parent_count` is 0 (root commit). All the
  /// given commits must be owned by the `repo`.
  ///
  /// @return 0 or an error code
  int git_commit_create_buffer(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
  ) {
    return _git_commit_create_buffer(
      out,
      repo,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
      parents,
    );
  }

  late final _git_commit_create_bufferPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_buf>,
                  ffi.Pointer<git_repository>,
                  ffi.Pointer<git_signature>,
                  ffi.Pointer<git_signature>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_tree>,
                  ffi.Size,
                  ffi.Pointer<ffi.Pointer<git_commit>>)>>(
      'git_commit_create_buffer');
  late final _git_commit_create_buffer =
      _git_commit_create_bufferPtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_tree>,
              int,
              ffi.Pointer<ffi.Pointer<git_commit>>)>();

  /// Create a commit object from the given buffer and signature
  ///
  /// Given the unsigned commit object's contents, its signature and the
  /// header field in which to store the signature, attach the signature
  /// to the commit and write it into the given repository.
  ///
  /// @param out the resulting commit id
  /// @param repo the repository to create the commit in.
  /// @param commit_content the content of the unsigned commit object
  /// @param signature the signature to add to the commit. Leave `NULL`
  /// to create a commit without adding a signature field.
  /// @param signature_field which header field should contain this
  /// signature. Leave `NULL` for the default of "gpgsig"
  /// @return 0 or an error code
  int git_commit_create_with_signature(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> commit_content,
    ffi.Pointer<ffi.Char> signature,
    ffi.Pointer<ffi.Char> signature_field,
  ) {
    return _git_commit_create_with_signature(
      out,
      repo,
      commit_content,
      signature,
      signature_field,
    );
  }

  late final _git_commit_create_with_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_commit_create_with_signature');
  late final _git_commit_create_with_signature =
      _git_commit_create_with_signaturePtr.asFunction<
          int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Create an in-memory copy of a commit. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the commit
  /// @param source Original commit to copy
  /// @return 0
  int git_commit_dup(
    ffi.Pointer<ffi.Pointer<git_commit>> out,
    ffi.Pointer<git_commit> source,
  ) {
    return _git_commit_dup(
      out,
      source,
    );
  }

  late final _git_commit_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_commit>>,
              ffi.Pointer<git_commit>)>>('git_commit_dup');
  late final _git_commit_dup = _git_commit_dupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_commit>>, ffi.Pointer<git_commit>)>();

  /// Free a config entry
  ///
  /// @param entry The entry to free.
  void git_config_entry_free(
    ffi.Pointer<git_config_entry> entry,
  ) {
    return _git_config_entry_free(
      entry,
    );
  }

  late final _git_config_entry_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_config_entry>)>>(
      'git_config_entry_free');
  late final _git_config_entry_free = _git_config_entry_freePtr
      .asFunction<void Function(ffi.Pointer<git_config_entry>)>();

  /// Locate the path to the global configuration file
  ///
  /// The user or global configuration file is usually
  /// located in `$HOME/.gitconfig`.
  ///
  /// This method will try to guess the full path to that
  /// file, if the file exists. The returned path
  /// may be used on any `git_config` call to load the
  /// global configuration file.
  ///
  /// This method will not guess the path to the xdg compatible
  /// config file (`.config/git/config`).
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a global configuration file has been found. Its path will be stored in `out`.
  int git_config_find_global(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_global(
      out,
    );
  }

  late final _git_config_find_globalPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_config_find_global');
  late final _git_config_find_global = _git_config_find_globalPtr
      .asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Locate the path to the global xdg compatible configuration file
  ///
  /// The xdg compatible configuration file is usually
  /// located in `$HOME/.config/git/config`.
  ///
  /// This method will try to guess the full path to that
  /// file, if the file exists. The returned path
  /// may be used on any `git_config` call to load the
  /// xdg compatible configuration file.
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a xdg compatible configuration file has been
  /// found. Its path will be stored in `out`.
  int git_config_find_xdg(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_xdg(
      out,
    );
  }

  late final _git_config_find_xdgPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_config_find_xdg');
  late final _git_config_find_xdg =
      _git_config_find_xdgPtr.asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Locate the path to the system configuration file
  ///
  /// If `/etc/gitconfig` doesn't exist, it will look for
  /// `%PROGRAMFILES%\Git\etc\gitconfig`.
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a system configuration file has been
  /// found. Its path will be stored in `out`.
  int git_config_find_system(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_system(
      out,
    );
  }

  late final _git_config_find_systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_config_find_system');
  late final _git_config_find_system = _git_config_find_systemPtr
      .asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Locate the path to the configuration file in ProgramData
  ///
  /// Look for the file in `%PROGRAMDATA%\Git\config` used by portable git.
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a ProgramData configuration file has been
  /// found. Its path will be stored in `out`.
  int git_config_find_programdata(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_programdata(
      out,
    );
  }

  late final _git_config_find_programdataPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_config_find_programdata');
  late final _git_config_find_programdata = _git_config_find_programdataPtr
      .asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Open the global, XDG and system configuration files
  ///
  /// Utility wrapper that finds the global, XDG and system configuration files
  /// and opens them into a single prioritized config object that can be
  /// used when accessing default config data outside a repository.
  ///
  /// @param out Pointer to store the config instance
  /// @return 0 or an error code
  int git_config_open_default(
    ffi.Pointer<ffi.Pointer<git_config>> out,
  ) {
    return _git_config_open_default(
      out,
    );
  }

  late final _git_config_open_defaultPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>)>>(
      'git_config_open_default');
  late final _git_config_open_default = _git_config_open_defaultPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_config>>)>();

  /// Allocate a new configuration object
  ///
  /// This object is empty, so you have to add a file to it before you
  /// can do anything with it.
  ///
  /// @param out pointer to the new configuration
  /// @return 0 or an error code
  int git_config_new(
    ffi.Pointer<ffi.Pointer<git_config>> out,
  ) {
    return _git_config_new(
      out,
    );
  }

  late final _git_config_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_config>>)>>('git_config_new');
  late final _git_config_new = _git_config_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_config>>)>();

  /// Add an on-disk config file instance to an existing config
  ///
  /// The on-disk file pointed at by `path` will be opened and
  /// parsed; it's expected to be a native Git config file following
  /// the default Git config syntax (see man git-config).
  ///
  /// If the file does not exist, the file will still be added and it
  /// will be created the first time we write to it.
  ///
  /// Note that the configuration object will free the file
  /// automatically.
  ///
  /// Further queries on this config object will access each
  /// of the config file instances in order (instances with
  /// a higher priority level will be accessed first).
  ///
  /// @param cfg the configuration to add the file to
  /// @param path path to the configuration file to add
  /// @param level the priority level of the backend
  /// @param force replace config file at the given priority level
  /// @param repo optional repository to allow parsing of
  /// conditional includes
  /// @return 0 on success, GIT_EEXISTS when adding more than one file
  /// for a given priority level (and force_replace set to 0),
  /// GIT_ENOTFOUND when the file doesn't exist or error code
  int git_config_add_file_ondisk(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> path,
    int level,
    ffi.Pointer<git_repository> repo,
    int force,
  ) {
    return _git_config_add_file_ondisk(
      cfg,
      path,
      level,
      repo,
      force,
    );
  }

  late final _git_config_add_file_ondiskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Pointer<git_repository>,
              ffi.Int)>>('git_config_add_file_ondisk');
  late final _git_config_add_file_ondisk =
      _git_config_add_file_ondiskPtr.asFunction<
          int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<git_repository>, int)>();

  /// Create a new config instance containing a single on-disk file
  ///
  /// This method is a simple utility wrapper for the following sequence
  /// of calls:
  /// - git_config_new
  /// - git_config_add_file_ondisk
  ///
  /// @param out The configuration instance to create
  /// @param path Path to the on-disk file to open
  /// @return 0 on success, or an error code
  int git_config_open_ondisk(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_config_open_ondisk(
      out,
      path,
    );
  }

  late final _git_config_open_ondiskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<ffi.Char>)>>('git_config_open_ondisk');
  late final _git_config_open_ondisk = _git_config_open_ondiskPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_config>>, ffi.Pointer<ffi.Char>)>();

  /// Build a single-level focused config object from a multi-level one.
  ///
  /// The returned config object can be used to perform get/set/delete operations
  /// on a single specific level.
  ///
  /// Getting several times the same level from the same parent multi-level config
  /// will return different config instances, but containing the same config_file
  /// instance.
  ///
  /// @param out The configuration instance to create
  /// @param parent Multi-level config to search for the given level
  /// @param level Configuration level to search for
  /// @return 0, GIT_ENOTFOUND if the passed level cannot be found in the
  /// multi-level parent config, or an error code
  int git_config_open_level(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_config> parent,
    int level,
  ) {
    return _git_config_open_level(
      out,
      parent,
      level,
    );
  }

  late final _git_config_open_levelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_config>, ffi.Int32)>>('git_config_open_level');
  late final _git_config_open_level = _git_config_open_levelPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_config>>,
          ffi.Pointer<git_config>, int)>();

  /// Open the global/XDG configuration file according to git's rules
  ///
  /// Git allows you to store your global configuration at
  /// `$HOME/.gitconfig` or `$XDG_CONFIG_HOME/git/config`. For backwards
  /// compatibility, the XDG file shouldn't be used unless the use has
  /// created it explicitly. With this function you'll open the correct
  /// one to write to.
  ///
  /// @param out pointer in which to store the config object
  /// @param config the config object in which to look
  /// @return 0 or an error code.
  int git_config_open_global(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_config> config,
  ) {
    return _git_config_open_global(
      out,
      config,
    );
  }

  late final _git_config_open_globalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_config>)>>('git_config_open_global');
  late final _git_config_open_global = _git_config_open_globalPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_config>>, ffi.Pointer<git_config>)>();

  /// Create a snapshot of the configuration
  ///
  /// Create a snapshot of the current state of a configuration, which
  /// allows you to look into a consistent view of the configuration for
  /// looking up complex values (e.g. a remote, submodule).
  ///
  /// The string returned when querying such a config object is valid
  /// until it is freed.
  ///
  /// @param out pointer in which to store the snapshot config object
  /// @param config configuration to snapshot
  /// @return 0 or an error code
  int git_config_snapshot(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_config> config,
  ) {
    return _git_config_snapshot(
      out,
      config,
    );
  }

  late final _git_config_snapshotPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config>>,
              ffi.Pointer<git_config>)>>('git_config_snapshot');
  late final _git_config_snapshot = _git_config_snapshotPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_config>>, ffi.Pointer<git_config>)>();

  /// Free the configuration and its associated memory and files
  ///
  /// @param cfg the configuration to free
  void git_config_free(
    ffi.Pointer<git_config> cfg,
  ) {
    return _git_config_free(
      cfg,
    );
  }

  late final _git_config_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_config>)>>(
          'git_config_free');
  late final _git_config_free =
      _git_config_freePtr.asFunction<void Function(ffi.Pointer<git_config>)>();

  /// Get the git_config_entry of a config variable.
  ///
  /// Free the git_config_entry after use with `git_config_entry_free()`.
  ///
  /// @param out pointer to the variable git_config_entry
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_entry(
    ffi.Pointer<ffi.Pointer<git_config_entry>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_entry(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_config_entry>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_entry');
  late final _git_config_get_entry = _git_config_get_entryPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_config_entry>>,
          ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>)>();

  /// Get the value of an integer config variable.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the variable where the value should be stored
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_int32(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_int32(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_int32');
  late final _git_config_get_int32 = _git_config_get_int32Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a long integer config variable.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the variable where the value should be stored
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_int64(
    ffi.Pointer<ffi.Int64> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_int64(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int64>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_int64');
  late final _git_config_get_int64 = _git_config_get_int64Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int64>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a boolean config variable.
  ///
  /// This function uses the usual C convention of 0 being false and
  /// anything else true.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the variable where the value should be stored
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_bool(
    ffi.Pointer<ffi.Int> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_bool(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_bool');
  late final _git_config_get_bool = _git_config_get_boolPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a path config variable.
  ///
  /// A leading '~' will be expanded to the global search path (which
  /// defaults to the user's home directory but can be overridden via
  /// `git_libgit2_opts()`.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out the buffer in which to store the result
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_path(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_path(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_path');
  late final _git_config_get_path = _git_config_get_pathPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a string config variable.
  ///
  /// This function can only be used on snapshot config objects. The
  /// string is owned by the config and should not be freed by the
  /// user. The pointer will be valid until the config is freed.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the string
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_string(
    ffi.Pointer<ffi.Pointer<ffi.Char>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_string(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_string');
  late final _git_config_get_string = _git_config_get_stringPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the value of a string config variable.
  ///
  /// The value of the config will be copied into the buffer.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out buffer in which to store the string
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_string_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_get_string_buf(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_string_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_get_string_buf');
  late final _git_config_get_string_buf =
      _git_config_get_string_bufPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>();

  /// Get each value of a multivar in a foreach callback
  ///
  /// The callback will be called on each variable found
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param regexp regular expression to filter which variables we're
  /// interested in. Use NULL to indicate all
  /// @param callback the function to be called on each value of the variable
  /// @param payload opaque pointer to pass to the callback
  /// @return 0 or an error code.
  int git_config_get_multivar_foreach(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regexp,
    git_config_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_get_multivar_foreach(
      cfg,
      name,
      regexp,
      callback,
      payload,
    );
  }

  late final _git_config_get_multivar_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_config_get_multivar_foreach');
  late final _git_config_get_multivar_foreach =
      _git_config_get_multivar_foreachPtr.asFunction<
          int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>();

  /// Get each value of a multivar
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param out pointer to store the iterator
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param regexp regular expression to filter which variables we're
  /// interested in. Use NULL to indicate all
  /// @return 0 or an error code.
  int git_config_multivar_iterator_new(
    ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regexp,
  ) {
    return _git_config_multivar_iterator_new(
      out,
      cfg,
      name,
      regexp,
    );
  }

  late final _git_config_multivar_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_config_multivar_iterator_new');
  late final _git_config_multivar_iterator_new =
      _git_config_multivar_iterator_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Return the current entry and advance the iterator
  ///
  /// The pointers returned by this function are valid until the next call
  /// to `git_config_next` or until the iterator is freed.
  ///
  /// @param entry pointer to store the entry
  /// @param iter the iterator
  /// @return 0 or an error code. GIT_ITEROVER if the iteration has completed
  int git_config_next(
    ffi.Pointer<ffi.Pointer<git_config_entry>> entry,
    ffi.Pointer<git_config_iterator> iter,
  ) {
    return _git_config_next(
      entry,
      iter,
    );
  }

  late final _git_config_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_entry>>,
              ffi.Pointer<git_config_iterator>)>>('git_config_next');
  late final _git_config_next = _git_config_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_config_entry>>,
          ffi.Pointer<git_config_iterator>)>();

  /// Free a config iterator
  ///
  /// @param iter the iterator to free
  void git_config_iterator_free(
    ffi.Pointer<git_config_iterator> iter,
  ) {
    return _git_config_iterator_free(
      iter,
    );
  }

  late final _git_config_iterator_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<git_config_iterator>)>>('git_config_iterator_free');
  late final _git_config_iterator_free = _git_config_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_config_iterator>)>();

  /// Set the value of an integer config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value Integer value for the variable
  /// @return 0 or an error code
  int git_config_set_int32(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    int value,
  ) {
    return _git_config_set_int32(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_config_set_int32');
  late final _git_config_set_int32 = _git_config_set_int32Ptr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the value of a long integer config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value Long integer value for the variable
  /// @return 0 or an error code
  int git_config_set_int64(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    int value,
  ) {
    return _git_config_set_int64(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Int64)>>('git_config_set_int64');
  late final _git_config_set_int64 = _git_config_set_int64Ptr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the value of a boolean config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value the value to store
  /// @return 0 or an error code
  int git_config_set_bool(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    int value,
  ) {
    return _git_config_set_bool(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_config_set_bool');
  late final _git_config_set_bool = _git_config_set_boolPtr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>, int)>();

  /// Set the value of a string config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// A copy of the string is made and the user is free to use it
  /// afterwards.
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value the string to store.
  /// @return 0 or an error code
  int git_config_set_string(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_set_string(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_stringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_config_set_string');
  late final _git_config_set_string = _git_config_set_stringPtr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Set a multivar in the local config file.
  ///
  /// The regular expression is applied case-sensitively on the value.
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param regexp a regular expression to indicate which values to replace
  /// @param value the new value.
  /// @return 0 or an error code.
  int git_config_set_multivar(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regexp,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_set_multivar(
      cfg,
      name,
      regexp,
      value,
    );
  }

  late final _git_config_set_multivarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_config_set_multivar');
  late final _git_config_set_multivar = _git_config_set_multivarPtr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Delete a config variable from the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg the configuration
  /// @param name the variable to delete
  /// @return 0 or an error code.
  int git_config_delete_entry(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_config_delete_entry(
      cfg,
      name,
    );
  }

  late final _git_config_delete_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_delete_entry');
  late final _git_config_delete_entry = _git_config_delete_entryPtr.asFunction<
      int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>)>();

  /// Deletes one or several entries from a multivar in the local config file.
  ///
  /// The regular expression is applied case-sensitively on the value.
  ///
  /// @param cfg where to look for the variables
  /// @param name the variable's name
  /// @param regexp a regular expression to indicate which values to delete
  ///
  /// @return 0 or an error code
  int git_config_delete_multivar(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> regexp,
  ) {
    return _git_config_delete_multivar(
      cfg,
      name,
      regexp,
    );
  }

  late final _git_config_delete_multivarPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_config_delete_multivar');
  late final _git_config_delete_multivar =
      _git_config_delete_multivarPtr.asFunction<
          int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Perform an operation on each config variable.
  ///
  /// The callback receives the normalized name and value of each variable
  /// in the config backend, and the data pointer passed to this function.
  /// If the callback returns a non-zero value, the function stops iterating
  /// and returns that value to the caller.
  ///
  /// The pointers passed to the callback are only valid as long as the
  /// iteration is ongoing.
  ///
  /// @param cfg where to get the variables from
  /// @param callback the function to call on each variable
  /// @param payload the data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_config_foreach(
    ffi.Pointer<git_config> cfg,
    git_config_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_foreach(
      cfg,
      callback,
      payload,
    );
  }

  late final _git_config_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_config>, git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_config_foreach');
  late final _git_config_foreach = _git_config_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_config>, git_config_foreach_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Iterate over all the config variables
  ///
  /// Use `git_config_next` to advance the iteration and
  /// `git_config_iterator_free` when done.
  ///
  /// @param out pointer to store the iterator
  /// @param cfg where to get the variables from
  /// @return 0 or an error code.
  int git_config_iterator_new(
    ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
    ffi.Pointer<git_config> cfg,
  ) {
    return _git_config_iterator_new(
      out,
      cfg,
    );
  }

  late final _git_config_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>)>>('git_config_iterator_new');
  late final _git_config_iterator_new = _git_config_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>>,
          ffi.Pointer<git_config>)>();

  /// Iterate over all the config variables whose name matches a pattern
  ///
  /// Use `git_config_next` to advance the iteration and
  /// `git_config_iterator_free` when done.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param out pointer to store the iterator
  /// @param cfg where to ge the variables from
  /// @param regexp regular expression to match the names
  /// @return 0 or an error code.
  int git_config_iterator_glob_new(
    ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> regexp,
  ) {
    return _git_config_iterator_glob_new(
      out,
      cfg,
      regexp,
    );
  }

  late final _git_config_iterator_glob_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>)>>('git_config_iterator_glob_new');
  late final _git_config_iterator_glob_new =
      _git_config_iterator_glob_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_config_iterator>>,
              ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>)>();

  /// Perform an operation on each config variable matching a regular expression.
  ///
  /// This behaves like `git_config_foreach` with an additional filter of a
  /// regular expression that filters which config keys are passed to the
  /// callback.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the case-insensitive parts are lower-case.
  ///
  /// @param cfg where to get the variables from
  /// @param regexp regular expression to match against config names
  /// @param callback the function to call on each variable
  /// @param payload the data to pass to the callback
  /// @return 0 or the return value of the callback which didn't return 0
  int git_config_foreach_match(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> regexp,
    git_config_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_foreach_match(
      cfg,
      regexp,
      callback,
      payload,
    );
  }

  late final _git_config_foreach_matchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_config_foreach_match');
  late final _git_config_foreach_match =
      _git_config_foreach_matchPtr.asFunction<
          int Function(ffi.Pointer<git_config>, ffi.Pointer<ffi.Char>,
              git_config_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Query the value of a config variable and return it mapped to
  /// an integer constant.
  ///
  /// This is a helper method to easily map different possible values
  /// to a variable to integer constants that easily identify them.
  ///
  /// A mapping array looks as follows:
  ///
  /// git_configmap autocrlf_mapping[] = {
  /// {GIT_CVAR_FALSE, NULL, GIT_AUTO_CRLF_FALSE},
  /// {GIT_CVAR_TRUE, NULL, GIT_AUTO_CRLF_TRUE},
  /// {GIT_CVAR_STRING, "input", GIT_AUTO_CRLF_INPUT},
  /// {GIT_CVAR_STRING, "default", GIT_AUTO_CRLF_DEFAULT}};
  ///
  /// On any "false" value for the variable (e.g. "false", "FALSE", "no"), the
  /// mapping will store `GIT_AUTO_CRLF_FALSE` in the `out` parameter.
  ///
  /// The same thing applies for any "true" value such as "true", "yes" or "1", storing
  /// the `GIT_AUTO_CRLF_TRUE` variable.
  ///
  /// Otherwise, if the value matches the string "input" (with case insensitive comparison),
  /// the given constant will be stored in `out`, and likewise for "default".
  ///
  /// If not a single match can be made to store in `out`, an error code will be
  /// returned.
  ///
  /// @param out place to store the result of the mapping
  /// @param cfg config file to get the variables from
  /// @param name name of the config variable to lookup
  /// @param maps array of `git_configmap` objects specifying the possible mappings
  /// @param map_n number of mapping objects in `maps`
  /// @return 0 on success, error code otherwise
  int git_config_get_mapped(
    ffi.Pointer<ffi.Int> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<git_configmap> maps,
    int map_n,
  ) {
    return _git_config_get_mapped(
      out,
      cfg,
      name,
      maps,
      map_n,
    );
  }

  late final _git_config_get_mappedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Int>,
              ffi.Pointer<git_config>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_configmap>,
              ffi.Size)>>('git_config_get_mapped');
  late final _git_config_get_mapped = _git_config_get_mappedPtr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_config>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<git_configmap>, int)>();

  /// Maps a string value to an integer constant
  ///
  /// @param out place to store the result of the parsing
  /// @param maps array of `git_configmap` objects specifying the possible mappings
  /// @param map_n number of mapping objects in `maps`
  /// @param value value to parse
  /// @return 0 or an error code.
  int git_config_lookup_map_value(
    ffi.Pointer<ffi.Int> out,
    ffi.Pointer<git_configmap> maps,
    int map_n,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_lookup_map_value(
      out,
      maps,
      map_n,
      value,
    );
  }

  late final _git_config_lookup_map_valuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_configmap>,
              ffi.Size, ffi.Pointer<ffi.Char>)>>('git_config_lookup_map_value');
  late final _git_config_lookup_map_value =
      _git_config_lookup_map_valuePtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_configmap>, int,
              ffi.Pointer<ffi.Char>)>();

  /// Parse a string value as a bool.
  ///
  /// Valid values for true are: 'true', 'yes', 'on', 1 or any
  /// number different from 0
  /// Valid values for false are: 'false', 'no', 'off', 0
  ///
  /// @param out place to store the result of the parsing
  /// @param value value to parse
  /// @return 0 or an error code.
  int git_config_parse_bool(
    ffi.Pointer<ffi.Int> out,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_parse_bool(
      out,
      value,
    );
  }

  late final _git_config_parse_boolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_config_parse_bool');
  late final _git_config_parse_bool = _git_config_parse_boolPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Parse a string value as an int32.
  ///
  /// An optional value suffix of 'k', 'm', or 'g' will
  /// cause the value to be multiplied by 1024, 1048576,
  /// or 1073741824 prior to output.
  ///
  /// @param out place to store the result of the parsing
  /// @param value value to parse
  /// @return 0 or an error code.
  int git_config_parse_int32(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_parse_int32(
      out,
      value,
    );
  }

  late final _git_config_parse_int32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int32>,
              ffi.Pointer<ffi.Char>)>>('git_config_parse_int32');
  late final _git_config_parse_int32 = _git_config_parse_int32Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int32>, ffi.Pointer<ffi.Char>)>();

  /// Parse a string value as an int64.
  ///
  /// An optional value suffix of 'k', 'm', or 'g' will
  /// cause the value to be multiplied by 1024, 1048576,
  /// or 1073741824 prior to output.
  ///
  /// @param out place to store the result of the parsing
  /// @param value value to parse
  /// @return 0 or an error code.
  int git_config_parse_int64(
    ffi.Pointer<ffi.Int64> out,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_parse_int64(
      out,
      value,
    );
  }

  late final _git_config_parse_int64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int64>,
              ffi.Pointer<ffi.Char>)>>('git_config_parse_int64');
  late final _git_config_parse_int64 = _git_config_parse_int64Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int64>, ffi.Pointer<ffi.Char>)>();

  /// Parse a string value as a path.
  ///
  /// A leading '~' will be expanded to the global search path (which
  /// defaults to the user's home directory but can be overridden via
  /// `git_libgit2_opts()`.
  ///
  /// If the value does not begin with a tilde, the input will be
  /// returned.
  ///
  /// @param out placae to store the result of parsing
  /// @param value the path to evaluate
  /// @return 0 or an error code.
  int git_config_parse_path(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<ffi.Char> value,
  ) {
    return _git_config_parse_path(
      out,
      value,
    );
  }

  late final _git_config_parse_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<ffi.Char>)>>('git_config_parse_path');
  late final _git_config_parse_path = _git_config_parse_pathPtr
      .asFunction<int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>)>();

  /// Perform an operation on each config variable in a given config backend,
  /// matching a regular expression.
  ///
  /// This behaves like `git_config_foreach_match` except that only config
  /// entries from the given backend entry are enumerated.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param backend where to get the variables from
  /// @param regexp regular expression to match against config names (can be NULL)
  /// @param callback the function to call on each variable
  /// @param payload the data to pass to the callback
  /// @return 0 or an error code.
  int git_config_backend_foreach_match(
    ffi.Pointer<git_config_backend> backend,
    ffi.Pointer<ffi.Char> regexp,
    git_config_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_backend_foreach_match(
      backend,
      regexp,
      callback,
      payload,
    );
  }

  late final _git_config_backend_foreach_matchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_config_backend>,
              ffi.Pointer<ffi.Char>,
              git_config_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_config_backend_foreach_match');
  late final _git_config_backend_foreach_match =
      _git_config_backend_foreach_matchPtr.asFunction<
          int Function(ffi.Pointer<git_config_backend>, ffi.Pointer<ffi.Char>,
              git_config_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Lock the backend with the highest priority
  ///
  /// Locking disallows anybody else from writing to that backend. Any
  /// updates made after locking will not be visible to a reader until
  /// the file is unlocked.
  ///
  /// You can apply the changes by calling `git_transaction_commit()`
  /// before freeing the transaction. Either of these actions will unlock
  /// the config.
  ///
  /// @param tx the resulting transaction, use this to commit or undo the
  /// changes
  /// @param cfg the configuration in which to lock
  /// @return 0 or an error code
  int git_config_lock(
    ffi.Pointer<ffi.Pointer<git_transaction>> tx,
    ffi.Pointer<git_config> cfg,
  ) {
    return _git_config_lock(
      tx,
      cfg,
    );
  }

  late final _git_config_lockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_transaction>>,
              ffi.Pointer<git_config>)>>('git_config_lock');
  late final _git_config_lock = _git_config_lockPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_transaction>>,
          ffi.Pointer<git_config>)>();

  /// Initialize git_describe_options structure
  ///
  /// Initializes a `git_describe_options` with default values. Equivalent to creating
  /// an instance with GIT_DESCRIBE_OPTIONS_INIT.
  ///
  /// @param opts The `git_describe_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DESCRIBE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_describe_options_init(
    ffi.Pointer<git_describe_options> opts,
    int version,
  ) {
    return _git_describe_options_init(
      opts,
      version,
    );
  }

  late final _git_describe_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_describe_options>,
              ffi.UnsignedInt)>>('git_describe_options_init');
  late final _git_describe_options_init = _git_describe_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_describe_options>, int)>();

  /// Initialize git_describe_format_options structure
  ///
  /// Initializes a `git_describe_format_options` with default values. Equivalent to creating
  /// an instance with GIT_DESCRIBE_FORMAT_OPTIONS_INIT.
  ///
  /// @param opts The `git_describe_format_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DESCRIBE_FORMAT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_describe_format_options_init(
    ffi.Pointer<git_describe_format_options> opts,
    int version,
  ) {
    return _git_describe_format_options_init(
      opts,
      version,
    );
  }

  late final _git_describe_format_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_describe_format_options>,
              ffi.UnsignedInt)>>('git_describe_format_options_init');
  late final _git_describe_format_options_init =
      _git_describe_format_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_describe_format_options>, int)>();

  /// Describe a commit
  ///
  /// Perform the describe operation on the given committish object.
  ///
  /// @param result pointer to store the result. You must free this once
  /// you're done with it.
  /// @param committish a committish to describe
  /// @param opts the lookup options (or NULL for defaults)
  /// @return 0 or an error code.
  int git_describe_commit(
    ffi.Pointer<ffi.Pointer<git_describe_result>> result,
    ffi.Pointer<git_object> committish,
    ffi.Pointer<git_describe_options> opts,
  ) {
    return _git_describe_commit(
      result,
      committish,
      opts,
    );
  }

  late final _git_describe_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_describe_result>>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_describe_options>)>>('git_describe_commit');
  late final _git_describe_commit = _git_describe_commitPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_describe_result>>,
          ffi.Pointer<git_object>, ffi.Pointer<git_describe_options>)>();

  /// Describe a commit
  ///
  /// Perform the describe operation on the current commit and the
  /// worktree. After performing describe on HEAD, a status is run and the
  /// description is considered to be dirty if there are.
  ///
  /// @param out pointer to store the result. You must free this once
  /// you're done with it.
  /// @param repo the repository in which to perform the describe
  /// @param opts the lookup options (or NULL for defaults)
  /// @return 0 or an error code.
  int git_describe_workdir(
    ffi.Pointer<ffi.Pointer<git_describe_result>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_describe_options> opts,
  ) {
    return _git_describe_workdir(
      out,
      repo,
      opts,
    );
  }

  late final _git_describe_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_describe_result>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_describe_options>)>>('git_describe_workdir');
  late final _git_describe_workdir = _git_describe_workdirPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_describe_result>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_describe_options>)>();

  /// Print the describe result to a buffer
  ///
  /// @param out The buffer to store the result
  /// @param result the result from `git_describe_commit()` or
  /// `git_describe_workdir()`.
  /// @param opts the formatting options (or NULL for defaults)
  /// @return 0 or an error code.
  int git_describe_format(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_describe_result> result,
    ffi.Pointer<git_describe_format_options> opts,
  ) {
    return _git_describe_format(
      out,
      result,
      opts,
    );
  }

  late final _git_describe_formatPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_buf>,
                  ffi.Pointer<git_describe_result>,
                  ffi.Pointer<git_describe_format_options>)>>(
      'git_describe_format');
  late final _git_describe_format = _git_describe_formatPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_describe_result>,
          ffi.Pointer<git_describe_format_options>)>();

  /// Free the describe result.
  ///
  /// @param result The result to free.
  void git_describe_result_free(
    ffi.Pointer<git_describe_result> result,
  ) {
    return _git_describe_result_free(
      result,
    );
  }

  late final _git_describe_result_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<git_describe_result>)>>('git_describe_result_free');
  late final _git_describe_result_free = _git_describe_result_freePtr
      .asFunction<void Function(ffi.Pointer<git_describe_result>)>();

  /// Return the last `git_error` object that was generated for the
  /// current thread.
  ///
  /// The default behaviour of this function is to return NULL if no previous error has occurred.
  /// However, libgit2's error strings are not cleared aggressively, so a prior
  /// (unrelated) error may be returned. This can be avoided by only calling
  /// this function if the prior call to a libgit2 API returned an error.
  ///
  /// @return A git_error object.
  ffi.Pointer<git_error> git_error_last() {
    return _git_error_last();
  }

  late final _git_error_lastPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<git_error> Function()>>(
          'git_error_last');
  late final _git_error_last =
      _git_error_lastPtr.asFunction<ffi.Pointer<git_error> Function()>();

  /// Clear the last library error that occurred for this thread.
  void git_error_clear() {
    return _git_error_clear();
  }

  late final _git_error_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('git_error_clear');
  late final _git_error_clear =
      _git_error_clearPtr.asFunction<void Function()>();

  /// Set the error message string for this thread, using `printf`-style
  /// formatting.
  ///
  /// This function is public so that custom ODB backends and the like can
  /// relay an error message through libgit2.  Most regular users of libgit2
  /// will never need to call this function -- actually, calling it in most
  /// circumstances (for example, calling from within a callback function)
  /// will just end up having the value overwritten by libgit2 internals.
  ///
  /// This error message is stored in thread-local storage and only applies
  /// to the particular thread that this libgit2 call is made from.
  ///
  /// @param error_class One of the `git_error_t` enum above describing the
  /// general subsystem that is responsible for the error.
  /// @param fmt The `printf`-style format string; subsequent arguments must
  /// be the arguments for the format string.
  void git_error_set(
    int error_class,
    ffi.Pointer<ffi.Char> fmt,
  ) {
    return _git_error_set(
      error_class,
      fmt,
    );
  }

  late final _git_error_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('git_error_set');
  late final _git_error_set =
      _git_error_setPtr.asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Set the error message string for this thread.  This function is like
  /// `git_error_set` but takes a static string instead of a `printf`-style
  /// format.
  ///
  /// @param error_class One of the `git_error_t` enum above describing the
  /// general subsystem that is responsible for the error.
  /// @param string The error message to keep
  /// @return 0 on success or -1 on failure
  int git_error_set_str(
    int error_class,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _git_error_set_str(
      error_class,
      string,
    );
  }

  late final _git_error_set_strPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<ffi.Char>)>>(
      'git_error_set_str');
  late final _git_error_set_str = _git_error_set_strPtr
      .asFunction<int Function(int, ffi.Pointer<ffi.Char>)>();

  /// Set the error message to a special value for memory allocation failure.
  ///
  /// The normal `git_error_set_str()` function attempts to `strdup()` the
  /// string that is passed in.  This is not a good idea when the error in
  /// question is a memory allocation failure.  That circumstance has a
  /// special setter function that sets the error string to a known and
  /// statically allocated internal value.
  void git_error_set_oom() {
    return _git_error_set_oom();
  }

  late final _git_error_set_oomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('git_error_set_oom');
  late final _git_error_set_oom =
      _git_error_set_oomPtr.asFunction<void Function()>();

  /// Load the filter list for a given path.
  ///
  /// This will return 0 (success) but set the output git_filter_list to NULL
  /// if no filters are requested for the given file.
  ///
  /// @param filters Output newly created git_filter_list (or NULL)
  /// @param repo Repository object that contains `path`
  /// @param blob The blob to which the filter will be applied (if known)
  /// @param path Relative path of the file to be filtered
  /// @param mode Filtering direction (WT->ODB or ODB->WT)
  /// @param flags Combination of `git_filter_flag_t` flags
  /// @return 0 on success (which could still return NULL if no filters are
  /// needed for the requested file), <0 on error
  int git_filter_list_load(
    ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Char> path,
    int mode,
    int flags,
  ) {
    return _git_filter_list_load(
      filters,
      repo,
      blob,
      path,
      mode,
      flags,
    );
  }

  late final _git_filter_list_loadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_filter_list>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Uint32)>>('git_filter_list_load');
  late final _git_filter_list_load = _git_filter_list_loadPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_filter_list>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          int,
          int)>();

  /// Load the filter list for a given path.
  ///
  /// This will return 0 (success) but set the output git_filter_list to NULL
  /// if no filters are requested for the given file.
  ///
  /// @param filters Output newly created git_filter_list (or NULL)
  /// @param repo Repository object that contains `path`
  /// @param blob The blob to which the filter will be applied (if known)
  /// @param path Relative path of the file to be filtered
  /// @param mode Filtering direction (WT->ODB or ODB->WT)
  /// @param opts The `git_filter_options` to use when loading filters
  /// @return 0 on success (which could still return NULL if no filters are
  /// needed for the requested file), <0 on error
  int git_filter_list_load_ext(
    ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Char> path,
    int mode,
    ffi.Pointer<git_filter_options> opts,
  ) {
    return _git_filter_list_load_ext(
      filters,
      repo,
      blob,
      path,
      mode,
      opts,
    );
  }

  late final _git_filter_list_load_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_filter_list>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32,
              ffi.Pointer<git_filter_options>)>>('git_filter_list_load_ext');
  late final _git_filter_list_load_ext =
      _git_filter_list_load_extPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_filter_list>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              int,
              ffi.Pointer<git_filter_options>)>();

  /// Query the filter list to see if a given filter (by name) will run.
  /// The built-in filters "crlf" and "ident" can be queried, otherwise this
  /// is the name of the filter specified by the filter attribute.
  ///
  /// This will return 0 if the given filter is not in the list, or 1 if
  /// the filter will be applied.
  ///
  /// @param filters A loaded git_filter_list (or NULL)
  /// @param name The name of the filter to query
  /// @return 1 if the filter is in the list, 0 otherwise
  int git_filter_list_contains(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_filter_list_contains(
      filters,
      name,
    );
  }

  late final _git_filter_list_containsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_filter_list>,
              ffi.Pointer<ffi.Char>)>>('git_filter_list_contains');
  late final _git_filter_list_contains =
      _git_filter_list_containsPtr.asFunction<
          int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<ffi.Char>)>();

  /// Apply filter list to a data buffer.
  ///
  /// @param out Buffer to store the result of the filtering
  /// @param filters A loaded git_filter_list (or NULL)
  /// @param in Buffer containing the data to filter
  /// @param in_len The length of the input buffer
  /// @return 0 on success, an error code otherwise
  int git_filter_list_apply_to_buffer(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<ffi.Char> in1,
    int in_len,
  ) {
    return _git_filter_list_apply_to_buffer(
      out,
      filters,
      in1,
      in_len,
    );
  }

  late final _git_filter_list_apply_to_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<ffi.Char>,
              ffi.Size)>>('git_filter_list_apply_to_buffer');
  late final _git_filter_list_apply_to_buffer =
      _git_filter_list_apply_to_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<ffi.Char>, int)>();

  /// Apply a filter list to the contents of a file on disk
  ///
  /// @param out buffer into which to store the filtered file
  /// @param filters the list of filters to apply
  /// @param repo the repository in which to perform the filtering
  /// @param path the path of the file to filter, a relative path will be
  /// taken as relative to the workdir
  /// @return 0 or an error code.
  int git_filter_list_apply_to_file(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_filter_list_apply_to_file(
      out,
      filters,
      repo,
      path,
    );
  }

  late final _git_filter_list_apply_to_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_filter_list_apply_to_file');
  late final _git_filter_list_apply_to_file =
      _git_filter_list_apply_to_filePtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Apply a filter list to the contents of a blob
  ///
  /// @param out buffer into which to store the filtered file
  /// @param filters the list of filters to apply
  /// @param blob the blob to filter
  /// @return 0 or an error code.
  int git_filter_list_apply_to_blob(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_filter_list_apply_to_blob(
      out,
      filters,
      blob,
    );
  }

  late final _git_filter_list_apply_to_blobPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_blob>)>>('git_filter_list_apply_to_blob');
  late final _git_filter_list_apply_to_blob =
      _git_filter_list_apply_to_blobPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_blob>)>();

  /// Apply a filter list to an arbitrary buffer as a stream
  ///
  /// @param filters the list of filters to apply
  /// @param buffer the buffer to filter
  /// @param len the size of the buffer
  /// @param target the stream into which the data will be written
  /// @return 0 or an error code.
  int git_filter_list_stream_buffer(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<ffi.Char> buffer,
    int len,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_buffer(
      filters,
      buffer,
      len,
      target,
    );
  }

  late final _git_filter_list_stream_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<git_writestream>)>>('git_filter_list_stream_buffer');
  late final _git_filter_list_stream_buffer =
      _git_filter_list_stream_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<ffi.Char>, int,
              ffi.Pointer<git_writestream>)>();

  /// Apply a filter list to a file as a stream
  ///
  /// @param filters the list of filters to apply
  /// @param repo the repository in which to perform the filtering
  /// @param path the path of the file to filter, a relative path will be
  /// taken as relative to the workdir
  /// @param target the stream into which the data will be written
  /// @return 0 or an error code.
  int git_filter_list_stream_file(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_file(
      filters,
      repo,
      path,
      target,
    );
  }

  late final _git_filter_list_stream_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_writestream>)>>('git_filter_list_stream_file');
  late final _git_filter_list_stream_file =
      _git_filter_list_stream_filePtr.asFunction<
          int Function(
              ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_writestream>)>();

  /// Apply a filter list to a blob as a stream
  ///
  /// @param filters the list of filters to apply
  /// @param blob the blob to filter
  /// @param target the stream into which the data will be written
  /// @return 0 or an error code.
  int git_filter_list_stream_blob(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_blob(
      filters,
      blob,
      target,
    );
  }

  late final _git_filter_list_stream_blobPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<git_blob>,
              ffi.Pointer<git_writestream>)>>('git_filter_list_stream_blob');
  late final _git_filter_list_stream_blob =
      _git_filter_list_stream_blobPtr.asFunction<
          int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<git_blob>,
              ffi.Pointer<git_writestream>)>();

  /// Free a git_filter_list
  ///
  /// @param filters A git_filter_list created by `git_filter_list_load`
  void git_filter_list_free(
    ffi.Pointer<git_filter_list> filters,
  ) {
    return _git_filter_list_free(
      filters,
    );
  }

  late final _git_filter_list_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_filter_list>)>>(
      'git_filter_list_free');
  late final _git_filter_list_free = _git_filter_list_freePtr
      .asFunction<void Function(ffi.Pointer<git_filter_list>)>();

  /// Initialize git_rebase_options structure
  ///
  /// Initializes a `git_rebase_options` with default values. Equivalent to
  /// creating an instance with `GIT_REBASE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_rebase_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REBASE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_rebase_options_init(
    ffi.Pointer<git_rebase_options> opts,
    int version,
  ) {
    return _git_rebase_options_init(
      opts,
      version,
    );
  }

  late final _git_rebase_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_rebase_options>,
              ffi.UnsignedInt)>>('git_rebase_options_init');
  late final _git_rebase_options_init = _git_rebase_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_rebase_options>, int)>();

  /// Initializes a rebase operation to rebase the changes in `branch`
  /// relative to `upstream` onto another branch.  To begin the rebase
  /// process, call `git_rebase_next`.  When you have finished with this
  /// object, call `git_rebase_free`.
  ///
  /// @param out Pointer to store the rebase object
  /// @param repo The repository to perform the rebase
  /// @param branch The terminal commit to rebase, or NULL to rebase the
  /// current branch
  /// @param upstream The commit to begin rebasing from, or NULL to rebase all
  /// reachable commits
  /// @param onto The branch to rebase onto, or NULL to rebase onto the given
  /// upstream
  /// @param opts Options to specify how rebase is performed, or NULL
  /// @return Zero on success; -1 on failure.
  int git_rebase_init(
    ffi.Pointer<ffi.Pointer<git_rebase>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_annotated_commit> branch,
    ffi.Pointer<git_annotated_commit> upstream,
    ffi.Pointer<git_annotated_commit> onto,
    ffi.Pointer<git_rebase_options> opts,
  ) {
    return _git_rebase_init(
      out,
      repo,
      branch,
      upstream,
      onto,
      opts,
    );
  }

  late final _git_rebase_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_rebase>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_annotated_commit>,
              ffi.Pointer<git_annotated_commit>,
              ffi.Pointer<git_annotated_commit>,
              ffi.Pointer<git_rebase_options>)>>('git_rebase_init');
  late final _git_rebase_init = _git_rebase_initPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_rebase>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_annotated_commit>,
          ffi.Pointer<git_annotated_commit>,
          ffi.Pointer<git_annotated_commit>,
          ffi.Pointer<git_rebase_options>)>();

  /// Opens an existing rebase that was previously started by either an
  /// invocation of `git_rebase_init` or by another client.
  ///
  /// @param out Pointer to store the rebase object
  /// @param repo The repository that has a rebase in-progress
  /// @param opts Options to specify how rebase is performed
  /// @return Zero on success; -1 on failure.
  int git_rebase_open(
    ffi.Pointer<ffi.Pointer<git_rebase>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_rebase_options> opts,
  ) {
    return _git_rebase_open(
      out,
      repo,
      opts,
    );
  }

  late final _git_rebase_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_rebase>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_rebase_options>)>>('git_rebase_open');
  late final _git_rebase_open = _git_rebase_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_rebase>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_rebase_options>)>();

  /// Gets the original `HEAD` ref name for merge rebases.
  ///
  /// @param rebase The in-progress rebase.
  /// @return The original `HEAD` ref name
  ffi.Pointer<ffi.Char> git_rebase_orig_head_name(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_orig_head_name(
      rebase,
    );
  }

  late final _git_rebase_orig_head_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_rebase>)>>('git_rebase_orig_head_name');
  late final _git_rebase_orig_head_name = _git_rebase_orig_head_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_rebase>)>();

  /// Gets the original `HEAD` id for merge rebases.
  ///
  /// @param rebase The in-progress rebase.
  /// @return The original `HEAD` id
  ffi.Pointer<git_oid> git_rebase_orig_head_id(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_orig_head_id(
      rebase,
    );
  }

  late final _git_rebase_orig_head_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_rebase>)>>('git_rebase_orig_head_id');
  late final _git_rebase_orig_head_id = _git_rebase_orig_head_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_rebase>)>();

  /// Gets the `onto` ref name for merge rebases.
  ///
  /// @param rebase The in-progress rebase.
  /// @return The `onto` ref name
  ffi.Pointer<ffi.Char> git_rebase_onto_name(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_onto_name(
      rebase,
    );
  }

  late final _git_rebase_onto_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_rebase>)>>('git_rebase_onto_name');
  late final _git_rebase_onto_name = _git_rebase_onto_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_rebase>)>();

  /// Gets the `onto` id for merge rebases.
  ///
  /// @param rebase The in-progress rebase.
  /// @return The `onto` id
  ffi.Pointer<git_oid> git_rebase_onto_id(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_onto_id(
      rebase,
    );
  }

  late final _git_rebase_onto_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_rebase>)>>('git_rebase_onto_id');
  late final _git_rebase_onto_id = _git_rebase_onto_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_rebase>)>();

  /// Gets the count of rebase operations that are to be applied.
  ///
  /// @param rebase The in-progress rebase
  /// @return The number of rebase operations in total
  int git_rebase_operation_entrycount(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_operation_entrycount(
      rebase,
    );
  }

  late final _git_rebase_operation_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_rebase>)>>(
          'git_rebase_operation_entrycount');
  late final _git_rebase_operation_entrycount =
      _git_rebase_operation_entrycountPtr
          .asFunction<int Function(ffi.Pointer<git_rebase>)>();

  /// Gets the index of the rebase operation that is currently being applied.
  /// If the first operation has not yet been applied (because you have
  /// called `init` but not yet `next`) then this returns
  /// `GIT_REBASE_NO_OPERATION`.
  ///
  /// @param rebase The in-progress rebase
  /// @return The index of the rebase operation currently being applied.
  int git_rebase_operation_current(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_operation_current(
      rebase,
    );
  }

  late final _git_rebase_operation_currentPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_rebase>)>>(
          'git_rebase_operation_current');
  late final _git_rebase_operation_current = _git_rebase_operation_currentPtr
      .asFunction<int Function(ffi.Pointer<git_rebase>)>();

  /// Gets the rebase operation specified by the given index.
  ///
  /// @param rebase The in-progress rebase
  /// @param idx The index of the rebase operation to retrieve
  /// @return The rebase operation or NULL if `idx` was out of bounds
  ffi.Pointer<git_rebase_operation> git_rebase_operation_byindex(
    ffi.Pointer<git_rebase> rebase,
    int idx,
  ) {
    return _git_rebase_operation_byindex(
      rebase,
      idx,
    );
  }

  late final _git_rebase_operation_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_rebase_operation> Function(ffi.Pointer<git_rebase>,
              ffi.Size)>>('git_rebase_operation_byindex');
  late final _git_rebase_operation_byindex =
      _git_rebase_operation_byindexPtr.asFunction<
          ffi.Pointer<git_rebase_operation> Function(
              ffi.Pointer<git_rebase>, int)>();

  /// Performs the next rebase operation and returns the information about it.
  /// If the operation is one that applies a patch (which is any operation except
  /// GIT_REBASE_OPERATION_EXEC) then the patch will be applied and the index and
  /// working directory will be updated with the changes.  If there are conflicts,
  /// you will need to address those before committing the changes.
  ///
  /// @param operation Pointer to store the rebase operation that is to be performed next
  /// @param rebase The rebase in progress
  /// @return Zero on success; -1 on failure.
  int git_rebase_next(
    ffi.Pointer<ffi.Pointer<git_rebase_operation>> operation,
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_next(
      operation,
      rebase,
    );
  }

  late final _git_rebase_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_rebase_operation>>,
              ffi.Pointer<git_rebase>)>>('git_rebase_next');
  late final _git_rebase_next = _git_rebase_nextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_rebase_operation>>,
          ffi.Pointer<git_rebase>)>();

  /// Gets the index produced by the last operation, which is the result
  /// of `git_rebase_next` and which will be committed by the next
  /// invocation of `git_rebase_commit`.  This is useful for resolving
  /// conflicts in an in-memory rebase before committing them.  You must
  /// call `git_index_free` when you are finished with this.
  ///
  /// This is only applicable for in-memory rebases; for rebases within
  /// a working directory, the changes were applied to the repository's
  /// index.
  ///
  /// @param index The result index of the last operation.
  /// @param rebase The in-progress rebase.
  /// @return 0 or an error code
  int git_rebase_inmemory_index(
    ffi.Pointer<ffi.Pointer<git_index>> index,
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_inmemory_index(
      index,
      rebase,
    );
  }

  late final _git_rebase_inmemory_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_rebase>)>>('git_rebase_inmemory_index');
  late final _git_rebase_inmemory_index =
      _git_rebase_inmemory_indexPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_index>>, ffi.Pointer<git_rebase>)>();

  /// Commits the current patch.  You must have resolved any conflicts that
  /// were introduced during the patch application from the `git_rebase_next`
  /// invocation.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  /// @param rebase The rebase that is in-progress
  /// @param author The author of the updated commit, or NULL to keep the
  /// author from the original commit
  /// @param committer The committer of the rebase
  /// @param message_encoding The encoding for the message in the commit,
  /// represented with a standard encoding name.  If message is NULL,
  /// this should also be NULL, and the encoding from the original
  /// commit will be maintained.  If message is specified, this may be
  /// NULL to indicate that "UTF-8" is to be used.
  /// @param message The message for this commit, or NULL to use the message
  /// from the original commit.
  /// @return Zero on success, GIT_EUNMERGED if there are unmerged changes in
  /// the index, GIT_EAPPLIED if the current commit has already
  /// been applied to the upstream and there is nothing to commit,
  /// -1 on failure.
  int git_rebase_commit(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_rebase> rebase,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> message_encoding,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _git_rebase_commit(
      id,
      rebase,
      author,
      committer,
      message_encoding,
      message,
    );
  }

  late final _git_rebase_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_rebase>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_rebase_commit');
  late final _git_rebase_commit = _git_rebase_commitPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_rebase>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Aborts a rebase that is currently in progress, resetting the repository
  /// and working directory to their state before rebase began.
  ///
  /// @param rebase The rebase that is in-progress
  /// @return Zero on success; GIT_ENOTFOUND if a rebase is not in progress,
  /// -1 on other errors.
  int git_rebase_abort(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_abort(
      rebase,
    );
  }

  late final _git_rebase_abortPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_rebase>)>>(
          'git_rebase_abort');
  late final _git_rebase_abort =
      _git_rebase_abortPtr.asFunction<int Function(ffi.Pointer<git_rebase>)>();

  /// Finishes a rebase that is currently in progress once all patches have
  /// been applied.
  ///
  /// @param rebase The rebase that is in-progress
  /// @param signature The identity that is finishing the rebase (optional)
  /// @return Zero on success; -1 on error
  int git_rebase_finish(
    ffi.Pointer<git_rebase> rebase,
    ffi.Pointer<git_signature> signature,
  ) {
    return _git_rebase_finish(
      rebase,
      signature,
    );
  }

  late final _git_rebase_finishPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_rebase>,
              ffi.Pointer<git_signature>)>>('git_rebase_finish');
  late final _git_rebase_finish = _git_rebase_finishPtr.asFunction<
      int Function(ffi.Pointer<git_rebase>, ffi.Pointer<git_signature>)>();

  /// Frees the `git_rebase` object.
  ///
  /// @param rebase The rebase object
  void git_rebase_free(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_free(
      rebase,
    );
  }

  late final _git_rebase_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_rebase>)>>(
          'git_rebase_free');
  late final _git_rebase_free =
      _git_rebase_freePtr.asFunction<void Function(ffi.Pointer<git_rebase>)>();

  /// Sets the system tracing configuration to the specified level with the
  /// specified callback.  When system events occur at a level equal to, or
  /// lower than, the given level they will be reported to the given callback.
  ///
  /// @param level Level to set tracing to
  /// @param cb Function to call with trace data
  /// @return 0 or an error code
  int git_trace_set(
    int level,
    git_trace_cb cb,
  ) {
    return _git_trace_set(
      level,
      cb,
    );
  }

  late final _git_trace_setPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32, git_trace_cb)>>(
          'git_trace_set');
  late final _git_trace_set =
      _git_trace_setPtr.asFunction<int Function(int, git_trace_cb)>();

  /// Initialize git_revert_options structure
  ///
  /// Initializes a `git_revert_options` with default values. Equivalent to
  /// creating an instance with `GIT_REVERT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_revert_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REVERT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_revert_options_init(
    ffi.Pointer<git_revert_options> opts,
    int version,
  ) {
    return _git_revert_options_init(
      opts,
      version,
    );
  }

  late final _git_revert_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revert_options>,
              ffi.UnsignedInt)>>('git_revert_options_init');
  late final _git_revert_options_init = _git_revert_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_revert_options>, int)>();

  /// Reverts the given commit against the given "our" commit, producing an
  /// index that reflects the result of the revert.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo the repository that contains the given commits
  /// @param revert_commit the commit to revert
  /// @param our_commit the commit to revert against (eg, HEAD)
  /// @param mainline the parent of the revert commit, if it is a merge
  /// @param merge_options the merge options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_revert_commit(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> revert_commit,
    ffi.Pointer<git_commit> our_commit,
    int mainline,
    ffi.Pointer<git_merge_options> merge_options,
  ) {
    return _git_revert_commit(
      out,
      repo,
      revert_commit,
      our_commit,
      mainline,
      merge_options,
    );
  }

  late final _git_revert_commitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_index>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_commit>,
              ffi.UnsignedInt,
              ffi.Pointer<git_merge_options>)>>('git_revert_commit');
  late final _git_revert_commit = _git_revert_commitPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_index>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_commit>,
          int,
          ffi.Pointer<git_merge_options>)>();

  /// Reverts the given commit, producing changes in the index and working directory.
  ///
  /// @param repo the repository to revert
  /// @param commit the commit to revert
  /// @param given_opts the revert options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_revert(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_revert_options> given_opts,
  ) {
    return _git_revert(
      repo,
      commit,
      given_opts,
    );
  }

  late final _git_revertPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_commit>,
              ffi.Pointer<git_revert_options>)>>('git_revert');
  late final _git_revert = _git_revertPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_commit>,
          ffi.Pointer<git_revert_options>)>();

  /// Find a single object, as specified by a revision string.
  ///
  /// See `man gitrevisions`, or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// The returned object should be released with `git_object_free` when no
  /// longer needed.
  ///
  /// @param out pointer to output object
  /// @param repo the repository to search in
  /// @param spec the textual specification for an object
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EAMBIGUOUS, GIT_EINVALIDSPEC or an error code
  int git_revparse_single(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> spec,
  ) {
    return _git_revparse_single(
      out,
      repo,
      spec,
    );
  }

  late final _git_revparse_singlePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_revparse_single');
  late final _git_revparse_single = _git_revparse_singlePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Find a single object and intermediate reference by a revision string.
  ///
  /// See `man gitrevisions`, or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// In some cases (`@{<-n>}` or `<branchname>@{upstream}`), the expression may
  /// point to an intermediate reference. When such expressions are being passed
  /// in, `reference_out` will be valued as well.
  ///
  /// The returned object should be released with `git_object_free` and the
  /// returned reference with `git_reference_free` when no longer needed.
  ///
  /// @param object_out pointer to output object
  /// @param reference_out pointer to output reference or NULL
  /// @param repo the repository to search in
  /// @param spec the textual specification for an object
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EAMBIGUOUS, GIT_EINVALIDSPEC
  /// or an error code
  int git_revparse_ext(
    ffi.Pointer<ffi.Pointer<git_object>> object_out,
    ffi.Pointer<ffi.Pointer<git_reference>> reference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> spec,
  ) {
    return _git_revparse_ext(
      object_out,
      reference_out,
      repo,
      spec,
    );
  }

  late final _git_revparse_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<ffi.Pointer<git_reference>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_revparse_ext');
  late final _git_revparse_ext = _git_revparse_extPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_object>>,
          ffi.Pointer<ffi.Pointer<git_reference>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>)>();

  /// Parse a revision string for `from`, `to`, and intent.
  ///
  /// See `man gitrevisions` or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// @param revspec Pointer to an user-allocated git_revspec struct where
  /// the result of the rev-parse will be stored
  /// @param repo the repository to search in
  /// @param spec the rev-parse spec to parse
  /// @return 0 on success, GIT_INVALIDSPEC, GIT_ENOTFOUND, GIT_EAMBIGUOUS or an error code
  int git_revparse(
    ffi.Pointer<git_revspec> revspec,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> spec,
  ) {
    return _git_revparse(
      revspec,
      repo,
      spec,
    );
  }

  late final _git_revparsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_revspec>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_revparse');
  late final _git_revparse = _git_revparsePtr.asFunction<
      int Function(ffi.Pointer<git_revspec>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>)>();

  /// Save the local modifications to a new stash.
  ///
  /// @param out Object id of the commit containing the stashed state.
  /// This commit is also the target of the direct reference refs/stash.
  ///
  /// @param repo The owning repository.
  ///
  /// @param stasher The identity of the person performing the stashing.
  ///
  /// @param message Optional description along with the stashed state.
  ///
  /// @param flags Flags to control the stashing process. (see GIT_STASH_* above)
  ///
  /// @return 0 on success, GIT_ENOTFOUND where there's nothing to stash,
  /// or error code.
  int git_stash_save(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_signature> stasher,
    ffi.Pointer<ffi.Char> message,
    int flags,
  ) {
    return _git_stash_save(
      out,
      repo,
      stasher,
      message,
      flags,
    );
  }

  late final _git_stash_savePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Uint32)>>('git_stash_save');
  late final _git_stash_save = _git_stash_savePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
          ffi.Pointer<git_signature>, ffi.Pointer<ffi.Char>, int)>();

  /// Initialize git_stash_apply_options structure
  ///
  /// Initializes a `git_stash_apply_options` with default values. Equivalent to
  /// creating an instance with `GIT_STASH_APPLY_OPTIONS_INIT`.
  ///
  /// @param opts The `git_stash_apply_options` struct to initialize.
  /// @param version The struct version; pass `GIT_STASH_APPLY_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_stash_apply_options_init(
    ffi.Pointer<git_stash_apply_options> opts,
    int version,
  ) {
    return _git_stash_apply_options_init(
      opts,
      version,
    );
  }

  late final _git_stash_apply_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_stash_apply_options>,
              ffi.UnsignedInt)>>('git_stash_apply_options_init');
  late final _git_stash_apply_options_init = _git_stash_apply_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_stash_apply_options>, int)>();

  /// Apply a single stashed state from the stash list.
  ///
  /// If local changes in the working directory conflict with changes in the
  /// stash then GIT_EMERGECONFLICT will be returned.  In this case, the index
  /// will always remain unmodified and all files in the working directory will
  /// remain unmodified.  However, if you are restoring untracked files or
  /// ignored files and there is a conflict when applying the modified files,
  /// then those files will remain in the working directory.
  ///
  /// If passing the GIT_STASH_APPLY_REINSTATE_INDEX flag and there would be
  /// conflicts when reinstating the index, the function will return
  /// GIT_EMERGECONFLICT and both the working directory and index will be left
  /// unmodified.
  ///
  /// Note that a minimum checkout strategy of `GIT_CHECKOUT_SAFE` is implied.
  ///
  /// @param repo The owning repository.
  /// @param index The position within the stash list. 0 points to the
  /// most recent stashed state.
  /// @param options Optional options to control how stashes are applied.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the
  /// given index, GIT_EMERGECONFLICT if changes exist in the working
  /// directory, or an error code
  int git_stash_apply(
    ffi.Pointer<git_repository> repo,
    int index,
    ffi.Pointer<git_stash_apply_options> options,
  ) {
    return _git_stash_apply(
      repo,
      index,
      options,
    );
  }

  late final _git_stash_applyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Size,
              ffi.Pointer<git_stash_apply_options>)>>('git_stash_apply');
  late final _git_stash_apply = _git_stash_applyPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_stash_apply_options>)>();

  /// Loop over all the stashed states and issue a callback for each one.
  ///
  /// If the callback returns a non-zero value, this will stop looping.
  ///
  /// @param repo Repository where to find the stash.
  ///
  /// @param callback Callback to invoke per found stashed state. The most
  /// recent stash state will be enumerated first.
  ///
  /// @param payload Extra parameter to callback function.
  ///
  /// @return 0 on success, non-zero callback return value, or error code.
  int git_stash_foreach(
    ffi.Pointer<git_repository> repo,
    git_stash_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_stash_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_stash_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, git_stash_cb,
              ffi.Pointer<ffi.Void>)>>('git_stash_foreach');
  late final _git_stash_foreach = _git_stash_foreachPtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>, git_stash_cb, ffi.Pointer<ffi.Void>)>();

  /// Remove a single stashed state from the stash list.
  ///
  /// @param repo The owning repository.
  ///
  /// @param index The position within the stash list. 0 points to the
  /// most recent stashed state.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
  /// index, or error code.
  int git_stash_drop(
    ffi.Pointer<git_repository> repo,
    int index,
  ) {
    return _git_stash_drop(
      repo,
      index,
    );
  }

  late final _git_stash_dropPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>, ffi.Size)>>('git_stash_drop');
  late final _git_stash_drop = _git_stash_dropPtr
      .asFunction<int Function(ffi.Pointer<git_repository>, int)>();

  /// Apply a single stashed state from the stash list and remove it from the list
  /// if successful.
  ///
  /// @param repo The owning repository.
  /// @param index The position within the stash list. 0 points to the
  /// most recent stashed state.
  /// @param options Optional options to control how stashes are applied.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
  /// index, or error code. (see git_stash_apply() above for details)
  int git_stash_pop(
    ffi.Pointer<git_repository> repo,
    int index,
    ffi.Pointer<git_stash_apply_options> options,
  ) {
    return _git_stash_pop(
      repo,
      index,
      options,
    );
  }

  late final _git_stash_popPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Size,
              ffi.Pointer<git_stash_apply_options>)>>('git_stash_pop');
  late final _git_stash_pop = _git_stash_popPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, int,
          ffi.Pointer<git_stash_apply_options>)>();

  /// Initialize git_status_options structure
  ///
  /// Initializes a `git_status_options` with default values. Equivalent to
  /// creating an instance with `GIT_STATUS_OPTIONS_INIT`.
  ///
  /// @param opts The `git_status_options` struct to initialize.
  /// @param version The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_status_options_init(
    ffi.Pointer<git_status_options> opts,
    int version,
  ) {
    return _git_status_options_init(
      opts,
      version,
    );
  }

  late final _git_status_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_status_options>,
              ffi.UnsignedInt)>>('git_status_options_init');
  late final _git_status_options_init = _git_status_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_status_options>, int)>();

  /// Gather file statuses and run a callback for each one.
  ///
  /// The callback is passed the path of the file, the status (a combination of
  /// the `git_status_t` values above) and the `payload` data pointer passed
  /// into this function.
  ///
  /// If the callback returns a non-zero value, this function will stop looping
  /// and return that value to caller.
  ///
  /// @param repo A repository object
  /// @param callback The function to call on each file
  /// @param payload Pointer to pass through to callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_status_foreach(
    ffi.Pointer<git_repository> repo,
    git_status_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_status_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_status_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, git_status_cb,
              ffi.Pointer<ffi.Void>)>>('git_status_foreach');
  late final _git_status_foreach = _git_status_foreachPtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>, git_status_cb, ffi.Pointer<ffi.Void>)>();

  /// Gather file status information and run callbacks as requested.
  ///
  /// This is an extended version of the `git_status_foreach()` API that
  /// allows for more granular control over which paths will be processed and
  /// in what order.  See the `git_status_options` structure for details
  /// about the additional controls that this makes available.
  ///
  /// Note that if a `pathspec` is given in the `git_status_options` to filter
  /// the status, then the results from rename detection (if you enable it) may
  /// not be accurate.  To do rename detection properly, this must be called
  /// with no `pathspec` so that all files can be considered.
  ///
  /// @param repo Repository object
  /// @param opts Status options structure
  /// @param callback The function to call on each file
  /// @param payload Pointer to pass through to callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_status_foreach_ext(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_status_options> opts,
    git_status_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_status_foreach_ext(
      repo,
      opts,
      callback,
      payload,
    );
  }

  late final _git_status_foreach_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_status_options>,
              git_status_cb,
              ffi.Pointer<ffi.Void>)>>('git_status_foreach_ext');
  late final _git_status_foreach_ext = _git_status_foreach_extPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_status_options>,
          git_status_cb, ffi.Pointer<ffi.Void>)>();

  /// Get file status for a single file.
  ///
  /// This tries to get status for the filename that you give.  If no files
  /// match that name (in either the HEAD, index, or working directory), this
  /// returns GIT_ENOTFOUND.
  ///
  /// If the name matches multiple files (for example, if the `path` names a
  /// directory or if running on a case- insensitive filesystem and yet the
  /// HEAD has two entries that both match the path), then this returns
  /// GIT_EAMBIGUOUS because it cannot give correct results.
  ///
  /// This does not do any sort of rename detection.  Renames require a set of
  /// targets and because of the path filtering, there is not enough
  /// information to check renames correctly.  To check file status with rename
  /// detection, there is no choice but to do a full `git_status_list_new` and
  /// scan through looking for the path that you are interested in.
  ///
  /// @param status_flags Output combination of git_status_t values for file
  /// @param repo A repository object
  /// @param path The exact path to retrieve status for relative to the
  /// repository working directory
  /// @return 0 on success, GIT_ENOTFOUND if the file is not found in the HEAD,
  /// index, and work tree, GIT_EAMBIGUOUS if `path` matches multiple files
  /// or if it refers to a folder, and -1 on other errors.
  int git_status_file(
    ffi.Pointer<ffi.UnsignedInt> status_flags,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_status_file(
      status_flags,
      repo,
      path,
    );
  }

  late final _git_status_filePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_status_file');
  late final _git_status_file = _git_status_filePtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>)>();

  /// Gather file status information and populate the `git_status_list`.
  ///
  /// Note that if a `pathspec` is given in the `git_status_options` to filter
  /// the status, then the results from rename detection (if you enable it) may
  /// not be accurate.  To do rename detection properly, this must be called
  /// with no `pathspec` so that all files can be considered.
  ///
  /// @param out Pointer to store the status results in
  /// @param repo Repository object
  /// @param opts Status options structure
  /// @return 0 on success or error code
  int git_status_list_new(
    ffi.Pointer<ffi.Pointer<git_status_list>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_status_options> opts,
  ) {
    return _git_status_list_new(
      out,
      repo,
      opts,
    );
  }

  late final _git_status_list_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_status_list>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_status_options>)>>('git_status_list_new');
  late final _git_status_list_new = _git_status_list_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_status_list>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_status_options>)>();

  /// Gets the count of status entries in this list.
  ///
  /// If there are no changes in status (at least according the options given
  /// when the status list was created), this can return 0.
  ///
  /// @param statuslist Existing status list object
  /// @return the number of status entries
  int git_status_list_entrycount(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _git_status_list_entrycount(
      statuslist,
    );
  }

  late final _git_status_list_entrycountPtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_status_list>)>>(
      'git_status_list_entrycount');
  late final _git_status_list_entrycount = _git_status_list_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_status_list>)>();

  /// Get a pointer to one of the entries in the status list.
  ///
  /// The entry is not modifiable and should not be freed.
  ///
  /// @param statuslist Existing status list object
  /// @param idx Position of the entry
  /// @return Pointer to the entry; NULL if out of bounds
  ffi.Pointer<git_status_entry> git_status_byindex(
    ffi.Pointer<git_status_list> statuslist,
    int idx,
  ) {
    return _git_status_byindex(
      statuslist,
      idx,
    );
  }

  late final _git_status_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_status_entry> Function(
              ffi.Pointer<git_status_list>, ffi.Size)>>('git_status_byindex');
  late final _git_status_byindex = _git_status_byindexPtr.asFunction<
      ffi.Pointer<git_status_entry> Function(
          ffi.Pointer<git_status_list>, int)>();

  /// Free an existing status list
  ///
  /// @param statuslist Existing status list object
  void git_status_list_free(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _git_status_list_free(
      statuslist,
    );
  }

  late final _git_status_list_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_status_list>)>>(
      'git_status_list_free');
  late final _git_status_list_free = _git_status_list_freePtr
      .asFunction<void Function(ffi.Pointer<git_status_list>)>();

  /// Test if the ignore rules apply to a given file.
  ///
  /// This function checks the ignore rules to see if they would apply to the
  /// given file.  This indicates if the file would be ignored regardless of
  /// whether the file is already in the index or committed to the repository.
  ///
  /// One way to think of this is if you were to do "git add ." on the
  /// directory containing the file, would it be added or not?
  ///
  /// @param ignored Boolean returning 0 if the file is not ignored, 1 if it is
  /// @param repo A repository object
  /// @param path The file to check ignores for, rooted at the repo's workdir.
  /// @return 0 if ignore rules could be processed for the file (regardless
  /// of whether it exists or not), or an error < 0 if they could not.
  int git_status_should_ignore(
    ffi.Pointer<ffi.Int> ignored,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_status_should_ignore(
      ignored,
      repo,
      path,
    );
  }

  late final _git_status_should_ignorePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_status_should_ignore');
  late final _git_status_should_ignore =
      _git_status_should_ignorePtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Initialize git_submodule_update_options structure
  ///
  /// Initializes a `git_submodule_update_options` with default values. Equivalent to
  /// creating an instance with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_submodule_update_options` struct to initialize.
  /// @param version The struct version; pass `GIT_SUBMODULE_UPDATE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_submodule_update_options_init(
    ffi.Pointer<git_submodule_update_options> opts,
    int version,
  ) {
    return _git_submodule_update_options_init(
      opts,
      version,
    );
  }

  late final _git_submodule_update_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_submodule_update_options>,
              ffi.UnsignedInt)>>('git_submodule_update_options_init');
  late final _git_submodule_update_options_init =
      _git_submodule_update_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_submodule_update_options>, int)>();

  /// Update a submodule. This will clone a missing submodule and
  /// checkout the subrepository to the commit specified in the index of
  /// the containing repository. If the submodule repository doesn't contain
  /// the target commit (e.g. because fetchRecurseSubmodules isn't set), then
  /// the submodule is fetched using the fetch options supplied in options.
  ///
  /// @param submodule Submodule object
  /// @param init If the submodule is not initialized, setting this flag to true
  /// will initialize the submodule before updating. Otherwise, this will
  /// return an error if attempting to update an uninitialized repository.
  /// but setting this to true forces them to be updated.
  /// @param options configuration options for the update.  If NULL, the
  /// function works as though GIT_SUBMODULE_UPDATE_OPTIONS_INIT was passed.
  /// @return 0 on success, any non-zero return value from a callback
  /// function, or a negative value to indicate an error (use
  /// `git_error_last` for a detailed error message).
  int git_submodule_update(
    ffi.Pointer<git_submodule> submodule,
    int init,
    ffi.Pointer<git_submodule_update_options> options,
  ) {
    return _git_submodule_update(
      submodule,
      init,
      options,
    );
  }

  late final _git_submodule_updatePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_submodule>, ffi.Int,
                  ffi.Pointer<git_submodule_update_options>)>>(
      'git_submodule_update');
  late final _git_submodule_update = _git_submodule_updatePtr.asFunction<
      int Function(ffi.Pointer<git_submodule>, int,
          ffi.Pointer<git_submodule_update_options>)>();

  /// Lookup submodule information by name or path.
  ///
  /// Given either the submodule name or path (they are usually the same), this
  /// returns a structure describing the submodule.
  ///
  /// There are two expected error scenarios:
  ///
  /// - The submodule is not mentioned in the HEAD, the index, and the config,
  /// but does "exist" in the working directory (i.e. there is a subdirectory
  /// that appears to be a Git repository).  In this case, this function
  /// returns GIT_EEXISTS to indicate a sub-repository exists but not in a
  /// state where a git_submodule can be instantiated.
  /// - The submodule is not mentioned in the HEAD, index, or config and the
  /// working directory doesn't contain a value git repo at that path.
  /// There may or may not be anything else at that path, but nothing that
  /// looks like a submodule.  In this case, this returns GIT_ENOTFOUND.
  ///
  /// You must call `git_submodule_free` when done with the submodule.
  ///
  /// @param out Output ptr to submodule; pass NULL to just get return code
  /// @param repo The parent repository
  /// @param name The name of or path to the submodule; trailing slashes okay
  /// @return 0 on success, GIT_ENOTFOUND if submodule does not exist,
  /// GIT_EEXISTS if a repository is found in working directory only,
  /// -1 on other errors.
  int git_submodule_lookup(
    ffi.Pointer<ffi.Pointer<git_submodule>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_submodule_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_submodule_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_submodule>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_submodule_lookup');
  late final _git_submodule_lookup = _git_submodule_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_submodule>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Create an in-memory copy of a submodule. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the submodule.
  /// @param source Original submodule to copy.
  /// @return 0
  int git_submodule_dup(
    ffi.Pointer<ffi.Pointer<git_submodule>> out,
    ffi.Pointer<git_submodule> source,
  ) {
    return _git_submodule_dup(
      out,
      source,
    );
  }

  late final _git_submodule_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_submodule>>,
              ffi.Pointer<git_submodule>)>>('git_submodule_dup');
  late final _git_submodule_dup = _git_submodule_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_submodule>>,
          ffi.Pointer<git_submodule>)>();

  /// Release a submodule
  ///
  /// @param submodule Submodule object
  void git_submodule_free(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_free(
      submodule,
    );
  }

  late final _git_submodule_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_submodule>)>>(
      'git_submodule_free');
  late final _git_submodule_free = _git_submodule_freePtr
      .asFunction<void Function(ffi.Pointer<git_submodule>)>();

  /// Iterate over all tracked submodules of a repository.
  ///
  /// See the note on `git_submodule` above.  This iterates over the tracked
  /// submodules as described therein.
  ///
  /// If you are concerned about items in the working directory that look like
  /// submodules but are not tracked, the diff API will generate a diff record
  /// for workdir items that look like submodules but are not tracked, showing
  /// them as added in the workdir.  Also, the status API will treat the entire
  /// subdirectory of a contained git repo as a single GIT_STATUS_WT_NEW item.
  ///
  /// @param repo The repository
  /// @param callback Function to be called with the name of each submodule.
  /// Return a non-zero value to terminate the iteration.
  /// @param payload Extra data to pass to callback
  /// @return 0 on success, -1 on error, or non-zero return value of callback
  int git_submodule_foreach(
    ffi.Pointer<git_repository> repo,
    git_submodule_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_submodule_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_submodule_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, git_submodule_cb,
              ffi.Pointer<ffi.Void>)>>('git_submodule_foreach');
  late final _git_submodule_foreach = _git_submodule_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, git_submodule_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Set up a new git submodule for checkout.
  ///
  /// This does "git submodule add" up to the fetch and checkout of the
  /// submodule contents.  It preps a new submodule, creates an entry in
  /// .gitmodules and creates an empty initialized repository either at the
  /// given path in the working directory or in .git/modules with a gitlink
  /// from the working directory to the new repo.
  ///
  /// To fully emulate "git submodule add" call this function, then open the
  /// submodule repo and perform the clone step as needed (if you don't need
  /// anything custom see `git_submodule_add_clone()`). Lastly, call
  /// `git_submodule_add_finalize()` to wrap up adding the new submodule and
  /// .gitmodules to the index to be ready to commit.
  ///
  /// You must call `git_submodule_free` on the submodule object when done.
  ///
  /// @param out The newly created submodule ready to open for clone
  /// @param repo The repository in which you want to create the submodule
  /// @param url URL for the submodule's remote
  /// @param path Path at which the submodule should be created
  /// @param use_gitlink Should workdir contain a gitlink to the repo in
  /// .git/modules vs. repo directly in workdir.
  /// @return 0 on success, GIT_EEXISTS if submodule already exists,
  /// -1 on other errors.
  int git_submodule_add_setup(
    ffi.Pointer<ffi.Pointer<git_submodule>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> path,
    int use_gitlink,
  ) {
    return _git_submodule_add_setup(
      out,
      repo,
      url,
      path,
      use_gitlink,
    );
  }

  late final _git_submodule_add_setupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_submodule>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_submodule_add_setup');
  late final _git_submodule_add_setup = _git_submodule_add_setupPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_submodule>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Perform the clone step for a newly created submodule.
  ///
  /// This performs the necessary `git_clone` to setup a newly-created submodule.
  ///
  /// @param out The newly created repository object. Optional.
  /// @param submodule The submodule currently waiting for its clone.
  /// @param opts The options to use.
  ///
  /// @return 0 on success, -1 on other errors (see git_clone).
  int git_submodule_clone(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_submodule> submodule,
    ffi.Pointer<git_submodule_update_options> opts,
  ) {
    return _git_submodule_clone(
      out,
      submodule,
      opts,
    );
  }

  late final _git_submodule_clonePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_repository>>,
                  ffi.Pointer<git_submodule>,
                  ffi.Pointer<git_submodule_update_options>)>>(
      'git_submodule_clone');
  late final _git_submodule_clone = _git_submodule_clonePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<git_submodule>,
          ffi.Pointer<git_submodule_update_options>)>();

  /// Resolve the setup of a new git submodule.
  ///
  /// This should be called on a submodule once you have called add setup
  /// and done the clone of the submodule.  This adds the .gitmodules file
  /// and the newly cloned submodule to the index to be ready to be committed
  /// (but doesn't actually do the commit).
  ///
  /// @param submodule The submodule to finish adding.
  /// @return 0 or an error code.
  int git_submodule_add_finalize(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_add_finalize(
      submodule,
    );
  }

  late final _git_submodule_add_finalizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_submodule>)>>(
          'git_submodule_add_finalize');
  late final _git_submodule_add_finalize = _git_submodule_add_finalizePtr
      .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Add current submodule HEAD commit to index of superproject.
  ///
  /// @param submodule The submodule to add to the index
  /// @param write_index Boolean if this should immediately write the index
  /// file.  If you pass this as false, you will have to get the
  /// git_index and explicitly call `git_index_write()` on it to
  /// save the change.
  /// @return 0 on success, <0 on failure
  int git_submodule_add_to_index(
    ffi.Pointer<git_submodule> submodule,
    int write_index,
  ) {
    return _git_submodule_add_to_index(
      submodule,
      write_index,
    );
  }

  late final _git_submodule_add_to_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_submodule>,
              ffi.Int)>>('git_submodule_add_to_index');
  late final _git_submodule_add_to_index = _git_submodule_add_to_indexPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>, int)>();

  /// Get the containing repository for a submodule.
  ///
  /// This returns a pointer to the repository that contains the submodule.
  /// This is a just a reference to the repository that was passed to the
  /// original `git_submodule_lookup()` call, so if that repository has been
  /// freed, then this may be a dangling reference.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to `git_repository`
  ffi.Pointer<git_repository> git_submodule_owner(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_owner(
      submodule,
    );
  }

  late final _git_submodule_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_owner');
  late final _git_submodule_owner = _git_submodule_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_submodule>)>();

  /// Get the name of submodule.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule name
  ffi.Pointer<ffi.Char> git_submodule_name(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_name(
      submodule,
    );
  }

  late final _git_submodule_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_name');
  late final _git_submodule_name = _git_submodule_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule>)>();

  /// Get the path to the submodule.
  ///
  /// The path is almost always the same as the submodule name, but the
  /// two are actually not required to match.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule path
  ffi.Pointer<ffi.Char> git_submodule_path(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_path(
      submodule,
    );
  }

  late final _git_submodule_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_path');
  late final _git_submodule_path = _git_submodule_pathPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule>)>();

  /// Get the URL for the submodule.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule url
  ffi.Pointer<ffi.Char> git_submodule_url(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_url(
      submodule,
    );
  }

  late final _git_submodule_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_url');
  late final _git_submodule_url = _git_submodule_urlPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule>)>();

  /// Resolve a submodule url relative to the given repository.
  ///
  /// @param out buffer to store the absolute submodule url in
  /// @param repo Pointer to repository object
  /// @param url Relative url
  /// @return 0 or an error code
  int git_submodule_resolve_url(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_submodule_resolve_url(
      out,
      repo,
      url,
    );
  }

  late final _git_submodule_resolve_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_submodule_resolve_url');
  late final _git_submodule_resolve_url =
      _git_submodule_resolve_urlPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the branch for the submodule.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule branch
  ffi.Pointer<ffi.Char> git_submodule_branch(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_branch(
      submodule,
    );
  }

  late final _git_submodule_branchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_branch');
  late final _git_submodule_branch = _git_submodule_branchPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_submodule>)>();

  /// Set the branch for the submodule in the configuration
  ///
  /// After calling this, you may wish to call `git_submodule_sync()` to
  /// write the changes to the checked out submodule repository.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submodule to configure
  /// @param branch Branch that should be used for the submodule
  /// @return 0 on success, <0 on failure
  int git_submodule_set_branch(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> branch,
  ) {
    return _git_submodule_set_branch(
      repo,
      name,
      branch,
    );
  }

  late final _git_submodule_set_branchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_submodule_set_branch');
  late final _git_submodule_set_branch =
      _git_submodule_set_branchPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  /// Set the URL for the submodule in the configuration
  ///
  ///
  /// After calling this, you may wish to call `git_submodule_sync()` to
  /// write the changes to the checked out submodule repository.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submodule to configure
  /// @param url URL that should be used for the submodule
  /// @return 0 on success, <0 on failure
  int git_submodule_set_url(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> url,
  ) {
    return _git_submodule_set_url(
      repo,
      name,
      url,
    );
  }

  late final _git_submodule_set_urlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_submodule_set_url');
  late final _git_submodule_set_url = _git_submodule_set_urlPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Get the OID for the submodule in the index.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to git_oid or NULL if submodule is not in index.
  ffi.Pointer<git_oid> git_submodule_index_id(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_index_id(
      submodule,
    );
  }

  late final _git_submodule_index_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_index_id');
  late final _git_submodule_index_id = _git_submodule_index_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_submodule>)>();

  /// Get the OID for the submodule in the current HEAD tree.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to git_oid or NULL if submodule is not in the HEAD.
  ffi.Pointer<git_oid> git_submodule_head_id(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_head_id(
      submodule,
    );
  }

  late final _git_submodule_head_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_head_id');
  late final _git_submodule_head_id = _git_submodule_head_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_submodule>)>();

  /// Get the OID for the submodule in the current working directory.
  ///
  /// This returns the OID that corresponds to looking up 'HEAD' in the checked
  /// out submodule.  If there are pending changes in the index or anything
  /// else, this won't notice that.  You should call `git_submodule_status()`
  /// for a more complete picture about the state of the working directory.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to git_oid or NULL if submodule is not checked out.
  ffi.Pointer<git_oid> git_submodule_wd_id(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_wd_id(
      submodule,
    );
  }

  late final _git_submodule_wd_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_submodule>)>>('git_submodule_wd_id');
  late final _git_submodule_wd_id = _git_submodule_wd_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_submodule>)>();

  /// Get the ignore rule that will be used for the submodule.
  ///
  /// These values control the behavior of `git_submodule_status()` for this
  /// submodule.  There are four ignore values:
  ///
  /// - **GIT_SUBMODULE_IGNORE_NONE** will consider any change to the contents
  /// of the submodule from a clean checkout to be dirty, including the
  /// addition of untracked files.  This is the default if unspecified.
  /// - **GIT_SUBMODULE_IGNORE_UNTRACKED** examines the contents of the
  /// working tree (i.e. call `git_status_foreach()` on the submodule) but
  /// UNTRACKED files will not count as making the submodule dirty.
  /// - **GIT_SUBMODULE_IGNORE_DIRTY** means to only check if the HEAD of the
  /// submodule has moved for status.  This is fast since it does not need to
  /// scan the working tree of the submodule at all.
  /// - **GIT_SUBMODULE_IGNORE_ALL** means not to open the submodule repo.
  /// The working directory will be consider clean so long as there is a
  /// checked out version present.
  ///
  /// @param submodule The submodule to check
  /// @return The current git_submodule_ignore_t valyue what will be used for
  /// this submodule.
  int git_submodule_ignore(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_ignore(
      submodule,
    );
  }

  late final _git_submodule_ignorePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_submodule>)>>(
      'git_submodule_ignore');
  late final _git_submodule_ignore = _git_submodule_ignorePtr
      .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Set the ignore rule for the submodule in the configuration
  ///
  /// This does not affect any currently-loaded instances.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submdule
  /// @param ignore The new value for the ignore rule
  /// @return 0 or an error code
  int git_submodule_set_ignore(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    int ignore,
  ) {
    return _git_submodule_set_ignore(
      repo,
      name,
      ignore,
    );
  }

  late final _git_submodule_set_ignorePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_submodule_set_ignore');
  late final _git_submodule_set_ignore =
      _git_submodule_set_ignorePtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Get the update rule that will be used for the submodule.
  ///
  /// This value controls the behavior of the `git submodule update` command.
  /// There are four useful values documented with `git_submodule_update_t`.
  ///
  /// @param submodule The submodule to check
  /// @return The current git_submodule_update_t value that will be used
  /// for this submodule.
  int git_submodule_update_strategy(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_update_strategy(
      submodule,
    );
  }

  late final _git_submodule_update_strategyPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_submodule>)>>(
      'git_submodule_update_strategy');
  late final _git_submodule_update_strategy = _git_submodule_update_strategyPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Set the update rule for the submodule in the configuration
  ///
  /// This setting won't affect any existing instances.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submodule to configure
  /// @param update The new value to use
  /// @return 0 or an error code
  int git_submodule_set_update(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    int update,
  ) {
    return _git_submodule_set_update(
      repo,
      name,
      update,
    );
  }

  late final _git_submodule_set_updatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_submodule_set_update');
  late final _git_submodule_set_update =
      _git_submodule_set_updatePtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Read the fetchRecurseSubmodules rule for a submodule.
  ///
  /// This accesses the submodule.<name>.fetchRecurseSubmodules value for
  /// the submodule that controls fetching behavior for the submodule.
  ///
  /// Note that at this time, libgit2 does not honor this setting and the
  /// fetch functionality current ignores submodules.
  ///
  /// @return 0 if fetchRecurseSubmodules is false, 1 if true
  int git_submodule_fetch_recurse_submodules(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_fetch_recurse_submodules(
      submodule,
    );
  }

  late final _git_submodule_fetch_recurse_submodulesPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_submodule>)>>(
      'git_submodule_fetch_recurse_submodules');
  late final _git_submodule_fetch_recurse_submodules =
      _git_submodule_fetch_recurse_submodulesPtr
          .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Set the fetchRecurseSubmodules rule for a submodule in the configuration
  ///
  /// This setting won't affect any existing instances.
  ///
  /// @param repo the repository to affect
  /// @param name the submodule to configure
  /// @param fetch_recurse_submodules Boolean value
  /// @return old value for fetchRecurseSubmodules
  int git_submodule_set_fetch_recurse_submodules(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    int fetch_recurse_submodules,
  ) {
    return _git_submodule_set_fetch_recurse_submodules(
      repo,
      name,
      fetch_recurse_submodules,
    );
  }

  late final _git_submodule_set_fetch_recurse_submodulesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_submodule_set_fetch_recurse_submodules');
  late final _git_submodule_set_fetch_recurse_submodules =
      _git_submodule_set_fetch_recurse_submodulesPtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>, int)>();

  /// Copy submodule info into ".git/config" file.
  ///
  /// Just like "git submodule init", this copies information about the
  /// submodule into ".git/config".  You can use the accessor functions
  /// above to alter the in-memory git_submodule object and control what
  /// is written to the config, overriding what is in .gitmodules.
  ///
  /// @param submodule The submodule to write into the superproject config
  /// @param overwrite By default, existing entries will not be overwritten,
  /// but setting this to true forces them to be updated.
  /// @return 0 on success, <0 on failure.
  int git_submodule_init(
    ffi.Pointer<git_submodule> submodule,
    int overwrite,
  ) {
    return _git_submodule_init(
      submodule,
      overwrite,
    );
  }

  late final _git_submodule_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_submodule>, ffi.Int)>>('git_submodule_init');
  late final _git_submodule_init = _git_submodule_initPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>, int)>();

  /// Set up the subrepository for a submodule in preparation for clone.
  ///
  /// This function can be called to init and set up a submodule
  /// repository from a submodule in preparation to clone it from
  /// its remote.
  ///
  /// @param out Output pointer to the created git repository.
  /// @param sm The submodule to create a new subrepository from.
  /// @param use_gitlink Should the workdir contain a gitlink to
  /// the repo in .git/modules vs. repo directly in workdir.
  /// @return 0 on success, <0 on failure.
  int git_submodule_repo_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_submodule> sm,
    int use_gitlink,
  ) {
    return _git_submodule_repo_init(
      out,
      sm,
      use_gitlink,
    );
  }

  late final _git_submodule_repo_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_submodule>, ffi.Int)>>('git_submodule_repo_init');
  late final _git_submodule_repo_init = _git_submodule_repo_initPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<git_submodule>, int)>();

  /// Copy submodule remote info into submodule repo.
  ///
  /// This copies the information about the submodules URL into the checked out
  /// submodule config, acting like "git submodule sync".  This is useful if
  /// you have altered the URL for the submodule (or it has been altered by a
  /// fetch of upstream changes) and you need to update your local repo.
  ///
  /// @param submodule The submodule to copy.
  /// @return 0 or an error code.
  int git_submodule_sync(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_sync(
      submodule,
    );
  }

  late final _git_submodule_syncPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_submodule>)>>(
          'git_submodule_sync');
  late final _git_submodule_sync = _git_submodule_syncPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>)>();

  /// Open the repository for a submodule.
  ///
  /// This is a newly opened repository object.  The caller is responsible for
  /// calling `git_repository_free()` on it when done.  Multiple calls to this
  /// function will return distinct `git_repository` objects.  This will only
  /// work if the submodule is checked out into the working directory.
  ///
  /// @param repo Pointer to the submodule repo which was opened
  /// @param submodule Submodule to be opened
  /// @return 0 on success, <0 if submodule repo could not be opened.
  int git_submodule_open(
    ffi.Pointer<ffi.Pointer<git_repository>> repo,
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_open(
      repo,
      submodule,
    );
  }

  late final _git_submodule_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
              ffi.Pointer<git_submodule>)>>('git_submodule_open');
  late final _git_submodule_open = _git_submodule_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
          ffi.Pointer<git_submodule>)>();

  /// Reread submodule info from config, index, and HEAD.
  ///
  /// Call this to reread cached submodule information for this submodule if
  /// you have reason to believe that it has changed.
  ///
  /// @param submodule The submodule to reload
  /// @param force Force reload even if the data doesn't seem out of date
  /// @return 0 on success, <0 on error
  int git_submodule_reload(
    ffi.Pointer<git_submodule> submodule,
    int force,
  ) {
    return _git_submodule_reload(
      submodule,
      force,
    );
  }

  late final _git_submodule_reloadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_submodule>, ffi.Int)>>('git_submodule_reload');
  late final _git_submodule_reload = _git_submodule_reloadPtr
      .asFunction<int Function(ffi.Pointer<git_submodule>, int)>();

  /// Get the status for a submodule.
  ///
  /// This looks at a submodule and tries to determine the status.  It
  /// will return a combination of the `GIT_SUBMODULE_STATUS` values above.
  /// How deeply it examines the working directory to do this will depend
  /// on the `git_submodule_ignore_t` value for the submodule.
  ///
  /// @param status Combination of `GIT_SUBMODULE_STATUS` flags
  /// @param repo the repository in which to look
  /// @param name name of the submodule
  /// @param ignore the ignore rules to follow
  /// @return 0 on success, <0 on error
  int git_submodule_status(
    ffi.Pointer<ffi.UnsignedInt> status,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    int ignore,
  ) {
    return _git_submodule_status(
      status,
      repo,
      name,
      ignore,
    );
  }

  late final _git_submodule_statusPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_submodule_status');
  late final _git_submodule_status = _git_submodule_statusPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>, int)>();

  /// Get the locations of submodule information.
  ///
  /// This is a bit like a very lightweight version of `git_submodule_status`.
  /// It just returns a made of the first four submodule status values (i.e.
  /// the ones like GIT_SUBMODULE_STATUS_IN_HEAD, etc) that tell you where the
  /// submodule data comes from (i.e. the HEAD commit, gitmodules file, etc.).
  /// This can be useful if you want to know if the submodule is present in the
  /// working directory at this point in time, etc.
  ///
  /// @param location_status Combination of first four `GIT_SUBMODULE_STATUS` flags
  /// @param submodule Submodule for which to get status
  /// @return 0 on success, <0 on error
  int git_submodule_location(
    ffi.Pointer<ffi.UnsignedInt> location_status,
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_location(
      location_status,
      submodule,
    );
  }

  late final _git_submodule_locationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>,
              ffi.Pointer<git_submodule>)>>('git_submodule_location');
  late final _git_submodule_location = _git_submodule_locationPtr.asFunction<
      int Function(ffi.Pointer<ffi.UnsignedInt>, ffi.Pointer<git_submodule>)>();

  /// List names of linked working trees
  ///
  /// The returned list should be released with `git_strarray_free`
  /// when no longer needed.
  ///
  /// @param out pointer to the array of working tree names
  /// @param repo the repo to use when listing working trees
  /// @return 0 or an error code
  int git_worktree_list(
    ffi.Pointer<git_strarray> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_worktree_list(
      out,
      repo,
    );
  }

  late final _git_worktree_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>)>>('git_worktree_list');
  late final _git_worktree_list = _git_worktree_listPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>)>();

  /// Lookup a working tree by its name for a given repository
  ///
  /// @param out Output pointer to looked up worktree or `NULL`
  /// @param repo The repository containing worktrees
  /// @param name Name of the working tree to look up
  /// @return 0 or an error code
  int git_worktree_lookup(
    ffi.Pointer<ffi.Pointer<git_worktree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_worktree_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_worktree_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_worktree>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_worktree_lookup');
  late final _git_worktree_lookup = _git_worktree_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_worktree>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Open a worktree of a given repository
  ///
  /// If a repository is not the main tree but a worktree, this
  /// function will look up the worktree inside the parent
  /// repository and create a new `git_worktree` structure.
  ///
  /// @param out Out-pointer for the newly allocated worktree
  /// @param repo Repository to look up worktree for
  /// @return 0 or an error code
  int git_worktree_open_from_repository(
    ffi.Pointer<ffi.Pointer<git_worktree>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_worktree_open_from_repository(
      out,
      repo,
    );
  }

  late final _git_worktree_open_from_repositoryPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Pointer<git_worktree>>,
                  ffi.Pointer<git_repository>)>>(
      'git_worktree_open_from_repository');
  late final _git_worktree_open_from_repository =
      _git_worktree_open_from_repositoryPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_worktree>>,
              ffi.Pointer<git_repository>)>();

  /// Free a previously allocated worktree
  ///
  /// @param wt worktree handle to close. If NULL nothing occurs.
  void git_worktree_free(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_free(
      wt,
    );
  }

  late final _git_worktree_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_worktree>)>>(
          'git_worktree_free');
  late final _git_worktree_free = _git_worktree_freePtr
      .asFunction<void Function(ffi.Pointer<git_worktree>)>();

  /// Check if worktree is valid
  ///
  /// A valid worktree requires both the git data structures inside
  /// the linked parent repository and the linked working copy to be
  /// present.
  ///
  /// @param wt Worktree to check
  /// @return 0 when worktree is valid, error-code otherwise
  int git_worktree_validate(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_validate(
      wt,
    );
  }

  late final _git_worktree_validatePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_worktree>)>>(
          'git_worktree_validate');
  late final _git_worktree_validate = _git_worktree_validatePtr
      .asFunction<int Function(ffi.Pointer<git_worktree>)>();

  /// Initialize git_worktree_add_options structure
  ///
  /// Initializes a `git_worktree_add_options` with default values. Equivalent to
  /// creating an instance with `GIT_WORKTREE_ADD_OPTIONS_INIT`.
  ///
  /// @param opts The `git_worktree_add_options` struct to initialize.
  /// @param version The struct version; pass `GIT_WORKTREE_ADD_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_worktree_add_options_init(
    ffi.Pointer<git_worktree_add_options> opts,
    int version,
  ) {
    return _git_worktree_add_options_init(
      opts,
      version,
    );
  }

  late final _git_worktree_add_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree_add_options>,
              ffi.UnsignedInt)>>('git_worktree_add_options_init');
  late final _git_worktree_add_options_init = _git_worktree_add_options_initPtr
      .asFunction<int Function(ffi.Pointer<git_worktree_add_options>, int)>();

  /// Add a new working tree
  ///
  /// Add a new working tree for the repository, that is create the
  /// required data structures inside the repository and check out
  /// the current HEAD at `path`
  ///
  /// @param out Output pointer containing new working tree
  /// @param repo Repository to create working tree for
  /// @param name Name of the working tree
  /// @param path Path to create working tree at
  /// @param opts Options to modify default behavior. May be NULL
  /// @return 0 or an error code
  int git_worktree_add(
    ffi.Pointer<ffi.Pointer<git_worktree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> path,
    ffi.Pointer<git_worktree_add_options> opts,
  ) {
    return _git_worktree_add(
      out,
      repo,
      name,
      path,
      opts,
    );
  }

  late final _git_worktree_addPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_worktree>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_worktree_add_options>)>>('git_worktree_add');
  late final _git_worktree_add = _git_worktree_addPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_worktree>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_worktree_add_options>)>();

  /// Lock worktree if not already locked
  ///
  /// Lock a worktree, optionally specifying a reason why the linked
  /// working tree is being locked.
  ///
  /// @param wt Worktree to lock
  /// @param reason Reason why the working tree is being locked
  /// @return 0 on success, non-zero otherwise
  int git_worktree_lock(
    ffi.Pointer<git_worktree> wt,
    ffi.Pointer<ffi.Char> reason,
  ) {
    return _git_worktree_lock(
      wt,
      reason,
    );
  }

  late final _git_worktree_lockPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree>,
              ffi.Pointer<ffi.Char>)>>('git_worktree_lock');
  late final _git_worktree_lock = _git_worktree_lockPtr.asFunction<
      int Function(ffi.Pointer<git_worktree>, ffi.Pointer<ffi.Char>)>();

  /// Unlock a locked worktree
  ///
  /// @param wt Worktree to unlock
  /// @return 0 on success, 1 if worktree was not locked, error-code
  /// otherwise
  int git_worktree_unlock(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_unlock(
      wt,
    );
  }

  late final _git_worktree_unlockPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_worktree>)>>(
          'git_worktree_unlock');
  late final _git_worktree_unlock = _git_worktree_unlockPtr
      .asFunction<int Function(ffi.Pointer<git_worktree>)>();

  /// Check if worktree is locked
  ///
  /// A worktree may be locked if the linked working tree is stored
  /// on a portable device which is not available.
  ///
  /// @param reason Buffer to store reason in. If NULL no reason is stored.
  /// @param wt Worktree to check
  /// @return 0 when the working tree not locked, a value greater
  /// than zero if it is locked, less than zero if there was an
  /// error
  int git_worktree_is_locked(
    ffi.Pointer<git_buf> reason,
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_is_locked(
      reason,
      wt,
    );
  }

  late final _git_worktree_is_lockedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_worktree>)>>('git_worktree_is_locked');
  late final _git_worktree_is_locked = _git_worktree_is_lockedPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_worktree>)>();

  /// Retrieve the name of the worktree
  ///
  /// @param wt Worktree to get the name for
  /// @return The worktree's name. The pointer returned is valid for the
  /// lifetime of the git_worktree
  ffi.Pointer<ffi.Char> git_worktree_name(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_name(
      wt,
    );
  }

  late final _git_worktree_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_worktree>)>>('git_worktree_name');
  late final _git_worktree_name = _git_worktree_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_worktree>)>();

  /// Retrieve the filesystem path for the worktree
  ///
  /// @param wt Worktree to get the path for
  /// @return The worktree's filesystem path. The pointer returned
  /// is valid for the lifetime of the git_worktree.
  ffi.Pointer<ffi.Char> git_worktree_path(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_path(
      wt,
    );
  }

  late final _git_worktree_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_worktree>)>>('git_worktree_path');
  late final _git_worktree_path = _git_worktree_pathPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_worktree>)>();

  /// Initialize git_worktree_prune_options structure
  ///
  /// Initializes a `git_worktree_prune_options` with default values. Equivalent to
  /// creating an instance with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_worktree_prune_options` struct to initialize.
  /// @param version The struct version; pass `GIT_WORKTREE_PRUNE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_worktree_prune_options_init(
    ffi.Pointer<git_worktree_prune_options> opts,
    int version,
  ) {
    return _git_worktree_prune_options_init(
      opts,
      version,
    );
  }

  late final _git_worktree_prune_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree_prune_options>,
              ffi.UnsignedInt)>>('git_worktree_prune_options_init');
  late final _git_worktree_prune_options_init =
      _git_worktree_prune_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_worktree_prune_options>, int)>();

  /// Is the worktree prunable with the given options?
  ///
  /// A worktree is not prunable in the following scenarios:
  ///
  /// - the worktree is linking to a valid on-disk worktree. The
  /// `valid` member will cause this check to be ignored.
  /// - the worktree is locked. The `locked` flag will cause this
  /// check to be ignored.
  ///
  /// If the worktree is not valid and not locked or if the above
  /// flags have been passed in, this function will return a
  /// positive value.
  ///
  /// @param wt Worktree to check.
  /// @param opts The prunable options.
  /// @return 1 if the worktree is prunable, 0 otherwise, or an error code.
  int git_worktree_is_prunable(
    ffi.Pointer<git_worktree> wt,
    ffi.Pointer<git_worktree_prune_options> opts,
  ) {
    return _git_worktree_is_prunable(
      wt,
      opts,
    );
  }

  late final _git_worktree_is_prunablePtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_worktree>,
                  ffi.Pointer<git_worktree_prune_options>)>>(
      'git_worktree_is_prunable');
  late final _git_worktree_is_prunable =
      _git_worktree_is_prunablePtr.asFunction<
          int Function(ffi.Pointer<git_worktree>,
              ffi.Pointer<git_worktree_prune_options>)>();

  /// Prune working tree
  ///
  /// Prune the working tree, that is remove the git data
  /// structures on disk. The repository will only be pruned of
  /// `git_worktree_is_prunable` succeeds.
  ///
  /// @param wt Worktree to prune
  /// @param opts Specifies which checks to override. See
  /// `git_worktree_is_prunable`. May be NULL
  /// @return 0 or an error code
  int git_worktree_prune(
    ffi.Pointer<git_worktree> wt,
    ffi.Pointer<git_worktree_prune_options> opts,
  ) {
    return _git_worktree_prune(
      wt,
      opts,
    );
  }

  late final _git_worktree_prunePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree>,
              ffi.Pointer<git_worktree_prune_options>)>>('git_worktree_prune');
  late final _git_worktree_prune = _git_worktree_prunePtr.asFunction<
      int Function(ffi.Pointer<git_worktree>,
          ffi.Pointer<git_worktree_prune_options>)>();

  /// Stock callback usable as a git_credential_acquire_cb.  This calls
  /// git_cred_userpass_plaintext_new unless the protocol has not specified
  /// `GIT_CREDENTIAL_USERPASS_PLAINTEXT` as an allowed type.
  ///
  /// @param out The newly created credential object.
  /// @param url The resource for which we are demanding a credential.
  /// @param user_from_url The username that was embedded in a "user\@host"
  /// remote url, or NULL if not included.
  /// @param allowed_types A bitmask stating which credential types are OK to return.
  /// @param payload The payload provided when specifying this callback.  (This is
  /// interpreted as a `git_credential_userpass_payload*`.)
  /// @return 0 or an error code.
  int git_credential_userpass(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> user_from_url,
    int allowed_types,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_credential_userpass(
      out,
      url,
      user_from_url,
      allowed_types,
      payload,
    );
  }

  late final _git_credential_userpassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>)>>('git_credential_userpass');
  late final _git_credential_userpass = _git_credential_userpassPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_credential>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Void>)>();

  int git_blob_create_fromworkdir(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> relative_path,
  ) {
    return _git_blob_create_fromworkdir(
      id,
      repo,
      relative_path,
    );
  }

  late final _git_blob_create_fromworkdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_blob_create_fromworkdir');
  late final _git_blob_create_fromworkdir =
      _git_blob_create_fromworkdirPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  int git_blob_create_fromdisk(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_blob_create_fromdisk(
      id,
      repo,
      path,
    );
  }

  late final _git_blob_create_fromdiskPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_blob_create_fromdisk');
  late final _git_blob_create_fromdisk =
      _git_blob_create_fromdiskPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  int git_blob_create_fromstream(
    ffi.Pointer<ffi.Pointer<git_writestream>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> hintpath,
  ) {
    return _git_blob_create_fromstream(
      out,
      repo,
      hintpath,
    );
  }

  late final _git_blob_create_fromstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_writestream>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_blob_create_fromstream');
  late final _git_blob_create_fromstream =
      _git_blob_create_fromstreamPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_writestream>>,
              ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  int git_blob_create_fromstream_commit(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_writestream> stream,
  ) {
    return _git_blob_create_fromstream_commit(
      out,
      stream,
    );
  }

  late final _git_blob_create_fromstream_commitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_oid>, ffi.Pointer<git_writestream>)>>(
      'git_blob_create_fromstream_commit');
  late final _git_blob_create_fromstream_commit =
      _git_blob_create_fromstream_commitPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_writestream>)>();

  int git_blob_create_frombuffer(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_blob_create_frombuffer(
      id,
      repo,
      buffer,
      len,
    );
  }

  late final _git_blob_create_frombufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('git_blob_create_frombuffer');
  late final _git_blob_create_frombuffer =
      _git_blob_create_frombufferPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Void>, int)>();

  /// Deprecated in favor of `git_blob_filter`.
  ///
  /// @deprecated Use git_blob_filter
  /// @see git_blob_filter
  int git_blob_filtered_content(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Char> as_path,
    int check_for_binary_data,
  ) {
    return _git_blob_filtered_content(
      out,
      blob,
      as_path,
      check_for_binary_data,
    );
  }

  late final _git_blob_filtered_contentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('git_blob_filtered_content');
  late final _git_blob_filtered_content =
      _git_blob_filtered_contentPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>, int)>();

  /// Deprecated in favor of `git_filter_list_stream_buffer`.
  ///
  /// @deprecated Use git_filter_list_stream_buffer
  /// @see Use git_filter_list_stream_buffer
  int git_filter_list_stream_data(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_buf> data,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_data(
      filters,
      data,
      target,
    );
  }

  late final _git_filter_list_stream_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<git_buf>,
              ffi.Pointer<git_writestream>)>>('git_filter_list_stream_data');
  late final _git_filter_list_stream_data =
      _git_filter_list_stream_dataPtr.asFunction<
          int Function(ffi.Pointer<git_filter_list>, ffi.Pointer<git_buf>,
              ffi.Pointer<git_writestream>)>();

  /// Deprecated in favor of `git_filter_list_apply_to_buffer`.
  ///
  /// @deprecated Use git_filter_list_apply_to_buffer
  /// @see Use git_filter_list_apply_to_buffer
  int git_filter_list_apply_to_data(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_buf> in1,
  ) {
    return _git_filter_list_apply_to_data(
      out,
      filters,
      in1,
    );
  }

  late final _git_filter_list_apply_to_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_buf>)>>('git_filter_list_apply_to_data');
  late final _git_filter_list_apply_to_data =
      _git_filter_list_apply_to_dataPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_filter_list>,
              ffi.Pointer<git_buf>)>();

  /// Write the contents of the tree builder as a tree object.
  /// This is an alias of `git_treebuilder_write` and is preserved
  /// for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_treebuilder_write
  /// @see git_treebuilder_write
  int git_treebuilder_write_with_buffer(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<git_buf> tree,
  ) {
    return _git_treebuilder_write_with_buffer(
      oid,
      bld,
      tree,
    );
  }

  late final _git_treebuilder_write_with_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_treebuilder>,
              ffi.Pointer<git_buf>)>>('git_treebuilder_write_with_buffer');
  late final _git_treebuilder_write_with_buffer =
      _git_treebuilder_write_with_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_treebuilder>,
              ffi.Pointer<git_buf>)>();

  /// Resize the buffer allocation to make more space.
  ///
  /// This will attempt to grow the buffer to accommodate the target size.
  ///
  /// If the buffer refers to memory that was not allocated by libgit2 (i.e.
  /// the `asize` field is zero), then `ptr` will be replaced with a newly
  /// allocated block of data.  Be careful so that memory allocated by the
  /// caller is not lost.  As a special variant, if you pass `target_size` as
  /// 0 and the memory is not allocated by libgit2, this will allocate a new
  /// buffer of size `size` and copy the external data into it.
  ///
  /// Currently, this will never shrink a buffer, only expand it.
  ///
  /// If the allocation fails, this will return an error and the buffer will be
  /// marked as invalid for future operations, invaliding the contents.
  ///
  /// @param buffer The buffer to be resized; may or may not be allocated yet
  /// @param target_size The desired available size
  /// @return 0 on success, -1 on allocation failure
  int git_buf_grow(
    ffi.Pointer<git_buf> buffer,
    int target_size,
  ) {
    return _git_buf_grow(
      buffer,
      target_size,
    );
  }

  late final _git_buf_growPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>, ffi.Size)>>(
      'git_buf_grow');
  late final _git_buf_grow =
      _git_buf_growPtr.asFunction<int Function(ffi.Pointer<git_buf>, int)>();

  /// Set buffer to a copy of some raw data.
  ///
  /// @param buffer The buffer to set
  /// @param data The data to copy into the buffer
  /// @param datalen The length of the data to copy into the buffer
  /// @return 0 on success, -1 on allocation failure
  int git_buf_set(
    ffi.Pointer<git_buf> buffer,
    ffi.Pointer<ffi.Void> data,
    int datalen,
  ) {
    return _git_buf_set(
      buffer,
      data,
      datalen,
    );
  }

  late final _git_buf_setPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Void>,
              ffi.Size)>>('git_buf_set');
  late final _git_buf_set = _git_buf_setPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Void>, int)>();

  /// Check quickly if buffer looks like it contains binary data
  ///
  /// @param buf Buffer to check
  /// @return 1 if buffer looks like non-text data
  int git_buf_is_binary(
    ffi.Pointer<git_buf> buf,
  ) {
    return _git_buf_is_binary(
      buf,
    );
  }

  late final _git_buf_is_binaryPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_buf_is_binary');
  late final _git_buf_is_binary =
      _git_buf_is_binaryPtr.asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Check quickly if buffer contains a NUL byte
  ///
  /// @param buf Buffer to check
  /// @return 1 if buffer contains a NUL byte
  int git_buf_contains_nul(
    ffi.Pointer<git_buf> buf,
  ) {
    return _git_buf_contains_nul(
      buf,
    );
  }

  late final _git_buf_contains_nulPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_buf>)>>(
          'git_buf_contains_nul');
  late final _git_buf_contains_nul =
      _git_buf_contains_nulPtr.asFunction<int Function(ffi.Pointer<git_buf>)>();

  /// Free the memory referred to by the git_buf.  This is an alias of
  /// `git_buf_dispose` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_buf_dispose
  /// @see git_buf_dispose
  void git_buf_free(
    ffi.Pointer<git_buf> buffer,
  ) {
    return _git_buf_free(
      buffer,
    );
  }

  late final _git_buf_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_buf>)>>(
          'git_buf_free');
  late final _git_buf_free =
      _git_buf_freePtr.asFunction<void Function(ffi.Pointer<git_buf>)>();

  /// Create an e-mail ready patch from a diff.
  ///
  /// @deprecated git_email_create_from_diff
  /// @see git_email_create_from_diff
  int git_diff_format_email(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_diff_format_email_options> opts,
  ) {
    return _git_diff_format_email(
      out,
      diff,
      opts,
    );
  }

  late final _git_diff_format_emailPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_diff>,
                  ffi.Pointer<git_diff_format_email_options>)>>(
      'git_diff_format_email');
  late final _git_diff_format_email = _git_diff_format_emailPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_diff>,
          ffi.Pointer<git_diff_format_email_options>)>();

  /// Create an e-mail ready patch for a commit.
  ///
  /// @deprecated git_email_create_from_commit
  /// @see git_email_create_from_commit
  int git_diff_commit_as_email(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> commit,
    int patch_no,
    int total_patches,
    int flags,
    ffi.Pointer<git_diff_options> diff_opts,
  ) {
    return _git_diff_commit_as_email(
      out,
      repo,
      commit,
      patch_no,
      total_patches,
      flags,
      diff_opts,
    );
  }

  late final _git_diff_commit_as_emailPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Size,
              ffi.Size,
              ffi.Uint32,
              ffi.Pointer<git_diff_options>)>>('git_diff_commit_as_email');
  late final _git_diff_commit_as_email =
      _git_diff_commit_as_emailPtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              int,
              int,
              int,
              ffi.Pointer<git_diff_options>)>();

  /// Initialize git_diff_format_email_options structure
  ///
  /// Initializes a `git_diff_format_email_options` with default values. Equivalent
  /// to creating an instance with GIT_DIFF_FORMAT_EMAIL_OPTIONS_INIT.
  ///
  /// @param opts The `git_blame_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_format_email_options_init(
    ffi.Pointer<git_diff_format_email_options> opts,
    int version,
  ) {
    return _git_diff_format_email_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_format_email_options_initPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_format_email_options>,
              ffi.UnsignedInt)>>('git_diff_format_email_options_init');
  late final _git_diff_format_email_options_init =
      _git_diff_format_email_options_initPtr.asFunction<
          int Function(ffi.Pointer<git_diff_format_email_options>, int)>();

  /// Return the last `git_error` object that was generated for the
  /// current thread.  This is an alias of `git_error_last` and is
  /// preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_error_last
  /// @see git_error_last
  ffi.Pointer<git_error> giterr_last() {
    return _giterr_last();
  }

  late final _giterr_lastPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<git_error> Function()>>(
          'giterr_last');
  late final _giterr_last =
      _giterr_lastPtr.asFunction<ffi.Pointer<git_error> Function()>();

  /// Clear the last error.  This is an alias of `git_error_last` and is
  /// preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_error_clear
  /// @see git_error_clear
  void giterr_clear() {
    return _giterr_clear();
  }

  late final _giterr_clearPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('giterr_clear');
  late final _giterr_clear = _giterr_clearPtr.asFunction<void Function()>();

  /// Sets the error message to the given string.  This is an alias of
  /// `git_error_set_str` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_error_set_str
  /// @see git_error_set_str
  void giterr_set_str(
    int error_class,
    ffi.Pointer<ffi.Char> string,
  ) {
    return _giterr_set_str(
      error_class,
      string,
    );
  }

  late final _giterr_set_strPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Int, ffi.Pointer<ffi.Char>)>>('giterr_set_str');
  late final _giterr_set_str = _giterr_set_strPtr
      .asFunction<void Function(int, ffi.Pointer<ffi.Char>)>();

  /// Indicates that an out-of-memory situation occurred.  This is an alias
  /// of `git_error_set_oom` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_error_set_oom
  /// @see git_error_set_oom
  void giterr_set_oom() {
    return _giterr_set_oom();
  }

  late final _giterr_set_oomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('giterr_set_oom');
  late final _giterr_set_oom = _giterr_set_oomPtr.asFunction<void Function()>();

  int git_index_add_frombuffer(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> entry,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_index_add_frombuffer(
      index,
      entry,
      buffer,
      len,
    );
  }

  late final _git_index_add_frombufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>,
              ffi.Pointer<ffi.Void>, ffi.Size)>>('git_index_add_frombuffer');
  late final _git_index_add_frombuffer =
      _git_index_add_frombufferPtr.asFunction<
          int Function(ffi.Pointer<git_index>, ffi.Pointer<git_index_entry>,
              ffi.Pointer<ffi.Void>, int)>();

  /// Get the size in bytes for the structure which
  /// acts as an in-memory representation of any given
  /// object type.
  ///
  /// For all the core types, this would the equivalent
  /// of calling `sizeof(git_commit)` if the core types
  /// were not opaque on the external API.
  ///
  /// @param type object type to get its size
  /// @return size in bytes of the object
  int git_object__size(
    int type,
  ) {
    return _git_object__size(
      type,
    );
  }

  late final _git_object__sizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Int32)>>(
          'git_object__size');
  late final _git_object__size =
      _git_object__sizePtr.asFunction<int Function(int)>();

  /// Ensure the remote name is well-formed.
  ///
  /// @deprecated Use git_remote_name_is_valid
  /// @param remote_name name to be checked.
  /// @return 1 if the reference name is acceptable; 0 if it isn't
  int git_remote_is_valid_name(
    ffi.Pointer<ffi.Char> remote_name,
  ) {
    return _git_remote_is_valid_name(
      remote_name,
    );
  }

  late final _git_remote_is_valid_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'git_remote_is_valid_name');
  late final _git_remote_is_valid_name = _git_remote_is_valid_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Ensure the reference name is well-formed.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// @deprecated Use git_reference_name_is_valid
  /// @param refname name to be checked.
  /// @return 1 if the reference name is acceptable; 0 if it isn't
  int git_reference_is_valid_name(
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_reference_is_valid_name(
      refname,
    );
  }

  late final _git_reference_is_valid_namePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'git_reference_is_valid_name');
  late final _git_reference_is_valid_name = _git_reference_is_valid_namePtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int git_tag_create_frombuffer(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> buffer,
    int force,
  ) {
    return _git_tag_create_frombuffer(
      oid,
      repo,
      buffer,
      force,
    );
  }

  late final _git_tag_create_frombufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('git_tag_create_frombuffer');
  late final _git_tag_create_frombuffer =
      _git_tag_create_frombufferPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>, int)>();

  void git_cred_free(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_cred_free(
      cred,
    );
  }

  late final _git_cred_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_credential>)>>(
      'git_cred_free');
  late final _git_cred_free = _git_cred_freePtr
      .asFunction<void Function(ffi.Pointer<git_credential>)>();

  int git_cred_has_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_cred_has_username(
      cred,
    );
  }

  late final _git_cred_has_usernamePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_credential>)>>(
      'git_cred_has_username');
  late final _git_cred_has_username = _git_cred_has_usernamePtr
      .asFunction<int Function(ffi.Pointer<git_credential>)>();

  ffi.Pointer<ffi.Char> git_cred_get_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_cred_get_username(
      cred,
    );
  }

  late final _git_cred_get_usernamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_credential>)>>('git_cred_get_username');
  late final _git_cred_get_username = _git_cred_get_usernamePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_credential>)>();

  int git_cred_userpass_plaintext_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> password,
  ) {
    return _git_cred_userpass_plaintext_new(
      out,
      username,
      password,
    );
  }

  late final _git_cred_userpass_plaintext_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_cred_userpass_plaintext_new');
  late final _git_cred_userpass_plaintext_new =
      _git_cred_userpass_plaintext_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int git_cred_default_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
  ) {
    return _git_cred_default_new(
      out,
    );
  }

  late final _git_cred_default_newPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>>)>>(
      'git_cred_default_new');
  late final _git_cred_default_new = _git_cred_default_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_credential>>)>();

  int git_cred_username_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
  ) {
    return _git_cred_username_new(
      out,
      username,
    );
  }

  late final _git_cred_username_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>>('git_cred_username_new');
  late final _git_cred_username_new = _git_cred_username_newPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_credential>>, ffi.Pointer<ffi.Char>)>();

  int git_cred_ssh_key_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    ffi.Pointer<ffi.Char> privatekey,
    ffi.Pointer<ffi.Char> passphrase,
  ) {
    return _git_cred_ssh_key_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_cred_ssh_key_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_cred_ssh_key_new');
  late final _git_cred_ssh_key_new = _git_cred_ssh_key_newPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_credential>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  int git_cred_ssh_key_memory_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    ffi.Pointer<ffi.Char> privatekey,
    ffi.Pointer<ffi.Char> passphrase,
  ) {
    return _git_cred_ssh_key_memory_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_cred_ssh_key_memory_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_cred_ssh_key_memory_new');
  late final _git_cred_ssh_key_memory_new =
      _git_cred_ssh_key_memory_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>();

  int git_cred_ssh_interactive_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    git_credential_ssh_interactive_cb prompt_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_cred_ssh_interactive_new(
      out,
      username,
      prompt_callback,
      payload,
    );
  }

  late final _git_cred_ssh_interactive_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              git_credential_ssh_interactive_cb,
              ffi.Pointer<ffi.Void>)>>('git_cred_ssh_interactive_new');
  late final _git_cred_ssh_interactive_new =
      _git_cred_ssh_interactive_newPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              git_credential_ssh_interactive_cb,
              ffi.Pointer<ffi.Void>)>();

  int git_cred_ssh_key_from_agent(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
  ) {
    return _git_cred_ssh_key_from_agent(
      out,
      username,
    );
  }

  late final _git_cred_ssh_key_from_agentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>>('git_cred_ssh_key_from_agent');
  late final _git_cred_ssh_key_from_agent =
      _git_cred_ssh_key_from_agentPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>)>();

  int git_cred_ssh_custom_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> username,
    ffi.Pointer<ffi.Char> publickey,
    int publickey_len,
    git_credential_sign_cb sign_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_cred_ssh_custom_new(
      out,
      username,
      publickey,
      publickey_len,
      sign_callback,
      payload,
    );
  }

  late final _git_cred_ssh_custom_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              git_credential_sign_cb,
              ffi.Pointer<ffi.Void>)>>('git_cred_ssh_custom_new');
  late final _git_cred_ssh_custom_new = _git_cred_ssh_custom_newPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_credential>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          git_credential_sign_cb,
          ffi.Pointer<ffi.Void>)>();

  int git_cred_userpass(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Char> url,
    ffi.Pointer<ffi.Char> user_from_url,
    int allowed_types,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_cred_userpass(
      out,
      url,
      user_from_url,
      allowed_types,
      payload,
    );
  }

  late final _git_cred_userpassPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_credential>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.UnsignedInt,
              ffi.Pointer<ffi.Void>)>>('git_cred_userpass');
  late final _git_cred_userpass = _git_cred_userpassPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_credential>>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          int,
          ffi.Pointer<ffi.Void>)>();

  /// @name Deprecated Object ID Types
  ///
  /// These types are retained for backward compatibility.  The newer
  /// versions of these values should be preferred in all new code.
  ///
  /// There is no plan to remove these backward compatibility values at
  /// this time.
  /// /
  /// /**@{
  int git_oid_iszero(
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_iszero(
      id,
    );
  }

  late final _git_oid_iszeroPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_oid>)>>(
          'git_oid_iszero');
  late final _git_oid_iszero =
      _git_oid_iszeroPtr.asFunction<int Function(ffi.Pointer<git_oid>)>();

  /// Free the memory referred to by the git_oidarray.  This is an alias of
  /// `git_oidarray_dispose` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_oidarray_dispose
  /// @see git_oidarray_dispose
  void git_oidarray_free(
    ffi.Pointer<git_oidarray> array,
  ) {
    return _git_oidarray_free(
      array,
    );
  }

  late final _git_oidarray_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_oidarray>)>>(
          'git_oidarray_free');
  late final _git_oidarray_free = _git_oidarray_freePtr
      .asFunction<void Function(ffi.Pointer<git_oidarray>)>();

  /// Copy a string array object from source to target.
  ///
  /// Note: target is overwritten and hence should be empty, otherwise its
  /// contents are leaked.  Call git_strarray_free() if necessary.
  ///
  /// @param tgt target
  /// @param src source
  /// @return 0 on success, < 0 on allocation failure
  int git_strarray_copy1(
    ffi.Pointer<git_strarray> tgt,
    ffi.Pointer<git_strarray> src,
  ) {
    return _git_strarray_copy1(
      tgt,
      src,
    );
  }

  late final _git_strarray_copy1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_strarray>)>>('git_strarray_copy');
  late final _git_strarray_copy1 = _git_strarray_copy1Ptr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_strarray>)>();

  /// Free the memory referred to by the git_strarray.  This is an alias of
  /// `git_strarray_dispose` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_strarray_dispose
  /// @see git_strarray_dispose
  void git_strarray_free(
    ffi.Pointer<git_strarray> array,
  ) {
    return _git_strarray_free(
      array,
    );
  }

  late final _git_strarray_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_strarray>)>>(
          'git_strarray_free');
  late final _git_strarray_free = _git_strarray_freePtr
      .asFunction<void Function(ffi.Pointer<git_strarray>)>();

  /// @name Deprecated Options Initialization Functions
  ///
  /// These functions are retained for backward compatibility.  The newer
  /// versions of these functions should be preferred in all new code.
  ///
  /// There is no plan to remove these backward compatibility functions at
  /// this time.
  /// /
  /// /**@{
  int git_blame_init_options(
    ffi.Pointer<git_blame_options> opts,
    int version,
  ) {
    return _git_blame_init_options(
      opts,
      version,
    );
  }

  late final _git_blame_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_blame_options>,
              ffi.UnsignedInt)>>('git_blame_init_options');
  late final _git_blame_init_options = _git_blame_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_blame_options>, int)>();

  int git_checkout_init_options(
    ffi.Pointer<git_checkout_options> opts,
    int version,
  ) {
    return _git_checkout_init_options(
      opts,
      version,
    );
  }

  late final _git_checkout_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_checkout_options>,
              ffi.UnsignedInt)>>('git_checkout_init_options');
  late final _git_checkout_init_options = _git_checkout_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_checkout_options>, int)>();

  int git_cherrypick_init_options(
    ffi.Pointer<git_cherrypick_options> opts,
    int version,
  ) {
    return _git_cherrypick_init_options(
      opts,
      version,
    );
  }

  late final _git_cherrypick_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_cherrypick_options>,
              ffi.UnsignedInt)>>('git_cherrypick_init_options');
  late final _git_cherrypick_init_options = _git_cherrypick_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_cherrypick_options>, int)>();

  int git_clone_init_options(
    ffi.Pointer<git_clone_options> opts,
    int version,
  ) {
    return _git_clone_init_options(
      opts,
      version,
    );
  }

  late final _git_clone_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_clone_options>,
              ffi.UnsignedInt)>>('git_clone_init_options');
  late final _git_clone_init_options = _git_clone_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_clone_options>, int)>();

  int git_describe_init_options(
    ffi.Pointer<git_describe_options> opts,
    int version,
  ) {
    return _git_describe_init_options(
      opts,
      version,
    );
  }

  late final _git_describe_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_describe_options>,
              ffi.UnsignedInt)>>('git_describe_init_options');
  late final _git_describe_init_options = _git_describe_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_describe_options>, int)>();

  int git_describe_init_format_options(
    ffi.Pointer<git_describe_format_options> opts,
    int version,
  ) {
    return _git_describe_init_format_options(
      opts,
      version,
    );
  }

  late final _git_describe_init_format_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_describe_format_options>,
              ffi.UnsignedInt)>>('git_describe_init_format_options');
  late final _git_describe_init_format_options =
      _git_describe_init_format_optionsPtr.asFunction<
          int Function(ffi.Pointer<git_describe_format_options>, int)>();

  int git_diff_init_options(
    ffi.Pointer<git_diff_options> opts,
    int version,
  ) {
    return _git_diff_init_options(
      opts,
      version,
    );
  }

  late final _git_diff_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_options>,
              ffi.UnsignedInt)>>('git_diff_init_options');
  late final _git_diff_init_options = _git_diff_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_diff_options>, int)>();

  int git_diff_find_init_options(
    ffi.Pointer<git_diff_find_options> opts,
    int version,
  ) {
    return _git_diff_find_init_options(
      opts,
      version,
    );
  }

  late final _git_diff_find_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_find_options>,
              ffi.UnsignedInt)>>('git_diff_find_init_options');
  late final _git_diff_find_init_options = _git_diff_find_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_diff_find_options>, int)>();

  int git_diff_format_email_init_options(
    ffi.Pointer<git_diff_format_email_options> opts,
    int version,
  ) {
    return _git_diff_format_email_init_options(
      opts,
      version,
    );
  }

  late final _git_diff_format_email_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_format_email_options>,
              ffi.UnsignedInt)>>('git_diff_format_email_init_options');
  late final _git_diff_format_email_init_options =
      _git_diff_format_email_init_optionsPtr.asFunction<
          int Function(ffi.Pointer<git_diff_format_email_options>, int)>();

  int git_diff_patchid_init_options(
    ffi.Pointer<git_diff_patchid_options> opts,
    int version,
  ) {
    return _git_diff_patchid_init_options(
      opts,
      version,
    );
  }

  late final _git_diff_patchid_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_diff_patchid_options>,
              ffi.UnsignedInt)>>('git_diff_patchid_init_options');
  late final _git_diff_patchid_init_options = _git_diff_patchid_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_diff_patchid_options>, int)>();

  int git_fetch_init_options(
    ffi.Pointer<git_fetch_options> opts,
    int version,
  ) {
    return _git_fetch_init_options(
      opts,
      version,
    );
  }

  late final _git_fetch_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_fetch_options>,
              ffi.UnsignedInt)>>('git_fetch_init_options');
  late final _git_fetch_init_options = _git_fetch_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_fetch_options>, int)>();

  int git_indexer_init_options(
    ffi.Pointer<git_indexer_options> opts,
    int version,
  ) {
    return _git_indexer_init_options(
      opts,
      version,
    );
  }

  late final _git_indexer_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_indexer_options>,
              ffi.UnsignedInt)>>('git_indexer_init_options');
  late final _git_indexer_init_options = _git_indexer_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_indexer_options>, int)>();

  int git_merge_init_options(
    ffi.Pointer<git_merge_options> opts,
    int version,
  ) {
    return _git_merge_init_options(
      opts,
      version,
    );
  }

  late final _git_merge_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_merge_options>,
              ffi.UnsignedInt)>>('git_merge_init_options');
  late final _git_merge_init_options = _git_merge_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_merge_options>, int)>();

  int git_merge_file_init_input(
    ffi.Pointer<git_merge_file_input> input,
    int version,
  ) {
    return _git_merge_file_init_input(
      input,
      version,
    );
  }

  late final _git_merge_file_init_inputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_merge_file_input>,
              ffi.UnsignedInt)>>('git_merge_file_init_input');
  late final _git_merge_file_init_input = _git_merge_file_init_inputPtr
      .asFunction<int Function(ffi.Pointer<git_merge_file_input>, int)>();

  int git_merge_file_init_options(
    ffi.Pointer<git_merge_file_options> opts,
    int version,
  ) {
    return _git_merge_file_init_options(
      opts,
      version,
    );
  }

  late final _git_merge_file_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_merge_file_options>,
              ffi.UnsignedInt)>>('git_merge_file_init_options');
  late final _git_merge_file_init_options = _git_merge_file_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_merge_file_options>, int)>();

  int git_proxy_init_options(
    ffi.Pointer<git_proxy_options> opts,
    int version,
  ) {
    return _git_proxy_init_options(
      opts,
      version,
    );
  }

  late final _git_proxy_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_proxy_options>,
              ffi.UnsignedInt)>>('git_proxy_init_options');
  late final _git_proxy_init_options = _git_proxy_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_proxy_options>, int)>();

  int git_push_init_options(
    ffi.Pointer<git_push_options> opts,
    int version,
  ) {
    return _git_push_init_options(
      opts,
      version,
    );
  }

  late final _git_push_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_push_options>,
              ffi.UnsignedInt)>>('git_push_init_options');
  late final _git_push_init_options = _git_push_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_push_options>, int)>();

  int git_rebase_init_options(
    ffi.Pointer<git_rebase_options> opts,
    int version,
  ) {
    return _git_rebase_init_options(
      opts,
      version,
    );
  }

  late final _git_rebase_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_rebase_options>,
              ffi.UnsignedInt)>>('git_rebase_init_options');
  late final _git_rebase_init_options = _git_rebase_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_rebase_options>, int)>();

  int git_remote_create_init_options(
    ffi.Pointer<git_remote_create_options> opts,
    int version,
  ) {
    return _git_remote_create_init_options(
      opts,
      version,
    );
  }

  late final _git_remote_create_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_remote_create_options>,
              ffi.UnsignedInt)>>('git_remote_create_init_options');
  late final _git_remote_create_init_options =
      _git_remote_create_init_optionsPtr.asFunction<
          int Function(ffi.Pointer<git_remote_create_options>, int)>();

  int git_repository_init_init_options(
    ffi.Pointer<git_repository_init_options> opts,
    int version,
  ) {
    return _git_repository_init_init_options(
      opts,
      version,
    );
  }

  late final _git_repository_init_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository_init_options>,
              ffi.UnsignedInt)>>('git_repository_init_init_options');
  late final _git_repository_init_init_options =
      _git_repository_init_init_optionsPtr.asFunction<
          int Function(ffi.Pointer<git_repository_init_options>, int)>();

  int git_revert_init_options(
    ffi.Pointer<git_revert_options> opts,
    int version,
  ) {
    return _git_revert_init_options(
      opts,
      version,
    );
  }

  late final _git_revert_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revert_options>,
              ffi.UnsignedInt)>>('git_revert_init_options');
  late final _git_revert_init_options = _git_revert_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_revert_options>, int)>();

  int git_stash_apply_init_options(
    ffi.Pointer<git_stash_apply_options> opts,
    int version,
  ) {
    return _git_stash_apply_init_options(
      opts,
      version,
    );
  }

  late final _git_stash_apply_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_stash_apply_options>,
              ffi.UnsignedInt)>>('git_stash_apply_init_options');
  late final _git_stash_apply_init_options = _git_stash_apply_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_stash_apply_options>, int)>();

  int git_status_init_options(
    ffi.Pointer<git_status_options> opts,
    int version,
  ) {
    return _git_status_init_options(
      opts,
      version,
    );
  }

  late final _git_status_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_status_options>,
              ffi.UnsignedInt)>>('git_status_init_options');
  late final _git_status_init_options = _git_status_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_status_options>, int)>();

  int git_submodule_update_init_options(
    ffi.Pointer<git_submodule_update_options> opts,
    int version,
  ) {
    return _git_submodule_update_init_options(
      opts,
      version,
    );
  }

  late final _git_submodule_update_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_submodule_update_options>,
              ffi.UnsignedInt)>>('git_submodule_update_init_options');
  late final _git_submodule_update_init_options =
      _git_submodule_update_init_optionsPtr.asFunction<
          int Function(ffi.Pointer<git_submodule_update_options>, int)>();

  int git_worktree_add_init_options(
    ffi.Pointer<git_worktree_add_options> opts,
    int version,
  ) {
    return _git_worktree_add_init_options(
      opts,
      version,
    );
  }

  late final _git_worktree_add_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree_add_options>,
              ffi.UnsignedInt)>>('git_worktree_add_init_options');
  late final _git_worktree_add_init_options = _git_worktree_add_init_optionsPtr
      .asFunction<int Function(ffi.Pointer<git_worktree_add_options>, int)>();

  int git_worktree_prune_init_options(
    ffi.Pointer<git_worktree_prune_options> opts,
    int version,
  ) {
    return _git_worktree_prune_init_options(
      opts,
      version,
    );
  }

  late final _git_worktree_prune_init_optionsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_worktree_prune_options>,
              ffi.UnsignedInt)>>('git_worktree_prune_init_options');
  late final _git_worktree_prune_init_options =
      _git_worktree_prune_init_optionsPtr.asFunction<
          int Function(ffi.Pointer<git_worktree_prune_options>, int)>();

  /// Create a diff for a commit in mbox format for sending via email.
  ///
  /// @param out buffer to store the e-mail patch in
  /// @param diff the changes to include in the email
  /// @param patch_idx the patch index
  /// @param patch_count the total number of patches that will be included
  /// @param commit_id the commit id for this change
  /// @param summary the commit message for this change
  /// @param body optional text to include above the diffstat
  /// @param author the person who authored this commit
  /// @param opts email creation options
  int git_email_create_from_diff(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff> diff,
    int patch_idx,
    int patch_count,
    ffi.Pointer<git_oid> commit_id,
    ffi.Pointer<ffi.Char> summary,
    ffi.Pointer<ffi.Char> body,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_email_create_options> opts,
  ) {
    return _git_email_create_from_diff(
      out,
      diff,
      patch_idx,
      patch_count,
      commit_id,
      summary,
      body,
      author,
      opts,
    );
  }

  late final _git_email_create_from_diffPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_buf>,
                  ffi.Pointer<git_diff>,
                  ffi.Size,
                  ffi.Size,
                  ffi.Pointer<git_oid>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_signature>,
                  ffi.Pointer<git_email_create_options>)>>(
      'git_email_create_from_diff');
  late final _git_email_create_from_diff =
      _git_email_create_from_diffPtr.asFunction<
          int Function(
              ffi.Pointer<git_buf>,
              ffi.Pointer<git_diff>,
              int,
              int,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_email_create_options>)>();

  /// Create a diff for a commit in mbox format for sending via email.
  /// The commit must not be a merge commit.
  ///
  /// @param out buffer to store the e-mail patch in
  /// @param commit commit to create a patch for
  /// @param opts email creation options
  int git_email_create_from_commit(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_email_create_options> opts,
  ) {
    return _git_email_create_from_commit(
      out,
      commit,
      opts,
    );
  }

  late final _git_email_create_from_commitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_commit>,
                  ffi.Pointer<git_email_create_options>)>>(
      'git_email_create_from_commit');
  late final _git_email_create_from_commit =
      _git_email_create_from_commitPtr.asFunction<
          int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_commit>,
              ffi.Pointer<git_email_create_options>)>();

  /// Init the global state
  ///
  /// This function must be called before any other libgit2 function in
  /// order to set up global state and threading.
  ///
  /// This function may be called multiple times - it will return the number
  /// of times the initialization has been called (including this one) that have
  /// not subsequently been shutdown.
  ///
  /// @return the number of initializations of the library, or an error code.
  int git_libgit2_init() {
    return _git_libgit2_init();
  }

  late final _git_libgit2_initPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('git_libgit2_init');
  late final _git_libgit2_init =
      _git_libgit2_initPtr.asFunction<int Function()>();

  /// Shutdown the global state
  ///
  /// Clean up the global state and threading context after calling it as
  /// many times as `git_libgit2_init()` was called - it will return the
  /// number of remainining initializations that have not been shutdown
  /// (after this one).
  ///
  /// @return the number of remaining initializations of the library, or an
  /// error code.
  int git_libgit2_shutdown() {
    return _git_libgit2_shutdown();
  }

  late final _git_libgit2_shutdownPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('git_libgit2_shutdown');
  late final _git_libgit2_shutdown =
      _git_libgit2_shutdownPtr.asFunction<int Function()>();

  /// Count the number of unique commits between two commit objects
  ///
  /// There is no need for branches containing the commits to have any
  /// upstream relationship, but it helps to think of one as a branch and
  /// the other as its upstream, the `ahead` and `behind` values will be
  /// what git would report for the branches.
  ///
  /// @param ahead number of unique from commits in `upstream`
  /// @param behind number of unique from commits in `local`
  /// @param repo the repository where the commits exist
  /// @param local the commit for local
  /// @param upstream the commit for upstream
  /// @return 0 or an error code.
  int git_graph_ahead_behind(
    ffi.Pointer<ffi.Size> ahead,
    ffi.Pointer<ffi.Size> behind,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> local,
    ffi.Pointer<git_oid> upstream,
  ) {
    return _git_graph_ahead_behind(
      ahead,
      behind,
      repo,
      local,
      upstream,
    );
  }

  late final _git_graph_ahead_behindPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>)>>('git_graph_ahead_behind');
  late final _git_graph_ahead_behind = _git_graph_ahead_behindPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_oid>)>();

  /// Determine if a commit is the descendant of another commit.
  ///
  /// Note that a commit is not considered a descendant of itself, in contrast
  /// to `git merge-base --is-ancestor`.
  ///
  /// @param repo the repository where the commits exist
  /// @param commit a previously loaded commit
  /// @param ancestor a potential ancestor commit
  /// @return 1 if the given commit is a descendant of the potential ancestor,
  /// 0 if not, error code otherwise.
  int git_graph_descendant_of(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> commit,
    ffi.Pointer<git_oid> ancestor,
  ) {
    return _git_graph_descendant_of(
      repo,
      commit,
      ancestor,
    );
  }

  late final _git_graph_descendant_ofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>)>>('git_graph_descendant_of');
  late final _git_graph_descendant_of = _git_graph_descendant_ofPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>,
          ffi.Pointer<git_oid>)>();

  /// Determine if a commit is reachable from any of a list of commits by
  /// following parent edges.
  ///
  /// @param repo the repository where the commits exist
  /// @param commit a previously loaded commit
  /// @param length the number of commits in the provided `descendant_array`
  /// @param descendant_array oids of the commits
  /// @return 1 if the given commit is an ancestor of any of the given potential
  /// descendants, 0 if not, error code otherwise.
  int git_graph_reachable_from_any(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> commit,
    ffi.Pointer<git_oid> descendant_array,
    int length,
  ) {
    return _git_graph_reachable_from_any(
      repo,
      commit,
      descendant_array,
      length,
    );
  }

  late final _git_graph_reachable_from_anyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>, ffi.Size)>>('git_graph_reachable_from_any');
  late final _git_graph_reachable_from_any =
      _git_graph_reachable_from_anyPtr.asFunction<
          int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>, int)>();

  /// Add ignore rules for a repository.
  ///
  /// Excludesfile rules (i.e. .gitignore rules) are generally read from
  /// .gitignore files in the repository tree or from a shared system file
  /// only if a "core.excludesfile" config value is set.  The library also
  /// keeps a set of per-repository internal ignores that can be configured
  /// in-memory and will not persist.  This function allows you to add to
  /// that internal rules list.
  ///
  /// Example usage:
  ///
  /// error = git_ignore_add_rule(myrepo, "*.c\ndir/\nFile with space\n");
  ///
  /// This would add three rules to the ignores.
  ///
  /// @param repo The repository to add ignore rules to.
  /// @param rules Text of rules, the contents to add on a .gitignore file.
  /// It is okay to have multiple rules in the text; if so,
  /// each rule should be terminated with a newline.
  /// @return 0 on success
  int git_ignore_add_rule(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> rules,
  ) {
    return _git_ignore_add_rule(
      repo,
      rules,
    );
  }

  late final _git_ignore_add_rulePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_ignore_add_rule');
  late final _git_ignore_add_rule = _git_ignore_add_rulePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Clear ignore rules that were explicitly added.
  ///
  /// Resets to the default internal ignore rules.  This will not turn off
  /// rules in .gitignore files that actually exist in the filesystem.
  ///
  /// The default internal ignores ignore ".", ".." and ".git" entries.
  ///
  /// @param repo The repository to remove ignore rules from.
  /// @return 0 on success
  int git_ignore_clear_internal_rules(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_ignore_clear_internal_rules(
      repo,
    );
  }

  late final _git_ignore_clear_internal_rulesPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_repository>)>>(
      'git_ignore_clear_internal_rules');
  late final _git_ignore_clear_internal_rules =
      _git_ignore_clear_internal_rulesPtr
          .asFunction<int Function(ffi.Pointer<git_repository>)>();

  /// Test if the ignore rules apply to a given path.
  ///
  /// This function checks the ignore rules to see if they would apply to the
  /// given file.  This indicates if the file would be ignored regardless of
  /// whether the file is already in the index or committed to the repository.
  ///
  /// One way to think of this is if you were to do "git check-ignore --no-index"
  /// on the given file, would it be shown or not?
  ///
  /// @param ignored boolean returning 0 if the file is not ignored, 1 if it is
  /// @param repo a repository object
  /// @param path the file to check ignores for, relative to the repo's workdir.
  /// @return 0 if ignore rules could be processed for the file (regardless
  /// of whether it exists or not), or an error < 0 if they could not.
  int git_ignore_path_is_ignored(
    ffi.Pointer<ffi.Int> ignored,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_ignore_path_is_ignored(
      ignored,
      repo,
      path,
    );
  }

  late final _git_ignore_path_is_ignoredPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_ignore_path_is_ignored');
  late final _git_ignore_path_is_ignored =
      _git_ignore_path_is_ignoredPtr.asFunction<
          int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>();

  /// Allocate a new mailmap object.
  ///
  /// This object is empty, so you'll have to add a mailmap file before you can do
  /// anything with it. The mailmap must be freed with 'git_mailmap_free'.
  ///
  /// @param out pointer to store the new mailmap
  /// @return 0 on success, or an error code
  int git_mailmap_new(
    ffi.Pointer<ffi.Pointer<git_mailmap>> out,
  ) {
    return _git_mailmap_new(
      out,
    );
  }

  late final _git_mailmap_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_mailmap>>)>>('git_mailmap_new');
  late final _git_mailmap_new = _git_mailmap_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_mailmap>>)>();

  /// Free the mailmap and its associated memory.
  ///
  /// @param mm the mailmap to free
  void git_mailmap_free(
    ffi.Pointer<git_mailmap> mm,
  ) {
    return _git_mailmap_free(
      mm,
    );
  }

  late final _git_mailmap_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_mailmap>)>>(
          'git_mailmap_free');
  late final _git_mailmap_free = _git_mailmap_freePtr
      .asFunction<void Function(ffi.Pointer<git_mailmap>)>();

  /// Add a single entry to the given mailmap object. If the entry already exists,
  /// it will be replaced with the new entry.
  ///
  /// @param mm mailmap to add the entry to
  /// @param real_name the real name to use, or NULL
  /// @param real_email the real email to use, or NULL
  /// @param replace_name the name to replace, or NULL
  /// @param replace_email the email to replace
  /// @return 0 on success, or an error code
  int git_mailmap_add_entry(
    ffi.Pointer<git_mailmap> mm,
    ffi.Pointer<ffi.Char> real_name,
    ffi.Pointer<ffi.Char> real_email,
    ffi.Pointer<ffi.Char> replace_name,
    ffi.Pointer<ffi.Char> replace_email,
  ) {
    return _git_mailmap_add_entry(
      mm,
      real_name,
      real_email,
      replace_name,
      replace_email,
    );
  }

  late final _git_mailmap_add_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_mailmap>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_mailmap_add_entry');
  late final _git_mailmap_add_entry = _git_mailmap_add_entryPtr.asFunction<
      int Function(
          ffi.Pointer<git_mailmap>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Create a new mailmap instance containing a single mailmap file
  ///
  /// @param out pointer to store the new mailmap
  /// @param buf buffer to parse the mailmap from
  /// @param len the length of the input buffer
  /// @return 0 on success, or an error code
  int git_mailmap_from_buffer(
    ffi.Pointer<ffi.Pointer<git_mailmap>> out,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _git_mailmap_from_buffer(
      out,
      buf,
      len,
    );
  }

  late final _git_mailmap_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_mailmap>>,
              ffi.Pointer<ffi.Char>, ffi.Size)>>('git_mailmap_from_buffer');
  late final _git_mailmap_from_buffer = _git_mailmap_from_bufferPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_mailmap>>, ffi.Pointer<ffi.Char>, int)>();

  /// Create a new mailmap instance from a repository, loading mailmap files based
  /// on the repository's configuration.
  ///
  /// Mailmaps are loaded in the following order:
  /// 1. '.mailmap' in the root of the repository's working directory, if present.
  /// 2. The blob object identified by the 'mailmap.blob' config entry, if set.
  /// [NOTE: 'mailmap.blob' defaults to 'HEAD:.mailmap' in bare repositories]
  /// 3. The path in the 'mailmap.file' config entry, if set.
  ///
  /// @param out pointer to store the new mailmap
  /// @param repo repository to load mailmap information from
  /// @return 0 on success, or an error code
  int git_mailmap_from_repository(
    ffi.Pointer<ffi.Pointer<git_mailmap>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_mailmap_from_repository(
      out,
      repo,
    );
  }

  late final _git_mailmap_from_repositoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_mailmap>>,
              ffi.Pointer<git_repository>)>>('git_mailmap_from_repository');
  late final _git_mailmap_from_repository =
      _git_mailmap_from_repositoryPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_mailmap>>,
              ffi.Pointer<git_repository>)>();

  /// Resolve a name and email to the corresponding real name and email.
  ///
  /// The lifetime of the strings are tied to `mm`, `name`, and `email` parameters.
  ///
  /// @param real_name pointer to store the real name
  /// @param real_email pointer to store the real email
  /// @param mm the mailmap to perform a lookup with (may be NULL)
  /// @param name the name to look up
  /// @param email the email to look up
  /// @return 0 on success, or an error code
  int git_mailmap_resolve(
    ffi.Pointer<ffi.Pointer<ffi.Char>> real_name,
    ffi.Pointer<ffi.Pointer<ffi.Char>> real_email,
    ffi.Pointer<git_mailmap> mm,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> email,
  ) {
    return _git_mailmap_resolve(
      real_name,
      real_email,
      mm,
      name,
      email,
    );
  }

  late final _git_mailmap_resolvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<git_mailmap>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_mailmap_resolve');
  late final _git_mailmap_resolve = _git_mailmap_resolvePtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<git_mailmap>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Resolve a signature to use real names and emails with a mailmap.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param out new signature
  /// @param mm mailmap to resolve with
  /// @param sig signature to resolve
  /// @return 0 or an error code
  int git_mailmap_resolve_signature(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_mailmap> mm,
    ffi.Pointer<git_signature> sig,
  ) {
    return _git_mailmap_resolve_signature(
      out,
      mm,
      sig,
    );
  }

  late final _git_mailmap_resolve_signaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_mailmap>,
              ffi.Pointer<git_signature>)>>('git_mailmap_resolve_signature');
  late final _git_mailmap_resolve_signature =
      _git_mailmap_resolve_signaturePtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_mailmap>, ffi.Pointer<git_signature>)>();

  /// Clean up excess whitespace and make sure there is a trailing newline in the message.
  ///
  /// Optionally, it can remove lines which start with the comment character.
  ///
  /// @param out The user-allocated git_buf which will be filled with the
  /// cleaned up message.
  ///
  /// @param message The message to be prettified.
  ///
  /// @param strip_comments Non-zero to remove comment lines, 0 to leave them in.
  ///
  /// @param comment_char Comment character. Lines starting with this character
  /// are considered to be comments and removed if `strip_comments` is non-zero.
  ///
  /// @return 0 or an error code.
  int git_message_prettify(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<ffi.Char> message,
    int strip_comments,
    int comment_char,
  ) {
    return _git_message_prettify(
      out,
      message,
      strip_comments,
      comment_char,
    );
  }

  late final _git_message_prettifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>, ffi.Int,
              ffi.Char)>>('git_message_prettify');
  late final _git_message_prettify = _git_message_prettifyPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Parse trailers out of a message, filling the array pointed to by +arr+.
  ///
  /// Trailers are key/value pairs in the last paragraph of a message, not
  /// including any patches or conflicts that may be present.
  ///
  /// @param arr A pre-allocated git_message_trailer_array struct to be filled in
  /// with any trailers found during parsing.
  /// @param message The message to be parsed
  /// @return 0 on success, or non-zero on error.
  int git_message_trailers(
    ffi.Pointer<git_message_trailer_array> arr,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _git_message_trailers(
      arr,
      message,
    );
  }

  late final _git_message_trailersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_message_trailer_array>,
              ffi.Pointer<ffi.Char>)>>('git_message_trailers');
  late final _git_message_trailers = _git_message_trailersPtr.asFunction<
      int Function(
          ffi.Pointer<git_message_trailer_array>, ffi.Pointer<ffi.Char>)>();

  /// Clean's up any allocated memory in the git_message_trailer_array filled by
  /// a call to git_message_trailers.
  ///
  /// @param arr The trailer to free.
  void git_message_trailer_array_free(
    ffi.Pointer<git_message_trailer_array> arr,
  ) {
    return _git_message_trailer_array_free(
      arr,
    );
  }

  late final _git_message_trailer_array_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_message_trailer_array>)>>(
      'git_message_trailer_array_free');
  late final _git_message_trailer_array_free =
      _git_message_trailer_array_freePtr
          .asFunction<void Function(ffi.Pointer<git_message_trailer_array>)>();

  /// Creates a new iterator for notes
  ///
  /// The iterator must be freed manually by the user.
  ///
  /// @param out pointer to the iterator
  /// @param repo repository where to look up the note
  /// @param notes_ref canonical name of the reference to use (optional); defaults to
  /// "refs/notes/commits"
  ///
  /// @return 0 or an error code
  int git_note_iterator_new(
    ffi.Pointer<ffi.Pointer<git_note_iterator>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
  ) {
    return _git_note_iterator_new(
      out,
      repo,
      notes_ref,
    );
  }

  late final _git_note_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_note_iterator>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_note_iterator_new');
  late final _git_note_iterator_new = _git_note_iterator_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_note_iterator>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Creates a new iterator for notes from a commit
  ///
  /// The iterator must be freed manually by the user.
  ///
  /// @param out pointer to the iterator
  /// @param notes_commit a pointer to the notes commit object
  ///
  /// @return 0 or an error code
  int git_note_commit_iterator_new(
    ffi.Pointer<ffi.Pointer<git_note_iterator>> out,
    ffi.Pointer<git_commit> notes_commit,
  ) {
    return _git_note_commit_iterator_new(
      out,
      notes_commit,
    );
  }

  late final _git_note_commit_iterator_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_note_iterator>>,
              ffi.Pointer<git_commit>)>>('git_note_commit_iterator_new');
  late final _git_note_commit_iterator_new =
      _git_note_commit_iterator_newPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_note_iterator>>,
              ffi.Pointer<git_commit>)>();

  /// Frees an git_note_iterator
  ///
  /// @param it pointer to the iterator
  void git_note_iterator_free(
    ffi.Pointer<git_note_iterator> it,
  ) {
    return _git_note_iterator_free(
      it,
    );
  }

  late final _git_note_iterator_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<git_note_iterator>)>>('git_note_iterator_free');
  late final _git_note_iterator_free = _git_note_iterator_freePtr
      .asFunction<void Function(ffi.Pointer<git_note_iterator>)>();

  /// Return the current item (note_id and annotated_id) and advance the iterator
  /// internally to the next value
  ///
  /// @param note_id id of blob containing the message
  /// @param annotated_id id of the git object being annotated
  /// @param it pointer to the iterator
  ///
  /// @return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
  /// (negative value)
  int git_note_next(
    ffi.Pointer<git_oid> note_id,
    ffi.Pointer<git_oid> annotated_id,
    ffi.Pointer<git_note_iterator> it,
  ) {
    return _git_note_next(
      note_id,
      annotated_id,
      it,
    );
  }

  late final _git_note_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_note_iterator>)>>('git_note_next');
  late final _git_note_next = _git_note_nextPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>,
          ffi.Pointer<git_note_iterator>)>();

  /// Read the note for an object
  ///
  /// The note must be freed manually by the user.
  ///
  /// @param out pointer to the read note; NULL in case of error
  /// @param repo repository where to look up the note
  /// @param notes_ref canonical name of the reference to use (optional); defaults to
  /// "refs/notes/commits"
  /// @param oid OID of the git object to read the note from
  ///
  /// @return 0 or an error code
  int git_note_read(
    ffi.Pointer<ffi.Pointer<git_note>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_read(
      out,
      repo,
      notes_ref,
      oid,
    );
  }

  late final _git_note_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_note>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>)>>('git_note_read');
  late final _git_note_read = _git_note_readPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_note>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_oid>)>();

  /// Read the note for an object from a note commit
  ///
  /// The note must be freed manually by the user.
  ///
  /// @param out pointer to the read note; NULL in case of error
  /// @param repo repository where to look up the note
  /// @param notes_commit a pointer to the notes commit object
  /// @param oid OID of the git object to read the note from
  ///
  /// @return 0 or an error code
  int git_note_commit_read(
    ffi.Pointer<ffi.Pointer<git_note>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> notes_commit,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_commit_read(
      out,
      repo,
      notes_commit,
      oid,
    );
  }

  late final _git_note_commit_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_note>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_oid>)>>('git_note_commit_read');
  late final _git_note_commit_read = _git_note_commit_readPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_note>>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_oid>)>();

  /// Get the note author
  ///
  /// @param note the note
  /// @return the author
  ffi.Pointer<git_signature> git_note_author(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_author(
      note,
    );
  }

  late final _git_note_authorPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_note>)>>('git_note_author');
  late final _git_note_author = _git_note_authorPtr
      .asFunction<ffi.Pointer<git_signature> Function(ffi.Pointer<git_note>)>();

  /// Get the note committer
  ///
  /// @param note the note
  /// @return the committer
  ffi.Pointer<git_signature> git_note_committer(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_committer(
      note,
    );
  }

  late final _git_note_committerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_note>)>>('git_note_committer');
  late final _git_note_committer = _git_note_committerPtr
      .asFunction<ffi.Pointer<git_signature> Function(ffi.Pointer<git_note>)>();

  /// Get the note message
  ///
  /// @param note the note
  /// @return the note message
  ffi.Pointer<ffi.Char> git_note_message(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_message(
      note,
    );
  }

  late final _git_note_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_note>)>>('git_note_message');
  late final _git_note_message = _git_note_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_note>)>();

  /// Get the note object's id
  ///
  /// @param note the note
  /// @return the note object's id
  ffi.Pointer<git_oid> git_note_id(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_id(
      note,
    );
  }

  late final _git_note_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_note>)>>('git_note_id');
  late final _git_note_id = _git_note_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_note>)>();

  /// Add a note for an object
  ///
  /// @param out pointer to store the OID (optional); NULL in case of error
  /// @param repo repository where to store the note
  /// @param notes_ref canonical name of the reference to use (optional);
  /// defaults to "refs/notes/commits"
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to decorate
  /// @param note Content of the note to add for object oid
  /// @param force Overwrite existing note
  ///
  /// @return 0 or an error code
  int git_note_create(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Char> note,
    int force,
  ) {
    return _git_note_create(
      out,
      repo,
      notes_ref,
      author,
      committer,
      oid,
      note,
      force,
    );
  }

  late final _git_note_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_note_create');
  late final _git_note_create = _git_note_createPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Add a note for an object from a commit
  ///
  /// This function will create a notes commit for a given object,
  /// the commit is a dangling commit, no reference is created.
  ///
  /// @param notes_commit_out pointer to store the commit (optional);
  /// NULL in case of error
  /// @param notes_blob_out a point to the id of a note blob (optional)
  /// @param repo repository where the note will live
  /// @param parent Pointer to parent note
  /// or NULL if this shall start a new notes tree
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to decorate
  /// @param note Content of the note to add for object oid
  /// @param allow_note_overwrite Overwrite existing note
  ///
  /// @return 0 or an error code
  int git_note_commit_create(
    ffi.Pointer<git_oid> notes_commit_out,
    ffi.Pointer<git_oid> notes_blob_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> parent,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Char> note,
    int allow_note_overwrite,
  ) {
    return _git_note_commit_create(
      notes_commit_out,
      notes_blob_out,
      repo,
      parent,
      author,
      committer,
      oid,
      note,
      allow_note_overwrite,
    );
  }

  late final _git_note_commit_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_note_commit_create');
  late final _git_note_commit_create = _git_note_commit_createPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_oid>,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Remove the note for an object
  ///
  /// @param repo repository where the note lives
  /// @param notes_ref canonical name of the reference to use (optional);
  /// defaults to "refs/notes/commits"
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to remove the note from
  ///
  /// @return 0 or an error code
  int git_note_remove(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_remove(
      repo,
      notes_ref,
      author,
      committer,
      oid,
    );
  }

  late final _git_note_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_oid>)>>('git_note_remove');
  late final _git_note_remove = _git_note_removePtr.asFunction<
      int Function(
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_oid>)>();

  /// Remove the note for an object
  ///
  /// @param notes_commit_out pointer to store the new notes commit (optional);
  /// NULL in case of error.
  /// When removing a note a new tree containing all notes
  /// sans the note to be removed is created and a new commit
  /// pointing to that tree is also created.
  /// In the case where the resulting tree is an empty tree
  /// a new commit pointing to this empty tree will be returned.
  /// @param repo repository where the note lives
  /// @param notes_commit a pointer to the notes commit object
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to remove the note from
  ///
  /// @return 0 or an error code
  int git_note_commit_remove(
    ffi.Pointer<git_oid> notes_commit_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> notes_commit,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_commit_remove(
      notes_commit_out,
      repo,
      notes_commit,
      author,
      committer,
      oid,
    );
  }

  late final _git_note_commit_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_commit>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<git_oid>)>>('git_note_commit_remove');
  late final _git_note_commit_remove = _git_note_commit_removePtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<git_commit>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<git_oid>)>();

  /// Free a git_note object
  ///
  /// @param note git_note object
  void git_note_free(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_free(
      note,
    );
  }

  late final _git_note_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_note>)>>(
          'git_note_free');
  late final _git_note_free =
      _git_note_freePtr.asFunction<void Function(ffi.Pointer<git_note>)>();

  /// Get the default notes reference for a repository
  ///
  /// @param out buffer in which to store the name of the default notes reference
  /// @param repo The Git repository
  ///
  /// @return 0 or an error code
  int git_note_default_ref(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_note_default_ref(
      out,
      repo,
    );
  }

  late final _git_note_default_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_repository>)>>('git_note_default_ref');
  late final _git_note_default_ref = _git_note_default_refPtr.asFunction<
      int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_repository>)>();

  /// Loop over all the notes within a specified namespace
  /// and issue a callback for each one.
  ///
  /// @param repo Repository where to find the notes.
  ///
  /// @param notes_ref Reference to read from (optional); defaults to
  /// "refs/notes/commits".
  ///
  /// @param note_cb Callback to invoke per found annotation.  Return non-zero
  /// to stop looping.
  ///
  /// @param payload Extra parameter to callback function.
  ///
  /// @return 0 on success, non-zero callback return value, or error code
  int git_note_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> notes_ref,
    git_note_foreach_cb note_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_note_foreach(
      repo,
      notes_ref,
      note_cb,
      payload,
    );
  }

  late final _git_note_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              git_note_foreach_cb, ffi.Pointer<ffi.Void>)>>('git_note_foreach');
  late final _git_note_foreach = _git_note_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          git_note_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Create a new object database with no backends.
  ///
  /// Before the ODB can be used for read/writing, a custom database
  /// backend must be manually added using `git_odb_add_backend()`
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @return 0 or an error code
  int git_odb_new(
    ffi.Pointer<ffi.Pointer<git_odb>> out,
  ) {
    return _git_odb_new(
      out,
    );
  }

  late final _git_odb_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb>>)>>('git_odb_new');
  late final _git_odb_new = _git_odb_newPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<git_odb>>)>();

  /// Create a new object database and automatically add
  /// the two default backends:
  ///
  /// - git_odb_backend_loose: read and write loose object files
  /// from disk, assuming `objects_dir` as the Objects folder
  ///
  /// - git_odb_backend_pack: read objects from packfiles,
  /// assuming `objects_dir` as the Objects folder which
  /// contains a 'pack/' folder with the corresponding data
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @param objects_dir path of the backends' "objects" directory.
  /// @return 0 or an error code
  int git_odb_open(
    ffi.Pointer<ffi.Pointer<git_odb>> out,
    ffi.Pointer<ffi.Char> objects_dir,
  ) {
    return _git_odb_open(
      out,
      objects_dir,
    );
  }

  late final _git_odb_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb>>,
              ffi.Pointer<ffi.Char>)>>('git_odb_open');
  late final _git_odb_open = _git_odb_openPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb>>, ffi.Pointer<ffi.Char>)>();

  /// Add an on-disk alternate to an existing Object DB.
  ///
  /// Note that the added path must point to an `objects`, not
  /// to a full repository, to use it as an alternate store.
  ///
  /// Alternate backends are always checked for objects *after*
  /// all the main backends have been exhausted.
  ///
  /// Writing is disabled on alternate backends.
  ///
  /// @param odb database to add the backend to
  /// @param path path to the objects folder for the alternate
  /// @return 0 on success, error code otherwise
  int git_odb_add_disk_alternate(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_odb_add_disk_alternate(
      odb,
      path,
    );
  }

  late final _git_odb_add_disk_alternatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>,
              ffi.Pointer<ffi.Char>)>>('git_odb_add_disk_alternate');
  late final _git_odb_add_disk_alternate = _git_odb_add_disk_alternatePtr
      .asFunction<int Function(ffi.Pointer<git_odb>, ffi.Pointer<ffi.Char>)>();

  /// Close an open object database.
  ///
  /// @param db database pointer to close. If NULL no action is taken.
  void git_odb_free(
    ffi.Pointer<git_odb> db,
  ) {
    return _git_odb_free(
      db,
    );
  }

  late final _git_odb_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb>)>>(
          'git_odb_free');
  late final _git_odb_free =
      _git_odb_freePtr.asFunction<void Function(ffi.Pointer<git_odb>)>();

  /// Read an object from the database.
  ///
  /// This method queries all available ODB backends
  /// trying to read the given OID.
  ///
  /// The returned object is reference counted and
  /// internally cached, so it should be closed
  /// by the user once it's no longer in use.
  ///
  /// @param out pointer where to store the read object
  /// @param db database to search for the object in.
  /// @param id identity of the object to read.
  /// @return 0 if the object was read, GIT_ENOTFOUND if the object is
  /// not in the database.
  int git_odb_read(
    ffi.Pointer<ffi.Pointer<git_odb_object>> out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_odb_read(
      out,
      db,
      id,
    );
  }

  late final _git_odb_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
              ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>>('git_odb_read');
  late final _git_odb_read = _git_odb_readPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
          ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>();

  /// Read an object from the database, given a prefix
  /// of its identifier.
  ///
  /// This method queries all available ODB backends
  /// trying to match the 'len' first hexadecimal
  /// characters of the 'short_id'.
  /// The remaining (GIT_OID_HEXSZ-len)*4 bits of
  /// 'short_id' must be 0s.
  /// 'len' must be at least GIT_OID_MINPREFIXLEN,
  /// and the prefix must be long enough to identify
  /// a unique object in all the backends; the
  /// method will fail otherwise.
  ///
  /// The returned object is reference counted and
  /// internally cached, so it should be closed
  /// by the user once it's no longer in use.
  ///
  /// @param out pointer where to store the read object
  /// @param db database to search for the object in.
  /// @param short_id a prefix of the id of the object to read.
  /// @param len the length of the prefix
  /// @return 0 if the object was read, GIT_ENOTFOUND if the object is not in the
  /// database. GIT_EAMBIGUOUS if the prefix is ambiguous
  /// (several objects match the prefix)
  int git_odb_read_prefix(
    ffi.Pointer<ffi.Pointer<git_odb_object>> out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> short_id,
    int len,
  ) {
    return _git_odb_read_prefix(
      out,
      db,
      short_id,
      len,
    );
  }

  late final _git_odb_read_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_object>>,
              ffi.Pointer<git_odb>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_odb_read_prefix');
  late final _git_odb_read_prefix = _git_odb_read_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
          ffi.Pointer<git_odb>, ffi.Pointer<git_oid>, int)>();

  /// Read the header of an object from the database, without
  /// reading its full contents.
  ///
  /// The header includes the length and the type of an object.
  ///
  /// Note that most backends do not support reading only the header
  /// of an object, so the whole object will be read and then the
  /// header will be returned.
  ///
  /// @param len_out pointer where to store the length
  /// @param type_out pointer where to store the type
  /// @param db database to search for the object in.
  /// @param id identity of the object to read.
  /// @return 0 if the object was read, GIT_ENOTFOUND if the object is not
  /// in the database.
  int git_odb_read_header(
    ffi.Pointer<ffi.Size> len_out,
    ffi.Pointer<ffi.Int32> type_out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_odb_read_header(
      len_out,
      type_out,
      db,
      id,
    );
  }

  late final _git_odb_read_headerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<git_odb>,
              ffi.Pointer<git_oid>)>>('git_odb_read_header');
  late final _git_odb_read_header = _git_odb_read_headerPtr.asFunction<
      int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Int32>,
          ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>();

  /// Determine if the given object can be found in the object database.
  ///
  /// @param db database to be searched for the given object.
  /// @param id the object to search for.
  /// @return 1 if the object was found, 0 otherwise
  int git_odb_exists(
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_odb_exists(
      db,
      id,
    );
  }

  late final _git_odb_existsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>>('git_odb_exists');
  late final _git_odb_exists = _git_odb_existsPtr
      .asFunction<int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_oid>)>();

  /// Determine if the given object can be found in the object database, with
  /// extended options.
  ///
  /// @param db database to be searched for the given object.
  /// @param id the object to search for.
  /// @param flags flags affecting the lookup (see `git_odb_lookup_flags_t`)
  /// @return 1 if the object was found, 0 otherwise
  int git_odb_exists_ext(
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
    int flags,
  ) {
    return _git_odb_exists_ext(
      db,
      id,
      flags,
    );
  }

  late final _git_odb_exists_extPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_oid>,
              ffi.UnsignedInt)>>('git_odb_exists_ext');
  late final _git_odb_exists_ext = _git_odb_exists_extPtr.asFunction<
      int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_oid>, int)>();

  /// Determine if an object can be found in the object database by an
  /// abbreviated object ID.
  ///
  /// @param out The full OID of the found object if just one is found.
  /// @param db The database to be searched for the given object.
  /// @param short_id A prefix of the id of the object to read.
  /// @param len The length of the prefix.
  /// @return 0 if found, GIT_ENOTFOUND if not found, GIT_EAMBIGUOUS if multiple
  /// matches were found, other value < 0 if there was a read error.
  int git_odb_exists_prefix(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> short_id,
    int len,
  ) {
    return _git_odb_exists_prefix(
      out,
      db,
      short_id,
      len,
    );
  }

  late final _git_odb_exists_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb>,
              ffi.Pointer<git_oid>, ffi.Size)>>('git_odb_exists_prefix');
  late final _git_odb_exists_prefix = _git_odb_exists_prefixPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb>,
          ffi.Pointer<git_oid>, int)>();

  /// Determine if one or more objects can be found in the object database
  /// by their abbreviated object ID and type.
  ///
  /// The given array will be updated in place: for each abbreviated ID that is
  /// unique in the database, and of the given type (if specified),
  /// the full object ID, object ID length (`GIT_OID_HEXSZ`) and type will be
  /// written back to the array. For IDs that are not found (or are ambiguous),
  /// the array entry will be zeroed.
  ///
  /// Note that since this function operates on multiple objects, the
  /// underlying database will not be asked to be reloaded if an object is
  /// not found (which is unlike other object database operations.)
  ///
  /// @param db The database to be searched for the given objects.
  /// @param ids An array of short object IDs to search for
  /// @param count The length of the `ids` array
  /// @return 0 on success or an error code on failure
  int git_odb_expand_ids(
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_odb_expand_id> ids,
    int count,
  ) {
    return _git_odb_expand_ids(
      db,
      ids,
      count,
    );
  }

  late final _git_odb_expand_idsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_expand_id>,
              ffi.Size)>>('git_odb_expand_ids');
  late final _git_odb_expand_ids = _git_odb_expand_idsPtr.asFunction<
      int Function(
          ffi.Pointer<git_odb>, ffi.Pointer<git_odb_expand_id>, int)>();

  /// Refresh the object database to load newly added files.
  ///
  /// If the object databases have changed on disk while the library
  /// is running, this function will force a reload of the underlying
  /// indexes.
  ///
  /// Use this function when you're confident that an external
  /// application has tampered with the ODB.
  ///
  /// NOTE that it is not necessary to call this function at all. The
  /// library will automatically attempt to refresh the ODB
  /// when a lookup fails, to see if the looked up object exists
  /// on disk but hasn't been loaded yet.
  ///
  /// @param db database to refresh
  /// @return 0 on success, error code otherwise
  int git_odb_refresh(
    ffi.Pointer<git_odb> db,
  ) {
    return _git_odb_refresh(
      db,
    );
  }

  late final _git_odb_refreshPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb>)>>(
          'git_odb_refresh');
  late final _git_odb_refresh =
      _git_odb_refreshPtr.asFunction<int Function(ffi.Pointer<git_odb>)>();

  /// List all objects available in the database
  ///
  /// The callback will be called for each object available in the
  /// database. Note that the objects are likely to be returned in the index
  /// order, which would make accessing the objects in that order inefficient.
  /// Return a non-zero value from the callback to stop looping.
  ///
  /// @param db database to use
  /// @param cb the callback to call for each object
  /// @param payload data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_odb_foreach(
    ffi.Pointer<git_odb> db,
    git_odb_foreach_cb cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_odb_foreach(
      db,
      cb,
      payload,
    );
  }

  late final _git_odb_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, git_odb_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_odb_foreach');
  late final _git_odb_foreach = _git_odb_foreachPtr.asFunction<
      int Function(
          ffi.Pointer<git_odb>, git_odb_foreach_cb, ffi.Pointer<ffi.Void>)>();

  /// Write an object directly into the ODB
  ///
  /// This method writes a full object straight into the ODB.
  /// For most cases, it is preferred to write objects through a write
  /// stream, which is both faster and less memory intensive, specially
  /// for big objects.
  ///
  /// This method is provided for compatibility with custom backends
  /// which are not able to support streaming writes
  ///
  /// @param out pointer to store the OID result of the write
  /// @param odb object database where to store the object
  /// @param data buffer with the data to store
  /// @param len size of the buffer
  /// @param type type of the data to store
  /// @return 0 or an error code
  int git_odb_write(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<ffi.Void> data,
    int len,
    int type,
  ) {
    return _git_odb_write(
      out,
      odb,
      data,
      len,
      type,
    );
  }

  late final _git_odb_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb>,
              ffi.Pointer<ffi.Void>, ffi.Size, ffi.Int32)>>('git_odb_write');
  late final _git_odb_write = _git_odb_writePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb>,
          ffi.Pointer<ffi.Void>, int, int)>();

  /// Open a stream to write an object into the ODB
  ///
  /// The type and final length of the object must be specified
  /// when opening the stream.
  ///
  /// The returned stream will be of type `GIT_STREAM_WRONLY`, and it
  /// won't be effective until `git_odb_stream_finalize_write` is called
  /// and returns without an error
  ///
  /// The stream must always be freed when done with `git_odb_stream_free` or
  /// will leak memory.
  ///
  /// @see git_odb_stream
  ///
  /// @param out pointer where to store the stream
  /// @param db object database where the stream will write
  /// @param size final size of the object that will be written
  /// @param type type of the object that will be written
  /// @return 0 if the stream was created; error code otherwise
  int git_odb_open_wstream(
    ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
    ffi.Pointer<git_odb> db,
    int size,
    int type,
  ) {
    return _git_odb_open_wstream(
      out,
      db,
      size,
      type,
    );
  }

  late final _git_odb_open_wstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_stream>>,
              ffi.Pointer<git_odb>,
              git_object_size_t,
              ffi.Int32)>>('git_odb_open_wstream');
  late final _git_odb_open_wstream = _git_odb_open_wstreamPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_stream>>,
          ffi.Pointer<git_odb>, int, int)>();

  /// Write to an odb stream
  ///
  /// This method will fail if the total number of received bytes exceeds the
  /// size declared with `git_odb_open_wstream()`
  ///
  /// @param stream the stream
  /// @param buffer the data to write
  /// @param len the buffer's length
  /// @return 0 if the write succeeded, error code otherwise
  int git_odb_stream_write(
    ffi.Pointer<git_odb_stream> stream,
    ffi.Pointer<ffi.Char> buffer,
    int len,
  ) {
    return _git_odb_stream_write(
      stream,
      buffer,
      len,
    );
  }

  late final _git_odb_stream_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('git_odb_stream_write');
  late final _git_odb_stream_write = _git_odb_stream_writePtr.asFunction<
      int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>, int)>();

  /// Finish writing to an odb stream
  ///
  /// The object will take its final name and will be available to the
  /// odb.
  ///
  /// This method will fail if the total number of received bytes
  /// differs from the size declared with `git_odb_open_wstream()`
  ///
  /// @param out pointer to store the resulting object's id
  /// @param stream the stream
  /// @return 0 on success, an error code otherwise
  int git_odb_stream_finalize_write(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_odb_stream> stream,
  ) {
    return _git_odb_stream_finalize_write(
      out,
      stream,
    );
  }

  late final _git_odb_stream_finalize_writePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<git_odb_stream>)>>('git_odb_stream_finalize_write');
  late final _git_odb_stream_finalize_write =
      _git_odb_stream_finalize_writePtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_odb_stream>)>();

  /// Read from an odb stream
  ///
  /// Most backends don't implement streaming reads
  ///
  /// @param stream the stream
  /// @param buffer a user-allocated buffer to store the data in.
  /// @param len the buffer's length
  /// @return 0 if the read succeeded, error code otherwise
  int git_odb_stream_read(
    ffi.Pointer<git_odb_stream> stream,
    ffi.Pointer<ffi.Char> buffer,
    int len,
  ) {
    return _git_odb_stream_read(
      stream,
      buffer,
      len,
    );
  }

  late final _git_odb_stream_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('git_odb_stream_read');
  late final _git_odb_stream_read = _git_odb_stream_readPtr.asFunction<
      int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>, int)>();

  /// Free an odb stream
  ///
  /// @param stream the stream to free
  void git_odb_stream_free(
    ffi.Pointer<git_odb_stream> stream,
  ) {
    return _git_odb_stream_free(
      stream,
    );
  }

  late final _git_odb_stream_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb_stream>)>>(
      'git_odb_stream_free');
  late final _git_odb_stream_free = _git_odb_stream_freePtr
      .asFunction<void Function(ffi.Pointer<git_odb_stream>)>();

  /// Open a stream to read an object from the ODB
  ///
  /// Note that most backends do *not* support streaming reads
  /// because they store their objects as compressed/delta'ed blobs.
  ///
  /// It's recommended to use `git_odb_read` instead, which is
  /// assured to work on all backends.
  ///
  /// The returned stream will be of type `GIT_STREAM_RDONLY` and
  /// will have the following methods:
  ///
  /// - stream->read: read `n` bytes from the stream
  /// - stream->free: free the stream
  ///
  /// The stream must always be free'd or will leak memory.
  ///
  /// @see git_odb_stream
  ///
  /// @param out pointer where to store the stream
  /// @param len pointer where to store the length of the object
  /// @param type pointer where to store the type of the object
  /// @param db object database where the stream will read from
  /// @param oid oid of the object the stream will read from
  /// @return 0 if the stream was created, error code otherwise
  int git_odb_open_rstream(
    ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
    ffi.Pointer<ffi.Size> len,
    ffi.Pointer<ffi.Int32> type,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_odb_open_rstream(
      out,
      len,
      type,
      db,
      oid,
    );
  }

  late final _git_odb_open_rstreamPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_stream>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Int32>,
              ffi.Pointer<git_odb>,
              ffi.Pointer<git_oid>)>>('git_odb_open_rstream');
  late final _git_odb_open_rstream = _git_odb_open_rstreamPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_odb_stream>>,
          ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Int32>,
          ffi.Pointer<git_odb>,
          ffi.Pointer<git_oid>)>();

  /// Open a stream for writing a pack file to the ODB.
  ///
  /// If the ODB layer understands pack files, then the given
  /// packfile will likely be streamed directly to disk (and a
  /// corresponding index created).  If the ODB layer does not
  /// understand pack files, the objects will be stored in whatever
  /// format the ODB layer uses.
  ///
  /// @see git_odb_writepack
  ///
  /// @param out pointer to the writepack functions
  /// @param db object database where the stream will read from
  /// @param progress_cb function to call with progress information.
  /// Be aware that this is called inline with network and indexing operations,
  /// so performance may be affected.
  /// @param progress_payload payload for the progress callback
  /// @return 0 or an error code.
  int git_odb_write_pack(
    ffi.Pointer<ffi.Pointer<git_odb_writepack>> out,
    ffi.Pointer<git_odb> db,
    git_indexer_progress_cb progress_cb,
    ffi.Pointer<ffi.Void> progress_payload,
  ) {
    return _git_odb_write_pack(
      out,
      db,
      progress_cb,
      progress_payload,
    );
  }

  late final _git_odb_write_packPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_writepack>>,
              ffi.Pointer<git_odb>,
              git_indexer_progress_cb,
              ffi.Pointer<ffi.Void>)>>('git_odb_write_pack');
  late final _git_odb_write_pack = _git_odb_write_packPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_odb_writepack>>,
          ffi.Pointer<git_odb>,
          git_indexer_progress_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Write a `multi-pack-index` file from all the `.pack` files in the ODB.
  ///
  /// If the ODB layer understands pack files, then this will create a file called
  /// `multi-pack-index` next to the `.pack` and `.idx` files, which will contain
  /// an index of all objects stored in `.pack` files. This will allow for
  /// O(log n) lookup for n objects (regardless of how many packfiles there
  /// exist).
  ///
  /// @param db object database where the `multi-pack-index` file will be written.
  /// @return 0 or an error code.
  int git_odb_write_multi_pack_index(
    ffi.Pointer<git_odb> db,
  ) {
    return _git_odb_write_multi_pack_index(
      db,
    );
  }

  late final _git_odb_write_multi_pack_indexPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_odb>)>>(
          'git_odb_write_multi_pack_index');
  late final _git_odb_write_multi_pack_index =
      _git_odb_write_multi_pack_indexPtr
          .asFunction<int Function(ffi.Pointer<git_odb>)>();

  /// Determine the object-ID (sha1 hash) of a data buffer
  ///
  /// The resulting SHA-1 OID will be the identifier for the data
  /// buffer as if the data buffer it were to written to the ODB.
  ///
  /// @param out the resulting object-ID.
  /// @param data data to hash
  /// @param len size of the data
  /// @param type of the data to hash
  /// @return 0 or an error code
  int git_odb_hash(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Void> data,
    int len,
    int type,
  ) {
    return _git_odb_hash(
      out,
      data,
      len,
      type,
    );
  }

  late final _git_odb_hashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>,
              ffi.Size, ffi.Int32)>>('git_odb_hash');
  late final _git_odb_hash = _git_odb_hashPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>, int, int)>();

  /// Read a file from disk and fill a git_oid with the object id
  /// that the file would have if it were written to the Object
  /// Database as an object of the given type (w/o applying filters).
  /// Similar functionality to git.git's `git hash-object` without
  /// the `-w` flag, however, with the --no-filters flag.
  /// If you need filters, see git_repository_hashfile.
  ///
  /// @param out oid structure the result is written into.
  /// @param path file to read and determine object id for
  /// @param type the type of the object that will be hashed
  /// @return 0 or an error code
  int git_odb_hashfile(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Char> path,
    int type,
  ) {
    return _git_odb_hashfile(
      out,
      path,
      type,
    );
  }

  late final _git_odb_hashfilePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>,
              ffi.Int32)>>('git_odb_hashfile');
  late final _git_odb_hashfile = _git_odb_hashfilePtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Char>, int)>();

  /// Create a copy of an odb_object
  ///
  /// The returned copy must be manually freed with `git_odb_object_free`.
  /// Note that because of an implementation detail, the returned copy will be
  /// the same pointer as `source`: the object is internally refcounted, so the
  /// copy still needs to be freed twice.
  ///
  /// @param dest pointer where to store the copy
  /// @param source object to copy
  /// @return 0 or an error code
  int git_odb_object_dup(
    ffi.Pointer<ffi.Pointer<git_odb_object>> dest,
    ffi.Pointer<git_odb_object> source,
  ) {
    return _git_odb_object_dup(
      dest,
      source,
    );
  }

  late final _git_odb_object_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
              ffi.Pointer<git_odb_object>)>>('git_odb_object_dup');
  late final _git_odb_object_dup = _git_odb_object_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_object>>,
          ffi.Pointer<git_odb_object>)>();

  /// Close an ODB object
  ///
  /// This method must always be called once a `git_odb_object` is no
  /// longer needed, otherwise memory will leak.
  ///
  /// @param object object to close
  void git_odb_object_free(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_free(
      object,
    );
  }

  late final _git_odb_object_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb_object>)>>(
      'git_odb_object_free');
  late final _git_odb_object_free = _git_odb_object_freePtr
      .asFunction<void Function(ffi.Pointer<git_odb_object>)>();

  /// Return the OID of an ODB object
  ///
  /// This is the OID from which the object was read from
  ///
  /// @param object the object
  /// @return a pointer to the OID
  ffi.Pointer<git_oid> git_odb_object_id(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_id(
      object,
    );
  }

  late final _git_odb_object_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_odb_object>)>>('git_odb_object_id');
  late final _git_odb_object_id = _git_odb_object_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_odb_object>)>();

  /// Return the data of an ODB object
  ///
  /// This is the uncompressed, raw data as read from the ODB,
  /// without the leading header.
  ///
  /// This pointer is owned by the object and shall not be free'd.
  ///
  /// @param object the object
  /// @return a pointer to the data
  ffi.Pointer<ffi.Void> git_odb_object_data(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_data(
      object,
    );
  }

  late final _git_odb_object_dataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<git_odb_object>)>>('git_odb_object_data');
  late final _git_odb_object_data = _git_odb_object_dataPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<git_odb_object>)>();

  /// Return the size of an ODB object
  ///
  /// This is the real size of the `data` buffer, not the
  /// actual size of the object.
  ///
  /// @param object the object
  /// @return the size
  int git_odb_object_size(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_size(
      object,
    );
  }

  late final _git_odb_object_sizePtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_odb_object>)>>(
      'git_odb_object_size');
  late final _git_odb_object_size = _git_odb_object_sizePtr
      .asFunction<int Function(ffi.Pointer<git_odb_object>)>();

  /// Return the type of an ODB object
  ///
  /// @param object the object
  /// @return the type
  int git_odb_object_type(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_type(
      object,
    );
  }

  late final _git_odb_object_typePtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_odb_object>)>>(
      'git_odb_object_type');
  late final _git_odb_object_type = _git_odb_object_typePtr
      .asFunction<int Function(ffi.Pointer<git_odb_object>)>();

  /// Add a custom backend to an existing Object DB
  ///
  /// The backends are checked in relative ordering, based on the
  /// value of the `priority` parameter.
  ///
  /// Read <sys/odb_backend.h> for more information.
  ///
  /// @param odb database to add the backend to
  /// @param backend pointer to a git_odb_backend instance
  /// @param priority Value for ordering the backends queue
  /// @return 0 on success, error code otherwise
  int git_odb_add_backend(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_odb_backend> backend,
    int priority,
  ) {
    return _git_odb_add_backend(
      odb,
      backend,
      priority,
    );
  }

  late final _git_odb_add_backendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_backend>,
              ffi.Int)>>('git_odb_add_backend');
  late final _git_odb_add_backend = _git_odb_add_backendPtr.asFunction<
      int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_backend>, int)>();

  /// Add a custom backend to an existing Object DB; this
  /// backend will work as an alternate.
  ///
  /// Alternate backends are always checked for objects *after*
  /// all the main backends have been exhausted.
  ///
  /// The backends are checked in relative ordering, based on the
  /// value of the `priority` parameter.
  ///
  /// Writing is disabled on alternate backends.
  ///
  /// Read <sys/odb_backend.h> for more information.
  ///
  /// @param odb database to add the backend to
  /// @param backend pointer to a git_odb_backend instance
  /// @param priority Value for ordering the backends queue
  /// @return 0 on success, error code otherwise
  int git_odb_add_alternate(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_odb_backend> backend,
    int priority,
  ) {
    return _git_odb_add_alternate(
      odb,
      backend,
      priority,
    );
  }

  late final _git_odb_add_alternatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_backend>,
              ffi.Int)>>('git_odb_add_alternate');
  late final _git_odb_add_alternate = _git_odb_add_alternatePtr.asFunction<
      int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_odb_backend>, int)>();

  /// Get the number of ODB backend objects
  ///
  /// @param odb object database
  /// @return number of backends in the ODB
  int git_odb_num_backends(
    ffi.Pointer<git_odb> odb,
  ) {
    return _git_odb_num_backends(
      odb,
    );
  }

  late final _git_odb_num_backendsPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_odb>)>>(
          'git_odb_num_backends');
  late final _git_odb_num_backends =
      _git_odb_num_backendsPtr.asFunction<int Function(ffi.Pointer<git_odb>)>();

  /// Lookup an ODB backend object by index
  ///
  /// @param out output pointer to ODB backend at pos
  /// @param odb object database
  /// @param pos index into object database backend list
  /// @return 0 on success, GIT_ENOTFOUND if pos is invalid, other errors < 0
  int git_odb_get_backend(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<git_odb> odb,
    int pos,
  ) {
    return _git_odb_get_backend(
      out,
      odb,
      pos,
    );
  }

  late final _git_odb_get_backendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
              ffi.Pointer<git_odb>, ffi.Size)>>('git_odb_get_backend');
  late final _git_odb_get_backend = _git_odb_get_backendPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
          ffi.Pointer<git_odb>, int)>();

  /// Set the git commit-graph for the ODB.
  ///
  /// After a successful call, the ownership of the cgraph parameter will be
  /// transferred to libgit2, and the caller should not free it.
  ///
  /// The commit-graph can also be unset by explicitly passing NULL as the cgraph
  /// parameter.
  ///
  /// @param odb object database
  /// @param cgraph the git commit-graph
  /// @return 0 on success; error code otherwise
  int git_odb_set_commit_graph(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_commit_graph> cgraph,
  ) {
    return _git_odb_set_commit_graph(
      odb,
      cgraph,
    );
  }

  late final _git_odb_set_commit_graphPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb>,
              ffi.Pointer<git_commit_graph>)>>('git_odb_set_commit_graph');
  late final _git_odb_set_commit_graph =
      _git_odb_set_commit_graphPtr.asFunction<
          int Function(ffi.Pointer<git_odb>, ffi.Pointer<git_commit_graph>)>();

  /// Create a backend for the packfiles.
  ///
  /// @param out location to store the odb backend pointer
  /// @param objects_dir the Git repository's objects directory
  ///
  /// @return 0 or an error code
  int git_odb_backend_pack(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<ffi.Char> objects_dir,
  ) {
    return _git_odb_backend_pack(
      out,
      objects_dir,
    );
  }

  late final _git_odb_backend_packPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
              ffi.Pointer<ffi.Char>)>>('git_odb_backend_pack');
  late final _git_odb_backend_pack = _git_odb_backend_packPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_odb_backend>>, ffi.Pointer<ffi.Char>)>();

  /// Create a backend for loose objects
  ///
  /// @param out location to store the odb backend pointer
  /// @param objects_dir the Git repository's objects directory
  /// @param compression_level zlib compression level to use
  /// @param do_fsync whether to do an fsync() after writing
  /// @param dir_mode permissions to use creating a directory or 0 for defaults
  /// @param file_mode permissions to use creating a file or 0 for defaults
  ///
  /// @return 0 or an error code
  int git_odb_backend_loose(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<ffi.Char> objects_dir,
    int compression_level,
    int do_fsync,
    int dir_mode,
    int file_mode,
  ) {
    return _git_odb_backend_loose(
      out,
      objects_dir,
      compression_level,
      do_fsync,
      dir_mode,
      file_mode,
    );
  }

  late final _git_odb_backend_loosePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_odb_backend>>,
              ffi.Pointer<ffi.Char>,
              ffi.Int,
              ffi.Int,
              ffi.UnsignedInt,
              ffi.UnsignedInt)>>('git_odb_backend_loose');
  late final _git_odb_backend_loose = _git_odb_backend_loosePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
          ffi.Pointer<ffi.Char>, int, int, int, int)>();

  /// Create a backend out of a single packfile
  ///
  /// This can be useful for inspecting the contents of a single
  /// packfile.
  ///
  /// @param out location to store the odb backend pointer
  /// @param index_file path to the packfile's .idx file
  ///
  /// @return 0 or an error code
  int git_odb_backend_one_pack(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<ffi.Char> index_file,
  ) {
    return _git_odb_backend_one_pack(
      out,
      index_file,
    );
  }

  late final _git_odb_backend_one_packPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
              ffi.Pointer<ffi.Char>)>>('git_odb_backend_one_pack');
  late final _git_odb_backend_one_pack =
      _git_odb_backend_one_packPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_odb_backend>>,
              ffi.Pointer<ffi.Char>)>();

  /// Get the repository associated with this patch. May be NULL.
  ///
  /// @param patch the patch
  /// @return a pointer to the repository
  ffi.Pointer<git_repository> git_patch_owner(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_owner(
      patch,
    );
  }

  late final _git_patch_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_patch>)>>('git_patch_owner');
  late final _git_patch_owner = _git_patch_ownerPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_patch>)>();

  /// Return a patch for an entry in the diff list.
  ///
  /// The `git_patch` is a newly created object contains the text diffs
  /// for the delta.  You have to call `git_patch_free()` when you are
  /// done with it.  You can use the patch object to loop over all the hunks
  /// and lines in the diff of the one delta.
  ///
  /// For an unchanged file or a binary file, no `git_patch` will be
  /// created, the output will be set to NULL, and the `binary` flag will be
  /// set true in the `git_diff_delta` structure.
  ///
  /// It is okay to pass NULL for either of the output parameters; if you pass
  /// NULL for the `git_patch`, then the text diff will not be calculated.
  ///
  /// @param out Output parameter for the delta patch object
  /// @param diff Diff list object
  /// @param idx Index into diff list
  /// @return 0 on success, other value < 0 on error
  int git_patch_from_diff(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<git_diff> diff,
    int idx,
  ) {
    return _git_patch_from_diff(
      out,
      diff,
      idx,
    );
  }

  late final _git_patch_from_diffPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_patch>>,
              ffi.Pointer<git_diff>, ffi.Size)>>('git_patch_from_diff');
  late final _git_patch_from_diff = _git_patch_from_diffPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_patch>>, ffi.Pointer<git_diff>, int)>();

  /// Directly generate a patch from the difference between two blobs.
  ///
  /// This is just like `git_diff_blobs()` except it generates a patch object
  /// for the difference instead of directly making callbacks.  You can use the
  /// standard `git_patch` accessor functions to read the patch data, and
  /// you must call `git_patch_free()` on the patch when done.
  ///
  /// @param out The generated patch; NULL on error
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param new_blob Blob for new side of diff, or NULL for empty blob
  /// @param new_as_path Treat new blob as if it had this filename; can be NULL
  /// @param opts Options for diff, or NULL for default options
  /// @return 0 on success or error code < 0
  int git_patch_from_blobs(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<git_blob> new_blob,
    ffi.Pointer<ffi.Char> new_as_path,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_patch_from_blobs(
      out,
      old_blob,
      old_as_path,
      new_blob,
      new_as_path,
      opts,
    );
  }

  late final _git_patch_from_blobsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_patch>>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>)>>('git_patch_from_blobs');
  late final _git_patch_from_blobs = _git_patch_from_blobsPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_patch>>,
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_blob>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>)>();

  /// Directly generate a patch from the difference between a blob and a buffer.
  ///
  /// This is just like `git_diff_blob_to_buffer()` except it generates a patch
  /// object for the difference instead of directly making callbacks.  You can
  /// use the standard `git_patch` accessor functions to read the patch
  /// data, and you must call `git_patch_free()` on the patch when done.
  ///
  /// @param out The generated patch; NULL on error
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param buffer Raw data for new side of diff, or NULL for empty
  /// @param buffer_len Length of raw data for new side of diff
  /// @param buffer_as_path Treat buffer as if it had this filename; can be NULL
  /// @param opts Options for diff, or NULL for default options
  /// @return 0 on success or error code < 0
  int git_patch_from_blob_and_buffer(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<ffi.Void> buffer,
    int buffer_len,
    ffi.Pointer<ffi.Char> buffer_as_path,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_patch_from_blob_and_buffer(
      out,
      old_blob,
      old_as_path,
      buffer,
      buffer_len,
      buffer_as_path,
      opts,
    );
  }

  late final _git_patch_from_blob_and_bufferPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.Pointer<git_patch>>,
                  ffi.Pointer<git_blob>,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Size,
                  ffi.Pointer<ffi.Char>,
                  ffi.Pointer<git_diff_options>)>>(
      'git_patch_from_blob_and_buffer');
  late final _git_patch_from_blob_and_buffer =
      _git_patch_from_blob_and_bufferPtr.asFunction<
          int Function(
              ffi.Pointer<ffi.Pointer<git_patch>>,
              ffi.Pointer<git_blob>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              int,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>)>();

  /// Directly generate a patch from the difference between two buffers.
  ///
  /// This is just like `git_diff_buffers()` except it generates a patch
  /// object for the difference instead of directly making callbacks.  You can
  /// use the standard `git_patch` accessor functions to read the patch
  /// data, and you must call `git_patch_free()` on the patch when done.
  ///
  /// @param out The generated patch; NULL on error
  /// @param old_buffer Raw data for old side of diff, or NULL for empty
  /// @param old_len Length of the raw data for old side of the diff
  /// @param old_as_path Treat old buffer as if it had this filename; can be NULL
  /// @param new_buffer Raw data for new side of diff, or NULL for empty
  /// @param new_len Length of raw data for new side of diff
  /// @param new_as_path Treat buffer as if it had this filename; can be NULL
  /// @param opts Options for diff, or NULL for default options
  /// @return 0 on success or error code < 0
  int git_patch_from_buffers(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<ffi.Void> old_buffer,
    int old_len,
    ffi.Pointer<ffi.Char> old_as_path,
    ffi.Pointer<ffi.Void> new_buffer,
    int new_len,
    ffi.Pointer<ffi.Char> new_as_path,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_patch_from_buffers(
      out,
      old_buffer,
      old_len,
      old_as_path,
      new_buffer,
      new_len,
      new_as_path,
      opts,
    );
  }

  late final _git_patch_from_buffersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_patch>>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_diff_options>)>>('git_patch_from_buffers');
  late final _git_patch_from_buffers = _git_patch_from_buffersPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_patch>>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Void>,
          int,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_diff_options>)>();

  /// Free a git_patch object.
  ///
  /// @param patch The patch to free.
  void git_patch_free(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_free(
      patch,
    );
  }

  late final _git_patch_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_patch>)>>(
          'git_patch_free');
  late final _git_patch_free =
      _git_patch_freePtr.asFunction<void Function(ffi.Pointer<git_patch>)>();

  /// Get the delta associated with a patch.  This delta points to internal
  /// data and you do not have to release it when you are done with it.
  ///
  /// @param patch The patch in which to get the delta.
  /// @return The delta associated with the patch.
  ffi.Pointer<git_diff_delta> git_patch_get_delta(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_get_delta(
      patch,
    );
  }

  late final _git_patch_get_deltaPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_diff_delta> Function(
              ffi.Pointer<git_patch>)>>('git_patch_get_delta');
  late final _git_patch_get_delta = _git_patch_get_deltaPtr.asFunction<
      ffi.Pointer<git_diff_delta> Function(ffi.Pointer<git_patch>)>();

  /// Get the number of hunks in a patch
  ///
  /// @param patch The patch in which to get the number of hunks.
  /// @return The number of hunks of the patch.
  int git_patch_num_hunks(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_num_hunks(
      patch,
    );
  }

  late final _git_patch_num_hunksPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_patch>)>>(
          'git_patch_num_hunks');
  late final _git_patch_num_hunks = _git_patch_num_hunksPtr
      .asFunction<int Function(ffi.Pointer<git_patch>)>();

  /// Get line counts of each type in a patch.
  ///
  /// This helps imitate a diff --numstat type of output.  For that purpose,
  /// you only need the `total_additions` and `total_deletions` values, but we
  /// include the `total_context` line count in case you want the total number
  /// of lines of diff output that will be generated.
  ///
  /// All outputs are optional. Pass NULL if you don't need a particular count.
  ///
  /// @param total_context Count of context lines in output, can be NULL.
  /// @param total_additions Count of addition lines in output, can be NULL.
  /// @param total_deletions Count of deletion lines in output, can be NULL.
  /// @param patch The git_patch object
  /// @return 0 on success, <0 on error
  int git_patch_line_stats(
    ffi.Pointer<ffi.Size> total_context,
    ffi.Pointer<ffi.Size> total_additions,
    ffi.Pointer<ffi.Size> total_deletions,
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_line_stats(
      total_context,
      total_additions,
      total_deletions,
      patch,
    );
  }

  late final _git_patch_line_statsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<git_patch>)>>('git_patch_line_stats');
  late final _git_patch_line_stats = _git_patch_line_statsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Size>, ffi.Pointer<ffi.Size>,
          ffi.Pointer<ffi.Size>, ffi.Pointer<git_patch>)>();

  /// Get the information about a hunk in a patch
  ///
  /// Given a patch and a hunk index into the patch, this returns detailed
  /// information about that hunk.  Any of the output pointers can be passed
  /// as NULL if you don't care about that particular piece of information.
  ///
  /// @param out Output pointer to git_diff_hunk of hunk
  /// @param lines_in_hunk Output count of total lines in this hunk
  /// @param patch Input pointer to patch object
  /// @param hunk_idx Input index of hunk to get information about
  /// @return 0 on success, GIT_ENOTFOUND if hunk_idx out of range, <0 on error
  int git_patch_get_hunk(
    ffi.Pointer<ffi.Pointer<git_diff_hunk>> out,
    ffi.Pointer<ffi.Size> lines_in_hunk,
    ffi.Pointer<git_patch> patch,
    int hunk_idx,
  ) {
    return _git_patch_get_hunk(
      out,
      lines_in_hunk,
      patch,
      hunk_idx,
    );
  }

  late final _git_patch_get_hunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff_hunk>>,
              ffi.Pointer<ffi.Size>,
              ffi.Pointer<git_patch>,
              ffi.Size)>>('git_patch_get_hunk');
  late final _git_patch_get_hunk = _git_patch_get_hunkPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_diff_hunk>>,
          ffi.Pointer<ffi.Size>, ffi.Pointer<git_patch>, int)>();

  /// Get the number of lines in a hunk.
  ///
  /// @param patch The git_patch object
  /// @param hunk_idx Index of the hunk
  /// @return Number of lines in hunk or GIT_ENOTFOUND if invalid hunk index
  int git_patch_num_lines_in_hunk(
    ffi.Pointer<git_patch> patch,
    int hunk_idx,
  ) {
    return _git_patch_num_lines_in_hunk(
      patch,
      hunk_idx,
    );
  }

  late final _git_patch_num_lines_in_hunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_patch>,
              ffi.Size)>>('git_patch_num_lines_in_hunk');
  late final _git_patch_num_lines_in_hunk = _git_patch_num_lines_in_hunkPtr
      .asFunction<int Function(ffi.Pointer<git_patch>, int)>();

  /// Get data about a line in a hunk of a patch.
  ///
  /// Given a patch, a hunk index, and a line index in the hunk, this
  /// will return a lot of details about that line.  If you pass a hunk
  /// index larger than the number of hunks or a line index larger than
  /// the number of lines in the hunk, this will return -1.
  ///
  /// @param out The git_diff_line data for this line
  /// @param patch The patch to look in
  /// @param hunk_idx The index of the hunk
  /// @param line_of_hunk The index of the line in the hunk
  /// @return 0 on success, <0 on failure
  int git_patch_get_line_in_hunk(
    ffi.Pointer<ffi.Pointer<git_diff_line>> out,
    ffi.Pointer<git_patch> patch,
    int hunk_idx,
    int line_of_hunk,
  ) {
    return _git_patch_get_line_in_hunk(
      out,
      patch,
      hunk_idx,
      line_of_hunk,
    );
  }

  late final _git_patch_get_line_in_hunkPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_diff_line>>,
              ffi.Pointer<git_patch>,
              ffi.Size,
              ffi.Size)>>('git_patch_get_line_in_hunk');
  late final _git_patch_get_line_in_hunk =
      _git_patch_get_line_in_hunkPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_diff_line>>,
              ffi.Pointer<git_patch>, int, int)>();

  /// Look up size of patch diff data in bytes
  ///
  /// This returns the raw size of the patch data.  This only includes the
  /// actual data from the lines of the diff, not the file or hunk headers.
  ///
  /// If you pass `include_context` as true (non-zero), this will be the size
  /// of all of the diff output; if you pass it as false (zero), this will
  /// only include the actual changed lines (as if `context_lines` was 0).
  ///
  /// @param patch A git_patch representing changes to one file
  /// @param include_context Include context lines in size if non-zero
  /// @param include_hunk_headers Include hunk header lines if non-zero
  /// @param include_file_headers Include file header lines if non-zero
  /// @return The number of bytes of data
  int git_patch_size(
    ffi.Pointer<git_patch> patch,
    int include_context,
    int include_hunk_headers,
    int include_file_headers,
  ) {
    return _git_patch_size(
      patch,
      include_context,
      include_hunk_headers,
      include_file_headers,
    );
  }

  late final _git_patch_sizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<git_patch>, ffi.Int, ffi.Int,
              ffi.Int)>>('git_patch_size');
  late final _git_patch_size = _git_patch_sizePtr
      .asFunction<int Function(ffi.Pointer<git_patch>, int, int, int)>();

  /// Serialize the patch to text via callback.
  ///
  /// Returning a non-zero value from the callback will terminate the iteration
  /// and return that value to the caller.
  ///
  /// @param patch A git_patch representing changes to one file
  /// @param print_cb Callback function to output lines of the patch.  Will be
  /// called for file headers, hunk headers, and diff lines.
  /// @param payload Reference pointer that will be passed to your callbacks.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_patch_print(
    ffi.Pointer<git_patch> patch,
    git_diff_line_cb print_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_patch_print(
      patch,
      print_cb,
      payload,
    );
  }

  late final _git_patch_printPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_patch>, git_diff_line_cb,
              ffi.Pointer<ffi.Void>)>>('git_patch_print');
  late final _git_patch_print = _git_patch_printPtr.asFunction<
      int Function(
          ffi.Pointer<git_patch>, git_diff_line_cb, ffi.Pointer<ffi.Void>)>();

  /// Get the content of a patch as a single diff text.
  ///
  /// @param out The git_buf to be filled in
  /// @param patch A git_patch representing changes to one file
  /// @return 0 on success, <0 on failure.
  int git_patch_to_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_to_buf(
      out,
      patch,
    );
  }

  late final _git_patch_to_bufPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>,
              ffi.Pointer<git_patch>)>>('git_patch_to_buf');
  late final _git_patch_to_buf = _git_patch_to_bufPtr
      .asFunction<int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_patch>)>();

  /// Compile a pathspec
  ///
  /// @param out Output of the compiled pathspec
  /// @param pathspec A git_strarray of the paths to match
  /// @return 0 on success, <0 on failure
  int git_pathspec_new(
    ffi.Pointer<ffi.Pointer<git_pathspec>> out,
    ffi.Pointer<git_strarray> pathspec,
  ) {
    return _git_pathspec_new(
      out,
      pathspec,
    );
  }

  late final _git_pathspec_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_pathspec>>,
              ffi.Pointer<git_strarray>)>>('git_pathspec_new');
  late final _git_pathspec_new = _git_pathspec_newPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_pathspec>>, ffi.Pointer<git_strarray>)>();

  /// Free a pathspec
  ///
  /// @param ps The compiled pathspec
  void git_pathspec_free(
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_free(
      ps,
    );
  }

  late final _git_pathspec_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_pathspec>)>>(
          'git_pathspec_free');
  late final _git_pathspec_free = _git_pathspec_freePtr
      .asFunction<void Function(ffi.Pointer<git_pathspec>)>();

  /// Try to match a path against a pathspec
  ///
  /// Unlike most of the other pathspec matching functions, this will not
  /// fall back on the native case-sensitivity for your platform.  You must
  /// explicitly pass flags to control case sensitivity or else this will
  /// fall back on being case sensitive.
  ///
  /// @param ps The compiled pathspec
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param path The pathname to attempt to match
  /// @return 1 is path matches spec, 0 if it does not
  int git_pathspec_matches_path(
    ffi.Pointer<git_pathspec> ps,
    int flags,
    ffi.Pointer<ffi.Char> path,
  ) {
    return _git_pathspec_matches_path(
      ps,
      flags,
      path,
    );
  }

  late final _git_pathspec_matches_pathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_pathspec>, ffi.Uint32,
              ffi.Pointer<ffi.Char>)>>('git_pathspec_matches_path');
  late final _git_pathspec_matches_path =
      _git_pathspec_matches_pathPtr.asFunction<
          int Function(
              ffi.Pointer<git_pathspec>, int, ffi.Pointer<ffi.Char>)>();

  /// Match a pathspec against the working directory of a repository.
  ///
  /// This matches the pathspec against the current files in the working
  /// directory of the repository.  It is an error to invoke this on a bare
  /// repo.  This handles git ignores (i.e. ignored files will not be
  /// considered to match the `pathspec` unless the file is tracked in the
  /// index).
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param repo The repository in which to match; bare repo is an error
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag was given
  int git_pathspec_match_workdir(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_workdir(
      out,
      repo,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_workdirPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_repository>,
              ffi.Uint32,
              ffi.Pointer<git_pathspec>)>>('git_pathspec_match_workdir');
  late final _git_pathspec_match_workdir =
      _git_pathspec_match_workdirPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_repository>, int, ffi.Pointer<git_pathspec>)>();

  /// Match a pathspec against entries in an index.
  ///
  /// This matches the pathspec against the files in the repository index.
  ///
  /// NOTE: At the moment, the case sensitivity of this match is controlled
  /// by the current case-sensitivity of the index object itself and the
  /// USE_CASE and IGNORE_CASE flags will have no effect.  This behavior will
  /// be corrected in a future release.
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param index The index to match against
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
  int git_pathspec_match_index(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_index> index,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_index(
      out,
      index,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_indexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_index>,
              ffi.Uint32,
              ffi.Pointer<git_pathspec>)>>('git_pathspec_match_index');
  late final _git_pathspec_match_index =
      _git_pathspec_match_indexPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_index>, int, ffi.Pointer<git_pathspec>)>();

  /// Match a pathspec against files in a tree.
  ///
  /// This matches the pathspec against the files in the given tree.
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param tree The root-level tree to match against
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
  int git_pathspec_match_tree(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_tree> tree,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_tree(
      out,
      tree,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_treePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_tree>,
              ffi.Uint32,
              ffi.Pointer<git_pathspec>)>>('git_pathspec_match_tree');
  late final _git_pathspec_match_tree = _git_pathspec_match_treePtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
          ffi.Pointer<git_tree>, int, ffi.Pointer<git_pathspec>)>();

  /// Match a pathspec against files in a diff list.
  ///
  /// This matches the pathspec against the files in the given diff list.
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param diff A generated diff list
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
  int git_pathspec_match_diff(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_diff> diff,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_diff(
      out,
      diff,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_diffPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
              ffi.Pointer<git_diff>,
              ffi.Uint32,
              ffi.Pointer<git_pathspec>)>>('git_pathspec_match_diff');
  late final _git_pathspec_match_diff = _git_pathspec_match_diffPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_pathspec_match_list>>,
          ffi.Pointer<git_diff>, int, ffi.Pointer<git_pathspec>)>();

  /// Free memory associates with a git_pathspec_match_list
  ///
  /// @param m The git_pathspec_match_list to be freed
  void git_pathspec_match_list_free(
    ffi.Pointer<git_pathspec_match_list> m,
  ) {
    return _git_pathspec_match_list_free(
      m,
    );
  }

  late final _git_pathspec_match_list_freePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<git_pathspec_match_list>)>>(
      'git_pathspec_match_list_free');
  late final _git_pathspec_match_list_free = _git_pathspec_match_list_freePtr
      .asFunction<void Function(ffi.Pointer<git_pathspec_match_list>)>();

  /// Get the number of items in a match list.
  ///
  /// @param m The git_pathspec_match_list object
  /// @return Number of items in match list
  int git_pathspec_match_list_entrycount(
    ffi.Pointer<git_pathspec_match_list> m,
  ) {
    return _git_pathspec_match_list_entrycount(
      m,
    );
  }

  late final _git_pathspec_match_list_entrycountPtr = _lookup<
          ffi.NativeFunction<
              ffi.Size Function(ffi.Pointer<git_pathspec_match_list>)>>(
      'git_pathspec_match_list_entrycount');
  late final _git_pathspec_match_list_entrycount =
      _git_pathspec_match_list_entrycountPtr
          .asFunction<int Function(ffi.Pointer<git_pathspec_match_list>)>();

  /// Get a matching filename by position.
  ///
  /// This routine cannot be used if the match list was generated by
  /// `git_pathspec_match_diff`.  If so, it will always return NULL.
  ///
  /// @param m The git_pathspec_match_list object
  /// @param pos The index into the list
  /// @return The filename of the match
  ffi.Pointer<ffi.Char> git_pathspec_match_list_entry(
    ffi.Pointer<git_pathspec_match_list> m,
    int pos,
  ) {
    return _git_pathspec_match_list_entry(
      m,
      pos,
    );
  }

  late final _git_pathspec_match_list_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_pathspec_match_list>,
              ffi.Size)>>('git_pathspec_match_list_entry');
  late final _git_pathspec_match_list_entry =
      _git_pathspec_match_list_entryPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_pathspec_match_list>, int)>();

  /// Get a matching diff delta by position.
  ///
  /// This routine can only be used if the match list was generated by
  /// `git_pathspec_match_diff`.  Otherwise it will always return NULL.
  ///
  /// @param m The git_pathspec_match_list object
  /// @param pos The index into the list
  /// @return The filename of the match
  ffi.Pointer<git_diff_delta> git_pathspec_match_list_diff_entry(
    ffi.Pointer<git_pathspec_match_list> m,
    int pos,
  ) {
    return _git_pathspec_match_list_diff_entry(
      m,
      pos,
    );
  }

  late final _git_pathspec_match_list_diff_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_diff_delta> Function(
              ffi.Pointer<git_pathspec_match_list>,
              ffi.Size)>>('git_pathspec_match_list_diff_entry');
  late final _git_pathspec_match_list_diff_entry =
      _git_pathspec_match_list_diff_entryPtr.asFunction<
          ffi.Pointer<git_diff_delta> Function(
              ffi.Pointer<git_pathspec_match_list>, int)>();

  /// Get the number of pathspec items that did not match.
  ///
  /// This will be zero unless you passed GIT_PATHSPEC_FIND_FAILURES when
  /// generating the git_pathspec_match_list.
  ///
  /// @param m The git_pathspec_match_list object
  /// @return Number of items in original pathspec that had no matches
  int git_pathspec_match_list_failed_entrycount(
    ffi.Pointer<git_pathspec_match_list> m,
  ) {
    return _git_pathspec_match_list_failed_entrycount(
      m,
    );
  }

  late final _git_pathspec_match_list_failed_entrycountPtr = _lookup<
          ffi.NativeFunction<
              ffi.Size Function(ffi.Pointer<git_pathspec_match_list>)>>(
      'git_pathspec_match_list_failed_entrycount');
  late final _git_pathspec_match_list_failed_entrycount =
      _git_pathspec_match_list_failed_entrycountPtr
          .asFunction<int Function(ffi.Pointer<git_pathspec_match_list>)>();

  /// Get an original pathspec string that had no matches.
  ///
  /// This will be return NULL for positions out of range.
  ///
  /// @param m The git_pathspec_match_list object
  /// @param pos The index into the failed items
  /// @return The pathspec pattern that didn't match anything
  ffi.Pointer<ffi.Char> git_pathspec_match_list_failed_entry(
    ffi.Pointer<git_pathspec_match_list> m,
    int pos,
  ) {
    return _git_pathspec_match_list_failed_entry(
      m,
      pos,
    );
  }

  late final _git_pathspec_match_list_failed_entryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_pathspec_match_list>,
              ffi.Size)>>('git_pathspec_match_list_failed_entry');
  late final _git_pathspec_match_list_failed_entry =
      _git_pathspec_match_list_failed_entryPtr.asFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_pathspec_match_list>, int)>();

  /// Create a new reference database with no backends.
  ///
  /// Before the Ref DB can be used for read/writing, a custom database
  /// backend must be manually set using `git_refdb_set_backend()`
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @param repo the repository
  /// @return 0 or an error code
  int git_refdb_new(
    ffi.Pointer<ffi.Pointer<git_refdb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_refdb_new(
      out,
      repo,
    );
  }

  late final _git_refdb_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb>>,
              ffi.Pointer<git_repository>)>>('git_refdb_new');
  late final _git_refdb_new = _git_refdb_newPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_refdb>>, ffi.Pointer<git_repository>)>();

  /// Create a new reference database and automatically add
  /// the default backends:
  ///
  /// - git_refdb_dir: read and write loose and packed refs
  /// from disk, assuming the repository dir as the folder
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @param repo the repository
  /// @return 0 or an error code
  int git_refdb_open(
    ffi.Pointer<ffi.Pointer<git_refdb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_refdb_open(
      out,
      repo,
    );
  }

  late final _git_refdb_openPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_refdb>>,
              ffi.Pointer<git_repository>)>>('git_refdb_open');
  late final _git_refdb_open = _git_refdb_openPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_refdb>>, ffi.Pointer<git_repository>)>();

  /// Suggests that the given refdb compress or optimize its references.
  /// This mechanism is implementation specific.  For on-disk reference
  /// databases, for example, this may pack all loose references.
  ///
  /// @param refdb The reference database to optimize.
  /// @return 0 or an error code.
  int git_refdb_compress(
    ffi.Pointer<git_refdb> refdb,
  ) {
    return _git_refdb_compress(
      refdb,
    );
  }

  late final _git_refdb_compressPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_refdb>)>>(
          'git_refdb_compress');
  late final _git_refdb_compress =
      _git_refdb_compressPtr.asFunction<int Function(ffi.Pointer<git_refdb>)>();

  /// Close an open reference database.
  ///
  /// @param refdb reference database pointer or NULL
  void git_refdb_free(
    ffi.Pointer<git_refdb> refdb,
  ) {
    return _git_refdb_free(
      refdb,
    );
  }

  late final _git_refdb_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_refdb>)>>(
          'git_refdb_free');
  late final _git_refdb_free =
      _git_refdb_freePtr.asFunction<void Function(ffi.Pointer<git_refdb>)>();

  /// Read the reflog for the given reference
  ///
  /// If there is no reflog file for the given
  /// reference yet, an empty reflog object will
  /// be returned.
  ///
  /// The reflog must be freed manually by using
  /// git_reflog_free().
  ///
  /// @param out pointer to reflog
  /// @param repo the repository
  /// @param name reference to look up
  /// @return 0 or an error code
  int git_reflog_read(
    ffi.Pointer<ffi.Pointer<git_reflog>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reflog_read(
      out,
      repo,
      name,
    );
  }

  late final _git_reflog_readPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_reflog>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reflog_read');
  late final _git_reflog_read = _git_reflog_readPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_reflog>>,
          ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Write an existing in-memory reflog object back to disk
  /// using an atomic file lock.
  ///
  /// @param reflog an existing reflog object
  /// @return 0 or an error code
  int git_reflog_write(
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_reflog_write(
      reflog,
    );
  }

  late final _git_reflog_writePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_reflog>)>>(
          'git_reflog_write');
  late final _git_reflog_write =
      _git_reflog_writePtr.asFunction<int Function(ffi.Pointer<git_reflog>)>();

  /// Add a new entry to the in-memory reflog.
  ///
  /// `msg` is optional and can be NULL.
  ///
  /// @param reflog an existing reflog object
  /// @param id the OID the reference is now pointing to
  /// @param committer the signature of the committer
  /// @param msg the reflog message
  /// @return 0 or an error code
  int git_reflog_append(
    ffi.Pointer<git_reflog> reflog,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Char> msg,
  ) {
    return _git_reflog_append(
      reflog,
      id,
      committer,
      msg,
    );
  }

  late final _git_reflog_appendPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_reflog>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>>('git_reflog_append');
  late final _git_reflog_append = _git_reflog_appendPtr.asFunction<
      int Function(ffi.Pointer<git_reflog>, ffi.Pointer<git_oid>,
          ffi.Pointer<git_signature>, ffi.Pointer<ffi.Char>)>();

  /// Rename a reflog
  ///
  /// The reflog to be renamed is expected to already exist
  ///
  /// The new name will be checked for validity.
  /// See `git_reference_create_symbolic()` for rules about valid names.
  ///
  /// @param repo the repository
  /// @param old_name the old name of the reference
  /// @param name the new name of the reference
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  int git_reflog_rename(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> old_name,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reflog_rename(
      repo,
      old_name,
      name,
    );
  }

  late final _git_reflog_renamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_reflog_rename');
  late final _git_reflog_rename = _git_reflog_renamePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Delete the reflog for the given reference
  ///
  /// @param repo the repository
  /// @param name the reflog to delete
  /// @return 0 or an error code
  int git_reflog_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_reflog_delete(
      repo,
      name,
    );
  }

  late final _git_reflog_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_reflog_delete');
  late final _git_reflog_delete = _git_reflog_deletePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Get the number of log entries in a reflog
  ///
  /// @param reflog the previously loaded reflog
  /// @return the number of log entries
  int git_reflog_entrycount(
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_reflog_entrycount(
      reflog,
    );
  }

  late final _git_reflog_entrycountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<git_reflog>)>>(
          'git_reflog_entrycount');
  late final _git_reflog_entrycount = _git_reflog_entrycountPtr
      .asFunction<int Function(ffi.Pointer<git_reflog>)>();

  /// Lookup an entry by its index
  ///
  /// Requesting the reflog entry with an index of 0 (zero) will
  /// return the most recently created entry.
  ///
  /// @param reflog a previously loaded reflog
  /// @param idx the position of the entry to lookup. Should be greater than or
  /// equal to 0 (zero) and less than `git_reflog_entrycount()`.
  /// @return the entry; NULL if not found
  ffi.Pointer<git_reflog_entry> git_reflog_entry_byindex(
    ffi.Pointer<git_reflog> reflog,
    int idx,
  ) {
    return _git_reflog_entry_byindex(
      reflog,
      idx,
    );
  }

  late final _git_reflog_entry_byindexPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_reflog_entry> Function(
              ffi.Pointer<git_reflog>, ffi.Size)>>('git_reflog_entry_byindex');
  late final _git_reflog_entry_byindex =
      _git_reflog_entry_byindexPtr.asFunction<
          ffi.Pointer<git_reflog_entry> Function(
              ffi.Pointer<git_reflog>, int)>();

  /// Remove an entry from the reflog by its index
  ///
  /// To ensure there's no gap in the log history, set `rewrite_previous_entry`
  /// param value to 1. When deleting entry `n`, member old_oid of entry `n-1`
  /// (if any) will be updated with the value of member new_oid of entry `n+1`.
  ///
  /// @param reflog a previously loaded reflog.
  ///
  /// @param idx the position of the entry to remove. Should be greater than or
  /// equal to 0 (zero) and less than `git_reflog_entrycount()`.
  ///
  /// @param rewrite_previous_entry 1 to rewrite the history; 0 otherwise.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if the entry doesn't exist
  /// or an error code.
  int git_reflog_drop(
    ffi.Pointer<git_reflog> reflog,
    int idx,
    int rewrite_previous_entry,
  ) {
    return _git_reflog_drop(
      reflog,
      idx,
      rewrite_previous_entry,
    );
  }

  late final _git_reflog_dropPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_reflog>, ffi.Size, ffi.Int)>>('git_reflog_drop');
  late final _git_reflog_drop = _git_reflog_dropPtr
      .asFunction<int Function(ffi.Pointer<git_reflog>, int, int)>();

  /// Get the old oid
  ///
  /// @param entry a reflog entry
  /// @return the old oid
  ffi.Pointer<git_oid> git_reflog_entry_id_old(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_id_old(
      entry,
    );
  }

  late final _git_reflog_entry_id_oldPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_reflog_entry>)>>('git_reflog_entry_id_old');
  late final _git_reflog_entry_id_old = _git_reflog_entry_id_oldPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_reflog_entry>)>();

  /// Get the new oid
  ///
  /// @param entry a reflog entry
  /// @return the new oid at this time
  ffi.Pointer<git_oid> git_reflog_entry_id_new(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_id_new(
      entry,
    );
  }

  late final _git_reflog_entry_id_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_reflog_entry>)>>('git_reflog_entry_id_new');
  late final _git_reflog_entry_id_new = _git_reflog_entry_id_newPtr.asFunction<
      ffi.Pointer<git_oid> Function(ffi.Pointer<git_reflog_entry>)>();

  /// Get the committer of this entry
  ///
  /// @param entry a reflog entry
  /// @return the committer
  ffi.Pointer<git_signature> git_reflog_entry_committer(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_committer(
      entry,
    );
  }

  late final _git_reflog_entry_committerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_reflog_entry>)>>('git_reflog_entry_committer');
  late final _git_reflog_entry_committer =
      _git_reflog_entry_committerPtr.asFunction<
          ffi.Pointer<git_signature> Function(ffi.Pointer<git_reflog_entry>)>();

  /// Get the log message
  ///
  /// @param entry a reflog entry
  /// @return the log msg
  ffi.Pointer<ffi.Char> git_reflog_entry_message(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_message(
      entry,
    );
  }

  late final _git_reflog_entry_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_reflog_entry>)>>('git_reflog_entry_message');
  late final _git_reflog_entry_message =
      _git_reflog_entry_messagePtr.asFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_reflog_entry>)>();

  /// Free the reflog
  ///
  /// @param reflog reflog to free
  void git_reflog_free(
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_reflog_free(
      reflog,
    );
  }

  late final _git_reflog_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_reflog>)>>(
          'git_reflog_free');
  late final _git_reflog_free =
      _git_reflog_freePtr.asFunction<void Function(ffi.Pointer<git_reflog>)>();

  /// Sets the current head to the specified commit oid and optionally
  /// resets the index and working tree to match.
  ///
  /// SOFT reset means the Head will be moved to the commit.
  ///
  /// MIXED reset will trigger a SOFT reset, plus the index will be replaced
  /// with the content of the commit tree.
  ///
  /// HARD reset will trigger a MIXED reset and the working directory will be
  /// replaced with the content of the index.  (Untracked and ignored files
  /// will be left alone, however.)
  ///
  /// TODO: Implement remaining kinds of resets.
  ///
  /// @param repo Repository where to perform the reset operation.
  ///
  /// @param target Committish to which the Head should be moved to. This object
  /// must belong to the given `repo` and can either be a git_commit or a
  /// git_tag. When a git_tag is being passed, it should be dereferenceable
  /// to a git_commit which oid will be used as the target of the branch.
  ///
  /// @param reset_type Kind of reset operation to perform.
  ///
  /// @param checkout_opts Optional checkout options to be used for a HARD reset.
  /// The checkout_strategy field will be overridden (based on reset_type).
  /// This parameter can be used to propagate notify and progress callbacks.
  ///
  /// @return 0 on success or an error code
  int git_reset(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> target,
    int reset_type,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _git_reset(
      repo,
      target,
      reset_type,
      checkout_opts,
    );
  }

  late final _git_resetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
              ffi.Int32, ffi.Pointer<git_checkout_options>)>>('git_reset');
  late final _git_reset = _git_resetPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>, int,
          ffi.Pointer<git_checkout_options>)>();

  /// Sets the current head to the specified commit oid and optionally
  /// resets the index and working tree to match.
  ///
  /// This behaves like `git_reset()` but takes an annotated commit,
  /// which lets you specify which extended sha syntax string was
  /// specified by a user, allowing for more exact reflog messages.
  ///
  /// See the documentation for `git_reset()`.
  ///
  /// @see git_reset
  int git_reset_from_annotated(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_annotated_commit> commit,
    int reset_type,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _git_reset_from_annotated(
      repo,
      commit,
      reset_type,
      checkout_opts,
    );
  }

  late final _git_reset_from_annotatedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_annotated_commit>,
              ffi.Int32,
              ffi.Pointer<git_checkout_options>)>>('git_reset_from_annotated');
  late final _git_reset_from_annotated =
      _git_reset_from_annotatedPtr.asFunction<
          int Function(
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_annotated_commit>,
              int,
              ffi.Pointer<git_checkout_options>)>();

  /// Updates some entries in the index from the target commit tree.
  ///
  /// The scope of the updated entries is determined by the paths
  /// being passed in the `pathspec` parameters.
  ///
  /// Passing a NULL `target` will result in removing
  /// entries in the index matching the provided pathspecs.
  ///
  /// @param repo Repository where to perform the reset operation.
  ///
  /// @param target The committish which content will be used to reset the content
  /// of the index.
  ///
  /// @param pathspecs List of pathspecs to operate on.
  ///
  /// @return 0 on success or an error code < 0
  int git_reset_default(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_strarray> pathspecs,
  ) {
    return _git_reset_default(
      repo,
      target,
      pathspecs,
    );
  }

  late final _git_reset_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
              ffi.Pointer<git_strarray>)>>('git_reset_default');
  late final _git_reset_default = _git_reset_defaultPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<git_object>,
          ffi.Pointer<git_strarray>)>();

  /// Allocate a new revision walker to iterate through a repo.
  ///
  /// This revision walker uses a custom memory pool and an internal
  /// commit cache, so it is relatively expensive to allocate.
  ///
  /// For maximum performance, this revision walker should be
  /// reused for different walks.
  ///
  /// This revision walker is *not* thread safe: it may only be
  /// used to walk a repository on a single thread; however,
  /// it is possible to have several revision walkers in
  /// several different threads walking the same repository.
  ///
  /// @param out pointer to the new revision walker
  /// @param repo the repo to walk through
  /// @return 0 or an error code
  int git_revwalk_new(
    ffi.Pointer<ffi.Pointer<git_revwalk>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_revwalk_new(
      out,
      repo,
    );
  }

  late final _git_revwalk_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_revwalk>>,
              ffi.Pointer<git_repository>)>>('git_revwalk_new');
  late final _git_revwalk_new = _git_revwalk_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_revwalk>>,
          ffi.Pointer<git_repository>)>();

  /// Reset the revision walker for reuse.
  ///
  /// This will clear all the pushed and hidden commits, and
  /// leave the walker in a blank state (just like at
  /// creation) ready to receive new commit pushes and
  /// start a new walk.
  ///
  /// The revision walk is automatically reset when a walk
  /// is over.
  ///
  /// @param walker handle to reset.
  /// @return 0 or an error code
  int git_revwalk_reset(
    ffi.Pointer<git_revwalk> walker,
  ) {
    return _git_revwalk_reset(
      walker,
    );
  }

  late final _git_revwalk_resetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_reset');
  late final _git_revwalk_reset = _git_revwalk_resetPtr
      .asFunction<int Function(ffi.Pointer<git_revwalk>)>();

  /// Add a new root for the traversal
  ///
  /// The pushed commit will be marked as one of the roots from which to
  /// start the walk. This commit may not be walked if it or a child is
  /// hidden.
  ///
  /// At least one commit must be pushed onto the walker before a walk
  /// can be started.
  ///
  /// The given id must belong to a committish on the walked
  /// repository.
  ///
  /// @param walk the walker being used for the traversal.
  /// @param id the oid of the commit to start from.
  /// @return 0 or an error code
  int git_revwalk_push(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_revwalk_push(
      walk,
      id,
    );
  }

  late final _git_revwalk_pushPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<git_oid>)>>('git_revwalk_push');
  late final _git_revwalk_push = _git_revwalk_pushPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<git_oid>)>();

  /// Push matching references
  ///
  /// The OIDs pointed to by the references that match the given glob
  /// pattern will be pushed to the revision walker.
  ///
  /// A leading 'refs/' is implied if not present as well as a trailing
  /// '/\*' if the glob lacks '?', '\*' or '['.
  ///
  /// Any references matching this glob which do not point to a
  /// committish will be ignored.
  ///
  /// @param walk the walker being used for the traversal
  /// @param glob the glob pattern references should match
  /// @return 0 or an error code
  int git_revwalk_push_glob(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> glob,
  ) {
    return _git_revwalk_push_glob(
      walk,
      glob,
    );
  }

  late final _git_revwalk_push_globPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_push_glob');
  late final _git_revwalk_push_glob = _git_revwalk_push_globPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Push the repository's HEAD
  ///
  /// @param walk the walker being used for the traversal
  /// @return 0 or an error code
  int git_revwalk_push_head(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_push_head(
      walk,
    );
  }

  late final _git_revwalk_push_headPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_push_head');
  late final _git_revwalk_push_head = _git_revwalk_push_headPtr
      .asFunction<int Function(ffi.Pointer<git_revwalk>)>();

  /// Mark a commit (and its ancestors) uninteresting for the output.
  ///
  /// The given id must belong to a committish on the walked
  /// repository.
  ///
  /// The resolved commit and all its parents will be hidden from the
  /// output on the revision walk.
  ///
  /// @param walk the walker being used for the traversal.
  /// @param commit_id the oid of commit that will be ignored during the traversal
  /// @return 0 or an error code
  int git_revwalk_hide(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<git_oid> commit_id,
  ) {
    return _git_revwalk_hide(
      walk,
      commit_id,
    );
  }

  late final _git_revwalk_hidePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<git_oid>)>>('git_revwalk_hide');
  late final _git_revwalk_hide = _git_revwalk_hidePtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<git_oid>)>();

  /// Hide matching references.
  ///
  /// The OIDs pointed to by the references that match the given glob
  /// pattern and their ancestors will be hidden from the output on the
  /// revision walk.
  ///
  /// A leading 'refs/' is implied if not present as well as a trailing
  /// '/\*' if the glob lacks '?', '\*' or '['.
  ///
  /// Any references matching this glob which do not point to a
  /// committish will be ignored.
  ///
  /// @param walk the walker being used for the traversal
  /// @param glob the glob pattern references should match
  /// @return 0 or an error code
  int git_revwalk_hide_glob(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> glob,
  ) {
    return _git_revwalk_hide_glob(
      walk,
      glob,
    );
  }

  late final _git_revwalk_hide_globPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_hide_glob');
  late final _git_revwalk_hide_glob = _git_revwalk_hide_globPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Hide the repository's HEAD
  ///
  /// @param walk the walker being used for the traversal
  /// @return 0 or an error code
  int git_revwalk_hide_head(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_hide_head(
      walk,
    );
  }

  late final _git_revwalk_hide_headPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_hide_head');
  late final _git_revwalk_hide_head = _git_revwalk_hide_headPtr
      .asFunction<int Function(ffi.Pointer<git_revwalk>)>();

  /// Push the OID pointed to by a reference
  ///
  /// The reference must point to a committish.
  ///
  /// @param walk the walker being used for the traversal
  /// @param refname the reference to push
  /// @return 0 or an error code
  int git_revwalk_push_ref(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_revwalk_push_ref(
      walk,
      refname,
    );
  }

  late final _git_revwalk_push_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_push_ref');
  late final _git_revwalk_push_ref = _git_revwalk_push_refPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Hide the OID pointed to by a reference
  ///
  /// The reference must point to a committish.
  ///
  /// @param walk the walker being used for the traversal
  /// @param refname the reference to hide
  /// @return 0 or an error code
  int git_revwalk_hide_ref(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_revwalk_hide_ref(
      walk,
      refname,
    );
  }

  late final _git_revwalk_hide_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_hide_ref');
  late final _git_revwalk_hide_ref = _git_revwalk_hide_refPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Get the next commit from the revision walk.
  ///
  /// The initial call to this method is *not* blocking when
  /// iterating through a repo with a time-sorting mode.
  ///
  /// Iterating with Topological or inverted modes makes the initial
  /// call blocking to preprocess the commit list, but this block should be
  /// mostly unnoticeable on most repositories (topological preprocessing
  /// times at 0.3s on the git.git repo).
  ///
  /// The revision walker is reset when the walk is over.
  ///
  /// @param out Pointer where to store the oid of the next commit
  /// @param walk the walker to pop the commit from.
  /// @return 0 if the next commit was found;
  /// GIT_ITEROVER if there are no commits left to iterate
  int git_revwalk_next(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_next(
      out,
      walk,
    );
  }

  late final _git_revwalk_nextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>,
              ffi.Pointer<git_revwalk>)>>('git_revwalk_next');
  late final _git_revwalk_next = _git_revwalk_nextPtr.asFunction<
      int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_revwalk>)>();

  /// Change the sorting mode when iterating through the
  /// repository's contents.
  ///
  /// Changing the sorting mode resets the walker.
  ///
  /// @param walk the walker being used for the traversal.
  /// @param sort_mode combination of GIT_SORT_XXX flags
  /// @return 0 or an error code
  int git_revwalk_sorting(
    ffi.Pointer<git_revwalk> walk,
    int sort_mode,
  ) {
    return _git_revwalk_sorting(
      walk,
      sort_mode,
    );
  }

  late final _git_revwalk_sortingPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.UnsignedInt)>>('git_revwalk_sorting');
  late final _git_revwalk_sorting = _git_revwalk_sortingPtr
      .asFunction<int Function(ffi.Pointer<git_revwalk>, int)>();

  /// Push and hide the respective endpoints of the given range.
  ///
  /// The range should be of the form
  /// <commit>..<commit>
  /// where each <commit> is in the form accepted by 'git_revparse_single'.
  /// The left-hand commit will be hidden and the right-hand commit pushed.
  ///
  /// @param walk the walker being used for the traversal
  /// @param range the range
  /// @return 0 or an error code
  int git_revwalk_push_range(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Char> range,
  ) {
    return _git_revwalk_push_range(
      walk,
      range,
    );
  }

  late final _git_revwalk_push_rangePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>,
              ffi.Pointer<ffi.Char>)>>('git_revwalk_push_range');
  late final _git_revwalk_push_range = _git_revwalk_push_rangePtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, ffi.Pointer<ffi.Char>)>();

  /// Simplify the history by first-parent
  ///
  /// No parents other than the first for each commit will be enqueued.
  ///
  /// @param walk The revision walker.
  /// @return 0 or an error code
  int git_revwalk_simplify_first_parent(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_simplify_first_parent(
      walk,
    );
  }

  late final _git_revwalk_simplify_first_parentPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_simplify_first_parent');
  late final _git_revwalk_simplify_first_parent =
      _git_revwalk_simplify_first_parentPtr
          .asFunction<int Function(ffi.Pointer<git_revwalk>)>();

  /// Free a revision walker previously allocated.
  ///
  /// @param walk traversal handle to close. If NULL nothing occurs.
  void git_revwalk_free(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_free(
      walk,
    );
  }

  late final _git_revwalk_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_revwalk>)>>(
          'git_revwalk_free');
  late final _git_revwalk_free = _git_revwalk_freePtr
      .asFunction<void Function(ffi.Pointer<git_revwalk>)>();

  /// Return the repository on which this walker
  /// is operating.
  ///
  /// @param walk the revision walker
  /// @return the repository being walked
  ffi.Pointer<git_repository> git_revwalk_repository(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_repository(
      walk,
    );
  }

  late final _git_revwalk_repositoryPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_revwalk>)>>('git_revwalk_repository');
  late final _git_revwalk_repository = _git_revwalk_repositoryPtr.asFunction<
      ffi.Pointer<git_repository> Function(ffi.Pointer<git_revwalk>)>();

  /// Adds, changes or removes a callback function to hide a commit and its parents
  ///
  /// @param walk the revision walker
  /// @param hide_cb  callback function to hide a commit and its parents
  /// @param payload  data payload to be passed to callback function
  /// @return 0 or an error code.
  int git_revwalk_add_hide_cb(
    ffi.Pointer<git_revwalk> walk,
    git_revwalk_hide_cb hide_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_revwalk_add_hide_cb(
      walk,
      hide_cb,
      payload,
    );
  }

  late final _git_revwalk_add_hide_cbPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_revwalk>, git_revwalk_hide_cb,
              ffi.Pointer<ffi.Void>)>>('git_revwalk_add_hide_cb');
  late final _git_revwalk_add_hide_cb = _git_revwalk_add_hide_cbPtr.asFunction<
      int Function(ffi.Pointer<git_revwalk>, git_revwalk_hide_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Create a new action signature.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// Note: angle brackets ('<' and '>') characters are not allowed
  /// to be used in either the `name` or the `email` parameter.
  ///
  /// @param out new signature, in case of error NULL
  /// @param name name of the person
  /// @param email email of the person
  /// @param time time (in seconds from epoch) when the action happened
  /// @param offset timezone offset (in minutes) for the time
  /// @return 0 or an error code
  int git_signature_new(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> email,
    int time,
    int offset,
  ) {
    return _git_signature_new(
      out,
      name,
      email,
      time,
      offset,
    );
  }

  late final _git_signature_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              git_time_t,
              ffi.Int)>>('git_signature_new');
  late final _git_signature_new = _git_signature_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int, int)>();

  /// Create a new action signature with a timestamp of 'now'.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param out new signature, in case of error NULL
  /// @param name name of the person
  /// @param email email of the person
  /// @return 0 or an error code
  int git_signature_now(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Char> name,
    ffi.Pointer<ffi.Char> email,
  ) {
    return _git_signature_now(
      out,
      name,
      email,
    );
  }

  late final _git_signature_nowPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('git_signature_now');
  late final _git_signature_now = _git_signature_nowPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  /// Create a new action signature with default user and now timestamp.
  ///
  /// This looks up the user.name and user.email from the configuration and
  /// uses the current time as the timestamp, and creates a new signature
  /// based on that information.  It will return GIT_ENOTFOUND if either the
  /// user.name or user.email are not set.
  ///
  /// @param out new signature
  /// @param repo repository pointer
  /// @return 0 on success, GIT_ENOTFOUND if config is missing, or error code
  int git_signature_default(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_signature_default(
      out,
      repo,
    );
  }

  late final _git_signature_defaultPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_repository>)>>('git_signature_default');
  late final _git_signature_default = _git_signature_defaultPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
          ffi.Pointer<git_repository>)>();

  /// Create a new signature by parsing the given buffer, which is
  /// expected to be in the format "Real Name <email> timestamp tzoffset",
  /// where `timestamp` is the number of seconds since the Unix epoch and
  /// `tzoffset` is the timezone offset in `hhmm` format (note the lack
  /// of a colon separator).
  ///
  /// @param out new signature
  /// @param buf signature string
  /// @return 0 on success, GIT_EINVALID if the signature is not parseable, or an error code
  int git_signature_from_buffer(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Char> buf,
  ) {
    return _git_signature_from_buffer(
      out,
      buf,
    );
  }

  late final _git_signature_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Char>)>>('git_signature_from_buffer');
  late final _git_signature_from_buffer =
      _git_signature_from_bufferPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a copy of an existing signature.  All internal strings are also
  /// duplicated.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param dest pointer where to store the copy
  /// @param sig signature to duplicate
  /// @return 0 or an error code
  int git_signature_dup(
    ffi.Pointer<ffi.Pointer<git_signature>> dest,
    ffi.Pointer<git_signature> sig,
  ) {
    return _git_signature_dup(
      dest,
      sig,
    );
  }

  late final _git_signature_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
              ffi.Pointer<git_signature>)>>('git_signature_dup');
  late final _git_signature_dup = _git_signature_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_signature>>,
          ffi.Pointer<git_signature>)>();

  /// Free an existing signature.
  ///
  /// Because the signature is not an opaque structure, it is legal to free it
  /// manually, but be sure to free the "name" and "email" strings in addition
  /// to the structure itself.
  ///
  /// @param sig signature to free
  void git_signature_free(
    ffi.Pointer<git_signature> sig,
  ) {
    return _git_signature_free(
      sig,
    );
  }

  late final _git_signature_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_signature>)>>(
      'git_signature_free');
  late final _git_signature_free = _git_signature_freePtr
      .asFunction<void Function(ffi.Pointer<git_signature>)>();

  /// Lookup a tag object from the repository.
  ///
  /// @param out pointer to the looked up tag
  /// @param repo the repo to use when locating the tag.
  /// @param id identity of the tag to locate.
  /// @return 0 or an error code
  int git_tag_lookup(
    ffi.Pointer<ffi.Pointer<git_tag>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tag_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_tag_lookupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tag>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>)>>('git_tag_lookup');
  late final _git_tag_lookup = _git_tag_lookupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tag>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>)>();

  /// Lookup a tag object from the repository,
  /// given a prefix of its identifier (short id).
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param out pointer to the looked up tag
  /// @param repo the repo to use when locating the tag.
  /// @param id identity of the tag to locate.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_tag_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_tag>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_tag_lookup_prefix(
      out,
      repo,
      id,
      len,
    );
  }

  late final _git_tag_lookup_prefixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<git_tag>>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<git_oid>,
              ffi.Size)>>('git_tag_lookup_prefix');
  late final _git_tag_lookup_prefix = _git_tag_lookup_prefixPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tag>>,
          ffi.Pointer<git_repository>, ffi.Pointer<git_oid>, int)>();

  /// Close an open tag
  ///
  /// You can no longer use the git_tag pointer after this call.
  ///
  /// IMPORTANT: You MUST call this method when you are through with a tag to
  /// release memory. Failure to do so will cause a memory leak.
  ///
  /// @param tag the tag to close
  void git_tag_free(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_free(
      tag,
    );
  }

  late final _git_tag_freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_tag>)>>(
          'git_tag_free');
  late final _git_tag_free =
      _git_tag_freePtr.asFunction<void Function(ffi.Pointer<git_tag>)>();

  /// Get the id of a tag.
  ///
  /// @param tag a previously loaded tag.
  /// @return object identity for the tag.
  ffi.Pointer<git_oid> git_tag_id(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_id(
      tag,
    );
  }

  late final _git_tag_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(ffi.Pointer<git_tag>)>>('git_tag_id');
  late final _git_tag_id = _git_tag_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tag>)>();

  /// Get the repository that contains the tag.
  ///
  /// @param tag A previously loaded tag.
  /// @return Repository that contains this tag.
  ffi.Pointer<git_repository> git_tag_owner(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_owner(
      tag,
    );
  }

  late final _git_tag_ownerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_repository> Function(
              ffi.Pointer<git_tag>)>>('git_tag_owner');
  late final _git_tag_owner = _git_tag_ownerPtr
      .asFunction<ffi.Pointer<git_repository> Function(ffi.Pointer<git_tag>)>();

  /// Get the tagged object of a tag
  ///
  /// This method performs a repository lookup for the
  /// given object and returns it
  ///
  /// @param target_out pointer where to store the target
  /// @param tag a previously loaded tag.
  /// @return 0 or an error code
  int git_tag_target(
    ffi.Pointer<ffi.Pointer<git_object>> target_out,
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_target(
      target_out,
      tag,
    );
  }

  late final _git_tag_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_tag>)>>('git_tag_target');
  late final _git_tag_target = _git_tag_targetPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_object>>, ffi.Pointer<git_tag>)>();

  /// Get the OID of the tagged object of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return pointer to the OID
  ffi.Pointer<git_oid> git_tag_target_id(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_target_id(
      tag,
    );
  }

  late final _git_tag_target_idPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_oid> Function(
              ffi.Pointer<git_tag>)>>('git_tag_target_id');
  late final _git_tag_target_id = _git_tag_target_idPtr
      .asFunction<ffi.Pointer<git_oid> Function(ffi.Pointer<git_tag>)>();

  /// Get the type of a tag's tagged object
  ///
  /// @param tag a previously loaded tag.
  /// @return type of the tagged object
  int git_tag_target_type(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_target_type(
      tag,
    );
  }

  late final _git_tag_target_typePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<git_tag>)>>(
          'git_tag_target_type');
  late final _git_tag_target_type =
      _git_tag_target_typePtr.asFunction<int Function(ffi.Pointer<git_tag>)>();

  /// Get the name of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return name of the tag
  ffi.Pointer<ffi.Char> git_tag_name(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_name(
      tag,
    );
  }

  late final _git_tag_namePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_tag>)>>('git_tag_name');
  late final _git_tag_name = _git_tag_namePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_tag>)>();

  /// Get the tagger (author) of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return reference to the tag's author or NULL when unspecified
  ffi.Pointer<git_signature> git_tag_tagger(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_tagger(
      tag,
    );
  }

  late final _git_tag_taggerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<git_signature> Function(
              ffi.Pointer<git_tag>)>>('git_tag_tagger');
  late final _git_tag_tagger = _git_tag_taggerPtr
      .asFunction<ffi.Pointer<git_signature> Function(ffi.Pointer<git_tag>)>();

  /// Get the message of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return message of the tag or NULL when unspecified
  ffi.Pointer<ffi.Char> git_tag_message(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_message(
      tag,
    );
  }

  late final _git_tag_messagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<git_tag>)>>('git_tag_message');
  late final _git_tag_message = _git_tag_messagePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<git_tag>)>();

  /// Create a new tag in the repository from an object
  ///
  /// A new reference will also be created pointing to
  /// this tag object. If `force` is true and a reference
  /// already exists with the given name, it'll be replaced.
  ///
  /// The message will not be cleaned up. This can be achieved
  /// through `git_message_prettify()`.
  ///
  /// The tag name will be checked for validity. You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// @param oid Pointer where to store the OID of the
  /// newly created tag. If the tag already exists, this parameter
  /// will be the oid of the existing tag, and the function will
  /// return a GIT_EEXISTS error code.
  ///
  /// @param repo Repository where to store the tag
  ///
  /// @param tag_name Name for the tag; this name is validated
  /// for consistency. It should also not conflict with an
  /// already existing tag name
  ///
  /// @param target Object to which this tag points. This object
  /// must belong to the given `repo`.
  ///
  /// @param tagger Signature of the tagger for this tag, and
  /// of the tagging time
  ///
  /// @param message Full message for this tag
  ///
  /// @param force Overwrite existing references
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  /// A tag object is written to the ODB, and a proper reference
  /// is written in the /refs/tags folder, pointing to it
  int git_tag_create(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> tag_name,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_signature> tagger,
    ffi.Pointer<ffi.Char> message,
    int force,
  ) {
    return _git_tag_create(
      oid,
      repo,
      tag_name,
      target,
      tagger,
      message,
      force,
    );
  }

  late final _git_tag_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>,
              ffi.Int)>>('git_tag_create');
  late final _git_tag_create = _git_tag_createPtr.asFunction<
      int Function(
          ffi.Pointer<git_oid>,
          ffi.Pointer<git_repository>,
          ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_object>,
          ffi.Pointer<git_signature>,
          ffi.Pointer<ffi.Char>,
          int)>();

  /// Create a new tag in the object database pointing to a git_object
  ///
  /// The message will not be cleaned up. This can be achieved
  /// through `git_message_prettify()`.
  ///
  /// @param oid Pointer where to store the OID of the
  /// newly created tag
  ///
  /// @param repo Repository where to store the tag
  ///
  /// @param tag_name Name for the tag
  ///
  /// @param target Object to which this tag points. This object
  /// must belong to the given `repo`.
  ///
  /// @param tagger Signature of the tagger for this tag, and
  /// of the tagging time
  ///
  /// @param message Full message for this tag
  ///
  /// @return 0 on success or an error code
  int git_tag_annotation_create(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> tag_name,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_signature> tagger,
    ffi.Pointer<ffi.Char> message,
  ) {
    return _git_tag_annotation_create(
      oid,
      repo,
      tag_name,
      target,
      tagger,
      message,
    );
  }

  late final _git_tag_annotation_createPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>>('git_tag_annotation_create');
  late final _git_tag_annotation_create =
      _git_tag_annotation_createPtr.asFunction<
          int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_object>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>();

  /// Create a new tag in the repository from a buffer
  ///
  /// @param oid Pointer where to store the OID of the newly created tag
  /// @param repo Repository where to store the tag
  /// @param buffer Raw tag data
  /// @param force Overwrite existing tags
  /// @return 0 on success; error code otherwise
  int git_tag_create_from_buffer(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> buffer,
    int force,
  ) {
    return _git_tag_create_from_buffer(
      oid,
      repo,
      buffer,
      force,
    );
  }

  late final _git_tag_create_from_bufferPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('git_tag_create_from_buffer');
  late final _git_tag_create_from_buffer =
      _git_tag_create_from_bufferPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>, int)>();

  /// Create a new lightweight tag pointing at a target object
  ///
  /// A new direct reference will be created pointing to
  /// this target object. If `force` is true and a reference
  /// already exists with the given name, it'll be replaced.
  ///
  /// The tag name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param oid Pointer where to store the OID of the provided
  /// target object. If the tag already exists, this parameter
  /// will be filled with the oid of the existing pointed object
  /// and the function will return a GIT_EEXISTS error code.
  ///
  /// @param repo Repository where to store the lightweight tag
  ///
  /// @param tag_name Name for the tag; this name is validated
  /// for consistency. It should also not conflict with an
  /// already existing tag name
  ///
  /// @param target Object to which this tag points. This object
  /// must belong to the given `repo`.
  ///
  /// @param force Overwrite existing references
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  /// A proper reference is written in the /refs/tags folder,
  /// pointing to the provided target object
  int git_tag_create_lightweight(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> tag_name,
    ffi.Pointer<git_object> target,
    int force,
  ) {
    return _git_tag_create_lightweight(
      oid,
      repo,
      tag_name,
      target,
      force,
    );
  }

  late final _git_tag_create_lightweightPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_object>,
              ffi.Int)>>('git_tag_create_lightweight');
  late final _git_tag_create_lightweight =
      _git_tag_create_lightweightPtr.asFunction<
          int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<git_object>, int)>();

  /// Delete an existing tag reference.
  ///
  /// The tag name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param repo Repository where lives the tag
  ///
  /// @param tag_name Name of the tag to be deleted;
  /// this name is validated for consistency.
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  int git_tag_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Char> tag_name,
  ) {
    return _git_tag_delete(
      repo,
      tag_name,
    );
  }

  late final _git_tag_deletePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>,
              ffi.Pointer<ffi.Char>)>>('git_tag_delete');
  late final _git_tag_delete = _git_tag_deletePtr.asFunction<
      int Function(ffi.Pointer<git_repository>, ffi.Pointer<ffi.Char>)>();

  /// Fill a list with all the tags in the Repository
  ///
  /// The string array will be filled with the names of the
  /// matching tags; these values are owned by the user and
  /// should be free'd manually when no longer needed, using
  /// `git_strarray_free`.
  ///
  /// @param tag_names Pointer to a git_strarray structure where
  /// the tag names will be stored
  /// @param repo Repository where to find the tags
  /// @return 0 or an error code
  int git_tag_list(
    ffi.Pointer<git_strarray> tag_names,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_tag_list(
      tag_names,
      repo,
    );
  }

  late final _git_tag_listPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>,
              ffi.Pointer<git_repository>)>>('git_tag_list');
  late final _git_tag_list = _git_tag_listPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<git_repository>)>();

  /// Fill a list with all the tags in the Repository
  /// which name match a defined pattern
  ///
  /// If an empty pattern is provided, all the tags
  /// will be returned.
  ///
  /// The string array will be filled with the names of the
  /// matching tags; these values are owned by the user and
  /// should be free'd manually when no longer needed, using
  /// `git_strarray_free`.
  ///
  /// @param tag_names Pointer to a git_strarray structure where
  /// the tag names will be stored
  /// @param pattern Standard fnmatch pattern
  /// @param repo Repository where to find the tags
  /// @return 0 or an error code
  int git_tag_list_match(
    ffi.Pointer<git_strarray> tag_names,
    ffi.Pointer<ffi.Char> pattern,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_tag_list_match(
      tag_names,
      pattern,
      repo,
    );
  }

  late final _git_tag_list_matchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_strarray>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_repository>)>>('git_tag_list_match');
  late final _git_tag_list_match = _git_tag_list_matchPtr.asFunction<
      int Function(ffi.Pointer<git_strarray>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<git_repository>)>();

  /// Call callback `cb' for each tag in the repository
  ///
  /// @param repo Repository
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  int git_tag_foreach(
    ffi.Pointer<git_repository> repo,
    git_tag_foreach_cb callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_tag_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_tag_foreachPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_repository>, git_tag_foreach_cb,
              ffi.Pointer<ffi.Void>)>>('git_tag_foreach');
  late final _git_tag_foreach = _git_tag_foreachPtr.asFunction<
      int Function(ffi.Pointer<git_repository>, git_tag_foreach_cb,
          ffi.Pointer<ffi.Void>)>();

  /// Recursively peel a tag until a non tag git_object is found
  ///
  /// The retrieved `tag_target` object is owned by the repository
  /// and should be closed with the `git_object_free` method.
  ///
  /// @param tag_target_out Pointer to the peeled git_object
  /// @param tag The tag to be processed
  /// @return 0 or an error code
  int git_tag_peel(
    ffi.Pointer<ffi.Pointer<git_object>> tag_target_out,
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_peel(
      tag_target_out,
      tag,
    );
  }

  late final _git_tag_peelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_object>>,
              ffi.Pointer<git_tag>)>>('git_tag_peel');
  late final _git_tag_peel = _git_tag_peelPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<git_object>>, ffi.Pointer<git_tag>)>();

  /// Create an in-memory copy of a tag. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the tag
  /// @param source Original tag to copy
  /// @return 0
  int git_tag_dup(
    ffi.Pointer<ffi.Pointer<git_tag>> out,
    ffi.Pointer<git_tag> source,
  ) {
    return _git_tag_dup(
      out,
      source,
    );
  }

  late final _git_tag_dupPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_tag>>,
              ffi.Pointer<git_tag>)>>('git_tag_dup');
  late final _git_tag_dup = _git_tag_dupPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_tag>>, ffi.Pointer<git_tag>)>();

  /// Determine whether a tag name is valid, meaning that (when prefixed
  /// with `refs/tags/`) that it is a valid reference name, and that any
  /// additional tag name restrictions are imposed (eg, it cannot start
  /// with a `-`).
  ///
  /// @param valid output pointer to set with validity of given tag name
  /// @param name a tag name to test
  /// @return 0 on success or an error code
  int git_tag_name_is_valid(
    ffi.Pointer<ffi.Int> valid,
    ffi.Pointer<ffi.Char> name,
  ) {
    return _git_tag_name_is_valid(
      valid,
      name,
    );
  }

  late final _git_tag_name_is_validPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>,
              ffi.Pointer<ffi.Char>)>>('git_tag_name_is_valid');
  late final _git_tag_name_is_valid = _git_tag_name_is_validPtr
      .asFunction<int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Char>)>();

  /// Create a new transaction object
  ///
  /// This does not lock anything, but sets up the transaction object to
  /// know from which repository to lock.
  ///
  /// @param out the resulting transaction
  /// @param repo the repository in which to lock
  /// @return 0 or an error code
  int git_transaction_new(
    ffi.Pointer<ffi.Pointer<git_transaction>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_transaction_new(
      out,
      repo,
    );
  }

  late final _git_transaction_newPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<git_transaction>>,
              ffi.Pointer<git_repository>)>>('git_transaction_new');
  late final _git_transaction_new = _git_transaction_newPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<git_transaction>>,
          ffi.Pointer<git_repository>)>();

  /// Lock a reference
  ///
  /// Lock the specified reference. This is the first step to updating a
  /// reference.
  ///
  /// @param tx the transaction
  /// @param refname the reference to lock
  /// @return 0 or an error message
  int git_transaction_lock_ref(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_transaction_lock_ref(
      tx,
      refname,
    );
  }

  late final _git_transaction_lock_refPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>)>>('git_transaction_lock_ref');
  late final _git_transaction_lock_ref =
      _git_transaction_lock_refPtr.asFunction<
          int Function(ffi.Pointer<git_transaction>, ffi.Pointer<ffi.Char>)>();

  /// Set the target of a reference
  ///
  /// Set the target of the specified reference. This reference must be
  /// locked.
  ///
  /// @param tx the transaction
  /// @param refname reference to update
  /// @param target target to set the reference to
  /// @param sig signature to use in the reflog; pass NULL to read the identity from the config
  /// @param msg message to use in the reflog
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_set_target(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
    ffi.Pointer<git_oid> target,
    ffi.Pointer<git_signature> sig,
    ffi.Pointer<ffi.Char> msg,
  ) {
    return _git_transaction_set_target(
      tx,
      refname,
      target,
      sig,
      msg,
    );
  }

  late final _git_transaction_set_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>>('git_transaction_set_target');
  late final _git_transaction_set_target =
      _git_transaction_set_targetPtr.asFunction<
          int Function(
              ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_oid>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>();

  /// Set the target of a reference
  ///
  /// Set the target of the specified reference. This reference must be
  /// locked.
  ///
  /// @param tx the transaction
  /// @param refname reference to update
  /// @param target target to set the reference to
  /// @param sig signature to use in the reflog; pass NULL to read the identity from the config
  /// @param msg message to use in the reflog
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_set_symbolic_target(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
    ffi.Pointer<ffi.Char> target,
    ffi.Pointer<git_signature> sig,
    ffi.Pointer<ffi.Char> msg,
  ) {
    return _git_transaction_set_symbolic_target(
      tx,
      refname,
      target,
      sig,
      msg,
    );
  }

  late final _git_transaction_set_symbolic_targetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>>('git_transaction_set_symbolic_target');
  late final _git_transaction_set_symbolic_target =
      _git_transaction_set_symbolic_targetPtr.asFunction<
          int Function(
              ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_signature>,
              ffi.Pointer<ffi.Char>)>();

  /// Set the reflog of a reference
  ///
  /// Set the specified reference's reflog. If this is combined with
  /// setting the target, that update won't be written to the reflog.
  ///
  /// @param tx the transaction
  /// @param refname the reference whose reflog to set
  /// @param reflog the reflog as it should be written out
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_set_reflog(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_transaction_set_reflog(
      tx,
      refname,
      reflog,
    );
  }

  late final _git_transaction_set_reflogPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transaction>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_reflog>)>>('git_transaction_set_reflog');
  late final _git_transaction_set_reflog =
      _git_transaction_set_reflogPtr.asFunction<
          int Function(ffi.Pointer<git_transaction>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<git_reflog>)>();

  /// Remove a reference
  ///
  /// @param tx the transaction
  /// @param refname the reference to remove
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_remove(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Char> refname,
  ) {
    return _git_transaction_remove(
      tx,
      refname,
    );
  }

  late final _git_transaction_removePtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_transaction>,
              ffi.Pointer<ffi.Char>)>>('git_transaction_remove');
  late final _git_transaction_remove = _git_transaction_removePtr.asFunction<
      int Function(ffi.Pointer<git_transaction>, ffi.Pointer<ffi.Char>)>();

  /// Commit the changes from the transaction
  ///
  /// Perform the changes that have been queued. The updates will be made
  /// one by one, and the first failure will stop the processing.
  ///
  /// @param tx the transaction
  /// @return 0 or an error code
  int git_transaction_commit(
    ffi.Pointer<git_transaction> tx,
  ) {
    return _git_transaction_commit(
      tx,
    );
  }

  late final _git_transaction_commitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_transaction>)>>(
      'git_transaction_commit');
  late final _git_transaction_commit = _git_transaction_commitPtr
      .asFunction<int Function(ffi.Pointer<git_transaction>)>();

  /// Free the resources allocated by this transaction
  ///
  /// If any references remain locked, they will be unlocked without any
  /// changes made to them.
  ///
  /// @param tx the transaction
  void git_transaction_free(
    ffi.Pointer<git_transaction> tx,
  ) {
    return _git_transaction_free(
      tx,
    );
  }

  late final _git_transaction_freePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_transaction>)>>(
      'git_transaction_free');
  late final _git_transaction_free = _git_transaction_freePtr
      .asFunction<void Function(ffi.Pointer<git_transaction>)>();
}

class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int> __val;
}

class tm extends ffi.Struct {
  @ffi.Int()
  external int tm_sec;

  @ffi.Int()
  external int tm_min;

  @ffi.Int()
  external int tm_hour;

  @ffi.Int()
  external int tm_mday;

  @ffi.Int()
  external int tm_mon;

  @ffi.Int()
  external int tm_year;

  @ffi.Int()
  external int tm_wday;

  @ffi.Int()
  external int tm_yday;

  @ffi.Int()
  external int tm_isdst;

  @ffi.Long()
  external int tm_gmtoff;

  external ffi.Pointer<ffi.Char> tm_zone;
}

class timespec extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__syscall_slong_t()
  external int tv_nsec;
}

typedef __time_t = ffi.Long;
typedef __syscall_slong_t = ffi.Long;

class itimerspec extends ffi.Struct {
  external timespec it_interval;

  external timespec it_value;
}

class sigevent extends ffi.Opaque {}

class __locale_struct extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<__locale_data>> __locales;

  external ffi.Pointer<ffi.UnsignedShort> __ctype_b;

  external ffi.Pointer<ffi.Int> __ctype_tolower;

  external ffi.Pointer<ffi.Int> __ctype_toupper;

  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<ffi.Char>> __names;
}

class __locale_data extends ffi.Opaque {}

typedef clock_t = __clock_t;
typedef __clock_t = ffi.Long;
typedef time_t = __time_t;
typedef locale_t = __locale_t;
typedef __locale_t = ffi.Pointer<__locale_struct>;
typedef clockid_t = __clockid_t;
typedef __clockid_t = ffi.Int;
typedef pid_t = __pid_t;
typedef __pid_t = ffi.Int;
typedef timer_t = __timer_t;
typedef __timer_t = ffi.Pointer<ffi.Void>;

class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedLong> __val;
}

class timeval extends ffi.Struct {
  @__time_t()
  external int tv_sec;

  @__suseconds_t()
  external int tv_usec;
}

typedef __suseconds_t = ffi.Long;

class fd_set extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__fd_mask> __fds_bits;
}

typedef __fd_mask = ffi.Long;

class __atomic_wide_counter extends ffi.Union {
  @ffi.UnsignedLongLong()
  external int __value64;

  external UnnamedStruct1 __value32;
}

class UnnamedStruct1 extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __low;

  @ffi.UnsignedInt()
  external int __high;
}

class __pthread_internal_list extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_list> __prev;

  external ffi.Pointer<__pthread_internal_list> __next;
}

class __pthread_internal_slist extends ffi.Struct {
  external ffi.Pointer<__pthread_internal_slist> __next;
}

class __pthread_mutex_s extends ffi.Struct {
  @ffi.Int()
  external int __lock;

  @ffi.UnsignedInt()
  external int __count;

  @ffi.Int()
  external int __owner;

  @ffi.UnsignedInt()
  external int __nusers;

  @ffi.Int()
  external int __kind;

  @ffi.Short()
  external int __spins;

  @ffi.Short()
  external int __elision;

  external __pthread_list_t __list;
}

typedef __pthread_list_t = __pthread_internal_list;

class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.UnsignedInt()
  external int __readers;

  @ffi.UnsignedInt()
  external int __writers;

  @ffi.UnsignedInt()
  external int __wrphase_futex;

  @ffi.UnsignedInt()
  external int __writers_futex;

  @ffi.UnsignedInt()
  external int __pad3;

  @ffi.UnsignedInt()
  external int __pad4;

  @ffi.Int()
  external int __cur_writer;

  @ffi.Int()
  external int __shared;

  @ffi.SignedChar()
  external int __rwelision;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedChar> __pad1;

  @ffi.UnsignedLong()
  external int __pad2;

  @ffi.UnsignedInt()
  external int __flags;
}

class __pthread_cond_s extends ffi.Struct {
  external __atomic_wide_counter __wseq;

  external __atomic_wide_counter __g1_start;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_refs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_size;

  @ffi.UnsignedInt()
  external int __g1_orig_size;

  @ffi.UnsignedInt()
  external int __wrefs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.UnsignedInt> __g_signals;
}

class __once_flag extends ffi.Struct {
  @ffi.Int()
  external int __data;
}

class pthread_mutexattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

class pthread_condattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

class pthread_attr_t extends ffi.Union {
  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_mutex_t extends ffi.Union {
  external __pthread_mutex_s __data;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_cond_t extends ffi.Union {
  external __pthread_cond_s __data;

  @ffi.Array.multi([48])
  external ffi.Array<ffi.Char> __size;

  @ffi.LongLong()
  external int __align;
}

class pthread_rwlock_t extends ffi.Union {
  external __pthread_rwlock_arch_t __data;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_rwlockattr_t extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_barrier_t extends ffi.Union {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Char> __size;

  @ffi.Long()
  external int __align;
}

class pthread_barrierattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Char> __size;

  @ffi.Int()
  external int __align;
}

class random_data extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> fptr;

  external ffi.Pointer<ffi.Int32> rptr;

  external ffi.Pointer<ffi.Int32> state;

  @ffi.Int()
  external int rand_type;

  @ffi.Int()
  external int rand_deg;

  @ffi.Int()
  external int rand_sep;

  external ffi.Pointer<ffi.Int32> end_ptr;
}

class drand48_data extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __x;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.UnsignedShort> __old_x;

  @ffi.UnsignedShort()
  external int __c;

  @ffi.UnsignedShort()
  external int __init;

  @ffi.UnsignedLongLong()
  external int __a;
}

typedef __compar_fn_t = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>;

class imaxdiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

typedef intmax_t = __intmax_t;
typedef __intmax_t = ffi.Long;
typedef uintmax_t = __uintmax_t;
typedef __uintmax_t = ffi.UnsignedLong;
typedef __gwchar_t = ffi.Int;

/// Combinations of these values describe the features with which libgit2
/// was compiled
abstract class git_feature_t {
  /// If set, libgit2 was built thread-aware and can be safely used from multiple
  /// threads.
  static const int GIT_FEATURE_THREADS = 1;

  /// If set, libgit2 was built with and linked against a TLS implementation.
  /// Custom TLS streams may still be added by the user to support HTTPS
  /// regardless of this.
  static const int GIT_FEATURE_HTTPS = 2;

  /// If set, libgit2 was built with and linked against libssh2. A custom
  /// transport may still be added by the user to support libssh2 regardless of
  /// this.
  static const int GIT_FEATURE_SSH = 4;

  /// If set, libgit2 was built with support for sub-second resolution in file
  /// modification times.
  static const int GIT_FEATURE_NSEC = 8;
}

/// Global library options
///
/// These are used to select which global option to set or get and are
/// used in `git_libgit2_opts()`.
abstract class git_libgit2_opt_t {
  static const int GIT_OPT_GET_MWINDOW_SIZE = 0;
  static const int GIT_OPT_SET_MWINDOW_SIZE = 1;
  static const int GIT_OPT_GET_MWINDOW_MAPPED_LIMIT = 2;
  static const int GIT_OPT_SET_MWINDOW_MAPPED_LIMIT = 3;
  static const int GIT_OPT_GET_SEARCH_PATH = 4;
  static const int GIT_OPT_SET_SEARCH_PATH = 5;
  static const int GIT_OPT_SET_CACHE_OBJECT_LIMIT = 6;
  static const int GIT_OPT_SET_CACHE_MAX_SIZE = 7;
  static const int GIT_OPT_ENABLE_CACHING = 8;
  static const int GIT_OPT_GET_CACHED_MEMORY = 9;
  static const int GIT_OPT_GET_TEMPLATE_PATH = 10;
  static const int GIT_OPT_SET_TEMPLATE_PATH = 11;
  static const int GIT_OPT_SET_SSL_CERT_LOCATIONS = 12;
  static const int GIT_OPT_SET_USER_AGENT = 13;
  static const int GIT_OPT_ENABLE_STRICT_OBJECT_CREATION = 14;
  static const int GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION = 15;
  static const int GIT_OPT_SET_SSL_CIPHERS = 16;
  static const int GIT_OPT_GET_USER_AGENT = 17;
  static const int GIT_OPT_ENABLE_OFS_DELTA = 18;
  static const int GIT_OPT_ENABLE_FSYNC_GITDIR = 19;
  static const int GIT_OPT_GET_WINDOWS_SHAREMODE = 20;
  static const int GIT_OPT_SET_WINDOWS_SHAREMODE = 21;
  static const int GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION = 22;
  static const int GIT_OPT_SET_ALLOCATOR = 23;
  static const int GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY = 24;
  static const int GIT_OPT_GET_PACK_MAX_OBJECTS = 25;
  static const int GIT_OPT_SET_PACK_MAX_OBJECTS = 26;
  static const int GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS = 27;
  static const int GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE = 28;
  static const int GIT_OPT_GET_MWINDOW_FILE_LIMIT = 29;
  static const int GIT_OPT_SET_MWINDOW_FILE_LIMIT = 30;
  static const int GIT_OPT_SET_ODB_PACKED_PRIORITY = 31;
  static const int GIT_OPT_SET_ODB_LOOSE_PRIORITY = 32;
  static const int GIT_OPT_GET_EXTENSIONS = 33;
  static const int GIT_OPT_SET_EXTENSIONS = 34;
  static const int GIT_OPT_GET_OWNER_VALIDATION = 35;
  static const int GIT_OPT_SET_OWNER_VALIDATION = 36;
}

/// A data buffer for exporting data from libgit2
///
/// Sometimes libgit2 wants to return an allocated data buffer to the
/// caller and have the caller take responsibility for freeing that memory.
/// To make ownership clear in these cases, libgit2 uses  `git_buf` to
/// return this data.  Callers should use `git_buf_dispose()` to release
/// the memory when they are done.
///
/// A `git_buf` contains a pointer to a NUL-terminated C string, and
/// the length of the string (not including the NUL terminator).
class git_buf extends ffi.Struct {
  /// The buffer contents.  `ptr` points to the start of the buffer
  /// being returned.  The buffer's length (in bytes) is specified
  /// by the `size` member of the structure, and contains a NUL
  /// terminator at position `(size + 1)`.
  external ffi.Pointer<ffi.Char> ptr;

  /// This field is reserved and unused.
  @ffi.Size()
  external int reserved;

  /// The length (in bytes) of the buffer pointed to by `ptr`,
  /// not including a NUL terminator.
  @ffi.Size()
  external int size;
}

/// Unique identity of any object (commit, tree, blob, tag).
class git_oid extends ffi.Struct {
  @ffi.Array.multi([20])
  external ffi.Array<ffi.UnsignedChar> id;
}

class git_oid_shorten extends ffi.Opaque {}

/// Basic type (loose or packed) of any Git object.
abstract class git_object_t {
  /// < Object can be any of the following
  static const int GIT_OBJECT_ANY = -2;

  /// < Object is invalid.
  static const int GIT_OBJECT_INVALID = -1;

  /// < A commit object.
  static const int GIT_OBJECT_COMMIT = 1;

  /// < A tree (directory listing) object.
  static const int GIT_OBJECT_TREE = 2;

  /// < A file revision object.
  static const int GIT_OBJECT_BLOB = 3;

  /// < An annotated tag object.
  static const int GIT_OBJECT_TAG = 4;

  /// < A delta, base is given by an offset.
  static const int GIT_OBJECT_OFS_DELTA = 6;

  /// < A delta, base is given by object id.
  static const int GIT_OBJECT_REF_DELTA = 7;
}

class git_odb extends ffi.Opaque {}

class git_odb_backend extends ffi.Opaque {}

class git_odb_object extends ffi.Opaque {}

/// A stream to read/write from a backend.
///
/// This represents a stream of data being written to or read from a
/// backend. When writing, the frontend functions take care of
/// calculating the object's id and all `finalize_write` needs to do is
/// store the object with the id it is passed.
class git_odb_stream extends ffi.Struct {
  external ffi.Pointer<git_odb_backend> backend;

  @ffi.UnsignedInt()
  external int mode;

  external ffi.Pointer<ffi.Void> hash_ctx;

  @git_object_size_t()
  external int declared_size;

  @git_object_size_t()
  external int received_bytes;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>,
              ffi.Size)>> read;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_stream>, ffi.Pointer<ffi.Char>,
              ffi.Size)>> write;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<git_odb_stream>, ffi.Pointer<git_oid>)>>
      finalize_write;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb_stream>)>> free;
}

/// The maximum size of an object
typedef git_object_size_t = ffi.Uint64;

/// A stream to write a pack file to the ODB
class git_odb_writepack extends ffi.Struct {
  external ffi.Pointer<git_odb_backend> backend;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<git_odb_writepack>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Pointer<git_indexer_progress>)>> append;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_odb_writepack>,
              ffi.Pointer<git_indexer_progress>)>> commit;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_odb_writepack>)>>
      free;
}

/// This structure is used to provide callers information about the
/// progress of indexing a packfile, either directly or part of a
/// fetch or clone that downloads a packfile.
class git_indexer_progress extends ffi.Struct {
  /// number of objects in the packfile being indexed
  @ffi.UnsignedInt()
  external int total_objects;

  /// received objects that have been hashed
  @ffi.UnsignedInt()
  external int indexed_objects;

  /// received_objects: objects which have been downloaded
  @ffi.UnsignedInt()
  external int received_objects;

  /// locally-available objects that have been injected in order
  /// to fix a thin pack
  @ffi.UnsignedInt()
  external int local_objects;

  /// number of deltas in the packfile being indexed
  @ffi.UnsignedInt()
  external int total_deltas;

  /// received deltas that have been indexed
  @ffi.UnsignedInt()
  external int indexed_deltas;

  /// size of the packfile received up to now
  @ffi.Size()
  external int received_bytes;
}

class git_midx_writer extends ffi.Opaque {}

class git_refdb extends ffi.Opaque {}

class git_refdb_backend extends ffi.Opaque {}

class git_commit_graph extends ffi.Opaque {}

class git_commit_graph_writer extends ffi.Opaque {}

class git_repository extends ffi.Opaque {}

class git_worktree extends ffi.Opaque {}

class git_object extends ffi.Opaque {}

class git_revwalk extends ffi.Opaque {}

class git_tag extends ffi.Opaque {}

class git_blob extends ffi.Opaque {}

class git_commit extends ffi.Opaque {}

class git_tree_entry extends ffi.Opaque {}

class git_tree extends ffi.Opaque {}

class git_treebuilder extends ffi.Opaque {}

class git_index extends ffi.Opaque {}

class git_index_iterator extends ffi.Opaque {}

class git_index_conflict_iterator extends ffi.Opaque {}

class git_config extends ffi.Opaque {}

class git_config_backend extends ffi.Opaque {}

class git_reflog_entry extends ffi.Opaque {}

class git_reflog extends ffi.Opaque {}

class git_note extends ffi.Opaque {}

class git_packbuilder extends ffi.Opaque {}

/// Time in a signature
class git_time extends ffi.Struct {
  /// < time in seconds from epoch
  @git_time_t()
  external int time;

  /// < timezone offset, in minutes
  @ffi.Int()
  external int offset;

  /// < indicator for questionable '-0000' offsets in signature
  @ffi.Char()
  external int sign;
}

typedef git_time_t = ffi.Int64;

/// An action signature (e.g. for committers, taggers, etc)
class git_signature extends ffi.Struct {
  /// < full name of the author
  external ffi.Pointer<ffi.Char> name;

  /// < email of the author
  external ffi.Pointer<ffi.Char> email;

  /// < time when the action happened
  external git_time when;
}

class git_reference extends ffi.Opaque {}

class git_reference_iterator extends ffi.Opaque {}

class git_transaction extends ffi.Opaque {}

class git_annotated_commit extends ffi.Opaque {}

class git_status_list extends ffi.Opaque {}

class git_rebase extends ffi.Opaque {}

/// Basic type of any Git reference.
abstract class git_reference_t {
  /// < Invalid reference
  static const int GIT_REFERENCE_INVALID = 0;

  /// < A reference that points at an object id
  static const int GIT_REFERENCE_DIRECT = 1;

  /// < A reference that points at another reference
  static const int GIT_REFERENCE_SYMBOLIC = 2;
  static const int GIT_REFERENCE_ALL = 3;
}

/// Basic type of any Git branch.
abstract class git_branch_t {
  static const int GIT_BRANCH_LOCAL = 1;
  static const int GIT_BRANCH_REMOTE = 2;
  static const int GIT_BRANCH_ALL = 3;
}

/// Valid modes for index and tree entries.
abstract class git_filemode_t {
  static const int GIT_FILEMODE_UNREADABLE = 0;
  static const int GIT_FILEMODE_TREE = 16384;
  static const int GIT_FILEMODE_BLOB = 33188;
  static const int GIT_FILEMODE_BLOB_EXECUTABLE = 33261;
  static const int GIT_FILEMODE_LINK = 40960;
  static const int GIT_FILEMODE_COMMIT = 57344;
}

class git_refspec extends ffi.Opaque {}

class git_remote extends ffi.Opaque {}

class git_transport extends ffi.Opaque {}

class git_push extends ffi.Opaque {}

/// Description of a reference advertised by a remote server, given out
/// on `ls` calls.
class git_remote_head extends ffi.Struct {
  /// available locally
  @ffi.Int()
  external int local;

  external git_oid oid;

  external git_oid loid;

  external ffi.Pointer<ffi.Char> name;

  /// If the server send a symref mapping for this ref, this will
  /// point to the target.
  external ffi.Pointer<ffi.Char> symref_target;
}

/// The callback settings structure
///
/// Set the callbacks to be called by the remote when informing the user
/// about the progress of the network operations.
class git_remote_callbacks extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// Textual progress from the remote. Text send over the
  /// progress side-band will be passed to this function (this is
  /// the 'counting objects' output).
  external git_transport_message_cb sideband_progress;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Int32, ffi.Pointer<ffi.Void>)>> completion;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external git_credential_acquire_cb credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external git_transport_certificate_check_cb certificate_check;

  /// During the download of new data, this will be regularly
  /// called with the current count of progress done by the
  /// indexer.
  external git_indexer_progress_cb transfer_progress;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>,
              ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>)>> update_tips;

  /// Function to call with progress information during pack
  /// building. Be aware that this is called inline with pack
  /// building operations, so performance may be affected.
  external git_packbuilder_progress pack_progress;

  /// Function to call with progress information during the
  /// upload portion of a push. Be aware that this is called
  /// inline with pack building operations, so performance may be
  /// affected.
  external git_push_transfer_progress_cb push_transfer_progress;

  /// See documentation of git_push_update_reference_cb
  external git_push_update_reference_cb push_update_reference;

  /// Called once between the negotiation step and the upload. It
  /// provides information about what updates will be performed.
  external git_push_negotiation push_negotiation;

  /// Create the transport to use for this operation. Leave NULL
  /// to auto-detect.
  external git_transport_cb transport;

  /// Callback when the remote is ready to connect.
  external git_remote_ready_cb remote_ready;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

  /// Resolve URL before connecting to remote.
  /// The returned URL will be used to connect to the remote instead.
  ///
  /// This callback is deprecated; users should use
  /// git_remote_ready_cb and configure the instance URL instead.
  external git_url_resolve_cb resolve_url;
}

/// Callback for messages received by the transport.
///
/// Return a negative value to cancel the network operation.
///
/// @param str The message from the transport
/// @param len The length of the message
/// @param payload Payload provided by the caller
typedef git_transport_message_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.Void>)>>;

/// Argument to the completion callback which tells it which operation
/// finished.
abstract class git_remote_completion_t {
  static const int GIT_REMOTE_COMPLETION_DOWNLOAD = 0;
  static const int GIT_REMOTE_COMPLETION_INDEXING = 1;
  static const int GIT_REMOTE_COMPLETION_ERROR = 2;
}

/// Credential acquisition callback.
///
/// This callback is usually involved any time another system might need
/// authentication. As such, you are expected to provide a valid
/// git_credential object back, depending on allowed_types (a
/// git_credential_t bitmask).
///
/// Note that most authentication details are your responsibility - this
/// callback will be called until the authentication succeeds, or you report
/// an error. As such, it's easy to get in a loop if you fail to stop providing
/// the same incorrect credentials.
///
/// @param out The newly created credential object.
/// @param url The resource for which we are demanding a credential.
/// @param username_from_url The username that was embedded in a "user\@host"
/// remote url, or NULL if not included.
/// @param allowed_types A bitmask stating which credential types are OK to return.
/// @param payload The payload provided when specifying this callback.
/// @return 0 for success, < 0 to indicate an error, > 0 to indicate
/// no credential was acquired
typedef git_credential_acquire_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Pointer<git_credential>>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.UnsignedInt,
            ffi.Pointer<ffi.Void>)>>;

/// The base structure for all credential types
class git_credential extends ffi.Struct {
  /// < A type of credential
  @ffi.Int32()
  external int credtype;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_credential>)>> free;
}

/// Supported credential types
///
/// This represents the various types of authentication methods supported by
/// the library.
abstract class git_credential_t {
  /// A vanilla user/password request
  /// @see git_credential_userpass_plaintext_new
  static const int GIT_CREDENTIAL_USERPASS_PLAINTEXT = 1;

  /// An SSH key-based authentication request
  /// @see git_credential_ssh_key_new
  static const int GIT_CREDENTIAL_SSH_KEY = 2;

  /// An SSH key-based authentication request, with a custom signature
  /// @see git_credential_ssh_custom_new
  static const int GIT_CREDENTIAL_SSH_CUSTOM = 4;

  /// An NTLM/Negotiate-based authentication request.
  /// @see git_credential_default
  static const int GIT_CREDENTIAL_DEFAULT = 8;

  /// An SSH interactive authentication request
  /// @see git_credential_ssh_interactive_new
  static const int GIT_CREDENTIAL_SSH_INTERACTIVE = 16;

  /// Username-only authentication request
  ///
  /// Used as a pre-authentication step if the underlying transport
  /// (eg. SSH, with no username in its URL) does not know which username
  /// to use.
  ///
  /// @see git_credential_username_new
  static const int GIT_CREDENTIAL_USERNAME = 32;

  /// An SSH key-based authentication request
  ///
  /// Allows credentials to be read from memory instead of files.
  /// Note that because of differences in crypto backend support, it might
  /// not be functional.
  ///
  /// @see git_credential_ssh_key_memory_new
  static const int GIT_CREDENTIAL_SSH_MEMORY = 64;
}

/// Callback for the user's custom certificate checks.
///
/// @param cert The host certificate
/// @param valid Whether the libgit2 checks (OpenSSL or WinHTTP) think
/// this certificate is valid
/// @param host Hostname of the host libgit2 connected to
/// @param payload Payload provided by the caller
/// @return 0 to proceed with the connection, < 0 to fail the connection
/// or > 0 to indicate that the callback refused to act and that
/// the existing validity determination should be honored
typedef git_transport_certificate_check_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_cert>, ffi.Int, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>)>>;

/// Parent type for `git_cert_hostkey` and `git_cert_x509`.
class git_cert extends ffi.Struct {
  /// Type of certificate. A `GIT_CERT_` value.
  @ffi.Int32()
  external int cert_type;
}

/// Type of host certificate structure that is passed to the check callback
abstract class git_cert_t {
  /// No information about the certificate is available. This may
  /// happen when using curl.
  static const int GIT_CERT_NONE = 0;

  /// The `data` argument to the callback will be a pointer to
  /// the DER-encoded data.
  static const int GIT_CERT_X509 = 1;

  /// The `data` argument to the callback will be a pointer to a
  /// `git_cert_hostkey` structure.
  static const int GIT_CERT_HOSTKEY_LIBSSH2 = 2;

  /// The `data` argument to the callback will be a pointer to a
  /// `git_strarray` with `name:content` strings containing
  /// information about the certificate. This is used when using
  /// curl.
  static const int GIT_CERT_STRARRAY = 3;
}

/// Type for progress callbacks during indexing.  Return a value less
/// than zero to cancel the indexing or download.
///
/// @param stats Structure containing information about the state of the transfer
/// @param payload Payload provided by caller
typedef git_indexer_progress_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<git_indexer_progress>, ffi.Pointer<ffi.Void>)>>;

/// Packbuilder progress notification function
typedef git_packbuilder_progress = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Int, ffi.Uint32, ffi.Uint32, ffi.Pointer<ffi.Void>)>>;

/// Push network progress notification function
typedef git_push_transfer_progress_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.UnsignedInt, ffi.UnsignedInt, ffi.Size,
            ffi.Pointer<ffi.Void>)>>;

/// Callback used to inform of the update status from the remote.
///
/// Called for each updated reference on push. If `status` is
/// not `NULL`, the update was rejected by the remote server
/// and `status` contains the reason given.
///
/// @param refname refname specifying to the remote ref
/// @param status status message sent from the remote
/// @param data data provided by the caller
/// @return 0 on success, otherwise an error
typedef git_push_update_reference_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>)>>;

/// Callback used to inform of upcoming updates.
///
/// @param updates an array containing the updates which will be sent
/// as commands to the destination.
/// @param len number of elements in `updates`
/// @param payload Payload provided by the caller
typedef git_push_negotiation = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Pointer<git_push_update>>, ffi.Size,
            ffi.Pointer<ffi.Void>)>>;

/// Represents an update which will be performed on the remote during push
class git_push_update extends ffi.Struct {
  /// The source name of the reference
  external ffi.Pointer<ffi.Char> src_refname;

  /// The name of the reference to update on the server
  external ffi.Pointer<ffi.Char> dst_refname;

  /// The current target of the reference
  external git_oid src;

  /// The new target for the reference
  external git_oid dst;
}

/// Signature of a function which creates a transport
typedef git_transport_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Pointer<git_transport>>,
            ffi.Pointer<git_remote>, ffi.Pointer<ffi.Void>)>>;

/// Callback invoked immediately before we attempt to connect to the
/// given url.  Callers may change the URL before the connection by
/// calling `git_remote_set_instance_url` in the callback.
///
/// @param remote The remote to be connected
/// @param direction GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
/// @param payload Payload provided by the caller
/// @return 0 on success, or an error
typedef git_remote_ready_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<git_remote>, ffi.Int, ffi.Pointer<ffi.Void>)>>;

/// Callback to resolve URLs before connecting to remote
///
/// If you return GIT_PASSTHROUGH, you don't need to write anything to
/// url_resolved.
///
/// @param url_resolved The buffer to write the resolved URL to
/// @param url The URL to resolve
/// @param direction GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
/// @param payload Payload provided by the caller
/// @return 0 on success, GIT_PASSTHROUGH or an error
/// @deprecated Use `git_remote_set_instance_url`
typedef git_url_resolve_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<ffi.Char>, ffi.Int,
            ffi.Pointer<ffi.Void>)>>;

class git_submodule extends ffi.Opaque {}

/// Submodule update values
///
/// These values represent settings for the `submodule.$name.update`
/// configuration value which says how to handle `git submodule update` for
/// this submodule.  The value is usually set in the ".gitmodules" file and
/// copied to ".git/config" when the submodule is initialized.
///
/// You can override this setting on a per-submodule basis with
/// `git_submodule_set_update()` and write the changed value to disk using
/// `git_submodule_save()`.  If you have overwritten the value, you can
/// revert it by passing `GIT_SUBMODULE_UPDATE_RESET` to the set function.
///
/// The values are:
///
/// - GIT_SUBMODULE_UPDATE_CHECKOUT: the default; when a submodule is
/// updated, checkout the new detached HEAD to the submodule directory.
/// - GIT_SUBMODULE_UPDATE_REBASE: update by rebasing the current checked
/// out branch onto the commit from the superproject.
/// - GIT_SUBMODULE_UPDATE_MERGE: update by merging the commit in the
/// superproject into the current checkout out branch of the submodule.
/// - GIT_SUBMODULE_UPDATE_NONE: do not update this submodule even when
/// the commit in the superproject is updated.
/// - GIT_SUBMODULE_UPDATE_DEFAULT: not used except as static initializer
/// when we don't want any particular update rule to be specified.
abstract class git_submodule_update_t {
  static const int GIT_SUBMODULE_UPDATE_CHECKOUT = 1;
  static const int GIT_SUBMODULE_UPDATE_REBASE = 2;
  static const int GIT_SUBMODULE_UPDATE_MERGE = 3;
  static const int GIT_SUBMODULE_UPDATE_NONE = 4;
  static const int GIT_SUBMODULE_UPDATE_DEFAULT = 0;
}

/// Submodule ignore values
///
/// These values represent settings for the `submodule.$name.ignore`
/// configuration value which says how deeply to look at the working
/// directory when getting submodule status.
///
/// You can override this value in memory on a per-submodule basis with
/// `git_submodule_set_ignore()` and can write the changed value to disk
/// with `git_submodule_save()`.  If you have overwritten the value, you
/// can revert to the on disk value by using `GIT_SUBMODULE_IGNORE_RESET`.
///
/// The values are:
///
/// - GIT_SUBMODULE_IGNORE_UNSPECIFIED: use the submodule's configuration
/// - GIT_SUBMODULE_IGNORE_NONE: don't ignore any change - i.e. even an
/// untracked file, will mark the submodule as dirty.  Ignored files are
/// still ignored, of course.
/// - GIT_SUBMODULE_IGNORE_UNTRACKED: ignore untracked files; only changes
/// to tracked files, or the index or the HEAD commit will matter.
/// - GIT_SUBMODULE_IGNORE_DIRTY: ignore changes in the working directory,
/// only considering changes if the HEAD of submodule has moved from the
/// value in the superproject.
/// - GIT_SUBMODULE_IGNORE_ALL: never check if the submodule is dirty
/// - GIT_SUBMODULE_IGNORE_DEFAULT: not used except as static initializer
/// when we don't want any particular ignore rule to be specified.
abstract class git_submodule_ignore_t {
  /// < use the submodule's configuration
  static const int GIT_SUBMODULE_IGNORE_UNSPECIFIED = -1;

  /// < any change or untracked == dirty
  static const int GIT_SUBMODULE_IGNORE_NONE = 1;

  /// < dirty if tracked files change
  static const int GIT_SUBMODULE_IGNORE_UNTRACKED = 2;

  /// < only dirty if HEAD moved
  static const int GIT_SUBMODULE_IGNORE_DIRTY = 3;

  /// < never dirty
  static const int GIT_SUBMODULE_IGNORE_ALL = 4;
}

/// Options for submodule recurse.
///
/// Represent the value of `submodule.$name.fetchRecurseSubmodules`
///
/// * GIT_SUBMODULE_RECURSE_NO    - do no recurse into submodules
/// * GIT_SUBMODULE_RECURSE_YES   - recurse into submodules
/// * GIT_SUBMODULE_RECURSE_ONDEMAND - recurse into submodules only when
/// commit not already in local clone
abstract class git_submodule_recurse_t {
  static const int GIT_SUBMODULE_RECURSE_NO = 0;
  static const int GIT_SUBMODULE_RECURSE_YES = 1;
  static const int GIT_SUBMODULE_RECURSE_ONDEMAND = 2;
}

/// A type to write in a streaming fashion, for example, for filters.
class git_writestream extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_writestream>, ffi.Pointer<ffi.Char>,
              ffi.Size)>> write;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Int Function(ffi.Pointer<git_writestream>)>> close;

  external ffi.Pointer<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_writestream>)>> free;
}

class git_mailmap extends ffi.Opaque {}

/// Option flags for `git_repository_open_ext`.
abstract class git_repository_open_flag_t {
  /// Only open the repository if it can be immediately found in the
  /// start_path. Do not walk up from the start_path looking at parent
  /// directories.
  static const int GIT_REPOSITORY_OPEN_NO_SEARCH = 1;

  /// Unless this flag is set, open will not continue searching across
  /// filesystem boundaries (i.e. when `st_dev` changes from the `stat`
  /// system call).  For example, searching in a user's home directory at
  /// "/home/user/source/" will not return "/.git/" as the found repo if
  /// "/" is a different filesystem than "/home".
  static const int GIT_REPOSITORY_OPEN_CROSS_FS = 2;

  /// Open repository as a bare repo regardless of core.bare config, and
  /// defer loading config file for faster setup.
  /// Unlike `git_repository_open_bare`, this can follow gitlinks.
  static const int GIT_REPOSITORY_OPEN_BARE = 4;

  /// Do not check for a repository by appending /.git to the start_path;
  /// only open the repository if start_path itself points to the git
  /// directory.
  static const int GIT_REPOSITORY_OPEN_NO_DOTGIT = 8;

  /// Find and open a git repository, respecting the environment variables
  /// used by the git command-line tools.
  /// If set, `git_repository_open_ext` will ignore the other flags and
  /// the `ceiling_dirs` argument, and will allow a NULL `path` to use
  /// `GIT_DIR` or search from the current directory.
  /// The search for a repository will respect $GIT_CEILING_DIRECTORIES and
  /// $GIT_DISCOVERY_ACROSS_FILESYSTEM.  The opened repository will
  /// respect $GIT_INDEX_FILE, $GIT_NAMESPACE, $GIT_OBJECT_DIRECTORY, and
  /// $GIT_ALTERNATE_OBJECT_DIRECTORIES.
  /// In the future, this flag will also cause `git_repository_open_ext`
  /// to respect $GIT_WORK_TREE and $GIT_COMMON_DIR; currently,
  /// `git_repository_open_ext` with this flag will error out if either
  /// $GIT_WORK_TREE or $GIT_COMMON_DIR is set.
  static const int GIT_REPOSITORY_OPEN_FROM_ENV = 16;
}

/// Option flags for `git_repository_init_ext`.
///
/// These flags configure extra behaviors to `git_repository_init_ext`.
/// In every case, the default behavior is the zero value (i.e. flag is
/// not set). Just OR the flag values together for the `flags` parameter
/// when initializing a new repo.
abstract class git_repository_init_flag_t {
  /// Create a bare repository with no working directory.
  static const int GIT_REPOSITORY_INIT_BARE = 1;

  /// Return an GIT_EEXISTS error if the repo_path appears to already be
  /// an git repository.
  static const int GIT_REPOSITORY_INIT_NO_REINIT = 2;

  /// Normally a "/.git/" will be appended to the repo path for
  /// non-bare repos (if it is not already there), but passing this flag
  /// prevents that behavior.
  static const int GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = 4;

  /// Make the repo_path (and workdir_path) as needed. Init is always willing
  /// to create the ".git" directory even without this flag. This flag tells
  /// init to create the trailing component of the repo and workdir paths
  /// as needed.
  static const int GIT_REPOSITORY_INIT_MKDIR = 8;

  /// Recursively make all components of the repo and workdir paths as
  /// necessary.
  static const int GIT_REPOSITORY_INIT_MKPATH = 16;

  /// libgit2 normally uses internal templates to initialize a new repo.
  /// This flags enables external templates, looking the "template_path" from
  /// the options if set, or the `init.templatedir` global config if not,
  /// or falling back on "/usr/share/git-core/templates" if it exists.
  static const int GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = 32;

  /// If an alternate workdir is specified, use relative paths for the gitdir
  /// and core.worktree.
  static const int GIT_REPOSITORY_INIT_RELATIVE_GITLINK = 64;
}

/// Mode options for `git_repository_init_ext`.
///
/// Set the mode field of the `git_repository_init_options` structure
/// either to the custom mode that you would like, or to one of the
/// defined modes.
abstract class git_repository_init_mode_t {
  /// Use permissions configured by umask - the default.
  static const int GIT_REPOSITORY_INIT_SHARED_UMASK = 0;

  /// Use "--shared=group" behavior, chmod'ing the new repo to be group
  /// writable and "g+sx" for sticky group assignment.
  static const int GIT_REPOSITORY_INIT_SHARED_GROUP = 1533;

  /// Use "--shared=all" behavior, adding world readability.
  static const int GIT_REPOSITORY_INIT_SHARED_ALL = 1535;
}

/// Extended options structure for `git_repository_init_ext`.
///
/// This contains extra options for `git_repository_init_ext` that enable
/// additional initialization features.
class git_repository_init_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Combination of GIT_REPOSITORY_INIT flags above.
  @ffi.Uint32()
  external int flags;

  /// Set to one of the standard GIT_REPOSITORY_INIT_SHARED_... constants
  /// above, or to a custom value that you would like.
  @ffi.Uint32()
  external int mode;

  /// The path to the working dir or NULL for default (i.e. repo_path parent
  /// on non-bare repos). IF THIS IS RELATIVE PATH, IT WILL BE EVALUATED
  /// RELATIVE TO THE REPO_PATH. If this is not the "natural" working
  /// directory, a .git gitlink file will be created here linking to the
  /// repo_path.
  external ffi.Pointer<ffi.Char> workdir_path;

  /// If set, this will be used to initialize the "description" file in the
  /// repository, instead of using the template content.
  external ffi.Pointer<ffi.Char> description;

  /// When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set, this contains
  /// the path to use for the template directory. If this is NULL, the config
  /// or default directory options will be used instead.
  external ffi.Pointer<ffi.Char> template_path;

  /// The name of the head to point HEAD at. If NULL, then this will be
  /// treated as "master" and the HEAD ref will be set to "refs/heads/master".
  /// If this begins with "refs/" it will be used verbatim;
  /// otherwise "refs/heads/" will be prefixed.
  external ffi.Pointer<ffi.Char> initial_head;

  /// If this is non-NULL, then after the rest of the repository
  /// initialization is completed, an "origin" remote will be added
  /// pointing to this URL.
  external ffi.Pointer<ffi.Char> origin_url;
}

/// List of items which belong to the git repository layout
abstract class git_repository_item_t {
  static const int GIT_REPOSITORY_ITEM_GITDIR = 0;
  static const int GIT_REPOSITORY_ITEM_WORKDIR = 1;
  static const int GIT_REPOSITORY_ITEM_COMMONDIR = 2;
  static const int GIT_REPOSITORY_ITEM_INDEX = 3;
  static const int GIT_REPOSITORY_ITEM_OBJECTS = 4;
  static const int GIT_REPOSITORY_ITEM_REFS = 5;
  static const int GIT_REPOSITORY_ITEM_PACKED_REFS = 6;
  static const int GIT_REPOSITORY_ITEM_REMOTES = 7;
  static const int GIT_REPOSITORY_ITEM_CONFIG = 8;
  static const int GIT_REPOSITORY_ITEM_INFO = 9;
  static const int GIT_REPOSITORY_ITEM_HOOKS = 10;
  static const int GIT_REPOSITORY_ITEM_LOGS = 11;
  static const int GIT_REPOSITORY_ITEM_MODULES = 12;
  static const int GIT_REPOSITORY_ITEM_WORKTREES = 13;
  static const int GIT_REPOSITORY_ITEM__LAST = 14;
}

/// Callback used to iterate over each FETCH_HEAD entry
///
/// @see git_repository_fetchhead_foreach
///
/// @param ref_name The reference name
/// @param remote_url The remote URL
/// @param oid The reference target OID
/// @param is_merge Was the reference the result of a merge
/// @param payload Payload passed to git_repository_fetchhead_foreach
/// @return non-zero to terminate the iteration
typedef git_repository_fetchhead_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<git_oid>, ffi.UnsignedInt, ffi.Pointer<ffi.Void>)>>;

/// Callback used to iterate over each MERGE_HEAD entry
///
/// @see git_repository_mergehead_foreach
///
/// @param oid The merge OID
/// @param payload Payload passed to git_repository_mergehead_foreach
/// @return non-zero to terminate the iteration
typedef git_repository_mergehead_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>)>>;

/// Repository state
///
/// These values represent possible states for the repository to be in,
/// based on the current operation which is ongoing.
abstract class git_repository_state_t {
  static const int GIT_REPOSITORY_STATE_NONE = 0;
  static const int GIT_REPOSITORY_STATE_MERGE = 1;
  static const int GIT_REPOSITORY_STATE_REVERT = 2;
  static const int GIT_REPOSITORY_STATE_REVERT_SEQUENCE = 3;
  static const int GIT_REPOSITORY_STATE_CHERRYPICK = 4;
  static const int GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE = 5;
  static const int GIT_REPOSITORY_STATE_BISECT = 6;
  static const int GIT_REPOSITORY_STATE_REBASE = 7;
  static const int GIT_REPOSITORY_STATE_REBASE_INTERACTIVE = 8;
  static const int GIT_REPOSITORY_STATE_REBASE_MERGE = 9;
  static const int GIT_REPOSITORY_STATE_APPLY_MAILBOX = 10;
  static const int GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE = 11;
}

/// Callback for git_treebuilder_filter
///
/// The return value is treated as a boolean, with zero indicating that the
/// entry should be left alone and any non-zero value meaning that the
/// entry should be removed from the treebuilder list (i.e. filtered out).
typedef git_treebuilder_filter_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_tree_entry>, ffi.Pointer<ffi.Void>)>>;

/// Tree traversal modes
abstract class git_treewalk_mode {
  /// Pre-order
  static const int GIT_TREEWALK_PRE = 0;

  /// Post-order
  static const int GIT_TREEWALK_POST = 1;
}

/// Callback for the tree traversal method
typedef git_treewalk_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_tree_entry>,
            ffi.Pointer<ffi.Void>)>>;

/// The kind of update to perform
abstract class git_tree_update_t {
  /// Update or insert an entry at the specified path
  static const int GIT_TREE_UPDATE_UPSERT = 0;

  /// Remove an entry from the specified path
  static const int GIT_TREE_UPDATE_REMOVE = 1;
}

/// An action to perform during the update of a tree
class git_tree_update extends ffi.Struct {
  /// Update action. If it's an removal, only the path is looked at
  @ffi.Int32()
  external int action;

  /// The entry's id
  external git_oid id;

  /// The filemode/kind of object
  @ffi.Int32()
  external int filemode;

  /// The full path from the root tree
  external ffi.Pointer<ffi.Char> path;
}

/// Array of strings
class git_strarray extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Char>> strings;

  @ffi.Size()
  external int count;
}

/// Callback used to iterate over references
///
/// @see git_reference_foreach
///
/// @param reference The reference object
/// @param payload Payload passed to git_reference_foreach
/// @return non-zero to terminate the iteration
typedef git_reference_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_reference>, ffi.Pointer<ffi.Void>)>>;

/// Callback used to iterate over reference names
///
/// @see git_reference_foreach_name
///
/// @param name The reference name
/// @param payload Payload passed to git_reference_foreach_name
/// @return non-zero to terminate the iteration
typedef git_reference_foreach_name_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>>;

/// Normalization options for reference lookup
abstract class git_reference_format_t {
  /// No particular normalization.
  static const int GIT_REFERENCE_FORMAT_NORMAL = 0;

  /// Control whether one-level refnames are accepted
  /// (i.e., refnames that do not contain multiple /-separated
  /// components). Those are expected to be written only using
  /// uppercase letters and underscore (FETCH_HEAD, ...)
  static const int GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL = 1;

  /// Interpret the provided name as a reference pattern for a
  /// refspec (as used with remote repositories). If this option
  /// is enabled, the name is allowed to contain a single * (<star>)
  /// in place of a one full pathname component
  /// (e.g., foo/<star>/bar but not foo/bar<star>).
  static const int GIT_REFERENCE_FORMAT_REFSPEC_PATTERN = 2;

  /// Interpret the name as part of a refspec in shorthand form
  /// so the `ONELEVEL` naming rules aren't enforced and 'master'
  /// becomes a valid name.
  static const int GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND = 4;
}

/// Flags for diff options.  A combination of these flags can be passed
/// in via the `flags` value in the `git_diff_options`.
abstract class git_diff_option_t {
  /// Normal diff, the default
  static const int GIT_DIFF_NORMAL = 0;

  /// Reverse the sides of the diff
  static const int GIT_DIFF_REVERSE = 1;

  /// Include ignored files in the diff
  static const int GIT_DIFF_INCLUDE_IGNORED = 2;

  /// Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory
  /// will be marked with only a single entry in the diff; this flag
  /// adds all files under the directory as IGNORED entries, too.
  static const int GIT_DIFF_RECURSE_IGNORED_DIRS = 4;

  /// Include untracked files in the diff
  static const int GIT_DIFF_INCLUDE_UNTRACKED = 8;

  /// Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked
  /// directory will be marked with only a single entry in the diff
  /// (a la what core Git does in `git status`); this flag adds *all*
  /// files under untracked directories as UNTRACKED entries, too.
  static const int GIT_DIFF_RECURSE_UNTRACKED_DIRS = 16;

  /// Include unmodified files in the diff
  static const int GIT_DIFF_INCLUDE_UNMODIFIED = 32;

  /// Normally, a type change between files will be converted into a
  /// DELETED record for the old and an ADDED record for the new; this
  /// options enabled the generation of TYPECHANGE delta records.
  static const int GIT_DIFF_INCLUDE_TYPECHANGE = 64;

  /// Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still
  /// generally show as a DELETED blob.  This flag tries to correctly
  /// label blob->tree transitions as TYPECHANGE records with new_file's
  /// mode set to tree.  Note: the tree SHA will not be available.
  static const int GIT_DIFF_INCLUDE_TYPECHANGE_TREES = 128;

  /// Ignore file mode changes
  static const int GIT_DIFF_IGNORE_FILEMODE = 256;

  /// Treat all submodules as unmodified
  static const int GIT_DIFF_IGNORE_SUBMODULES = 512;

  /// Use case insensitive filename comparisons
  static const int GIT_DIFF_IGNORE_CASE = 1024;

  /// May be combined with `GIT_DIFF_IGNORE_CASE` to specify that a file
  /// that has changed case will be returned as an add/delete pair.
  static const int GIT_DIFF_INCLUDE_CASECHANGE = 2048;

  /// If the pathspec is set in the diff options, this flags indicates
  /// that the paths will be treated as literal paths instead of
  /// fnmatch patterns.  Each path in the list must either be a full
  /// path to a file or a directory.  (A trailing slash indicates that
  /// the path will _only_ match a directory).  If a directory is
  /// specified, all children will be included.
  static const int GIT_DIFF_DISABLE_PATHSPEC_MATCH = 4096;

  /// Disable updating of the `binary` flag in delta records.  This is
  /// useful when iterating over a diff if you don't need hunk and data
  /// callbacks and want to avoid having to load file completely.
  static const int GIT_DIFF_SKIP_BINARY_CHECK = 8192;

  /// When diff finds an untracked directory, to match the behavior of
  /// core Git, it scans the contents for IGNORED and UNTRACKED files.
  /// If *all* contents are IGNORED, then the directory is IGNORED; if
  /// any contents are not IGNORED, then the directory is UNTRACKED.
  /// This is extra work that may not matter in many cases.  This flag
  /// turns off that scan and immediately labels an untracked directory
  /// as UNTRACKED (changing the behavior to not match core Git).
  static const int GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = 16384;

  /// When diff finds a file in the working directory with stat
  /// information different from the index, but the OID ends up being the
  /// same, write the correct stat information into the index.  Note:
  /// without this flag, diff will always leave the index untouched.
  static const int GIT_DIFF_UPDATE_INDEX = 32768;

  /// Include unreadable files in the diff
  static const int GIT_DIFF_INCLUDE_UNREADABLE = 65536;

  /// Include unreadable files in the diff
  static const int GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = 131072;

  /// Use a heuristic that takes indentation and whitespace into account
  /// which generally can produce better diffs when dealing with ambiguous
  /// diff hunks.
  static const int GIT_DIFF_INDENT_HEURISTIC = 262144;

  /// Ignore blank lines
  static const int GIT_DIFF_IGNORE_BLANK_LINES = 524288;

  /// Treat all files as text, disabling binary attributes & detection
  static const int GIT_DIFF_FORCE_TEXT = 1048576;

  /// Treat all files as binary, disabling text diffs
  static const int GIT_DIFF_FORCE_BINARY = 2097152;

  /// Ignore all whitespace
  static const int GIT_DIFF_IGNORE_WHITESPACE = 4194304;

  /// Ignore changes in amount of whitespace
  static const int GIT_DIFF_IGNORE_WHITESPACE_CHANGE = 8388608;

  /// Ignore whitespace at end of line
  static const int GIT_DIFF_IGNORE_WHITESPACE_EOL = 16777216;

  /// When generating patch text, include the content of untracked
  /// files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but
  /// it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that
  /// flag if you want the content of every single UNTRACKED file.
  static const int GIT_DIFF_SHOW_UNTRACKED_CONTENT = 33554432;

  /// When generating output, include the names of unmodified files if
  /// they are included in the git_diff.  Normally these are skipped in
  /// the formats that list files (e.g. name-only, name-status, raw).
  /// Even with this, these will not be included in patch format.
  static const int GIT_DIFF_SHOW_UNMODIFIED = 67108864;

  /// Use the "patience diff" algorithm
  static const int GIT_DIFF_PATIENCE = 268435456;

  /// Take extra time to find minimal diff
  static const int GIT_DIFF_MINIMAL = 536870912;

  /// Include the necessary deflate / delta information so that `git-apply`
  /// can apply given diff information to binary files.
  static const int GIT_DIFF_SHOW_BINARY = 1073741824;
}

class git_diff extends ffi.Opaque {}

/// Flags for the delta object and the file objects on each side.
///
/// These flags are used for both the `flags` value of the `git_diff_delta`
/// and the flags for the `git_diff_file` objects representing the old and
/// new sides of the delta.  Values outside of this public range should be
/// considered reserved for internal or future use.
abstract class git_diff_flag_t {
  /// < file(s) treated as binary data
  static const int GIT_DIFF_FLAG_BINARY = 1;

  /// < file(s) treated as text data
  static const int GIT_DIFF_FLAG_NOT_BINARY = 2;

  /// < `id` value is known correct
  static const int GIT_DIFF_FLAG_VALID_ID = 4;

  /// < file exists at this side of the delta
  static const int GIT_DIFF_FLAG_EXISTS = 8;

  /// < file size value is known correct
  static const int GIT_DIFF_FLAG_VALID_SIZE = 16;
}

/// What type of change is described by a git_diff_delta?
///
/// `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run
/// `git_diff_find_similar()` on the diff object.
///
/// `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE`
/// in the option flags (otherwise type changes will be split into ADDED /
/// DELETED pairs).
abstract class git_delta_t {
  /// < no changes
  static const int GIT_DELTA_UNMODIFIED = 0;

  /// < entry does not exist in old version
  static const int GIT_DELTA_ADDED = 1;

  /// < entry does not exist in new version
  static const int GIT_DELTA_DELETED = 2;

  /// < entry content changed between old and new
  static const int GIT_DELTA_MODIFIED = 3;

  /// < entry was renamed between old and new
  static const int GIT_DELTA_RENAMED = 4;

  /// < entry was copied from another old entry
  static const int GIT_DELTA_COPIED = 5;

  /// < entry is ignored item in workdir
  static const int GIT_DELTA_IGNORED = 6;

  /// < entry is untracked item in workdir
  static const int GIT_DELTA_UNTRACKED = 7;

  /// < type of entry changed between old and new
  static const int GIT_DELTA_TYPECHANGE = 8;

  /// < entry is unreadable
  static const int GIT_DELTA_UNREADABLE = 9;

  /// < entry in the index is conflicted
  static const int GIT_DELTA_CONFLICTED = 10;
}

/// Description of one side of a delta.
///
/// Although this is called a "file", it could represent a file, a symbolic
/// link, a submodule commit id, or even a tree (although that only if you
/// are tracking type changes or ignored/untracked directories).
class git_diff_file extends ffi.Struct {
  /// The `git_oid` of the item.  If the entry represents an
  /// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
  /// then the oid will be zeroes.
  external git_oid id;

  /// The NUL-terminated path to the entry relative to the working
  /// directory of the repository.
  external ffi.Pointer<ffi.Char> path;

  /// The size of the entry in bytes.
  @git_object_size_t()
  external int size;

  /// A combination of the `git_diff_flag_t` types
  @ffi.Uint32()
  external int flags;

  /// Roughly, the stat() `st_mode` value for the item.  This will
  /// be restricted to one of the `git_filemode_t` values.
  @ffi.Uint16()
  external int mode;

  /// Represents the known length of the `id` field, when
  /// converted to a hex string.  It is generally `GIT_OID_HEXSZ`, unless this
  /// delta was created from reading a patch file, in which case it may be
  /// abbreviated to something reasonable, like 7 characters.
  @ffi.Uint16()
  external int id_abbrev;
}

/// Description of changes to one entry.
///
/// A `delta` is a file pair with an old and new revision.  The old version
/// may be absent if the file was just created and the new version may be
/// absent if the file was deleted.  A diff is mostly just a list of deltas.
///
/// When iterating over a diff, this will be passed to most callbacks and
/// you can use the contents to understand exactly what has changed.
///
/// The `old_file` represents the "from" side of the diff and the `new_file`
/// represents to "to" side of the diff.  What those means depend on the
/// function that was used to generate the diff and will be documented below.
/// You can also use the `GIT_DIFF_REVERSE` flag to flip it around.
///
/// Although the two sides of the delta are named "old_file" and "new_file",
/// they actually may correspond to entries that represent a file, a symbolic
/// link, a submodule commit id, or even a tree (if you are tracking type
/// changes or ignored/untracked directories).
///
/// Under some circumstances, in the name of efficiency, not all fields will
/// be filled in, but we generally try to fill in as much as possible.  One
/// example is that the "flags" field may not have either the `BINARY` or the
/// `NOT_BINARY` flag set to avoid examining file contents if you do not pass
/// in hunk and/or line callbacks to the diff foreach iteration function.  It
/// will just use the git attributes for those files.
///
/// The similarity score is zero unless you call `git_diff_find_similar()`
/// which does a similarity analysis of files in the diff.  Use that
/// function to do rename and copy detection, and to split heavily modified
/// files in add/delete pairs.  After that call, deltas with a status of
/// GIT_DELTA_RENAMED or GIT_DELTA_COPIED will have a similarity score
/// between 0 and 100 indicating how similar the old and new sides are.
///
/// If you ask `git_diff_find_similar` to find heavily modified files to
/// break, but to not *actually* break the records, then GIT_DELTA_MODIFIED
/// records may have a non-zero similarity score if the self-similarity is
/// below the split threshold.  To display this value like core Git, invert
/// the score (a la `printf("M%03d", 100 - delta->similarity)`).
class git_diff_delta extends ffi.Struct {
  @ffi.Int32()
  external int status;

  /// < git_diff_flag_t values
  @ffi.Uint32()
  external int flags;

  /// < for RENAMED and COPIED, value 0-100
  @ffi.Uint16()
  external int similarity;

  /// < number of files in this delta
  @ffi.Uint16()
  external int nfiles;

  external git_diff_file old_file;

  external git_diff_file new_file;
}

/// Structure describing options about how the diff should be executed.
///
/// Setting all values of the structure to zero will yield the default
/// values.  Similarly, passing NULL for the options structure will
/// give the defaults.  The default values are marked below.
class git_diff_options extends ffi.Struct {
  /// < version for the struct
  @ffi.UnsignedInt()
  external int version;

  /// A combination of `git_diff_option_t` values above.
  /// Defaults to GIT_DIFF_NORMAL
  @ffi.Uint32()
  external int flags;

  /// Overrides the submodule ignore setting for all submodules in the diff.
  @ffi.Int32()
  external int ignore_submodules;

  /// An array of paths / fnmatch patterns to constrain diff.
  /// All paths are included by default.
  external git_strarray pathspec;

  /// An optional callback function, notifying the consumer of changes to
  /// the diff as new deltas are added.
  external git_diff_notify_cb notify_cb;

  /// An optional callback function, notifying the consumer of which files
  /// are being examined as the diff is generated.
  external git_diff_progress_cb progress_cb;

  /// The payload to pass to the callback functions.
  external ffi.Pointer<ffi.Void> payload;

  /// The number of unchanged lines that define the boundary of a hunk
  /// (and to display before and after). Defaults to 3.
  @ffi.Uint32()
  external int context_lines;

  /// The maximum number of unchanged lines between hunk boundaries before
  /// the hunks will be merged into one. Defaults to 0.
  @ffi.Uint32()
  external int interhunk_lines;

  /// The abbreviation length to use when formatting object ids.
  /// Defaults to the value of 'core.abbrev' from the config, or 7 if unset.
  @ffi.Uint16()
  external int id_abbrev;

  /// A size (in bytes) above which a blob will be marked as binary
  /// automatically; pass a negative value to disable.
  /// Defaults to 512MB.
  @git_off_t()
  external int max_size;

  /// The virtual "directory" prefix for old file names in hunk headers.
  /// Default is "a".
  external ffi.Pointer<ffi.Char> old_prefix;

  /// The virtual "directory" prefix for new file names in hunk headers.
  /// Defaults to "b".
  external ffi.Pointer<ffi.Char> new_prefix;
}

/// Diff notification callback function.
///
/// The callback will be called for each file, just before the `git_diff_delta`
/// gets inserted into the diff.
///
/// When the callback:
/// - returns < 0, the diff process will be aborted.
/// - returns > 0, the delta will not be inserted into the diff, but the
/// diff process continues.
/// - returns 0, the delta is inserted into the diff, and the diff process
/// continues.
typedef git_diff_notify_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_diff>, ffi.Pointer<git_diff_delta>,
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>>;

/// Diff progress callback.
///
/// Called before each file comparison.
///
/// @param diff_so_far The diff being generated.
/// @param old_path The path to the old file or NULL.
/// @param new_path The path to the new file or NULL.
/// @return Non-zero to abort the diff.
typedef git_diff_progress_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_diff>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>>;

/// Note: Can't use off_t since if a client program includes <sys/types.h>
/// before us (directly or indirectly), they'll get 32 bit off_t in their client
/// app, even though /we/ define _FILE_OFFSET_BITS=64.
typedef git_off_t = ffi.Int64;

/// When producing a binary diff, the binary data returned will be
/// either the deflated full ("literal") contents of the file, or
/// the deflated binary delta between the two sides (whichever is
/// smaller).
abstract class git_diff_binary_t {
  /// There is no binary delta.
  static const int GIT_DIFF_BINARY_NONE = 0;

  /// The binary data is the literal contents of the file.
  static const int GIT_DIFF_BINARY_LITERAL = 1;

  /// The binary data is the delta from one side to the other.
  static const int GIT_DIFF_BINARY_DELTA = 2;
}

/// The contents of one of the files in a binary diff.
class git_diff_binary_file extends ffi.Struct {
  /// The type of binary data for this file.
  @ffi.Int32()
  external int type;

  /// The binary data, deflated.
  external ffi.Pointer<ffi.Char> data;

  /// The length of the binary data.
  @ffi.Size()
  external int datalen;

  /// The length of the binary data after inflation.
  @ffi.Size()
  external int inflatedlen;
}

/// Structure describing the binary contents of a diff.
///
/// A `binary` file / delta is a file (or pair) for which no text diffs
/// should be generated. A diff can contain delta entries that are
/// binary, but no diff content will be output for those files. There is
/// a base heuristic for binary detection and you can further tune the
/// behavior with git attributes or diff flags and option settings.
class git_diff_binary extends ffi.Struct {
  /// Whether there is data in this binary structure or not.
  ///
  /// If this is `1`, then this was produced and included binary content.
  /// If this is `0` then this was generated knowing only that a binary
  /// file changed but without providing the data, probably from a patch
  /// that said `Binary files a/file.txt and b/file.txt differ`.
  @ffi.UnsignedInt()
  external int contains_data;

  /// < The contents of the old file.
  external git_diff_binary_file old_file;

  /// < The contents of the new file.
  external git_diff_binary_file new_file;
}

/// Structure describing a hunk of a diff.
///
/// A `hunk` is a span of modified lines in a delta along with some stable
/// surrounding context. You can configure the amount of context and other
/// properties of how hunks are generated. Each hunk also comes with a
/// header that described where it starts and ends in both the old and new
/// versions in the delta.
class git_diff_hunk extends ffi.Struct {
  /// < Starting line number in old_file
  @ffi.Int()
  external int old_start;

  /// < Number of lines in old_file
  @ffi.Int()
  external int old_lines;

  /// < Starting line number in new_file
  @ffi.Int()
  external int new_start;

  /// < Number of lines in new_file
  @ffi.Int()
  external int new_lines;

  /// < Number of bytes in header text
  @ffi.Size()
  external int header_len;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> header;
}

/// Line origin constants.
///
/// These values describe where a line came from and will be passed to
/// the git_diff_line_cb when iterating over a diff.  There are some
/// special origin constants at the end that are used for the text
/// output callbacks to demarcate lines that are actually part of
/// the file or hunk headers.
abstract class git_diff_line_t {
  /// These values will be sent to `git_diff_line_cb` along with the line
  static const int GIT_DIFF_LINE_CONTEXT = 32;
  static const int GIT_DIFF_LINE_ADDITION = 43;
  static const int GIT_DIFF_LINE_DELETION = 45;

  /// < Both files have no LF at end
  static const int GIT_DIFF_LINE_CONTEXT_EOFNL = 61;

  /// < Old has no LF at end, new does
  static const int GIT_DIFF_LINE_ADD_EOFNL = 62;

  /// < Old has LF at end, new does not
  static const int GIT_DIFF_LINE_DEL_EOFNL = 60;

  /// The following values will only be sent to a `git_diff_line_cb` when
  /// the content of a diff is being formatted through `git_diff_print`.
  static const int GIT_DIFF_LINE_FILE_HDR = 70;
  static const int GIT_DIFF_LINE_HUNK_HDR = 72;

  /// < For "Binary files x and y differ"
  static const int GIT_DIFF_LINE_BINARY = 66;
}

/// Structure describing a line (or data span) of a diff.
///
/// A `line` is a range of characters inside a hunk.  It could be a context
/// line (i.e. in both old and new versions), an added line (i.e. only in
/// the new version), or a removed line (i.e. only in the old version).
/// Unfortunately, we don't know anything about the encoding of data in the
/// file being diffed, so we cannot tell you much about the line content.
/// Line data will not be NUL-byte terminated, however, because it will be
/// just a span of bytes inside the larger file.
class git_diff_line extends ffi.Struct {
  /// < A git_diff_line_t value
  @ffi.Char()
  external int origin;

  /// < Line number in old file or -1 for added line
  @ffi.Int()
  external int old_lineno;

  /// < Line number in new file or -1 for deleted line
  @ffi.Int()
  external int new_lineno;

  /// < Number of newline characters in content
  @ffi.Int()
  external int num_lines;

  /// < Number of bytes of data
  @ffi.Size()
  external int content_len;

  /// < Offset in the original file to the content
  @git_off_t()
  external int content_offset;

  /// < Pointer to diff text, not NUL-byte terminated
  external ffi.Pointer<ffi.Char> content;
}

/// Flags to control the behavior of diff rename/copy detection.
abstract class git_diff_find_t {
  /// Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag.
  static const int GIT_DIFF_FIND_BY_CONFIG = 0;

  /// Look for renames? (`--find-renames`)
  static const int GIT_DIFF_FIND_RENAMES = 1;

  /// Consider old side of MODIFIED for renames? (`--break-rewrites=N`)
  static const int GIT_DIFF_FIND_RENAMES_FROM_REWRITES = 2;

  /// Look for copies? (a la `--find-copies`).
  static const int GIT_DIFF_FIND_COPIES = 4;

  /// Consider UNMODIFIED as copy sources? (`--find-copies-harder`).
  ///
  /// For this to work correctly, use GIT_DIFF_INCLUDE_UNMODIFIED when
  /// the initial `git_diff` is being generated.
  static const int GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED = 8;

  /// Mark significant rewrites for split (`--break-rewrites=/M`)
  static const int GIT_DIFF_FIND_REWRITES = 16;

  /// Actually split large rewrites into delete/add pairs
  static const int GIT_DIFF_BREAK_REWRITES = 32;

  /// Mark rewrites for split and break into delete/add pairs
  static const int GIT_DIFF_FIND_AND_BREAK_REWRITES = 48;

  /// Find renames/copies for UNTRACKED items in working directory.
  ///
  /// For this to work correctly, use GIT_DIFF_INCLUDE_UNTRACKED when the
  /// initial `git_diff` is being generated (and obviously the diff must
  /// be against the working directory for this to make sense).
  static const int GIT_DIFF_FIND_FOR_UNTRACKED = 64;

  /// Turn on all finding features.
  static const int GIT_DIFF_FIND_ALL = 255;

  /// Measure similarity ignoring leading whitespace (default)
  static const int GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE = 0;

  /// Measure similarity ignoring all whitespace
  static const int GIT_DIFF_FIND_IGNORE_WHITESPACE = 4096;

  /// Measure similarity including all data
  static const int GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE = 8192;

  /// Measure similarity only by comparing SHAs (fast and cheap)
  static const int GIT_DIFF_FIND_EXACT_MATCH_ONLY = 16384;

  /// Do not break rewrites unless they contribute to a rename.
  ///
  /// Normally, GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-
  /// similarity of modified files and split the ones that have changed a
  /// lot into a DELETE / ADD pair.  Then the sides of that pair will be
  /// considered candidates for rename and copy detection.
  ///
  /// If you add this flag in and the split pair is *not* used for an
  /// actual rename or copy, then the modified record will be restored to
  /// a regular MODIFIED record instead of being split.
  static const int GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY = 32768;

  /// Remove any UNMODIFIED deltas after find_similar is done.
  ///
  /// Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the
  /// --find-copies-harder behavior requires building a diff with the
  /// GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED
  /// records in the final result, pass this flag to have them removed.
  static const int GIT_DIFF_FIND_REMOVE_UNMODIFIED = 65536;
}

/// Pluggable similarity metric
class git_diff_similarity_metric extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<git_diff_file>,
              ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Void>)>> file_signature;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Void>>,
              ffi.Pointer<git_diff_file>,
              ffi.Pointer<ffi.Char>,
              ffi.Size,
              ffi.Pointer<ffi.Void>)>> buffer_signature;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
      free_signature;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>> similarity;

  external ffi.Pointer<ffi.Void> payload;
}

/// Control behavior of rename and copy detection
///
/// These options mostly mimic parameters that can be passed to git-diff.
class git_diff_find_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).
  /// NOTE: if you don't explicitly set this, `diff.renames` could be set
  /// to false, resulting in `git_diff_find_similar` doing nothing.
  @ffi.Uint32()
  external int flags;

  /// Threshold above which similar files will be considered renames.
  /// This is equivalent to the -M option. Defaults to 50.
  @ffi.Uint16()
  external int rename_threshold;

  /// Threshold below which similar files will be eligible to be a rename source.
  /// This is equivalent to the first part of the -B option. Defaults to 50.
  @ffi.Uint16()
  external int rename_from_rewrite_threshold;

  /// Threshold above which similar files will be considered copies.
  /// This is equivalent to the -C option. Defaults to 50.
  @ffi.Uint16()
  external int copy_threshold;

  /// Threshold below which similar files will be split into a delete/add pair.
  /// This is equivalent to the last part of the -B option. Defaults to 60.
  @ffi.Uint16()
  external int break_rewrite_threshold;

  /// Maximum number of matches to consider for a particular file.
  ///
  /// This is a little different from the `-l` option from Git because we
  /// will still process up to this many matches before abandoning the search.
  /// Defaults to 1000.
  @ffi.Size()
  external int rename_limit;

  /// The `metric` option allows you to plug in a custom similarity metric.
  ///
  /// Set it to NULL to use the default internal metric.
  ///
  /// The default metric is based on sampling hashes of ranges of data in
  /// the file, which is a pretty good similarity approximation that should
  /// work fairly well for both text and binary data while still being
  /// pretty fast with a fixed memory overhead.
  external ffi.Pointer<git_diff_similarity_metric> metric;
}

/// When iterating over a diff, callback that will be made per file.
///
/// @param delta A pointer to the delta data for the file
/// @param progress Goes from 0 to 1 over the diff
/// @param payload User-specified pointer from foreach function
typedef git_diff_file_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<git_diff_delta>, ffi.Float, ffi.Pointer<ffi.Void>)>>;

/// When iterating over a diff, callback that will be made for
/// binary content within the diff.
typedef git_diff_binary_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_diff_delta>,
            ffi.Pointer<git_diff_binary>, ffi.Pointer<ffi.Void>)>>;

/// When iterating over a diff, callback that will be made per hunk.
typedef git_diff_hunk_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_diff_delta>,
            ffi.Pointer<git_diff_hunk>, ffi.Pointer<ffi.Void>)>>;

/// When iterating over a diff, callback that will be made per text diff
/// line. In this context, the provided range will be NULL.
///
/// When printing a diff, callback that will be made to output each line
/// of text.  This uses some extra GIT_DIFF_LINE_... constants for output
/// of lines of file and hunk headers.
typedef git_diff_line_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<git_diff_delta>,
            ffi.Pointer<git_diff_hunk>,
            ffi.Pointer<git_diff_line>,
            ffi.Pointer<ffi.Void>)>>;

/// Possible output formats for diff data
abstract class git_diff_format_t {
  /// < full git diff
  static const int GIT_DIFF_FORMAT_PATCH = 1;

  /// < just the file headers of patch
  static const int GIT_DIFF_FORMAT_PATCH_HEADER = 2;

  /// < like git diff --raw
  static const int GIT_DIFF_FORMAT_RAW = 3;

  /// < like git diff --name-only
  static const int GIT_DIFF_FORMAT_NAME_ONLY = 4;

  /// < like git diff --name-status
  static const int GIT_DIFF_FORMAT_NAME_STATUS = 5;

  /// < git diff as used by git patch-id
  static const int GIT_DIFF_FORMAT_PATCH_ID = 6;
}

class git_diff_stats extends ffi.Opaque {}

/// Formatting options for diff stats
abstract class git_diff_stats_format_t {
  /// No stats
  static const int GIT_DIFF_STATS_NONE = 0;

  /// Full statistics, equivalent of `--stat`
  static const int GIT_DIFF_STATS_FULL = 1;

  /// Short statistics, equivalent of `--shortstat`
  static const int GIT_DIFF_STATS_SHORT = 2;

  /// Number statistics, equivalent of `--numstat`
  static const int GIT_DIFF_STATS_NUMBER = 4;

  /// Extended header information such as creations, renames and mode changes, equivalent of `--summary`
  static const int GIT_DIFF_STATS_INCLUDE_SUMMARY = 8;
}

/// Patch ID options structure
///
/// Initialize with `GIT_PATCHID_OPTIONS_INIT`. Alternatively, you can
/// use `git_diff_patchid_options_init`.
class git_diff_patchid_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;
}

/// Flags controlling the behavior of git_apply
abstract class git_apply_flags_t {
  /// Don't actually make changes, just test that the patch applies.
  /// This is the equivalent of `git apply --check`.
  static const int GIT_APPLY_CHECK = 1;
}

/// Apply options structure
///
/// Initialize with `GIT_APPLY_OPTIONS_INIT`. Alternatively, you can
/// use `git_apply_options_init`.
///
/// @see git_apply_to_tree, git_apply
class git_apply_options extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// When applying a patch, callback that will be made per delta (file).
  external git_apply_delta_cb delta_cb;

  /// When applying a patch, callback that will be made per hunk.
  external git_apply_hunk_cb hunk_cb;

  /// Payload passed to both delta_cb & hunk_cb.
  external ffi.Pointer<ffi.Void> payload;

  /// Bitmask of git_apply_flags_t
  @ffi.UnsignedInt()
  external int flags;
}

/// When applying a patch, callback that will be made per delta (file).
///
/// When the callback:
/// - returns < 0, the apply process will be aborted.
/// - returns > 0, the delta will not be applied, but the apply process
/// continues
/// - returns 0, the delta is applied, and the apply process continues.
///
/// @param delta The delta to be applied
/// @param payload User-specified payload
/// @return 0 if the delta is applied, < 0 if the apply process will be aborted
/// or > 0 if the delta will not be applied.
typedef git_apply_delta_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_diff_delta>, ffi.Pointer<ffi.Void>)>>;

/// When applying a patch, callback that will be made per hunk.
///
/// When the callback:
/// - returns < 0, the apply process will be aborted.
/// - returns > 0, the hunk will not be applied, but the apply process
/// continues
/// - returns 0, the hunk is applied, and the apply process continues.
///
/// @param hunk The hunk to be applied
/// @param payload User-specified payload
/// @return 0 if the hunk is applied, < 0 if the apply process will be aborted
/// or > 0 if the hunk will not be applied.
typedef git_apply_hunk_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_diff_hunk>, ffi.Pointer<ffi.Void>)>>;

/// Possible application locations for git_apply
abstract class git_apply_location_t {
  /// Apply the patch to the workdir, leaving the index untouched.
  /// This is the equivalent of `git apply` with no location argument.
  static const int GIT_APPLY_LOCATION_WORKDIR = 0;

  /// Apply the patch to the index, leaving the working directory
  /// untouched.  This is the equivalent of `git apply --cached`.
  static const int GIT_APPLY_LOCATION_INDEX = 1;

  /// Apply the patch to both the working directory and the index.
  /// This is the equivalent of `git apply --index`.
  static const int GIT_APPLY_LOCATION_BOTH = 2;
}

/// Possible states for an attribute
abstract class git_attr_value_t {
  /// < The attribute has been left unspecified
  static const int GIT_ATTR_VALUE_UNSPECIFIED = 0;

  /// < The attribute has been set
  static const int GIT_ATTR_VALUE_TRUE = 1;

  /// < The attribute has been unset
  static const int GIT_ATTR_VALUE_FALSE = 2;

  /// < This attribute has a value
  static const int GIT_ATTR_VALUE_STRING = 3;
}

/// An options structure for querying attributes.
class git_attr_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// A combination of GIT_ATTR_CHECK flags
  @ffi.UnsignedInt()
  external int flags;

  external ffi.Pointer<git_oid> commit_id;

  /// The commit to load attributes from, when
  /// `GIT_ATTR_CHECK_INCLUDE_COMMIT` is specified.
  external git_oid attr_commit_id;
}

/// The callback used with git_attr_foreach.
///
/// This callback will be invoked only once per attribute name, even if there
/// are multiple rules for a given file. The highest priority rule will be
/// used.
///
/// @see git_attr_foreach.
///
/// @param name The attribute name.
/// @param value The attribute value. May be NULL if the attribute is explicitly
/// set to UNSPECIFIED using the '!' sign.
/// @param payload A user-specified pointer.
/// @return 0 to continue looping, non-zero to stop. This value will be returned
/// from git_attr_foreach.
typedef git_attr_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>)>>;

/// Flags to control the functionality of `git_blob_filter`.
abstract class git_blob_filter_flag_t {
  /// When set, filters will not be applied to binary files.
  static const int GIT_BLOB_FILTER_CHECK_FOR_BINARY = 1;

  /// When set, filters will not load configuration from the
  /// system-wide `gitattributes` in `/etc` (or system equivalent).
  static const int GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES = 2;

  /// When set, filters will be loaded from a `.gitattributes` file
  /// in the HEAD commit.
  static const int GIT_BLOB_FILTER_ATTRIBUTES_FROM_HEAD = 4;

  /// When set, filters will be loaded from a `.gitattributes` file
  /// in the specified commit.
  static const int GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT = 8;
}

/// The options used when applying filter options to a file.
///
/// Initialize with `GIT_BLOB_FILTER_OPTIONS_INIT`. Alternatively, you can
/// use `git_blob_filter_options_init`.
class git_blob_filter_options extends ffi.Struct {
  @ffi.Int()
  external int version;

  /// Flags to control the filtering process, see `git_blob_filter_flag_t` above
  @ffi.Uint32()
  external int flags;

  external ffi.Pointer<git_oid> commit_id;

  /// The commit to load attributes from, when
  /// `GIT_BLOB_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.
  external git_oid attr_commit_id;
}

/// Flags for indicating option behavior for git_blame APIs.
abstract class git_blame_flag_t {
  /// Normal blame, the default
  static const int GIT_BLAME_NORMAL = 0;

  /// Track lines that have moved within a file (like `git blame -M`).
  ///
  /// This is not yet implemented and reserved for future use.
  static const int GIT_BLAME_TRACK_COPIES_SAME_FILE = 1;

  /// Track lines that have moved across files in the same commit
  /// (like `git blame -C`).
  ///
  /// This is not yet implemented and reserved for future use.
  static const int GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES = 2;

  /// Track lines that have been copied from another file that exists
  /// in the same commit (like `git blame -CC`).  Implies SAME_FILE.
  ///
  /// This is not yet implemented and reserved for future use.
  static const int GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES = 4;

  /// Track lines that have been copied from another file that exists in
  /// *any* commit (like `git blame -CCC`).  Implies SAME_COMMIT_COPIES.
  ///
  /// This is not yet implemented and reserved for future use.
  static const int GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES = 8;

  /// Restrict the search of commits to those reachable following only
  /// the first parents.
  static const int GIT_BLAME_FIRST_PARENT = 16;

  /// Use mailmap file to map author and committer names and email
  /// addresses to canonical real names and email addresses. The
  /// mailmap will be read from the working directory, or HEAD in a
  /// bare repository.
  static const int GIT_BLAME_USE_MAILMAP = 32;

  /// Ignore whitespace differences
  static const int GIT_BLAME_IGNORE_WHITESPACE = 64;
}

/// Blame options structure
///
/// Initialize with `GIT_BLAME_OPTIONS_INIT`. Alternatively, you can
/// use `git_blame_options_init`.
class git_blame_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// A combination of `git_blame_flag_t`
  @ffi.Uint32()
  external int flags;

  /// The lower bound on the number of alphanumeric characters that
  /// must be detected as moving/copying within a file for it to
  /// associate those lines with the parent commit. The default value
  /// is 20.
  ///
  /// This value only takes effect if any of the `GIT_BLAME_TRACK_COPIES_*`
  /// flags are specified.
  @ffi.Uint16()
  external int min_match_characters;

  /// The id of the newest commit to consider. The default is HEAD.
  external git_oid newest_commit;

  /// The id of the oldest commit to consider.
  /// The default is the first commit encountered with a NULL parent.
  external git_oid oldest_commit;

  /// The first line in the file to blame.
  /// The default is 1 (line numbers start with 1).
  @ffi.Size()
  external int min_line;

  /// The last line in the file to blame.
  /// The default is the last line of the file.
  @ffi.Size()
  external int max_line;
}

/// Structure that represents a blame hunk.
class git_blame_hunk extends ffi.Struct {
  /// The number of lines in this hunk.
  @ffi.Size()
  external int lines_in_hunk;

  /// The OID of the commit where this line was last changed.
  external git_oid final_commit_id;

  /// The 1-based line number where this hunk begins, in the final version
  /// of the file.
  @ffi.Size()
  external int final_start_line_number;

  /// The author of `final_commit_id`. If `GIT_BLAME_USE_MAILMAP` has been
  /// specified, it will contain the canonical real name and email address.
  external ffi.Pointer<git_signature> final_signature;

  /// The OID of the commit where this hunk was found.
  /// This will usually be the same as `final_commit_id`, except when
  /// `GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES` has been specified.
  external git_oid orig_commit_id;

  /// The path to the file where this hunk originated, as of the commit
  /// specified by `orig_commit_id`.
  external ffi.Pointer<ffi.Char> orig_path;

  /// The 1-based line number where this hunk begins in the file named by
  /// `orig_path` in the commit specified by `orig_commit_id`.
  @ffi.Size()
  external int orig_start_line_number;

  /// The author of `orig_commit_id`. If `GIT_BLAME_USE_MAILMAP` has been
  /// specified, it will contain the canonical real name and email address.
  external ffi.Pointer<git_signature> orig_signature;

  /// The 1 iff the hunk has been tracked to a boundary commit (the root,
  /// or the commit specified in git_blame_options.oldest_commit)
  @ffi.Char()
  external int boundary;
}

class git_blame extends ffi.Opaque {}

class git_branch_iterator extends ffi.Opaque {}

/// Type of SSH host fingerprint
abstract class git_cert_ssh_t {
  /// MD5 is available
  static const int GIT_CERT_SSH_MD5 = 1;

  /// SHA-1 is available
  static const int GIT_CERT_SSH_SHA1 = 2;

  /// SHA-256 is available
  static const int GIT_CERT_SSH_SHA256 = 4;

  /// Raw hostkey is available
  static const int GIT_CERT_SSH_RAW = 8;
}

abstract class git_cert_ssh_raw_type_t {
  /// The raw key is of an unknown type.
  static const int GIT_CERT_SSH_RAW_TYPE_UNKNOWN = 0;

  /// The raw key is an RSA key.
  static const int GIT_CERT_SSH_RAW_TYPE_RSA = 1;

  /// The raw key is a DSS key.
  static const int GIT_CERT_SSH_RAW_TYPE_DSS = 2;

  /// The raw key is a ECDSA 256 key.
  static const int GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_256 = 3;

  /// The raw key is a ECDSA 384 key.
  static const int GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_384 = 4;

  /// The raw key is a ECDSA 521 key.
  static const int GIT_CERT_SSH_RAW_TYPE_KEY_ECDSA_521 = 5;

  /// The raw key is a ED25519 key.
  static const int GIT_CERT_SSH_RAW_TYPE_KEY_ED25519 = 6;
}

/// Hostkey information taken from libssh2
class git_cert_hostkey extends ffi.Struct {
  /// < The parent cert
  external git_cert parent;

  /// A bitmask containing the available fields.
  @ffi.Int32()
  external int type;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.UnsignedChar> hash_md5;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.UnsignedChar> hash_sha1;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.UnsignedChar> hash_sha256;

  /// Raw hostkey type. If `type` has `GIT_CERT_SSH_RAW` set, this will
  /// have the type of the raw hostkey.
  @ffi.Int32()
  external int raw_type;

  /// Pointer to the raw hostkey. If `type` has `GIT_CERT_SSH_RAW` set,
  /// this will have the raw contents of the hostkey.
  external ffi.Pointer<ffi.Char> hostkey;

  /// Raw hostkey length. If `type` has `GIT_CERT_SSH_RAW` set, this will
  /// have the length of the raw contents of the hostkey.
  @ffi.Size()
  external int hostkey_len;
}

/// X.509 certificate information
class git_cert_x509 extends ffi.Struct {
  /// < The parent cert
  external git_cert parent;

  /// Pointer to the X.509 certificate data
  external ffi.Pointer<ffi.Void> data;

  /// Length of the memory block pointed to by `data`.
  @ffi.Size()
  external int len;
}

/// Checkout behavior flags
///
/// In libgit2, checkout is used to update the working directory and index
/// to match a target tree.  Unlike git checkout, it does not move the HEAD
/// commit for you - use `git_repository_set_head` or the like to do that.
///
/// Checkout looks at (up to) four things: the "target" tree you want to
/// check out, the "baseline" tree of what was checked out previously, the
/// working directory for actual files, and the index for staged changes.
///
/// You give checkout one of three strategies for update:
///
/// - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts,
/// etc., but doesn't make any actual changes.
///
/// - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to
/// make the working directory match the target (including potentially
/// discarding modified files).
///
/// - `GIT_CHECKOUT_SAFE` is between these two options, it will only make
/// modifications that will not lose changes.
///
/// |  target == baseline   |  target != baseline  |
/// ---------------------|-----------------------|----------------------|
/// workdir == baseline |       no action       |  create, update, or  |
/// |                       |     delete file      |
/// ---------------------|-----------------------|----------------------|
/// workdir exists and  |       no action       |   conflict (notify   |
/// is != baseline    | notify dirty MODIFIED | and cancel checkout) |
/// ---------------------|-----------------------|----------------------|
/// workdir missing,   | notify dirty DELETED  |     create file      |
/// baseline present   |                       |                      |
/// ---------------------|-----------------------|----------------------|
///
/// To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout
/// notification callback (see below) that displays information about dirty
/// files.  The default behavior will cancel checkout on conflicts.
///
/// To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a
/// notification callback that cancels the operation if a dirty-but-existing
/// file is found in the working directory.  This core git command isn't
/// quite "force" but is sensitive about some types of changes.
///
/// To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`.
///
///
/// There are some additional flags to modify the behavior of checkout:
///
/// - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates
/// even if there are conflicts (instead of cancelling the checkout).
///
/// - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not
/// in target, baseline, or index, and not ignored) from the working dir.
///
/// - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also
/// untracked) from the working directory as well.
///
/// - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that
/// already exist.  Files will not be created nor deleted.  This just skips
/// applying adds, deletes, and typechanges.
///
/// - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the
/// updated files' information to the index.
///
/// - Normally, checkout will reload the index and git attributes from disk
/// before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload.
///
/// - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips
/// files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and
/// GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the
/// stage 2 ("ours") or stage 3 ("theirs") version of files in the index.
///
/// - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being
/// overwritten.  Normally, files that are ignored in the working directory
/// are not considered "precious" and may be overwritten if the checkout
/// target contains that file.
///
/// - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing
/// files or folders that fold to the same name on case insensitive
/// filesystems.  This can cause files to retain their existing names
/// and write through existing symbolic links.
abstract class git_checkout_strategy_t {
  /// < default is a dry run, no actual updates
  static const int GIT_CHECKOUT_NONE = 0;

  /// Allow safe updates that cannot overwrite uncommitted data.
  /// If the uncommitted changes don't conflict with the checked out files,
  /// the checkout will still proceed, leaving the changes intact.
  ///
  /// Mutually exclusive with GIT_CHECKOUT_FORCE.
  /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
  static const int GIT_CHECKOUT_SAFE = 1;

  /// Allow all updates to force working directory to look like index.
  ///
  /// Mutually exclusive with GIT_CHECKOUT_SAFE.
  /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
  static const int GIT_CHECKOUT_FORCE = 2;

  /// Allow checkout to recreate missing files
  static const int GIT_CHECKOUT_RECREATE_MISSING = 4;

  /// Allow checkout to make safe updates even if conflicts are found
  static const int GIT_CHECKOUT_ALLOW_CONFLICTS = 16;

  /// Remove untracked files not in index (that are not ignored)
  static const int GIT_CHECKOUT_REMOVE_UNTRACKED = 32;

  /// Remove ignored files not in index
  static const int GIT_CHECKOUT_REMOVE_IGNORED = 64;

  /// Only update existing files, don't create new ones
  static const int GIT_CHECKOUT_UPDATE_ONLY = 128;

  /// Normally checkout updates index entries as it goes; this stops that.
  /// Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
  static const int GIT_CHECKOUT_DONT_UPDATE_INDEX = 256;

  /// Don't refresh index/config/etc before doing checkout
  static const int GIT_CHECKOUT_NO_REFRESH = 512;

  /// Allow checkout to skip unmerged files
  static const int GIT_CHECKOUT_SKIP_UNMERGED = 1024;

  /// For unmerged files, checkout stage 2 from index
  static const int GIT_CHECKOUT_USE_OURS = 2048;

  /// For unmerged files, checkout stage 3 from index
  static const int GIT_CHECKOUT_USE_THEIRS = 4096;

  /// Treat pathspec as simple list of exact match file paths
  static const int GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = 8192;

  /// Ignore directories in use, they will be left empty
  static const int GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = 262144;

  /// Don't overwrite ignored files that exist in the checkout target
  static const int GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = 524288;

  /// Write normal merge files for conflicts
  static const int GIT_CHECKOUT_CONFLICT_STYLE_MERGE = 1048576;

  /// Include common ancestor data in diff3 format files for conflicts
  static const int GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = 2097152;

  /// Don't overwrite existing files or folders
  static const int GIT_CHECKOUT_DONT_REMOVE_EXISTING = 4194304;

  /// Normally checkout writes the index upon completion; this prevents that.
  static const int GIT_CHECKOUT_DONT_WRITE_INDEX = 8388608;

  /// Show what would be done by a checkout.  Stop after sending
  /// notifications; don't update the working directory or index.
  static const int GIT_CHECKOUT_DRY_RUN = 16777216;

  /// Include common ancestor data in zdiff3 format for conflicts
  static const int GIT_CHECKOUT_CONFLICT_STYLE_ZDIFF3 = 33554432;

  /// Recursively checkout submodules with same options (NOT IMPLEMENTED)
  static const int GIT_CHECKOUT_UPDATE_SUBMODULES = 65536;

  /// Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED)
  static const int GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = 131072;
}

/// Checkout notification flags
///
/// Checkout will invoke an options notification callback (`notify_cb`) for
/// certain cases - you pick which ones via `notify_flags`:
///
/// Returning a non-zero value from this callback will cancel the checkout.
/// The non-zero return value will be propagated back and returned by the
/// git_checkout_... call.
///
/// Notification callbacks are made prior to modifying any files on disk,
/// so canceling on any notification will still happen prior to any files
/// being modified.
abstract class git_checkout_notify_t {
  static const int GIT_CHECKOUT_NOTIFY_NONE = 0;

  /// Invokes checkout on conflicting paths.
  static const int GIT_CHECKOUT_NOTIFY_CONFLICT = 1;

  /// Notifies about "dirty" files, i.e. those that do not need an update
  /// but no longer match the baseline.  Core git displays these files when
  /// checkout runs, but won't stop the checkout.
  static const int GIT_CHECKOUT_NOTIFY_DIRTY = 2;

  /// Sends notification for any file changed.
  static const int GIT_CHECKOUT_NOTIFY_UPDATED = 4;

  /// Notifies about untracked files.
  static const int GIT_CHECKOUT_NOTIFY_UNTRACKED = 8;

  /// Notifies about ignored files.
  static const int GIT_CHECKOUT_NOTIFY_IGNORED = 16;
  static const int GIT_CHECKOUT_NOTIFY_ALL = 65535;
}

/// Checkout performance-reporting structure
class git_checkout_perfdata extends ffi.Struct {
  @ffi.Size()
  external int mkdir_calls;

  @ffi.Size()
  external int stat_calls;

  @ffi.Size()
  external int chmod_calls;
}

/// Checkout options structure
///
/// Initialize with `GIT_CHECKOUT_OPTIONS_INIT`. Alternatively, you can
/// use `git_checkout_options_init`.
class git_checkout_options extends ffi.Struct {
  /// < The version
  @ffi.UnsignedInt()
  external int version;

  /// < default will be a safe checkout
  @ffi.UnsignedInt()
  external int checkout_strategy;

  /// < don't apply filters like CRLF conversion
  @ffi.Int()
  external int disable_filters;

  /// < default is 0755
  @ffi.UnsignedInt()
  external int dir_mode;

  /// < default is 0644 or 0755 as dictated by blob
  @ffi.UnsignedInt()
  external int file_mode;

  /// < default is O_CREAT | O_TRUNC | O_WRONLY
  @ffi.Int()
  external int file_open_flags;

  /// < see `git_checkout_notify_t` above
  @ffi.UnsignedInt()
  external int notify_flags;

  /// Optional callback to get notifications on specific file states.
  /// @see git_checkout_notify_t
  external git_checkout_notify_cb notify_cb;

  /// Payload passed to notify_cb
  external ffi.Pointer<ffi.Void> notify_payload;

  /// Optional callback to notify the consumer of checkout progress.
  external git_checkout_progress_cb progress_cb;

  /// Payload passed to progress_cb
  external ffi.Pointer<ffi.Void> progress_payload;

  /// A list of wildmatch patterns or paths.
  ///
  /// By default, all paths are processed. If you pass an array of wildmatch
  /// patterns, those will be used to filter which paths should be taken into
  /// account.
  ///
  /// Use GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as a simple list.
  external git_strarray paths;

  /// The expected content of the working directory; defaults to HEAD.
  ///
  /// If the working directory does not match this baseline information,
  /// that will produce a checkout conflict.
  external ffi.Pointer<git_tree> baseline;

  /// Like `baseline` above, though expressed as an index.  This
  /// option overrides `baseline`.
  external ffi.Pointer<git_index> baseline_index;

  /// < alternative checkout path to workdir
  external ffi.Pointer<ffi.Char> target_directory;

  /// < the name of the common ancestor side of conflicts
  external ffi.Pointer<ffi.Char> ancestor_label;

  /// < the name of the "our" side of conflicts
  external ffi.Pointer<ffi.Char> our_label;

  /// < the name of the "their" side of conflicts
  external ffi.Pointer<ffi.Char> their_label;

  /// Optional callback to notify the consumer of performance data.
  external git_checkout_perfdata_cb perfdata_cb;

  /// Payload passed to perfdata_cb
  external ffi.Pointer<ffi.Void> perfdata_payload;
}

/// Checkout notification callback function
typedef git_checkout_notify_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Int32,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<git_diff_file>,
            ffi.Pointer<git_diff_file>,
            ffi.Pointer<git_diff_file>,
            ffi.Pointer<ffi.Void>)>>;

/// Checkout progress notification function
typedef git_checkout_progress_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Char>, ffi.Size, ffi.Size, ffi.Pointer<ffi.Void>)>>;

/// Checkout perfdata notification function
typedef git_checkout_perfdata_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<git_checkout_perfdata>, ffi.Pointer<ffi.Void>)>>;

/// Array of object ids
class git_oidarray extends ffi.Struct {
  external ffi.Pointer<git_oid> ids;

  @ffi.Size()
  external int count;
}

class git_indexer extends ffi.Opaque {}

/// Options for indexer configuration
class git_indexer_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// progress_cb function to call with progress information
  external git_indexer_progress_cb progress_cb;

  /// progress_cb_payload payload for the progress callback
  external ffi.Pointer<ffi.Void> progress_cb_payload;

  /// Do connectivity checks for the received pack
  @ffi.UnsignedChar()
  external int verify;
}

/// Time structure used in a git index entry
class git_index_time extends ffi.Struct {
  @ffi.Int32()
  external int seconds;

  /// nsec should not be stored as time_t compatible
  @ffi.Uint32()
  external int nanoseconds;
}

/// In-memory representation of a file entry in the index.
///
/// This is a public structure that represents a file entry in the index.
/// The meaning of the fields corresponds to core Git's documentation (in
/// "Documentation/technical/index-format.txt").
///
/// The `flags` field consists of a number of bit fields which can be
/// accessed via the first set of `GIT_INDEX_ENTRY_...` bitmasks below.
/// These flags are all read from and persisted to disk.
///
/// The `flags_extended` field also has a number of bit fields which can be
/// accessed via the later `GIT_INDEX_ENTRY_...` bitmasks below.  Some of
/// these flags are read from and written to disk, but some are set aside
/// for in-memory only reference.
///
/// Note that the time and size fields are truncated to 32 bits. This
/// is enough to detect changes, which is enough for the index to
/// function as a cache, but it should not be taken as an authoritative
/// source for that data.
class git_index_entry extends ffi.Struct {
  external git_index_time ctime;

  external git_index_time mtime;

  @ffi.Uint32()
  external int dev;

  @ffi.Uint32()
  external int ino;

  @ffi.Uint32()
  external int mode;

  @ffi.Uint32()
  external int uid;

  @ffi.Uint32()
  external int gid;

  @ffi.Uint32()
  external int file_size;

  external git_oid id;

  @ffi.Uint16()
  external int flags;

  @ffi.Uint16()
  external int flags_extended;

  external ffi.Pointer<ffi.Char> path;
}

/// Flags for index entries
abstract class git_index_entry_flag_t {
  static const int GIT_INDEX_ENTRY_EXTENDED = 16384;
  static const int GIT_INDEX_ENTRY_VALID = 32768;
}

/// Bitmasks for on-disk fields of `git_index_entry`'s `flags_extended`
///
/// In memory, the `flags_extended` fields are divided into two parts: the
/// fields that are read from and written to disk, and other fields that
/// in-memory only and used by libgit2.  Only the flags in
/// `GIT_INDEX_ENTRY_EXTENDED_FLAGS` will get saved on-disk.
///
/// Thee first three bitmasks match the three fields in the
/// `git_index_entry` `flags_extended` value that belong on disk.  You
/// can use them to interpret the data in the `flags_extended`.
///
/// The rest of the bitmasks match the other fields in the `git_index_entry`
/// `flags_extended` value that are only used in-memory by libgit2.
/// You can use them to interpret the data in the `flags_extended`.
abstract class git_index_entry_extended_flag_t {
  static const int GIT_INDEX_ENTRY_INTENT_TO_ADD = 8192;
  static const int GIT_INDEX_ENTRY_SKIP_WORKTREE = 16384;
  static const int GIT_INDEX_ENTRY_EXTENDED_FLAGS = 24576;
  static const int GIT_INDEX_ENTRY_UPTODATE = 4;
}

/// Capabilities of system that affect index actions.
abstract class git_index_capability_t {
  static const int GIT_INDEX_CAPABILITY_IGNORE_CASE = 1;
  static const int GIT_INDEX_CAPABILITY_NO_FILEMODE = 2;
  static const int GIT_INDEX_CAPABILITY_NO_SYMLINKS = 4;
  static const int GIT_INDEX_CAPABILITY_FROM_OWNER = -1;
}

/// Flags for APIs that add files matching pathspec
abstract class git_index_add_option_t {
  static const int GIT_INDEX_ADD_DEFAULT = 0;
  static const int GIT_INDEX_ADD_FORCE = 1;
  static const int GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH = 2;
  static const int GIT_INDEX_ADD_CHECK_PATHSPEC = 4;
}

/// Git index stage states
abstract class git_index_stage_t {
  /// Match any index stage.
  ///
  /// Some index APIs take a stage to match; pass this value to match
  /// any entry matching the path regardless of stage.
  static const int GIT_INDEX_STAGE_ANY = -1;

  /// A normal staged file in the index.
  static const int GIT_INDEX_STAGE_NORMAL = 0;

  /// The ancestor side of a conflict.
  static const int GIT_INDEX_STAGE_ANCESTOR = 1;

  /// The "ours" side of a conflict.
  static const int GIT_INDEX_STAGE_OURS = 2;

  /// The "theirs" side of a conflict.
  static const int GIT_INDEX_STAGE_THEIRS = 3;
}

/// Callback for APIs that add/remove/update files matching pathspec
typedef git_index_matched_path_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>)>>;

/// The file inputs to `git_merge_file`.  Callers should populate the
/// `git_merge_file_input` structure with descriptions of the files in
/// each side of the conflict for use in producing the merge file.
class git_merge_file_input extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Pointer to the contents of the file.
  external ffi.Pointer<ffi.Char> ptr;

  /// Size of the contents pointed to in `ptr`.
  @ffi.Size()
  external int size;

  /// File name of the conflicted file, or `NULL` to not merge the path.
  external ffi.Pointer<ffi.Char> path;

  /// File mode of the conflicted file, or `0` to not merge the mode.
  @ffi.UnsignedInt()
  external int mode;
}

/// Flags for `git_merge` options.  A combination of these flags can be
/// passed in via the `flags` value in the `git_merge_options`.
abstract class git_merge_flag_t {
  /// Detect renames that occur between the common ancestor and the "ours"
  /// side or the common ancestor and the "theirs" side.  This will enable
  /// the ability to merge between a modified and renamed file.
  static const int GIT_MERGE_FIND_RENAMES = 1;

  /// If a conflict occurs, exit immediately instead of attempting to
  /// continue resolving conflicts.  The merge operation will fail with
  /// GIT_EMERGECONFLICT and no index will be returned.
  static const int GIT_MERGE_FAIL_ON_CONFLICT = 2;

  /// Do not write the REUC extension on the generated index
  static const int GIT_MERGE_SKIP_REUC = 4;

  /// If the commits being merged have multiple merge bases, do not build
  /// a recursive merge base (by merging the multiple merge bases),
  /// instead simply use the first base.  This flag provides a similar
  /// merge base to `git-merge-resolve`.
  static const int GIT_MERGE_NO_RECURSIVE = 8;

  /// Treat this merge as if it is to produce the virtual base
  /// of a recursive merge.  This will ensure that there are
  /// no conflicts, any conflicting regions will keep conflict
  /// markers in the merge result.
  static const int GIT_MERGE_VIRTUAL_BASE = 16;
}

/// Merge file favor options for `git_merge_options` instruct the file-level
/// merging functionality how to deal with conflicting regions of the files.
abstract class git_merge_file_favor_t {
  /// When a region of a file is changed in both branches, a conflict
  /// will be recorded in the index so that `git_checkout` can produce
  /// a merge file with conflict markers in the working directory.
  /// This is the default.
  static const int GIT_MERGE_FILE_FAVOR_NORMAL = 0;

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "ours" side of any conflicting
  /// region.  The index will not record a conflict.
  static const int GIT_MERGE_FILE_FAVOR_OURS = 1;

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "theirs" side of any conflicting
  /// region.  The index will not record a conflict.
  static const int GIT_MERGE_FILE_FAVOR_THEIRS = 2;

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain each unique line from each side,
  /// which has the result of combining both files.  The index will not
  /// record a conflict.
  static const int GIT_MERGE_FILE_FAVOR_UNION = 3;
}

/// File merging flags
abstract class git_merge_file_flag_t {
  /// Defaults
  static const int GIT_MERGE_FILE_DEFAULT = 0;

  /// Create standard conflicted merge files
  static const int GIT_MERGE_FILE_STYLE_MERGE = 1;

  /// Create diff3-style files
  static const int GIT_MERGE_FILE_STYLE_DIFF3 = 2;

  /// Condense non-alphanumeric regions for simplified diff file
  static const int GIT_MERGE_FILE_SIMPLIFY_ALNUM = 4;

  /// Ignore all whitespace
  static const int GIT_MERGE_FILE_IGNORE_WHITESPACE = 8;

  /// Ignore changes in amount of whitespace
  static const int GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE = 16;

  /// Ignore whitespace at end of line
  static const int GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL = 32;

  /// Use the "patience diff" algorithm
  static const int GIT_MERGE_FILE_DIFF_PATIENCE = 64;

  /// Take extra time to find minimal diff
  static const int GIT_MERGE_FILE_DIFF_MINIMAL = 128;

  /// Create zdiff3 ("zealous diff3")-style files
  static const int GIT_MERGE_FILE_STYLE_ZDIFF3 = 256;

  /// Do not produce file conflicts when common regions have
  /// changed; keep the conflict markers in the file and accept
  /// that as the merge result.
  static const int GIT_MERGE_FILE_ACCEPT_CONFLICTS = 512;
}

/// Options for merging a file
class git_merge_file_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Label for the ancestor file side of the conflict which will be prepended
  /// to labels in diff3-format merge files.
  external ffi.Pointer<ffi.Char> ancestor_label;

  /// Label for our file side of the conflict which will be prepended
  /// to labels in merge files.
  external ffi.Pointer<ffi.Char> our_label;

  /// Label for their file side of the conflict which will be prepended
  /// to labels in merge files.
  external ffi.Pointer<ffi.Char> their_label;

  /// The file to favor in region conflicts.
  @ffi.Int32()
  external int favor;

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// The size of conflict markers (eg, "<<<<<<<").  Default is
  /// GIT_MERGE_CONFLICT_MARKER_SIZE.
  @ffi.UnsignedShort()
  external int marker_size;
}

/// Information about file-level merging
class git_merge_file_result extends ffi.Struct {
  /// True if the output was automerged, false if the output contains
  /// conflict markers.
  @ffi.UnsignedInt()
  external int automergeable;

  /// The path that the resultant merge file should use, or NULL if a
  /// filename conflict would occur.
  external ffi.Pointer<ffi.Char> path;

  /// The mode that the resultant merge file should use.
  @ffi.UnsignedInt()
  external int mode;

  /// The contents of the merge.
  external ffi.Pointer<ffi.Char> ptr;

  /// The length of the merge contents.
  @ffi.Size()
  external int len;
}

/// Merging options
class git_merge_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// See `git_merge_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// Similarity to consider a file renamed (default 50).  If
  /// `GIT_MERGE_FIND_RENAMES` is enabled, added files will be compared
  /// with deleted files to determine their similarity.  Files that are
  /// more similar than the rename threshold (percentage-wise) will be
  /// treated as a rename.
  @ffi.UnsignedInt()
  external int rename_threshold;

  /// Maximum similarity sources to examine for renames (default 200).
  /// If the number of rename candidates (add / delete pairs) is greater
  /// than this value, inexact rename detection is aborted.
  ///
  /// This setting overrides the `merge.renameLimit` configuration value.
  @ffi.UnsignedInt()
  external int target_limit;

  /// Pluggable similarity metric; pass NULL to use internal metric
  external ffi.Pointer<git_diff_similarity_metric> metric;

  /// Maximum number of times to merge common ancestors to build a
  /// virtual merge base when faced with criss-cross merges.  When this
  /// limit is reached, the next ancestor will simply be used instead of
  /// attempting to merge it.  The default is unlimited.
  @ffi.UnsignedInt()
  external int recursion_limit;

  /// Default merge driver to be used when both sides of a merge have
  /// changed.  The default is the `text` driver.
  external ffi.Pointer<ffi.Char> default_driver;

  /// Flags for handling conflicting content, to be used with the standard
  /// (`text`) merge driver.
  @ffi.Int32()
  external int file_favor;

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int file_flags;
}

/// The results of `git_merge_analysis` indicate the merge opportunities.
abstract class git_merge_analysis_t {
  /// No merge is possible.  (Unused.)
  static const int GIT_MERGE_ANALYSIS_NONE = 0;

  /// A "normal" merge; both HEAD and the given merge input have diverged
  /// from their common ancestor.  The divergent commits must be merged.
  static const int GIT_MERGE_ANALYSIS_NORMAL = 1;

  /// All given merge inputs are reachable from HEAD, meaning the
  /// repository is up-to-date and no merge needs to be performed.
  static const int GIT_MERGE_ANALYSIS_UP_TO_DATE = 2;

  /// The given merge input is a fast-forward from HEAD and no merge
  /// needs to be performed.  Instead, the client can check out the
  /// given merge input.
  static const int GIT_MERGE_ANALYSIS_FASTFORWARD = 4;

  /// The HEAD of the current repository is "unborn" and does not point to
  /// a valid commit.  No merge can be performed, but the caller may wish
  /// to simply set HEAD to the target commit(s).
  static const int GIT_MERGE_ANALYSIS_UNBORN = 8;
}

/// The user's stated preference for merges.
abstract class git_merge_preference_t {
  /// No configuration was found that suggests a preferred behavior for
  /// merge.
  static const int GIT_MERGE_PREFERENCE_NONE = 0;

  /// There is a `merge.ff=false` configuration setting, suggesting that
  /// the user does not want to allow a fast-forward merge.
  static const int GIT_MERGE_PREFERENCE_NO_FASTFORWARD = 1;

  /// There is a `merge.ff=only` configuration setting, suggesting that
  /// the user only wants fast-forward merges.
  static const int GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY = 2;
}

/// Cherry-pick options
class git_cherrypick_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// For merge commits, the "mainline" is treated as the parent.
  @ffi.UnsignedInt()
  external int mainline;

  /// < Options for the merging
  external git_merge_options merge_opts;

  /// < Options for the checkout
  external git_checkout_options checkout_opts;
}

/// Direction of the connection.
///
/// We need this because we need to know whether we should call
/// git-upload-pack or git-receive-pack on the remote end when get_refs
/// gets called.
abstract class git_direction {
  static const int GIT_DIRECTION_FETCH = 0;
  static const int GIT_DIRECTION_PUSH = 1;
}

/// A plaintext username and password
class git_credential_userpass_plaintext extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// < The password to use
  external ffi.Pointer<ffi.Char> password;
}

/// Username-only credential information
class git_credential_username extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> username;
}

/// A ssh key from disk
class git_credential_ssh_key extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// < The path to a public key
  external ffi.Pointer<ffi.Char> publickey;

  /// < The path to a private key
  external ffi.Pointer<ffi.Char> privatekey;

  /// < Passphrase to decrypt the private key
  external ffi.Pointer<ffi.Char> passphrase;
}

/// Keyboard-interactive based ssh authentication
class git_credential_ssh_interactive extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// Callback used for authentication.
  external git_credential_ssh_interactive_cb prompt_callback;

  /// < Payload passed to prompt_callback
  external ffi.Pointer<ffi.Void> payload;
}

typedef git_credential_ssh_interactive_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Void Function(
            ffi.Pointer<ffi.Char>,
            ffi.Int,
            ffi.Pointer<ffi.Char>,
            ffi.Int,
            ffi.Int,
            ffi.Pointer<LIBSSH2_USERAUTH_KBDINT_PROMPT>,
            ffi.Pointer<LIBSSH2_USERAUTH_KBDINT_RESPONSE>,
            ffi.Pointer<ffi.Pointer<ffi.Void>>)>>;
typedef LIBSSH2_USERAUTH_KBDINT_PROMPT = _LIBSSH2_USERAUTH_KBDINT_PROMPT;

class _LIBSSH2_USERAUTH_KBDINT_PROMPT extends ffi.Opaque {}

typedef LIBSSH2_USERAUTH_KBDINT_RESPONSE = _LIBSSH2_USERAUTH_KBDINT_RESPONSE;

class _LIBSSH2_USERAUTH_KBDINT_RESPONSE extends ffi.Opaque {}

/// A key with a custom signature function
class git_credential_ssh_custom extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Char> username;

  /// < The public key data
  external ffi.Pointer<ffi.Char> publickey;

  /// < Length of the public key
  @ffi.Size()
  external int publickey_len;

  /// Callback used to sign the data.
  external git_credential_sign_cb sign_callback;

  /// < Payload passed to prompt_callback
  external ffi.Pointer<ffi.Void> payload;
}

typedef git_credential_sign_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<LIBSSH2_SESSION>,
            ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>,
            ffi.Pointer<ffi.Size>,
            ffi.Pointer<ffi.UnsignedChar>,
            ffi.Size,
            ffi.Pointer<ffi.Pointer<ffi.Void>>)>>;
typedef LIBSSH2_SESSION = _LIBSSH2_SESSION;

class _LIBSSH2_SESSION extends ffi.Opaque {}

/// Stages that are reported by the packbuilder progress callback.
abstract class git_packbuilder_stage_t {
  static const int GIT_PACKBUILDER_ADDING_OBJECTS = 0;
  static const int GIT_PACKBUILDER_DELTAFICATION = 1;
}

/// Callback used to iterate over packed objects
///
/// @see git_packbuilder_foreach
///
/// @param buf A pointer to the object's data
/// @param size The size of the underlying object
/// @param payload Payload passed to git_packbuilder_foreach
/// @return non-zero to terminate the iteration
typedef git_packbuilder_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Void>, ffi.Size, ffi.Pointer<ffi.Void>)>>;

/// The type of proxy to use.
abstract class git_proxy_t {
  /// Do not attempt to connect through a proxy
  ///
  /// If built against libcurl, it itself may attempt to connect
  /// to a proxy if the environment variables specify it.
  static const int GIT_PROXY_NONE = 0;

  /// Try to auto-detect the proxy from the git configuration.
  static const int GIT_PROXY_AUTO = 1;

  /// Connect via the URL given in the options
  static const int GIT_PROXY_SPECIFIED = 2;
}

/// Options for connecting through a proxy
///
/// Note that not all types may be supported, depending on the platform
/// and compilation options.
class git_proxy_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// The type of proxy to use, by URL, auto-detect.
  @ffi.Int32()
  external int type;

  /// The URL of the proxy.
  external ffi.Pointer<ffi.Char> url;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external git_credential_acquire_cb credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external git_transport_certificate_check_cb certificate_check;

  /// Payload to be provided to the credentials and certificate
  /// check callbacks.
  external ffi.Pointer<ffi.Void> payload;
}

/// Remote redirection settings; whether redirects to another host
/// are permitted.  By default, git will follow a redirect on the
/// initial request (`/info/refs`), but not subsequent requests.
abstract class git_remote_redirect_t {
  /// Do not follow any off-site redirects at any stage of
  /// the fetch or push.
  static const int GIT_REMOTE_REDIRECT_NONE = 1;

  /// Allow off-site redirects only upon the initial request.
  /// This is the default.
  static const int GIT_REMOTE_REDIRECT_INITIAL = 2;

  /// Allow redirects at any stage in the fetch or push.
  static const int GIT_REMOTE_REDIRECT_ALL = 4;
}

/// Remote creation options flags
abstract class git_remote_create_flags {
  /// Ignore the repository apply.insteadOf configuration
  static const int GIT_REMOTE_CREATE_SKIP_INSTEADOF = 1;

  /// Don't build a fetchspec from the name if none is set
  static const int GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC = 2;
}

/// Remote creation options structure
///
/// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_remote_create_options_init`.
class git_remote_create_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// The repository that should own the remote.
  /// Setting this to NULL results in a detached remote.
  external ffi.Pointer<git_repository> repository;

  /// The remote's name.
  /// Setting this to NULL results in an in-memory/anonymous remote.
  external ffi.Pointer<ffi.Char> name;

  /// The fetchspec the remote should use.
  external ffi.Pointer<ffi.Char> fetchspec;

  /// Additional flags for the remote. See git_remote_create_flags.
  @ffi.UnsignedInt()
  external int flags;
}

/// Acceptable prune settings when fetching
abstract class git_fetch_prune_t {
  /// Use the setting from the configuration
  static const int GIT_FETCH_PRUNE_UNSPECIFIED = 0;

  /// Force pruning on
  static const int GIT_FETCH_PRUNE = 1;

  /// Force pruning off
  static const int GIT_FETCH_NO_PRUNE = 2;
}

/// Automatic tag following option
///
/// Lets us select the --tags option to use.
abstract class git_remote_autotag_option_t {
  /// Use the setting from the configuration.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = 0;

  /// Ask the server for tags pointing to objects we're already
  /// downloading.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_AUTO = 1;

  /// Don't ask for any tags beyond the refspecs.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_NONE = 2;

  /// Ask for the all the tags.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_ALL = 3;
}

/// Fetch options structure.
///
/// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
/// correctly set the `version` field.  E.g.
///
/// git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
class git_fetch_options extends ffi.Struct {
  @ffi.Int()
  external int version;

  /// Callbacks to use for this fetch operation
  external git_remote_callbacks callbacks;

  /// Whether to perform a prune after the fetch
  @ffi.Int32()
  external int prune;

  /// Whether to write the results to FETCH_HEAD. Defaults to
  /// on. Leave this default in order to behave like git.
  @ffi.Int()
  external int update_fetchhead;

  /// Determines how to behave regarding tags on the remote, such
  /// as auto-downloading tags for objects we're downloading or
  /// downloading all of them.
  ///
  /// The default is to auto-follow tags.
  @ffi.Int32()
  external int download_tags;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.Int32()
  external int follow_redirects;

  /// Extra headers for this fetch operation
  external git_strarray custom_headers;
}

/// Controls the behavior of a git_push object.
class git_push_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// If the transport being used to push to the remote requires the creation
  /// of a pack file, this controls the number of worker threads used by
  /// the packbuilder when creating that pack file to be sent to the remote.
  ///
  /// If set to 0, the packbuilder will auto-detect the number of threads
  /// to create. The default value is 1.
  @ffi.UnsignedInt()
  external int pb_parallelism;

  /// Callbacks to use for this push operation
  external git_remote_callbacks callbacks;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.Int32()
  external int follow_redirects;

  /// Extra headers for this push operation
  external git_strarray custom_headers;
}

/// Remote creation options structure
///
/// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_remote_create_options_init`.
class git_remote_connect_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Callbacks to use for this connection
  external git_remote_callbacks callbacks;

  /// HTTP Proxy settings
  external git_proxy_options proxy_opts;

  /// Whether to allow off-site redirects.  If this is not
  /// specified, the `http.followRedirects` configuration setting
  /// will be consulted.
  @ffi.Int32()
  external int follow_redirects;

  /// Extra HTTP headers to use in this connection
  external git_strarray custom_headers;
}

/// Options for bypassing the git-aware transport on clone. Bypassing
/// it means that instead of a fetch, libgit2 will copy the object
/// database directory instead of figuring out what it needs, which is
/// faster. If possible, it will hardlink the files to save space.
abstract class git_clone_local_t {
  /// Auto-detect (default), libgit2 will bypass the git-aware
  /// transport for local paths, but use a normal fetch for
  /// `file://` urls.
  static const int GIT_CLONE_LOCAL_AUTO = 0;

  /// Bypass the git-aware transport even for a `file://` url.
  static const int GIT_CLONE_LOCAL = 1;

  /// Do no bypass the git-aware transport
  static const int GIT_CLONE_NO_LOCAL = 2;

  /// Bypass the git-aware transport, but do not try to use
  /// hardlinks.
  static const int GIT_CLONE_LOCAL_NO_LINKS = 3;
}

/// Clone options structure
///
/// Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can
/// use `git_clone_options_init`.
class git_clone_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to
  /// `GIT_CHECKOUT_NONE`.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  ///
  /// The callbacks are used for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Set to zero (false) to create a standard repo, or non-zero
  /// for a bare repo
  @ffi.Int()
  external int bare;

  /// Whether to use a fetch or copy the object database.
  @ffi.Int32()
  external int local;

  /// The name of the branch to checkout. NULL means use the
  /// remote's default branch.
  external ffi.Pointer<ffi.Char> checkout_branch;

  /// A callback used to create the new repository into which to
  /// clone. If NULL, the 'bare' field will be used to determine
  /// whether to create a bare repository.
  external git_repository_create_cb repository_cb;

  /// An opaque payload to pass to the git_repository creation callback.
  /// This parameter is ignored unless repository_cb is non-NULL.
  external ffi.Pointer<ffi.Void> repository_cb_payload;

  /// A callback used to create the git_remote, prior to its being
  /// used to perform the clone operation. See the documentation for
  /// git_remote_create_cb for details. This parameter may be NULL,
  /// indicating that git_clone should provide default behavior.
  external git_remote_create_cb remote_cb;

  /// An opaque payload to pass to the git_remote creation callback.
  /// This parameter is ignored unless remote_cb is non-NULL.
  external ffi.Pointer<ffi.Void> remote_cb_payload;
}

/// The signature of a function matching git_repository_init, with an
/// additional void * as callback payload.
///
/// Callers of git_clone my provide a function matching this signature
/// to override the repository creation and customization process
/// during a clone operation.
///
/// @param out the resulting repository
/// @param path path in which to create the repository
/// @param bare whether the repository is bare. This is the value from the clone options
/// @param payload payload specified by the options
/// @return 0, or a negative value to indicate error
typedef git_repository_create_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Pointer<git_repository>>,
            ffi.Pointer<ffi.Char>, ffi.Int, ffi.Pointer<ffi.Void>)>>;

/// The signature of a function matching git_remote_create, with an additional
/// void* as a callback payload.
///
/// Callers of git_clone may provide a function matching this signature to override
/// the remote creation and customization process during a clone operation.
///
/// @param out the resulting remote
/// @param repo the repository in which to create the remote
/// @param name the remote's name
/// @param url the remote's url
/// @param payload an opaque payload
/// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
typedef git_remote_create_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Pointer<git_remote>>,
            ffi.Pointer<git_repository>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>)>>;

/// Priority level of a config file.
/// These priority levels correspond to the natural escalation logic
/// (from higher to lower) when searching for config entries in git.git.
///
/// git_config_open_default() and git_repository_config() honor those
/// priority levels as well.
abstract class git_config_level_t {
  /// System-wide on Windows, for compatibility with portable git
  static const int GIT_CONFIG_LEVEL_PROGRAMDATA = 1;

  /// System-wide configuration file; /etc/gitconfig on Linux systems
  static const int GIT_CONFIG_LEVEL_SYSTEM = 2;

  /// XDG compatible configuration file; typically ~/.config/git/config
  static const int GIT_CONFIG_LEVEL_XDG = 3;

  /// User-specific configuration file (also called Global configuration
  /// file); typically ~/.gitconfig
  static const int GIT_CONFIG_LEVEL_GLOBAL = 4;

  /// Repository specific configuration file; $WORK_DIR/.git/config on
  /// non-bare repos
  static const int GIT_CONFIG_LEVEL_LOCAL = 5;

  /// Application specific configuration file; freely defined by applications
  static const int GIT_CONFIG_LEVEL_APP = 6;

  /// Represents the highest level available config file (i.e. the most
  /// specific config file available that actually is loaded)
  static const int GIT_CONFIG_HIGHEST_LEVEL = -1;
}

/// An entry in a configuration file
class git_config_entry extends ffi.Struct {
  /// < Name of the entry (normalised)
  external ffi.Pointer<ffi.Char> name;

  /// < String value of the entry
  external ffi.Pointer<ffi.Char> value;

  /// < Depth of includes where this variable was found
  @ffi.UnsignedInt()
  external int include_depth;

  /// < Which config file this was found in
  @ffi.Int32()
  external int level;

  external ffi.Pointer<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<git_config_entry>)>>
      free;

  /// < Opaque value for the free function. Do not read or write
  external ffi.Pointer<ffi.Void> payload;
}

class git_config_iterator extends ffi.Opaque {}

/// Config var type
abstract class git_configmap_t {
  static const int GIT_CONFIGMAP_FALSE = 0;
  static const int GIT_CONFIGMAP_TRUE = 1;
  static const int GIT_CONFIGMAP_INT32 = 2;
  static const int GIT_CONFIGMAP_STRING = 3;
}

/// Mapping from config variables to values.
class git_configmap extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external ffi.Pointer<ffi.Char> str_match;

  @ffi.Int()
  external int map_value;
}

/// A config enumeration callback
///
/// @param entry the entry currently being enumerated
/// @param payload a user-specified pointer
/// @return non-zero to terminate the iteration.
typedef git_config_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<git_config_entry>, ffi.Pointer<ffi.Void>)>>;

/// Reference lookup strategy
///
/// These behave like the --tags and --all options to git-describe,
/// namely they say to look for any reference in either refs/tags/ or
/// refs/ respectively.
abstract class git_describe_strategy_t {
  static const int GIT_DESCRIBE_DEFAULT = 0;
  static const int GIT_DESCRIBE_TAGS = 1;
  static const int GIT_DESCRIBE_ALL = 2;
}

/// Describe options structure
///
/// Initialize with `GIT_DESCRIBE_OPTIONS_INIT`. Alternatively, you can
/// use `git_describe_options_init`.
class git_describe_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// < default: 10
  @ffi.UnsignedInt()
  external int max_candidates_tags;

  /// < default: GIT_DESCRIBE_DEFAULT
  @ffi.UnsignedInt()
  external int describe_strategy;

  external ffi.Pointer<ffi.Char> pattern;

  /// When calculating the distance from the matching tag or
  /// reference, only walk down the first-parent ancestry.
  @ffi.Int()
  external int only_follow_first_parent;

  /// If no matching tag or reference is found, the describe
  /// operation would normally fail. If this option is set, it
  /// will instead fall back to showing the full id of the
  /// commit.
  @ffi.Int()
  external int show_commit_oid_as_fallback;
}

/// Describe format options structure
///
/// Initialize with `GIT_DESCRIBE_FORMAT_OPTIONS_INIT`. Alternatively, you can
/// use `git_describe_format_options_init`.
class git_describe_format_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Size of the abbreviated commit id to use. This value is the
  /// lower bound for the length of the abbreviated string. The
  /// default is 7.
  @ffi.UnsignedInt()
  external int abbreviated_size;

  /// Set to use the long format even when a shorter name could be used.
  @ffi.Int()
  external int always_use_long_format;

  /// If the workdir is dirty and this is set, this string will
  /// be appended to the description string.
  external ffi.Pointer<ffi.Char> dirty_suffix;
}

class git_describe_result extends ffi.Opaque {}

/// Generic return codes
abstract class git_error_code {
  /// < No error
  static const int GIT_OK = 0;

  /// < Generic error
  static const int GIT_ERROR = -1;

  /// < Requested object could not be found
  static const int GIT_ENOTFOUND = -3;

  /// < Object exists preventing operation
  static const int GIT_EEXISTS = -4;

  /// < More than one object matches
  static const int GIT_EAMBIGUOUS = -5;

  /// < Output buffer too short to hold data
  static const int GIT_EBUFS = -6;

  /// GIT_EUSER is a special error that is never generated by libgit2
  /// code.  You can return it from a callback (e.g to stop an iteration)
  /// to know that it was generated by the callback and not by libgit2.
  static const int GIT_EUSER = -7;

  /// < Operation not allowed on bare repository
  static const int GIT_EBAREREPO = -8;

  /// < HEAD refers to branch with no commits
  static const int GIT_EUNBORNBRANCH = -9;

  /// < Merge in progress prevented operation
  static const int GIT_EUNMERGED = -10;

  /// < Reference was not fast-forwardable
  static const int GIT_ENONFASTFORWARD = -11;

  /// < Name/ref spec was not in a valid format
  static const int GIT_EINVALIDSPEC = -12;

  /// < Checkout conflicts prevented operation
  static const int GIT_ECONFLICT = -13;

  /// < Lock file prevented operation
  static const int GIT_ELOCKED = -14;

  /// < Reference value does not match expected
  static const int GIT_EMODIFIED = -15;

  /// < Authentication error
  static const int GIT_EAUTH = -16;

  /// < Server certificate is invalid
  static const int GIT_ECERTIFICATE = -17;

  /// < Patch/merge has already been applied
  static const int GIT_EAPPLIED = -18;

  /// < The requested peel operation is not possible
  static const int GIT_EPEEL = -19;

  /// < Unexpected EOF
  static const int GIT_EEOF = -20;

  /// < Invalid operation or input
  static const int GIT_EINVALID = -21;

  /// < Uncommitted changes in index prevented operation
  static const int GIT_EUNCOMMITTED = -22;

  /// < The operation is not valid for a directory
  static const int GIT_EDIRECTORY = -23;

  /// < A merge conflict exists and cannot continue
  static const int GIT_EMERGECONFLICT = -24;

  /// < A user-configured callback refused to act
  static const int GIT_PASSTHROUGH = -30;

  /// < Signals end of iteration with iterator
  static const int GIT_ITEROVER = -31;

  /// < Internal only
  static const int GIT_RETRY = -32;

  /// < Hashsum mismatch in object
  static const int GIT_EMISMATCH = -33;

  /// < Unsaved changes in the index would be overwritten
  static const int GIT_EINDEXDIRTY = -34;

  /// < Patch application failed
  static const int GIT_EAPPLYFAIL = -35;

  /// < The object is not owned by the current user
  static const int GIT_EOWNER = -36;
}

/// Structure to store extra details of the last error that occurred.
///
/// This is kept on a per-thread basis if GIT_THREADS was defined when the
/// library was build, otherwise one is kept globally for the library
class git_error extends ffi.Struct {
  external ffi.Pointer<ffi.Char> message;

  @ffi.Int()
  external int klass;
}

/// Error classes
abstract class git_error_t {
  static const int GIT_ERROR_NONE = 0;
  static const int GIT_ERROR_NOMEMORY = 1;
  static const int GIT_ERROR_OS = 2;
  static const int GIT_ERROR_INVALID = 3;
  static const int GIT_ERROR_REFERENCE = 4;
  static const int GIT_ERROR_ZLIB = 5;
  static const int GIT_ERROR_REPOSITORY = 6;
  static const int GIT_ERROR_CONFIG = 7;
  static const int GIT_ERROR_REGEX = 8;
  static const int GIT_ERROR_ODB = 9;
  static const int GIT_ERROR_INDEX = 10;
  static const int GIT_ERROR_OBJECT = 11;
  static const int GIT_ERROR_NET = 12;
  static const int GIT_ERROR_TAG = 13;
  static const int GIT_ERROR_TREE = 14;
  static const int GIT_ERROR_INDEXER = 15;
  static const int GIT_ERROR_SSL = 16;
  static const int GIT_ERROR_SUBMODULE = 17;
  static const int GIT_ERROR_THREAD = 18;
  static const int GIT_ERROR_STASH = 19;
  static const int GIT_ERROR_CHECKOUT = 20;
  static const int GIT_ERROR_FETCHHEAD = 21;
  static const int GIT_ERROR_MERGE = 22;
  static const int GIT_ERROR_SSH = 23;
  static const int GIT_ERROR_FILTER = 24;
  static const int GIT_ERROR_REVERT = 25;
  static const int GIT_ERROR_CALLBACK = 26;
  static const int GIT_ERROR_CHERRYPICK = 27;
  static const int GIT_ERROR_DESCRIBE = 28;
  static const int GIT_ERROR_REBASE = 29;
  static const int GIT_ERROR_FILESYSTEM = 30;
  static const int GIT_ERROR_PATCH = 31;
  static const int GIT_ERROR_WORKTREE = 32;
  static const int GIT_ERROR_SHA = 33;
  static const int GIT_ERROR_HTTP = 34;
  static const int GIT_ERROR_INTERNAL = 35;
}

/// Filters are applied in one of two directions: smudging - which is
/// exporting a file from the Git object database to the working directory,
/// and cleaning - which is importing a file from the working directory to
/// the Git object database.  These values control which direction of
/// change is being applied.
abstract class git_filter_mode_t {
  static const int GIT_FILTER_TO_WORKTREE = 0;
  static const int GIT_FILTER_SMUDGE = 0;
  static const int GIT_FILTER_TO_ODB = 1;
  static const int GIT_FILTER_CLEAN = 1;
}

/// Filter option flags.
abstract class git_filter_flag_t {
  static const int GIT_FILTER_DEFAULT = 0;

  /// Don't error for `safecrlf` violations, allow them to continue.
  static const int GIT_FILTER_ALLOW_UNSAFE = 1;

  /// Don't load `/etc/gitattributes` (or the system equivalent)
  static const int GIT_FILTER_NO_SYSTEM_ATTRIBUTES = 2;

  /// Load attributes from `.gitattributes` in the root of HEAD
  static const int GIT_FILTER_ATTRIBUTES_FROM_HEAD = 4;

  /// Load attributes from `.gitattributes` in a given commit.
  /// This can only be specified in a `git_filter_options`.
  static const int GIT_FILTER_ATTRIBUTES_FROM_COMMIT = 8;
}

/// Filtering options
class git_filter_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// See `git_filter_flag_t` above
  @ffi.Uint32()
  external int flags;

  external ffi.Pointer<git_oid> commit_id;

  /// The commit to load attributes from, when
  /// `GIT_FILTER_ATTRIBUTES_FROM_COMMIT` is specified.
  external git_oid attr_commit_id;
}

class git_filter extends ffi.Opaque {}

class git_filter_list extends ffi.Opaque {}

/// Rebase options
///
/// Use to tell the rebase machinery how to operate.
class git_rebase_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// Used by `git_rebase_init`, this will instruct other clients working
  /// on this rebase that you want a quiet rebase experience, which they
  /// may choose to provide in an application-specific manner.  This has no
  /// effect upon libgit2 directly, but is provided for interoperability
  /// between Git tools.
  @ffi.Int()
  external int quiet;

  /// Used by `git_rebase_init`, this will begin an in-memory rebase,
  /// which will allow callers to step through the rebase operations and
  /// commit the rebased changes, but will not rewind HEAD or update the
  /// repository to be in a rebasing state.  This will not interfere with
  /// the working directory (if there is one).
  @ffi.Int()
  external int inmemory;

  /// Used by `git_rebase_finish`, this is the name of the notes reference
  /// used to rewrite notes for rebased commits when finishing the rebase;
  /// if NULL, the contents of the configuration option `notes.rewriteRef`
  /// is examined, unless the configuration option `notes.rewrite.rebase`
  /// is set to false.  If `notes.rewriteRef` is also NULL, notes will
  /// not be rewritten.
  external ffi.Pointer<ffi.Char> rewrite_notes_ref;

  /// Options to control how trees are merged during `git_rebase_next`.
  external git_merge_options merge_options;

  /// Options to control how files are written during `git_rebase_init`,
  /// `git_rebase_next` and `git_rebase_abort`.  Note that a minimum
  /// strategy of `GIT_CHECKOUT_SAFE` is defaulted in `init` and `next`,
  /// and a minimum strategy of `GIT_CHECKOUT_FORCE` is defaulted in
  /// `abort` to match git semantics.
  external git_checkout_options checkout_options;

  /// Optional callback that allows users to override commit
  /// creation in `git_rebase_commit`.  If specified, users can
  /// create their own commit and provide the commit ID, which
  /// may be useful for signing commits or otherwise customizing
  /// the commit creation.
  ///
  /// If this callback returns `GIT_PASSTHROUGH`, then
  /// `git_rebase_commit` will continue to create the commit.
  external git_commit_create_cb commit_create_cb;

  /// If provided, this will be called with the commit content, allowing
  /// a signature to be added to the rebase commit. Can be skipped with
  /// GIT_PASSTHROUGH. If GIT_PASSTHROUGH is returned, a commit will be made
  /// without a signature.
  ///
  /// This field is only used when performing git_rebase_commit.
  ///
  /// This callback is not invoked if a `git_commit_create_cb` is
  /// specified.
  ///
  /// This callback is deprecated; users should provide a
  /// creation callback as `commit_create_cb` that produces a
  /// commit buffer, signs it, and commits it.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<git_buf>, ffi.Pointer<git_buf>,
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Void>)>> signing_cb;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;
}

/// Commit creation callback: used when a function is going to create
/// commits (for example, in `git_rebase_commit`) to allow callers to
/// override the commit creation behavior.  For example, users may
/// wish to sign commits by providing this information to
/// `git_commit_create_buffer`, signing that buffer, then calling
/// `git_commit_create_with_signature`.  The resultant commit id
/// should be set in the `out` object id parameter.
///
/// @param out pointer that this callback will populate with the object
/// id of the commit that is created
/// @param author the author name and time of the commit
/// @param committer the committer name and time of the commit
/// @param message_encoding the encoding of the given message, or NULL
/// to assume UTF8
/// @param message the commit message
/// @param tree the tree to be committed
/// @param parent_count the number of parents for this commit
/// @param parents the commit parents
/// @param payload the payload pointer in the rebase options
/// @return 0 if this callback has created the commit and populated the out
/// parameter, GIT_PASSTHROUGH if the callback has not created a
/// commit and wants the calling function to create the commit as
/// if no callback had been specified, any other value to stop
/// and return a failure
typedef git_commit_create_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<git_oid>,
            ffi.Pointer<git_signature>,
            ffi.Pointer<git_signature>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Char>,
            ffi.Pointer<git_tree>,
            ffi.Size,
            ffi.Pointer<ffi.Pointer<git_commit>>,
            ffi.Pointer<ffi.Void>)>>;

/// Type of rebase operation in-progress after calling `git_rebase_next`.
abstract class git_rebase_operation_t {
  /// The given commit is to be cherry-picked.  The client should commit
  /// the changes and continue if there are no conflicts.
  static const int GIT_REBASE_OPERATION_PICK = 0;

  /// The given commit is to be cherry-picked, but the client should prompt
  /// the user to provide an updated commit message.
  static const int GIT_REBASE_OPERATION_REWORD = 1;

  /// The given commit is to be cherry-picked, but the client should stop
  /// to allow the user to edit the changes before committing them.
  static const int GIT_REBASE_OPERATION_EDIT = 2;

  /// The given commit is to be squashed into the previous commit.  The
  /// commit message will be merged with the previous message.
  static const int GIT_REBASE_OPERATION_SQUASH = 3;

  /// The given commit is to be squashed into the previous commit.  The
  /// commit message from this commit will be discarded.
  static const int GIT_REBASE_OPERATION_FIXUP = 4;

  /// No commit will be cherry-picked.  The client should run the given
  /// command and (if successful) continue.
  static const int GIT_REBASE_OPERATION_EXEC = 5;
}

/// A rebase operation
///
/// Describes a single instruction/operation to be performed during the
/// rebase.
class git_rebase_operation extends ffi.Struct {
  /// The type of rebase operation.
  @ffi.Int32()
  external int type;

  /// The commit ID being cherry-picked.  This will be populated for
  /// all operations except those of type `GIT_REBASE_OPERATION_EXEC`.
  external git_oid id;

  /// The executable the user has requested be run.  This will only
  /// be populated for operations of type `GIT_REBASE_OPERATION_EXEC`.
  external ffi.Pointer<ffi.Char> exec;
}

/// Available tracing levels.  When tracing is set to a particular level,
/// callers will be provided tracing at the given level and all lower levels.
abstract class git_trace_level_t {
  /// No tracing will be performed.
  static const int GIT_TRACE_NONE = 0;

  /// Severe errors that may impact the program's execution
  static const int GIT_TRACE_FATAL = 1;

  /// Errors that do not impact the program's execution
  static const int GIT_TRACE_ERROR = 2;

  /// Warnings that suggest abnormal data
  static const int GIT_TRACE_WARN = 3;

  /// Informational messages about program execution
  static const int GIT_TRACE_INFO = 4;

  /// Detailed data that allows for debugging
  static const int GIT_TRACE_DEBUG = 5;

  /// Exceptionally detailed debugging data
  static const int GIT_TRACE_TRACE = 6;
}

/// An instance for a tracing function
typedef git_trace_cb = ffi.Pointer<
    ffi.NativeFunction<ffi.Void Function(ffi.Int32, ffi.Pointer<ffi.Char>)>>;

/// Options for revert
class git_revert_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// For merge commits, the "mainline" is treated as the parent.
  @ffi.UnsignedInt()
  external int mainline;

  /// < Options for the merging
  external git_merge_options merge_opts;

  /// < Options for the checkout
  external git_checkout_options checkout_opts;
}

/// Revparse flags.  These indicate the intended behavior of the spec passed to
/// git_revparse.
abstract class git_revspec_t {
  /// The spec targeted a single object.
  static const int GIT_REVSPEC_SINGLE = 1;

  /// The spec targeted a range of commits.
  static const int GIT_REVSPEC_RANGE = 2;

  /// The spec used the '...' operator, which invokes special semantics.
  static const int GIT_REVSPEC_MERGE_BASE = 4;
}

/// Git Revision Spec: output of a `git_revparse` operation
class git_revspec extends ffi.Struct {
  /// The left element of the revspec; must be freed by the user
  external ffi.Pointer<git_object> from;

  /// The right element of the revspec; must be freed by the user
  external ffi.Pointer<git_object> to;

  /// The intent of the revspec (i.e. `git_revspec_mode_t` flags)
  @ffi.UnsignedInt()
  external int flags;
}

/// Stash flags
abstract class git_stash_flags {
  /// No option, default
  static const int GIT_STASH_DEFAULT = 0;

  /// All changes already added to the index are left intact in
  /// the working directory
  static const int GIT_STASH_KEEP_INDEX = 1;

  /// All untracked files are also stashed and then cleaned up
  /// from the working directory
  static const int GIT_STASH_INCLUDE_UNTRACKED = 2;

  /// All ignored files are also stashed and then cleaned up from
  /// the working directory
  static const int GIT_STASH_INCLUDE_IGNORED = 4;
}

/// Stash application flags.
abstract class git_stash_apply_flags {
  static const int GIT_STASH_APPLY_DEFAULT = 0;

  /// Try to reinstate not only the working tree's changes,
  /// but also the index's changes.
  static const int GIT_STASH_APPLY_REINSTATE_INDEX = 1;
}

/// Stash apply progression states
abstract class git_stash_apply_progress_t {
  static const int GIT_STASH_APPLY_PROGRESS_NONE = 0;

  /// Loading the stashed data from the object database.
  static const int GIT_STASH_APPLY_PROGRESS_LOADING_STASH = 1;

  /// The stored index is being analyzed.
  static const int GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX = 2;

  /// The modified files are being analyzed.
  static const int GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED = 3;

  /// The untracked and ignored files are being analyzed.
  static const int GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED = 4;

  /// The untracked files are being written to disk.
  static const int GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED = 5;

  /// The modified files are being written to disk.
  static const int GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED = 6;

  /// The stash was applied successfully.
  static const int GIT_STASH_APPLY_PROGRESS_DONE = 7;
}

/// Stash application options structure
///
/// Initialize with `GIT_STASH_APPLY_OPTIONS_INIT`. Alternatively, you can
/// use `git_stash_apply_options_init`.
class git_stash_apply_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// See `git_stash_apply_flags`, above.
  @ffi.Uint32()
  external int flags;

  /// Options to use when writing files to the working directory.
  external git_checkout_options checkout_options;

  /// Optional callback to notify the consumer of application progress.
  external git_stash_apply_progress_cb progress_cb;

  external ffi.Pointer<ffi.Void> progress_payload;
}

/// Stash application progress notification function.
/// Return 0 to continue processing, or a negative value to
/// abort the stash application.
typedef git_stash_apply_progress_cb = ffi.Pointer<
    ffi.NativeFunction<ffi.Int Function(ffi.Int32, ffi.Pointer<ffi.Void>)>>;

/// This is a callback function you can provide to iterate over all the
/// stashed states that will be invoked per entry.
///
/// @param index The position within the stash list. 0 points to the
/// most recent stashed state.
/// @param message The stash message.
/// @param stash_id The commit oid of the stashed state.
/// @param payload Extra parameter to callback function.
/// @return 0 to continue iterating or non-zero to stop.
typedef git_stash_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Size, ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>,
            ffi.Pointer<ffi.Void>)>>;

/// Status flags for a single file.
///
/// A combination of these values will be returned to indicate the status of
/// a file.  Status compares the working directory, the index, and the
/// current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags
/// represents the status of file in the index relative to the HEAD, and the
/// `GIT_STATUS_WT` set of flags represent the status of the file in the
/// working directory relative to the index.
abstract class git_status_t {
  static const int GIT_STATUS_CURRENT = 0;
  static const int GIT_STATUS_INDEX_NEW = 1;
  static const int GIT_STATUS_INDEX_MODIFIED = 2;
  static const int GIT_STATUS_INDEX_DELETED = 4;
  static const int GIT_STATUS_INDEX_RENAMED = 8;
  static const int GIT_STATUS_INDEX_TYPECHANGE = 16;
  static const int GIT_STATUS_WT_NEW = 128;
  static const int GIT_STATUS_WT_MODIFIED = 256;
  static const int GIT_STATUS_WT_DELETED = 512;
  static const int GIT_STATUS_WT_TYPECHANGE = 1024;
  static const int GIT_STATUS_WT_RENAMED = 2048;
  static const int GIT_STATUS_WT_UNREADABLE = 4096;
  static const int GIT_STATUS_IGNORED = 16384;
  static const int GIT_STATUS_CONFLICTED = 32768;
}

/// Select the files on which to report status.
///
/// With `git_status_foreach_ext`, this will control which changes get
/// callbacks.  With `git_status_list_new`, these will control which
/// changes are included in the list.
abstract class git_status_show_t {
  /// The default. This roughly matches `git status --porcelain` regarding
  /// which files are included and in what order.
  static const int GIT_STATUS_SHOW_INDEX_AND_WORKDIR = 0;

  /// Only gives status based on HEAD to index comparison, not looking at
  /// working directory changes.
  static const int GIT_STATUS_SHOW_INDEX_ONLY = 1;

  /// Only gives status based on index to working directory comparison,
  /// not comparing the index to the HEAD.
  static const int GIT_STATUS_SHOW_WORKDIR_ONLY = 2;
}

/// Flags to control status callbacks
///
/// Calling `git_status_foreach()` is like calling the extended version
/// with: GIT_STATUS_OPT_INCLUDE_IGNORED, GIT_STATUS_OPT_INCLUDE_UNTRACKED,
/// and GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS.  Those options are bundled
/// together as `GIT_STATUS_OPT_DEFAULTS` if you want them as a baseline.
abstract class git_status_opt_t {
  /// Says that callbacks should be made on untracked files.
  /// These will only be made if the workdir files are included in the status
  /// "show" option.
  static const int GIT_STATUS_OPT_INCLUDE_UNTRACKED = 1;

  /// Says that ignored files get callbacks.
  /// Again, these callbacks will only be made if the workdir files are
  /// included in the status "show" option.
  static const int GIT_STATUS_OPT_INCLUDE_IGNORED = 2;

  /// Indicates that callback should be made even on unmodified files.
  static const int GIT_STATUS_OPT_INCLUDE_UNMODIFIED = 4;

  /// Indicates that submodules should be skipped.
  /// This only applies if there are no pending typechanges to the submodule
  /// (either from or to another type).
  static const int GIT_STATUS_OPT_EXCLUDE_SUBMODULES = 8;

  /// Indicates that all files in untracked directories should be included.
  /// Normally if an entire directory is new, then just the top-level
  /// directory is included (with a trailing slash on the entry name).
  /// This flag says to include all of the individual files in the directory
  /// instead.
  static const int GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = 16;

  /// Indicates that the given path should be treated as a literal path,
  /// and not as a pathspec pattern.
  static const int GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = 32;

  /// Indicates that the contents of ignored directories should be included
  /// in the status. This is like doing `git ls-files -o -i --exclude-standard`
  /// with core git.
  static const int GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = 64;

  /// Indicates that rename detection should be processed between the head and
  /// the index and enables the GIT_STATUS_INDEX_RENAMED as a possible status
  /// flag.
  static const int GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = 128;

  /// Indicates that rename detection should be run between the index and the
  /// working directory and enabled GIT_STATUS_WT_RENAMED as a possible status
  /// flag.
  static const int GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = 256;

  /// Overrides the native case sensitivity for the file system and forces
  /// the output to be in case-sensitive order.
  static const int GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = 512;

  /// Overrides the native case sensitivity for the file system and forces
  /// the output to be in case-insensitive order.
  static const int GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = 1024;

  /// Iindicates that rename detection should include rewritten files.
  static const int GIT_STATUS_OPT_RENAMES_FROM_REWRITES = 2048;

  /// Bypasses the default status behavior of doing a "soft" index reload
  /// (i.e. reloading the index data if the file on disk has been modified
  /// outside libgit2).
  static const int GIT_STATUS_OPT_NO_REFRESH = 4096;

  /// Tells libgit2 to refresh the stat cache in the index for files that are
  /// unchanged but have out of date stat einformation in the index.
  /// It will result in less work being done on subsequent calls to get status.
  /// This is mutually exclusive with the NO_REFRESH option.
  static const int GIT_STATUS_OPT_UPDATE_INDEX = 8192;

  /// Normally files that cannot be opened or read are ignored as
  /// these are often transient files; this option will return
  /// unreadable files as `GIT_STATUS_WT_UNREADABLE`.
  static const int GIT_STATUS_OPT_INCLUDE_UNREADABLE = 16384;

  /// Unreadable files will be detected and given the status
  /// untracked instead of unreadable.
  static const int GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = 32768;
}

/// Options to control how `git_status_foreach_ext()` will issue callbacks.
///
/// Initialize with `GIT_STATUS_OPTIONS_INIT`. Alternatively, you can
/// use `git_status_options_init`.
class git_status_options extends ffi.Struct {
  /// The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
  @ffi.UnsignedInt()
  external int version;

  /// The `show` value is one of the `git_status_show_t` constants that
  /// control which files to scan and in what order. The default is
  /// `GIT_STATUS_SHOW_INDEX_AND_WORKDIR`.
  @ffi.Int32()
  external int show1;

  /// The `flags` value is an OR'ed combination of the
  /// `git_status_opt_t` values above. The default is
  /// `GIT_STATUS_OPT_DEFAULTS`, which matches git's default
  /// behavior.
  @ffi.UnsignedInt()
  external int flags;

  /// The `pathspec` is an array of path patterns to match (using
  /// fnmatch-style matching), or just an array of paths to match
  /// exactly if `GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH` is specified
  /// in the flags.
  external git_strarray pathspec;

  /// The `baseline` is the tree to be used for comparison to the
  /// working directory and index; defaults to HEAD.
  external ffi.Pointer<git_tree> baseline;

  /// Threshold above which similar files will be considered renames.
  /// This is equivalent to the -M option. Defaults to 50.
  @ffi.Uint16()
  external int rename_threshold;
}

/// A status entry, providing the differences between the file as it exists
/// in HEAD and the index, and providing the differences between the index
/// and the working directory.
///
/// The `status` value provides the status flags for this file.
///
/// The `head_to_index` value provides detailed information about the
/// differences between the file in HEAD and the file in the index.
///
/// The `index_to_workdir` value provides detailed information about the
/// differences between the file in the index and the file in the
/// working directory.
class git_status_entry extends ffi.Struct {
  @ffi.Int32()
  external int status;

  external ffi.Pointer<git_diff_delta> head_to_index;

  external ffi.Pointer<git_diff_delta> index_to_workdir;
}

/// Function pointer to receive status on individual files
///
/// `path` is the relative path to the file from the root of the repository.
///
/// `status_flags` is a combination of `git_status_t` values that apply.
///
/// `payload` is the value you passed to the foreach function as payload.
typedef git_status_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(
            ffi.Pointer<ffi.Char>, ffi.UnsignedInt, ffi.Pointer<ffi.Void>)>>;

/// Return codes for submodule status.
///
/// A combination of these flags will be returned to describe the status of a
/// submodule.  Depending on the "ignore" property of the submodule, some of
/// the flags may never be returned because they indicate changes that are
/// supposed to be ignored.
///
/// Submodule info is contained in 4 places: the HEAD tree, the index, config
/// files (both .git/config and .gitmodules), and the working directory.  Any
/// or all of those places might be missing information about the submodule
/// depending on what state the repo is in.  We consider all four places to
/// build the combination of status flags.
///
/// There are four values that are not really status, but give basic info
/// about what sources of submodule data are available.  These will be
/// returned even if ignore is set to "ALL".
///
/// * IN_HEAD   - superproject head contains submodule
/// * IN_INDEX  - superproject index contains submodule
/// * IN_CONFIG - superproject gitmodules has submodule
/// * IN_WD     - superproject workdir has submodule
///
/// The following values will be returned so long as ignore is not "ALL".
///
/// * INDEX_ADDED       - in index, not in head
/// * INDEX_DELETED     - in head, not in index
/// * INDEX_MODIFIED    - index and head don't match
/// * WD_UNINITIALIZED  - workdir contains empty directory
/// * WD_ADDED          - in workdir, not index
/// * WD_DELETED        - in index, not workdir
/// * WD_MODIFIED       - index and workdir head don't match
///
/// The following can only be returned if ignore is "NONE" or "UNTRACKED".
///
/// * WD_INDEX_MODIFIED - submodule workdir index is dirty
/// * WD_WD_MODIFIED    - submodule workdir has modified files
///
/// Lastly, the following will only be returned for ignore "NONE".
///
/// * WD_UNTRACKED      - wd contains untracked files
abstract class git_submodule_status_t {
  static const int GIT_SUBMODULE_STATUS_IN_HEAD = 1;
  static const int GIT_SUBMODULE_STATUS_IN_INDEX = 2;
  static const int GIT_SUBMODULE_STATUS_IN_CONFIG = 4;
  static const int GIT_SUBMODULE_STATUS_IN_WD = 8;
  static const int GIT_SUBMODULE_STATUS_INDEX_ADDED = 16;
  static const int GIT_SUBMODULE_STATUS_INDEX_DELETED = 32;
  static const int GIT_SUBMODULE_STATUS_INDEX_MODIFIED = 64;
  static const int GIT_SUBMODULE_STATUS_WD_UNINITIALIZED = 128;
  static const int GIT_SUBMODULE_STATUS_WD_ADDED = 256;
  static const int GIT_SUBMODULE_STATUS_WD_DELETED = 512;
  static const int GIT_SUBMODULE_STATUS_WD_MODIFIED = 1024;
  static const int GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED = 2048;
  static const int GIT_SUBMODULE_STATUS_WD_WD_MODIFIED = 4096;
  static const int GIT_SUBMODULE_STATUS_WD_UNTRACKED = 8192;
}

/// Submodule update options structure
///
/// Initialize with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_submodule_update_options_init`.
class git_submodule_update_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to
  /// `GIT_CHECKOUT_NONE`. Generally you will want the use
  /// GIT_CHECKOUT_SAFE to update files in the working
  /// directory.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  ///
  /// The callbacks to use for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Allow fetching from the submodule's default remote if the target
  /// commit isn't found. Enabled by default.
  @ffi.Int()
  external int allow_fetch;
}

/// Function pointer to receive each submodule
///
/// @param sm git_submodule currently being visited
/// @param name name of the submodule
/// @param payload value you passed to the foreach function as payload
/// @return 0 on success or error code
typedef git_submodule_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_submodule>, ffi.Pointer<ffi.Char>,
            ffi.Pointer<ffi.Void>)>>;

/// Worktree add options structure
///
/// Initialize with `GIT_WORKTREE_ADD_OPTIONS_INIT`. Alternatively, you can
/// use `git_worktree_add_options_init`.
class git_worktree_add_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// < lock newly created worktree
  @ffi.Int()
  external int lock;

  /// < reference to use for the new worktree HEAD
  external ffi.Pointer<git_reference> ref;

  /// Options for the checkout.
  external git_checkout_options checkout_options;
}

/// Flags which can be passed to git_worktree_prune to alter its
/// behavior.
abstract class git_worktree_prune_t {
  /// Prune working tree even if working tree is valid
  static const int GIT_WORKTREE_PRUNE_VALID = 1;

  /// Prune working tree even if it is locked
  static const int GIT_WORKTREE_PRUNE_LOCKED = 2;

  /// Prune checked out working tree
  static const int GIT_WORKTREE_PRUNE_WORKING_TREE = 4;
}

/// Worktree prune options structure
///
/// Initialize with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`. Alternatively, you can
/// use `git_worktree_prune_options_init`.
class git_worktree_prune_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// A combination of `git_worktree_prune_t`
  @ffi.Uint32()
  external int flags;
}

/// Payload for git_credential_userpass_plaintext.
class git_credential_userpass_payload extends ffi.Struct {
  external ffi.Pointer<ffi.Char> username;

  external ffi.Pointer<ffi.Char> password;
}

/// Formatting options for diff e-mail generation
abstract class git_diff_format_email_flags_t {
  /// Normal patch, the default
  static const int GIT_DIFF_FORMAT_EMAIL_NONE = 0;

  /// Don't insert "[PATCH]" in the subject header
  static const int GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER = 1;
}

/// Options for controlling the formatting of the generated e-mail.
class git_diff_format_email_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// see `git_diff_format_email_flags_t` above
  @ffi.Uint32()
  external int flags;

  /// This patch number
  @ffi.Size()
  external int patch_no;

  /// Total number of patches in this series
  @ffi.Size()
  external int total_patches;

  /// id to use for the commit
  external ffi.Pointer<git_oid> id;

  /// Summary of the change
  external ffi.Pointer<ffi.Char> summary;

  /// Commit message's body
  external ffi.Pointer<ffi.Char> body;

  /// Author of the change
  external ffi.Pointer<git_signature> author;
}

/// Formatting options for diff e-mail generation
abstract class git_email_create_flags_t {
  /// Normal patch, the default
  static const int GIT_EMAIL_CREATE_DEFAULT = 0;

  /// Do not include patch numbers in the subject prefix.
  static const int GIT_EMAIL_CREATE_OMIT_NUMBERS = 1;

  /// Include numbers in the subject prefix even when the
  /// patch is for a single commit (1/1).
  static const int GIT_EMAIL_CREATE_ALWAYS_NUMBER = 2;

  /// Do not perform rename or similarity detection.
  static const int GIT_EMAIL_CREATE_NO_RENAMES = 4;
}

/// Options for controlling the formatting of the generated e-mail.
class git_email_create_options extends ffi.Struct {
  @ffi.UnsignedInt()
  external int version;

  /// see `git_email_create_flags_t` above
  @ffi.Uint32()
  external int flags;

  /// Options to use when creating diffs
  external git_diff_options diff_opts;

  /// Options for finding similarities within diffs
  external git_diff_find_options diff_find_opts;

  /// The subject prefix, by default "PATCH".  If set to an empty
  /// string ("") then only the patch numbers will be shown in the
  /// prefix.  If the subject_prefix is empty and patch numbers
  /// are not being shown, the prefix will be omitted entirely.
  external ffi.Pointer<ffi.Char> subject_prefix;

  /// The starting patch number; this cannot be 0.  By default,
  /// this is 1.
  @ffi.Size()
  external int start_number;

  /// The "re-roll" number.  By default, there is no re-roll.
  @ffi.Size()
  external int reroll_number;
}

/// Represents a single git message trailer.
class git_message_trailer extends ffi.Struct {
  external ffi.Pointer<ffi.Char> key;

  external ffi.Pointer<ffi.Char> value;
}

/// Represents an array of git message trailers.
///
/// Struct members under the private comment are private, subject to change
/// and should not be used by callers.
class git_message_trailer_array extends ffi.Struct {
  external ffi.Pointer<git_message_trailer> trailers;

  @ffi.Size()
  external int count;

  /// private
  external ffi.Pointer<ffi.Char> _trailer_block;
}

class git_iterator extends ffi.Opaque {}

/// note iterator
typedef git_note_iterator = git_iterator;

/// Callback for git_note_foreach.
///
/// Receives:
/// - blob_id: Oid of the blob containing the message
/// - annotated_object_id: Oid of the git object being annotated
/// - payload: Payload data passed to `git_note_foreach`
typedef git_note_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<git_oid>,
            ffi.Pointer<ffi.Void>)>>;

/// Flags controlling the behavior of ODB lookup operations
abstract class git_odb_lookup_flags_t {
  /// Don't call `git_odb_refresh` if the lookup fails. Useful when doing
  /// a batch of lookup operations for objects that may legitimately not
  /// exist. When using this flag, you may wish to manually call
  /// `git_odb_refresh` before processing a batch of objects.
  static const int GIT_ODB_LOOKUP_NO_REFRESH = 1;
}

/// The information about object IDs to query in `git_odb_expand_ids`,
/// which will be populated upon return.
class git_odb_expand_id extends ffi.Struct {
  /// The object ID to expand
  external git_oid id;

  /// The length of the object ID (in nibbles, or packets of 4 bits; the
  /// number of hex characters)
  @ffi.UnsignedShort()
  external int length;

  /// The (optional) type of the object to search for; leave as `0` or set
  /// to `GIT_OBJECT_ANY` to query for any object matching the ID.
  @ffi.Int32()
  external int type;
}

/// Function type for callbacks from git_odb_foreach.
typedef git_odb_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>)>>;

/// Streaming mode
abstract class git_odb_stream_t {
  static const int GIT_STREAM_RDONLY = 2;
  static const int GIT_STREAM_WRONLY = 4;
  static const int GIT_STREAM_RW = 6;
}

class git_patch extends ffi.Opaque {}

class git_pathspec extends ffi.Opaque {}

class git_pathspec_match_list extends ffi.Opaque {}

/// Options controlling how pathspec match should be executed
abstract class git_pathspec_flag_t {
  static const int GIT_PATHSPEC_DEFAULT = 0;

  /// GIT_PATHSPEC_IGNORE_CASE forces match to ignore case; otherwise
  /// match will use native case sensitivity of platform filesystem
  static const int GIT_PATHSPEC_IGNORE_CASE = 1;

  /// GIT_PATHSPEC_USE_CASE forces case sensitive match; otherwise
  /// match will use native case sensitivity of platform filesystem
  static const int GIT_PATHSPEC_USE_CASE = 2;

  /// GIT_PATHSPEC_NO_GLOB disables glob patterns and just uses simple
  /// string comparison for matching
  static const int GIT_PATHSPEC_NO_GLOB = 4;

  /// GIT_PATHSPEC_NO_MATCH_ERROR means the match functions return error
  /// code GIT_ENOTFOUND if no matches are found; otherwise no matches is
  /// still success (return 0) but `git_pathspec_match_list_entrycount`
  /// will indicate 0 matches.
  static const int GIT_PATHSPEC_NO_MATCH_ERROR = 8;

  /// GIT_PATHSPEC_FIND_FAILURES means that the `git_pathspec_match_list`
  /// should track which patterns matched which files so that at the end of
  /// the match we can identify patterns that did not match any files.
  static const int GIT_PATHSPEC_FIND_FAILURES = 16;

  /// GIT_PATHSPEC_FAILURES_ONLY means that the `git_pathspec_match_list`
  /// does not need to keep the actual matching filenames.  Use this to
  /// just test if there were any matches at all or in combination with
  /// GIT_PATHSPEC_FIND_FAILURES to validate a pathspec.
  static const int GIT_PATHSPEC_FAILURES_ONLY = 32;
}

/// Kinds of reset operation
abstract class git_reset_t {
  /// < Move the head to the given commit
  static const int GIT_RESET_SOFT = 1;

  /// < SOFT plus reset index to the commit
  static const int GIT_RESET_MIXED = 2;

  /// < MIXED plus changes in working tree discarded
  static const int GIT_RESET_HARD = 3;
}

/// Flags to specify the sorting which a revwalk should perform.
abstract class git_sort_t {
  /// Sort the output with the same default method from `git`: reverse
  /// chronological order. This is the default sorting for new walkers.
  static const int GIT_SORT_NONE = 0;

  /// Sort the repository contents in topological order (no parents before
  /// all of its children are shown); this sorting mode can be combined
  /// with time sorting to produce `git`'s `--date-order``.
  static const int GIT_SORT_TOPOLOGICAL = 1;

  /// Sort the repository contents by commit time;
  /// this sorting mode can be combined with
  /// topological sorting.
  static const int GIT_SORT_TIME = 2;

  /// Iterate through the repository contents in reverse
  /// order; this sorting mode can be combined with
  /// any of the above.
  static const int GIT_SORT_REVERSE = 4;
}

/// This is a callback function that user can provide to hide a
/// commit and its parents. If the callback function returns non-zero value,
/// then this commit and its parents will be hidden.
///
/// @param commit_id oid of Commit
/// @param payload User-specified pointer to data to be passed as data payload
/// @return non-zero to hide the commmit and it parent.
typedef git_revwalk_hide_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<git_oid>, ffi.Pointer<ffi.Void>)>>;

/// Callback used to iterate over tag names
///
/// @see git_tag_foreach
///
/// @param name The tag name
/// @param oid The tag's OID
/// @param payload Payload passed to git_tag_foreach
/// @return non-zero to terminate the iteration
typedef git_tag_foreach_cb = ffi.Pointer<
    ffi.NativeFunction<
        ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<git_oid>,
            ffi.Pointer<ffi.Void>)>>;

const int _TIME_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __TIMESIZE = 64;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_60559_BFP__ = 201404;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_IEC_60559_COMPLEX__ = 201404;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 35;

const int _SYS_CDEFS_H = 1;

const int __THROW = 1;

const int __THROWNL = 1;

const int __glibc_c99_flexarr_available = 1;

const int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int NULL = 0;

const int _BITS_TIME_H = 1;

const int _BITS_TYPES_H = 1;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int CLOCKS_PER_SEC = 1000000;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 1;

const int CLOCK_PROCESS_CPUTIME_ID = 2;

const int CLOCK_THREAD_CPUTIME_ID = 3;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_REALTIME_COARSE = 5;

const int CLOCK_MONOTONIC_COARSE = 6;

const int CLOCK_BOOTTIME = 7;

const int CLOCK_REALTIME_ALARM = 8;

const int CLOCK_BOOTTIME_ALARM = 9;

const int CLOCK_TAI = 11;

const int TIMER_ABSTIME = 1;

const int __clock_t_defined = 1;

const int __time_t_defined = 1;

const int __struct_tm_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int __clockid_t_defined = 1;

const int __timer_t_defined = 1;

const int __itimerspec_defined = 1;

const int _BITS_TYPES_LOCALE_T_H = 1;

const int _BITS_TYPES___LOCALE_T_H = 1;

const int TIME_UTC = 1;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _SYS_TYPES_H = 1;

const int _BITS_STDINT_INTN_H = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int _ALLOCA_H = 1;

const int _INTTYPES_H = 1;

const int _STDINT_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_UINTN_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int ____gwchar_t_defined = 1;

const String __PRI64_PREFIX = 'l';

const String __PRIPTR_PREFIX = 'l';

const String PRId8 = 'd';

const String PRId16 = 'd';

const String PRId32 = 'd';

const String PRId64 = 'ld';

const String PRIdLEAST8 = 'd';

const String PRIdLEAST16 = 'd';

const String PRIdLEAST32 = 'd';

const String PRIdLEAST64 = 'ld';

const String PRIdFAST8 = 'd';

const String PRIdFAST16 = 'ld';

const String PRIdFAST32 = 'ld';

const String PRIdFAST64 = 'ld';

const String PRIi8 = 'i';

const String PRIi16 = 'i';

const String PRIi32 = 'i';

const String PRIi64 = 'li';

const String PRIiLEAST8 = 'i';

const String PRIiLEAST16 = 'i';

const String PRIiLEAST32 = 'i';

const String PRIiLEAST64 = 'li';

const String PRIiFAST8 = 'i';

const String PRIiFAST16 = 'li';

const String PRIiFAST32 = 'li';

const String PRIiFAST64 = 'li';

const String PRIo8 = 'o';

const String PRIo16 = 'o';

const String PRIo32 = 'o';

const String PRIo64 = 'lo';

const String PRIoLEAST8 = 'o';

const String PRIoLEAST16 = 'o';

const String PRIoLEAST32 = 'o';

const String PRIoLEAST64 = 'lo';

const String PRIoFAST8 = 'o';

const String PRIoFAST16 = 'lo';

const String PRIoFAST32 = 'lo';

const String PRIoFAST64 = 'lo';

const String PRIu8 = 'u';

const String PRIu16 = 'u';

const String PRIu32 = 'u';

const String PRIu64 = 'lu';

const String PRIuLEAST8 = 'u';

const String PRIuLEAST16 = 'u';

const String PRIuLEAST32 = 'u';

const String PRIuLEAST64 = 'lu';

const String PRIuFAST8 = 'u';

const String PRIuFAST16 = 'lu';

const String PRIuFAST32 = 'lu';

const String PRIuFAST64 = 'lu';

const String PRIx8 = 'x';

const String PRIx16 = 'x';

const String PRIx32 = 'x';

const String PRIx64 = 'lx';

const String PRIxLEAST8 = 'x';

const String PRIxLEAST16 = 'x';

const String PRIxLEAST32 = 'x';

const String PRIxLEAST64 = 'lx';

const String PRIxFAST8 = 'x';

const String PRIxFAST16 = 'lx';

const String PRIxFAST32 = 'lx';

const String PRIxFAST64 = 'lx';

const String PRIX8 = 'X';

const String PRIX16 = 'X';

const String PRIX32 = 'X';

const String PRIX64 = 'lX';

const String PRIXLEAST8 = 'X';

const String PRIXLEAST16 = 'X';

const String PRIXLEAST32 = 'X';

const String PRIXLEAST64 = 'lX';

const String PRIXFAST8 = 'X';

const String PRIXFAST16 = 'lX';

const String PRIXFAST32 = 'lX';

const String PRIXFAST64 = 'lX';

const String PRIdMAX = 'ld';

const String PRIiMAX = 'li';

const String PRIoMAX = 'lo';

const String PRIuMAX = 'lu';

const String PRIxMAX = 'lx';

const String PRIXMAX = 'lX';

const String PRIdPTR = 'ld';

const String PRIiPTR = 'li';

const String PRIoPTR = 'lo';

const String PRIuPTR = 'lu';

const String PRIxPTR = 'lx';

const String PRIXPTR = 'lX';

const String SCNd8 = 'hhd';

const String SCNd16 = 'hd';

const String SCNd32 = 'd';

const String SCNd64 = 'ld';

const String SCNdLEAST8 = 'hhd';

const String SCNdLEAST16 = 'hd';

const String SCNdLEAST32 = 'd';

const String SCNdLEAST64 = 'ld';

const String SCNdFAST8 = 'hhd';

const String SCNdFAST16 = 'ld';

const String SCNdFAST32 = 'ld';

const String SCNdFAST64 = 'ld';

const String SCNi8 = 'hhi';

const String SCNi16 = 'hi';

const String SCNi32 = 'i';

const String SCNi64 = 'li';

const String SCNiLEAST8 = 'hhi';

const String SCNiLEAST16 = 'hi';

const String SCNiLEAST32 = 'i';

const String SCNiLEAST64 = 'li';

const String SCNiFAST8 = 'hhi';

const String SCNiFAST16 = 'li';

const String SCNiFAST32 = 'li';

const String SCNiFAST64 = 'li';

const String SCNu8 = 'hhu';

const String SCNu16 = 'hu';

const String SCNu32 = 'u';

const String SCNu64 = 'lu';

const String SCNuLEAST8 = 'hhu';

const String SCNuLEAST16 = 'hu';

const String SCNuLEAST32 = 'u';

const String SCNuLEAST64 = 'lu';

const String SCNuFAST8 = 'hhu';

const String SCNuFAST16 = 'lu';

const String SCNuFAST32 = 'lu';

const String SCNuFAST64 = 'lu';

const String SCNo8 = 'hho';

const String SCNo16 = 'ho';

const String SCNo32 = 'o';

const String SCNo64 = 'lo';

const String SCNoLEAST8 = 'hho';

const String SCNoLEAST16 = 'ho';

const String SCNoLEAST32 = 'o';

const String SCNoLEAST64 = 'lo';

const String SCNoFAST8 = 'hho';

const String SCNoFAST16 = 'lo';

const String SCNoFAST32 = 'lo';

const String SCNoFAST64 = 'lo';

const String SCNx8 = 'hhx';

const String SCNx16 = 'hx';

const String SCNx32 = 'x';

const String SCNx64 = 'lx';

const String SCNxLEAST8 = 'hhx';

const String SCNxLEAST16 = 'hx';

const String SCNxLEAST32 = 'x';

const String SCNxLEAST64 = 'lx';

const String SCNxFAST8 = 'hhx';

const String SCNxFAST16 = 'lx';

const String SCNxFAST32 = 'lx';

const String SCNxFAST64 = 'lx';

const String SCNdMAX = 'ld';

const String SCNiMAX = 'li';

const String SCNoMAX = 'lo';

const String SCNuMAX = 'lu';

const String SCNxMAX = 'lx';

const String SCNdPTR = 'ld';

const String SCNiPTR = 'li';

const String SCNoPTR = 'lo';

const String SCNuPTR = 'lu';

const String SCNxPTR = 'lx';

const int GIT_PATH_LIST_SEPARATOR = 58;

const int GIT_PATH_MAX = 4096;

const String GIT_OID_HEX_ZERO = '0000000000000000000000000000000000000000';

const int GIT_OID_RAWSZ = 20;

const int GIT_OID_HEXSZ = 40;

const int GIT_OID_MINPREFIXLEN = 4;

const int GIT_REPOSITORY_INIT_OPTIONS_VERSION = 1;

const int GIT_OBJECT_SIZE_MAX = -1;

const int GIT_DIFF_OPTIONS_VERSION = 1;

const int GIT_DIFF_HUNK_HEADER_SIZE = 128;

const int GIT_DIFF_FIND_OPTIONS_VERSION = 1;

const int GIT_DIFF_PATCHID_OPTIONS_VERSION = 1;

const int GIT_APPLY_OPTIONS_VERSION = 1;

const int GIT_ATTR_CHECK_FILE_THEN_INDEX = 0;

const int GIT_ATTR_CHECK_INDEX_THEN_FILE = 1;

const int GIT_ATTR_CHECK_INDEX_ONLY = 2;

const int GIT_ATTR_CHECK_NO_SYSTEM = 4;

const int GIT_ATTR_CHECK_INCLUDE_HEAD = 8;

const int GIT_ATTR_CHECK_INCLUDE_COMMIT = 16;

const int GIT_ATTR_OPTIONS_VERSION = 1;

const int GIT_BLOB_FILTER_OPTIONS_VERSION = 1;

const int GIT_BLAME_OPTIONS_VERSION = 1;

const int GIT_CHECKOUT_OPTIONS_VERSION = 1;

const int GIT_INDEXER_OPTIONS_VERSION = 1;

const int GIT_INDEX_ENTRY_NAMEMASK = 4095;

const int GIT_INDEX_ENTRY_STAGEMASK = 12288;

const int GIT_INDEX_ENTRY_STAGESHIFT = 12;

const int GIT_MERGE_FILE_INPUT_VERSION = 1;

const int GIT_MERGE_CONFLICT_MARKER_SIZE = 7;

const int GIT_MERGE_FILE_OPTIONS_VERSION = 1;

const int GIT_MERGE_OPTIONS_VERSION = 1;

const int GIT_CHERRYPICK_OPTIONS_VERSION = 1;

const String GIT_DEFAULT_PORT = '9418';

const int GIT_PROXY_OPTIONS_VERSION = 1;

const int GIT_REMOTE_CREATE_OPTIONS_VERSION = 1;

const int GIT_REMOTE_CALLBACKS_VERSION = 1;

const int GIT_FETCH_OPTIONS_VERSION = 1;

const int GIT_PUSH_OPTIONS_VERSION = 1;

const int GIT_REMOTE_CONNECT_OPTIONS_VERSION = 1;

const int GIT_CLONE_OPTIONS_VERSION = 1;

const int GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS = 10;

const int GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE = 7;

const int GIT_DESCRIBE_OPTIONS_VERSION = 1;

const int GIT_DESCRIBE_FORMAT_OPTIONS_VERSION = 1;

const int GIT_FILTER_OPTIONS_VERSION = 1;

const int GIT_REBASE_OPTIONS_VERSION = 1;

const int GIT_REBASE_NO_OPERATION = -1;

const int GIT_REVERT_OPTIONS_VERSION = 1;

const int GIT_STASH_APPLY_OPTIONS_VERSION = 1;

const int GIT_STATUS_OPT_DEFAULTS = 19;

const int GIT_STATUS_OPTIONS_VERSION = 1;

const int GIT_SUBMODULE_STATUS__IN_FLAGS = 15;

const int GIT_SUBMODULE_STATUS__INDEX_FLAGS = 112;

const int GIT_SUBMODULE_STATUS__WD_FLAGS = 16256;

const int GIT_SUBMODULE_UPDATE_OPTIONS_VERSION = 1;

const int GIT_WORKTREE_ADD_OPTIONS_VERSION = 1;

const int GIT_WORKTREE_PRUNE_OPTIONS_VERSION = 1;

const int GIT_ATTR_UNSPECIFIED_T = 0;

const int GIT_ATTR_TRUE_T = 1;

const int GIT_ATTR_FALSE_T = 2;

const int GIT_ATTR_VALUE_T = 3;

const int GIT_BLOB_FILTER_ATTTRIBUTES_FROM_HEAD = 4;

const int GIT_CVAR_FALSE = 0;

const int GIT_CVAR_TRUE = 1;

const int GIT_CVAR_INT32 = 2;

const int GIT_CVAR_STRING = 3;

const int GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION = 1;

const int GITERR_NONE = 0;

const int GITERR_NOMEMORY = 1;

const int GITERR_OS = 2;

const int GITERR_INVALID = 3;

const int GITERR_REFERENCE = 4;

const int GITERR_ZLIB = 5;

const int GITERR_REPOSITORY = 6;

const int GITERR_CONFIG = 7;

const int GITERR_REGEX = 8;

const int GITERR_ODB = 9;

const int GITERR_INDEX = 10;

const int GITERR_OBJECT = 11;

const int GITERR_NET = 12;

const int GITERR_TAG = 13;

const int GITERR_TREE = 14;

const int GITERR_INDEXER = 15;

const int GITERR_SSL = 16;

const int GITERR_SUBMODULE = 17;

const int GITERR_THREAD = 18;

const int GITERR_STASH = 19;

const int GITERR_CHECKOUT = 20;

const int GITERR_FETCHHEAD = 21;

const int GITERR_MERGE = 22;

const int GITERR_SSH = 23;

const int GITERR_FILTER = 24;

const int GITERR_REVERT = 25;

const int GITERR_CALLBACK = 26;

const int GITERR_CHERRYPICK = 27;

const int GITERR_DESCRIBE = 28;

const int GITERR_REBASE = 29;

const int GITERR_FILESYSTEM = 30;

const int GITERR_PATCH = 31;

const int GITERR_WORKTREE = 32;

const int GITERR_SHA1 = 33;

const int GIT_ERROR_SHA1 = 33;

const int GIT_IDXENTRY_NAMEMASK = 4095;

const int GIT_IDXENTRY_STAGEMASK = 12288;

const int GIT_IDXENTRY_STAGESHIFT = 12;

const int GIT_IDXENTRY_EXTENDED = 16384;

const int GIT_IDXENTRY_VALID = 32768;

const int GIT_IDXENTRY_INTENT_TO_ADD = 8192;

const int GIT_IDXENTRY_SKIP_WORKTREE = 16384;

const int GIT_IDXENTRY_EXTENDED_FLAGS = 24576;

const int GIT_IDXENTRY_EXTENDED2 = 32768;

const int GIT_IDXENTRY_UPDATE = 1;

const int GIT_IDXENTRY_REMOVE = 2;

const int GIT_IDXENTRY_UPTODATE = 4;

const int GIT_IDXENTRY_ADDED = 8;

const int GIT_IDXENTRY_HASHED = 16;

const int GIT_IDXENTRY_UNHASHED = 32;

const int GIT_IDXENTRY_WT_REMOVE = 64;

const int GIT_IDXENTRY_CONFLICTED = 128;

const int GIT_IDXENTRY_UNPACKED = 256;

const int GIT_IDXENTRY_NEW_SKIP_WORKTREE = 512;

const int GIT_INDEXCAP_IGNORE_CASE = 1;

const int GIT_INDEXCAP_NO_FILEMODE = 2;

const int GIT_INDEXCAP_NO_SYMLINKS = 4;

const int GIT_INDEXCAP_FROM_OWNER = -1;

const int GIT_OBJ_ANY = -2;

const int GIT_OBJ_BAD = -1;

const int GIT_OBJ__EXT1 = 0;

const int GIT_OBJ_COMMIT = 1;

const int GIT_OBJ_TREE = 2;

const int GIT_OBJ_BLOB = 3;

const int GIT_OBJ_TAG = 4;

const int GIT_OBJ__EXT2 = 5;

const int GIT_OBJ_OFS_DELTA = 6;

const int GIT_OBJ_REF_DELTA = 7;

const int GIT_REF_INVALID = 0;

const int GIT_REF_OID = 1;

const int GIT_REF_SYMBOLIC = 2;

const int GIT_REF_LISTALL = 3;

const int GIT_REF_FORMAT_NORMAL = 0;

const int GIT_REF_FORMAT_ALLOW_ONELEVEL = 1;

const int GIT_REF_FORMAT_REFSPEC_PATTERN = 2;

const int GIT_REF_FORMAT_REFSPEC_SHORTHAND = 4;

const int GIT_REVPARSE_SINGLE = 1;

const int GIT_REVPARSE_RANGE = 2;

const int GIT_REVPARSE_MERGE_BASE = 4;

const int GIT_CREDTYPE_USERPASS_PLAINTEXT = 1;

const int GIT_CREDTYPE_SSH_KEY = 2;

const int GIT_CREDTYPE_SSH_CUSTOM = 4;

const int GIT_CREDTYPE_DEFAULT = 8;

const int GIT_CREDTYPE_SSH_INTERACTIVE = 16;

const int GIT_CREDTYPE_USERNAME = 32;

const int GIT_CREDTYPE_SSH_MEMORY = 64;

const int GIT_EMAIL_CREATE_OPTIONS_VERSION = 1;

const String LIBGIT2_VERSION = '1.5.0';

const int LIBGIT2_VER_MAJOR = 1;

const int LIBGIT2_VER_MINOR = 5;

const int LIBGIT2_VER_REVISION = 0;

const int LIBGIT2_VER_PATCH = 0;

const int LIBGIT2_VER_PRERELEASE = 0;

const String LIBGIT2_SOVERSION = '1.5';
