// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Bindings to libgit2
class Libgit2 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  Libgit2(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  Libgit2.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int clock() {
    return _clock();
  }

  late final _clock_ptr = _lookup<ffi.NativeFunction<_c_clock>>('clock');
  late final _dart_clock _clock = _clock_ptr.asFunction<_dart_clock>();

  int time(
    ffi.Pointer<ffi.Int64> __timer,
  ) {
    return _time(
      __timer,
    );
  }

  late final _time_ptr = _lookup<ffi.NativeFunction<_c_time>>('time');
  late final _dart_time _time = _time_ptr.asFunction<_dart_time>();

  double difftime(
    int __time1,
    int __time0,
  ) {
    return _difftime(
      __time1,
      __time0,
    );
  }

  late final _difftime_ptr =
      _lookup<ffi.NativeFunction<_c_difftime>>('difftime');
  late final _dart_difftime _difftime =
      _difftime_ptr.asFunction<_dart_difftime>();

  int mktime(
    ffi.Pointer<tm> __tp,
  ) {
    return _mktime(
      __tp,
    );
  }

  late final _mktime_ptr = _lookup<ffi.NativeFunction<_c_mktime>>('mktime');
  late final _dart_mktime _mktime = _mktime_ptr.asFunction<_dart_mktime>();

  int strftime(
    ffi.Pointer<ffi.Int8> __s,
    int __maxsize,
    ffi.Pointer<ffi.Int8> __format,
    ffi.Pointer<tm> __tp,
  ) {
    return _strftime(
      __s,
      __maxsize,
      __format,
      __tp,
    );
  }

  late final _strftime_ptr =
      _lookup<ffi.NativeFunction<_c_strftime>>('strftime');
  late final _dart_strftime _strftime =
      _strftime_ptr.asFunction<_dart_strftime>();

  int strftime_l(
    ffi.Pointer<ffi.Int8> __s,
    int __maxsize,
    ffi.Pointer<ffi.Int8> __format,
    ffi.Pointer<tm> __tp,
    ffi.Pointer<__locale_struct> __loc,
  ) {
    return _strftime_l(
      __s,
      __maxsize,
      __format,
      __tp,
      __loc,
    );
  }

  late final _strftime_l_ptr =
      _lookup<ffi.NativeFunction<_c_strftime_l>>('strftime_l');
  late final _dart_strftime_l _strftime_l =
      _strftime_l_ptr.asFunction<_dart_strftime_l>();

  ffi.Pointer<tm> gmtime(
    ffi.Pointer<ffi.Int64> __timer,
  ) {
    return _gmtime(
      __timer,
    );
  }

  late final _gmtime_ptr = _lookup<ffi.NativeFunction<_c_gmtime>>('gmtime');
  late final _dart_gmtime _gmtime = _gmtime_ptr.asFunction<_dart_gmtime>();

  ffi.Pointer<tm> localtime(
    ffi.Pointer<ffi.Int64> __timer,
  ) {
    return _localtime(
      __timer,
    );
  }

  late final _localtime_ptr =
      _lookup<ffi.NativeFunction<_c_localtime>>('localtime');
  late final _dart_localtime _localtime =
      _localtime_ptr.asFunction<_dart_localtime>();

  ffi.Pointer<tm> gmtime_r(
    ffi.Pointer<ffi.Int64> __timer,
    ffi.Pointer<tm> __tp,
  ) {
    return _gmtime_r(
      __timer,
      __tp,
    );
  }

  late final _gmtime_r_ptr =
      _lookup<ffi.NativeFunction<_c_gmtime_r>>('gmtime_r');
  late final _dart_gmtime_r _gmtime_r =
      _gmtime_r_ptr.asFunction<_dart_gmtime_r>();

  ffi.Pointer<tm> localtime_r(
    ffi.Pointer<ffi.Int64> __timer,
    ffi.Pointer<tm> __tp,
  ) {
    return _localtime_r(
      __timer,
      __tp,
    );
  }

  late final _localtime_r_ptr =
      _lookup<ffi.NativeFunction<_c_localtime_r>>('localtime_r');
  late final _dart_localtime_r _localtime_r =
      _localtime_r_ptr.asFunction<_dart_localtime_r>();

  ffi.Pointer<ffi.Int8> asctime(
    ffi.Pointer<tm> __tp,
  ) {
    return _asctime(
      __tp,
    );
  }

  late final _asctime_ptr = _lookup<ffi.NativeFunction<_c_asctime>>('asctime');
  late final _dart_asctime _asctime = _asctime_ptr.asFunction<_dart_asctime>();

  ffi.Pointer<ffi.Int8> ctime(
    ffi.Pointer<ffi.Int64> __timer,
  ) {
    return _ctime(
      __timer,
    );
  }

  late final _ctime_ptr = _lookup<ffi.NativeFunction<_c_ctime>>('ctime');
  late final _dart_ctime _ctime = _ctime_ptr.asFunction<_dart_ctime>();

  ffi.Pointer<ffi.Int8> asctime_r(
    ffi.Pointer<tm> __tp,
    ffi.Pointer<ffi.Int8> __buf,
  ) {
    return _asctime_r(
      __tp,
      __buf,
    );
  }

  late final _asctime_r_ptr =
      _lookup<ffi.NativeFunction<_c_asctime_r>>('asctime_r');
  late final _dart_asctime_r _asctime_r =
      _asctime_r_ptr.asFunction<_dart_asctime_r>();

  ffi.Pointer<ffi.Int8> ctime_r(
    ffi.Pointer<ffi.Int64> __timer,
    ffi.Pointer<ffi.Int8> __buf,
  ) {
    return _ctime_r(
      __timer,
      __buf,
    );
  }

  late final _ctime_r_ptr = _lookup<ffi.NativeFunction<_c_ctime_r>>('ctime_r');
  late final _dart_ctime_r _ctime_r = _ctime_r_ptr.asFunction<_dart_ctime_r>();

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> ___tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Int8>>>('__tzname');

  ffi.Pointer<ffi.Pointer<ffi.Int8>> get __tzname => ___tzname.value;

  set __tzname(ffi.Pointer<ffi.Pointer<ffi.Int8>> value) =>
      ___tzname.value = value;

  late final ffi.Pointer<ffi.Int32> ___daylight =
      _lookup<ffi.Int32>('__daylight');

  int get __daylight => ___daylight.value;

  set __daylight(int value) => ___daylight.value = value;

  late final ffi.Pointer<ffi.Int64> ___timezone =
      _lookup<ffi.Int64>('__timezone');

  int get __timezone => ___timezone.value;

  set __timezone(int value) => ___timezone.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Int8>>> _tzname =
      _lookup<ffi.Pointer<ffi.Pointer<ffi.Int8>>>('tzname');

  ffi.Pointer<ffi.Pointer<ffi.Int8>> get tzname => _tzname.value;

  set tzname(ffi.Pointer<ffi.Pointer<ffi.Int8>> value) => _tzname.value = value;

  void tzset() {
    return _tzset();
  }

  late final _tzset_ptr = _lookup<ffi.NativeFunction<_c_tzset>>('tzset');
  late final _dart_tzset _tzset = _tzset_ptr.asFunction<_dart_tzset>();

  late final ffi.Pointer<ffi.Int32> _daylight = _lookup<ffi.Int32>('daylight');

  int get daylight => _daylight.value;

  set daylight(int value) => _daylight.value = value;

  late final ffi.Pointer<ffi.Int64> _timezone = _lookup<ffi.Int64>('timezone');

  int get timezone => _timezone.value;

  set timezone(int value) => _timezone.value = value;

  int timegm(
    ffi.Pointer<tm> __tp,
  ) {
    return _timegm(
      __tp,
    );
  }

  late final _timegm_ptr = _lookup<ffi.NativeFunction<_c_timegm>>('timegm');
  late final _dart_timegm _timegm = _timegm_ptr.asFunction<_dart_timegm>();

  int timelocal(
    ffi.Pointer<tm> __tp,
  ) {
    return _timelocal(
      __tp,
    );
  }

  late final _timelocal_ptr =
      _lookup<ffi.NativeFunction<_c_timelocal>>('timelocal');
  late final _dart_timelocal _timelocal =
      _timelocal_ptr.asFunction<_dart_timelocal>();

  int dysize(
    int __year,
  ) {
    return _dysize(
      __year,
    );
  }

  late final _dysize_ptr = _lookup<ffi.NativeFunction<_c_dysize>>('dysize');
  late final _dart_dysize _dysize = _dysize_ptr.asFunction<_dart_dysize>();

  int nanosleep(
    ffi.Pointer<timespec> __requested_time,
    ffi.Pointer<timespec> __remaining,
  ) {
    return _nanosleep(
      __requested_time,
      __remaining,
    );
  }

  late final _nanosleep_ptr =
      _lookup<ffi.NativeFunction<_c_nanosleep>>('nanosleep');
  late final _dart_nanosleep _nanosleep =
      _nanosleep_ptr.asFunction<_dart_nanosleep>();

  int clock_getres(
    int __clock_id,
    ffi.Pointer<timespec> __res,
  ) {
    return _clock_getres(
      __clock_id,
      __res,
    );
  }

  late final _clock_getres_ptr =
      _lookup<ffi.NativeFunction<_c_clock_getres>>('clock_getres');
  late final _dart_clock_getres _clock_getres =
      _clock_getres_ptr.asFunction<_dart_clock_getres>();

  int clock_gettime(
    int __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_gettime(
      __clock_id,
      __tp,
    );
  }

  late final _clock_gettime_ptr =
      _lookup<ffi.NativeFunction<_c_clock_gettime>>('clock_gettime');
  late final _dart_clock_gettime _clock_gettime =
      _clock_gettime_ptr.asFunction<_dart_clock_gettime>();

  int clock_settime(
    int __clock_id,
    ffi.Pointer<timespec> __tp,
  ) {
    return _clock_settime(
      __clock_id,
      __tp,
    );
  }

  late final _clock_settime_ptr =
      _lookup<ffi.NativeFunction<_c_clock_settime>>('clock_settime');
  late final _dart_clock_settime _clock_settime =
      _clock_settime_ptr.asFunction<_dart_clock_settime>();

  int clock_nanosleep(
    int __clock_id,
    int __flags,
    ffi.Pointer<timespec> __req,
    ffi.Pointer<timespec> __rem,
  ) {
    return _clock_nanosleep(
      __clock_id,
      __flags,
      __req,
      __rem,
    );
  }

  late final _clock_nanosleep_ptr =
      _lookup<ffi.NativeFunction<_c_clock_nanosleep>>('clock_nanosleep');
  late final _dart_clock_nanosleep _clock_nanosleep =
      _clock_nanosleep_ptr.asFunction<_dart_clock_nanosleep>();

  int clock_getcpuclockid(
    int __pid,
    ffi.Pointer<ffi.Int32> __clock_id,
  ) {
    return _clock_getcpuclockid(
      __pid,
      __clock_id,
    );
  }

  late final _clock_getcpuclockid_ptr =
      _lookup<ffi.NativeFunction<_c_clock_getcpuclockid>>(
          'clock_getcpuclockid');
  late final _dart_clock_getcpuclockid _clock_getcpuclockid =
      _clock_getcpuclockid_ptr.asFunction<_dart_clock_getcpuclockid>();

  int timer_create(
    int __clock_id,
    ffi.Pointer<sigevent> __evp,
    ffi.Pointer<ffi.Pointer<ffi.Void>> __timerid,
  ) {
    return _timer_create(
      __clock_id,
      __evp,
      __timerid,
    );
  }

  late final _timer_create_ptr =
      _lookup<ffi.NativeFunction<_c_timer_create>>('timer_create');
  late final _dart_timer_create _timer_create =
      _timer_create_ptr.asFunction<_dart_timer_create>();

  int timer_delete(
    ffi.Pointer<ffi.Void> __timerid,
  ) {
    return _timer_delete(
      __timerid,
    );
  }

  late final _timer_delete_ptr =
      _lookup<ffi.NativeFunction<_c_timer_delete>>('timer_delete');
  late final _dart_timer_delete _timer_delete =
      _timer_delete_ptr.asFunction<_dart_timer_delete>();

  int timer_settime(
    ffi.Pointer<ffi.Void> __timerid,
    int __flags,
    ffi.Pointer<itimerspec> __value,
    ffi.Pointer<itimerspec> __ovalue,
  ) {
    return _timer_settime(
      __timerid,
      __flags,
      __value,
      __ovalue,
    );
  }

  late final _timer_settime_ptr =
      _lookup<ffi.NativeFunction<_c_timer_settime>>('timer_settime');
  late final _dart_timer_settime _timer_settime =
      _timer_settime_ptr.asFunction<_dart_timer_settime>();

  int timer_gettime(
    ffi.Pointer<ffi.Void> __timerid,
    ffi.Pointer<itimerspec> __value,
  ) {
    return _timer_gettime(
      __timerid,
      __value,
    );
  }

  late final _timer_gettime_ptr =
      _lookup<ffi.NativeFunction<_c_timer_gettime>>('timer_gettime');
  late final _dart_timer_gettime _timer_gettime =
      _timer_gettime_ptr.asFunction<_dart_timer_gettime>();

  int timer_getoverrun(
    ffi.Pointer<ffi.Void> __timerid,
  ) {
    return _timer_getoverrun(
      __timerid,
    );
  }

  late final _timer_getoverrun_ptr =
      _lookup<ffi.NativeFunction<_c_timer_getoverrun>>('timer_getoverrun');
  late final _dart_timer_getoverrun _timer_getoverrun =
      _timer_getoverrun_ptr.asFunction<_dart_timer_getoverrun>();

  int timespec_get(
    ffi.Pointer<timespec> __ts,
    int __base,
  ) {
    return _timespec_get(
      __ts,
      __base,
    );
  }

  late final _timespec_get_ptr =
      _lookup<ffi.NativeFunction<_c_timespec_get>>('timespec_get');
  late final _dart_timespec_get _timespec_get =
      _timespec_get_ptr.asFunction<_dart_timespec_get>();

  int __ctype_get_mb_cur_max() {
    return ___ctype_get_mb_cur_max();
  }

  late final ___ctype_get_mb_cur_max_ptr =
      _lookup<ffi.NativeFunction<_c___ctype_get_mb_cur_max>>(
          '__ctype_get_mb_cur_max');
  late final _dart___ctype_get_mb_cur_max ___ctype_get_mb_cur_max =
      ___ctype_get_mb_cur_max_ptr.asFunction<_dart___ctype_get_mb_cur_max>();

  double atof(
    ffi.Pointer<ffi.Int8> __nptr,
  ) {
    return _atof(
      __nptr,
    );
  }

  late final _atof_ptr = _lookup<ffi.NativeFunction<_c_atof>>('atof');
  late final _dart_atof _atof = _atof_ptr.asFunction<_dart_atof>();

  int atoi(
    ffi.Pointer<ffi.Int8> __nptr,
  ) {
    return _atoi(
      __nptr,
    );
  }

  late final _atoi_ptr = _lookup<ffi.NativeFunction<_c_atoi>>('atoi');
  late final _dart_atoi _atoi = _atoi_ptr.asFunction<_dart_atoi>();

  int atol(
    ffi.Pointer<ffi.Int8> __nptr,
  ) {
    return _atol(
      __nptr,
    );
  }

  late final _atol_ptr = _lookup<ffi.NativeFunction<_c_atol>>('atol');
  late final _dart_atol _atol = _atol_ptr.asFunction<_dart_atol>();

  int atoll(
    ffi.Pointer<ffi.Int8> __nptr,
  ) {
    return _atoll(
      __nptr,
    );
  }

  late final _atoll_ptr = _lookup<ffi.NativeFunction<_c_atoll>>('atoll');
  late final _dart_atoll _atoll = _atoll_ptr.asFunction<_dart_atoll>();

  double strtod(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ) {
    return _strtod(
      __nptr,
      __endptr,
    );
  }

  late final _strtod_ptr = _lookup<ffi.NativeFunction<_c_strtod>>('strtod');
  late final _dart_strtod _strtod = _strtod_ptr.asFunction<_dart_strtod>();

  double strtof(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ) {
    return _strtof(
      __nptr,
      __endptr,
    );
  }

  late final _strtof_ptr = _lookup<ffi.NativeFunction<_c_strtof>>('strtof');
  late final _dart_strtof _strtof = _strtof_ptr.asFunction<_dart_strtof>();

  int strtol(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtol(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtol_ptr = _lookup<ffi.NativeFunction<_c_strtol>>('strtol');
  late final _dart_strtol _strtol = _strtol_ptr.asFunction<_dart_strtol>();

  int strtoul(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoul_ptr = _lookup<ffi.NativeFunction<_c_strtoul>>('strtoul');
  late final _dart_strtoul _strtoul = _strtoul_ptr.asFunction<_dart_strtoul>();

  int strtoq(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoq_ptr = _lookup<ffi.NativeFunction<_c_strtoq>>('strtoq');
  late final _dart_strtoq _strtoq = _strtoq_ptr.asFunction<_dart_strtoq>();

  int strtouq(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtouq_ptr = _lookup<ffi.NativeFunction<_c_strtouq>>('strtouq');
  late final _dart_strtouq _strtouq = _strtouq_ptr.asFunction<_dart_strtouq>();

  int strtoll(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoll_ptr = _lookup<ffi.NativeFunction<_c_strtoll>>('strtoll');
  late final _dart_strtoll _strtoll = _strtoll_ptr.asFunction<_dart_strtoll>();

  int strtoull(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoull_ptr =
      _lookup<ffi.NativeFunction<_c_strtoull>>('strtoull');
  late final _dart_strtoull _strtoull =
      _strtoull_ptr.asFunction<_dart_strtoull>();

  ffi.Pointer<ffi.Int8> l64a(
    int __n,
  ) {
    return _l64a(
      __n,
    );
  }

  late final _l64a_ptr = _lookup<ffi.NativeFunction<_c_l64a>>('l64a');
  late final _dart_l64a _l64a = _l64a_ptr.asFunction<_dart_l64a>();

  int a64l(
    ffi.Pointer<ffi.Int8> __s,
  ) {
    return _a64l(
      __s,
    );
  }

  late final _a64l_ptr = _lookup<ffi.NativeFunction<_c_a64l>>('a64l');
  late final _dart_a64l _a64l = _a64l_ptr.asFunction<_dart_a64l>();

  int select(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timeval> __timeout,
  ) {
    return _select(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
    );
  }

  late final _select_ptr = _lookup<ffi.NativeFunction<_c_select>>('select');
  late final _dart_select _select = _select_ptr.asFunction<_dart_select>();

  int pselect(
    int __nfds,
    ffi.Pointer<fd_set> __readfds,
    ffi.Pointer<fd_set> __writefds,
    ffi.Pointer<fd_set> __exceptfds,
    ffi.Pointer<timespec> __timeout,
    ffi.Pointer<__sigset_t> __sigmask,
  ) {
    return _pselect(
      __nfds,
      __readfds,
      __writefds,
      __exceptfds,
      __timeout,
      __sigmask,
    );
  }

  late final _pselect_ptr = _lookup<ffi.NativeFunction<_c_pselect>>('pselect');
  late final _dart_pselect _pselect = _pselect_ptr.asFunction<_dart_pselect>();

  int random() {
    return _random();
  }

  late final _random_ptr = _lookup<ffi.NativeFunction<_c_random>>('random');
  late final _dart_random _random = _random_ptr.asFunction<_dart_random>();

  void srandom(
    int __seed,
  ) {
    return _srandom(
      __seed,
    );
  }

  late final _srandom_ptr = _lookup<ffi.NativeFunction<_c_srandom>>('srandom');
  late final _dart_srandom _srandom = _srandom_ptr.asFunction<_dart_srandom>();

  ffi.Pointer<ffi.Int8> initstate(
    int __seed,
    ffi.Pointer<ffi.Int8> __statebuf,
    int __statelen,
  ) {
    return _initstate(
      __seed,
      __statebuf,
      __statelen,
    );
  }

  late final _initstate_ptr =
      _lookup<ffi.NativeFunction<_c_initstate>>('initstate');
  late final _dart_initstate _initstate =
      _initstate_ptr.asFunction<_dart_initstate>();

  ffi.Pointer<ffi.Int8> setstate(
    ffi.Pointer<ffi.Int8> __statebuf,
  ) {
    return _setstate(
      __statebuf,
    );
  }

  late final _setstate_ptr =
      _lookup<ffi.NativeFunction<_c_setstate>>('setstate');
  late final _dart_setstate _setstate =
      _setstate_ptr.asFunction<_dart_setstate>();

  int random_r(
    ffi.Pointer<random_data> __buf,
    ffi.Pointer<ffi.Int32> __result,
  ) {
    return _random_r(
      __buf,
      __result,
    );
  }

  late final _random_r_ptr =
      _lookup<ffi.NativeFunction<_c_random_r>>('random_r');
  late final _dart_random_r _random_r =
      _random_r_ptr.asFunction<_dart_random_r>();

  int srandom_r(
    int __seed,
    ffi.Pointer<random_data> __buf,
  ) {
    return _srandom_r(
      __seed,
      __buf,
    );
  }

  late final _srandom_r_ptr =
      _lookup<ffi.NativeFunction<_c_srandom_r>>('srandom_r');
  late final _dart_srandom_r _srandom_r =
      _srandom_r_ptr.asFunction<_dart_srandom_r>();

  int initstate_r(
    int __seed,
    ffi.Pointer<ffi.Int8> __statebuf,
    int __statelen,
    ffi.Pointer<random_data> __buf,
  ) {
    return _initstate_r(
      __seed,
      __statebuf,
      __statelen,
      __buf,
    );
  }

  late final _initstate_r_ptr =
      _lookup<ffi.NativeFunction<_c_initstate_r>>('initstate_r');
  late final _dart_initstate_r _initstate_r =
      _initstate_r_ptr.asFunction<_dart_initstate_r>();

  int setstate_r(
    ffi.Pointer<ffi.Int8> __statebuf,
    ffi.Pointer<random_data> __buf,
  ) {
    return _setstate_r(
      __statebuf,
      __buf,
    );
  }

  late final _setstate_r_ptr =
      _lookup<ffi.NativeFunction<_c_setstate_r>>('setstate_r');
  late final _dart_setstate_r _setstate_r =
      _setstate_r_ptr.asFunction<_dart_setstate_r>();

  int rand() {
    return _rand();
  }

  late final _rand_ptr = _lookup<ffi.NativeFunction<_c_rand>>('rand');
  late final _dart_rand _rand = _rand_ptr.asFunction<_dart_rand>();

  void srand(
    int __seed,
  ) {
    return _srand(
      __seed,
    );
  }

  late final _srand_ptr = _lookup<ffi.NativeFunction<_c_srand>>('srand');
  late final _dart_srand _srand = _srand_ptr.asFunction<_dart_srand>();

  int rand_r(
    ffi.Pointer<ffi.Uint32> __seed,
  ) {
    return _rand_r(
      __seed,
    );
  }

  late final _rand_r_ptr = _lookup<ffi.NativeFunction<_c_rand_r>>('rand_r');
  late final _dart_rand_r _rand_r = _rand_r_ptr.asFunction<_dart_rand_r>();

  double drand48() {
    return _drand48();
  }

  late final _drand48_ptr = _lookup<ffi.NativeFunction<_c_drand48>>('drand48');
  late final _dart_drand48 _drand48 = _drand48_ptr.asFunction<_dart_drand48>();

  double erand48(
    ffi.Pointer<ffi.Uint16> __xsubi,
  ) {
    return _erand48(
      __xsubi,
    );
  }

  late final _erand48_ptr = _lookup<ffi.NativeFunction<_c_erand48>>('erand48');
  late final _dart_erand48 _erand48 = _erand48_ptr.asFunction<_dart_erand48>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48_ptr = _lookup<ffi.NativeFunction<_c_lrand48>>('lrand48');
  late final _dart_lrand48 _lrand48 = _lrand48_ptr.asFunction<_dart_lrand48>();

  int nrand48(
    ffi.Pointer<ffi.Uint16> __xsubi,
  ) {
    return _nrand48(
      __xsubi,
    );
  }

  late final _nrand48_ptr = _lookup<ffi.NativeFunction<_c_nrand48>>('nrand48');
  late final _dart_nrand48 _nrand48 = _nrand48_ptr.asFunction<_dart_nrand48>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48_ptr = _lookup<ffi.NativeFunction<_c_mrand48>>('mrand48');
  late final _dart_mrand48 _mrand48 = _mrand48_ptr.asFunction<_dart_mrand48>();

  int jrand48(
    ffi.Pointer<ffi.Uint16> __xsubi,
  ) {
    return _jrand48(
      __xsubi,
    );
  }

  late final _jrand48_ptr = _lookup<ffi.NativeFunction<_c_jrand48>>('jrand48');
  late final _dart_jrand48 _jrand48 = _jrand48_ptr.asFunction<_dart_jrand48>();

  void srand48(
    int __seedval,
  ) {
    return _srand48(
      __seedval,
    );
  }

  late final _srand48_ptr = _lookup<ffi.NativeFunction<_c_srand48>>('srand48');
  late final _dart_srand48 _srand48 = _srand48_ptr.asFunction<_dart_srand48>();

  ffi.Pointer<ffi.Uint16> seed48(
    ffi.Pointer<ffi.Uint16> __seed16v,
  ) {
    return _seed48(
      __seed16v,
    );
  }

  late final _seed48_ptr = _lookup<ffi.NativeFunction<_c_seed48>>('seed48');
  late final _dart_seed48 _seed48 = _seed48_ptr.asFunction<_dart_seed48>();

  void lcong48(
    ffi.Pointer<ffi.Uint16> __param,
  ) {
    return _lcong48(
      __param,
    );
  }

  late final _lcong48_ptr = _lookup<ffi.NativeFunction<_c_lcong48>>('lcong48');
  late final _dart_lcong48 _lcong48 = _lcong48_ptr.asFunction<_dart_lcong48>();

  int drand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _drand48_r(
      __buffer,
      __result,
    );
  }

  late final _drand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_drand48_r>>('drand48_r');
  late final _dart_drand48_r _drand48_r =
      _drand48_r_ptr.asFunction<_dart_drand48_r>();

  int erand48_r(
    ffi.Pointer<ffi.Uint16> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Double> __result,
  ) {
    return _erand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _erand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_erand48_r>>('erand48_r');
  late final _dart_erand48_r _erand48_r =
      _erand48_r_ptr.asFunction<_dart_erand48_r>();

  int lrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Int64> __result,
  ) {
    return _lrand48_r(
      __buffer,
      __result,
    );
  }

  late final _lrand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_lrand48_r>>('lrand48_r');
  late final _dart_lrand48_r _lrand48_r =
      _lrand48_r_ptr.asFunction<_dart_lrand48_r>();

  int nrand48_r(
    ffi.Pointer<ffi.Uint16> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Int64> __result,
  ) {
    return _nrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _nrand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_nrand48_r>>('nrand48_r');
  late final _dart_nrand48_r _nrand48_r =
      _nrand48_r_ptr.asFunction<_dart_nrand48_r>();

  int mrand48_r(
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Int64> __result,
  ) {
    return _mrand48_r(
      __buffer,
      __result,
    );
  }

  late final _mrand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_mrand48_r>>('mrand48_r');
  late final _dart_mrand48_r _mrand48_r =
      _mrand48_r_ptr.asFunction<_dart_mrand48_r>();

  int jrand48_r(
    ffi.Pointer<ffi.Uint16> __xsubi,
    ffi.Pointer<drand48_data> __buffer,
    ffi.Pointer<ffi.Int64> __result,
  ) {
    return _jrand48_r(
      __xsubi,
      __buffer,
      __result,
    );
  }

  late final _jrand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_jrand48_r>>('jrand48_r');
  late final _dart_jrand48_r _jrand48_r =
      _jrand48_r_ptr.asFunction<_dart_jrand48_r>();

  int srand48_r(
    int __seedval,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _srand48_r(
      __seedval,
      __buffer,
    );
  }

  late final _srand48_r_ptr =
      _lookup<ffi.NativeFunction<_c_srand48_r>>('srand48_r');
  late final _dart_srand48_r _srand48_r =
      _srand48_r_ptr.asFunction<_dart_srand48_r>();

  int seed48_r(
    ffi.Pointer<ffi.Uint16> __seed16v,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _seed48_r(
      __seed16v,
      __buffer,
    );
  }

  late final _seed48_r_ptr =
      _lookup<ffi.NativeFunction<_c_seed48_r>>('seed48_r');
  late final _dart_seed48_r _seed48_r =
      _seed48_r_ptr.asFunction<_dart_seed48_r>();

  int lcong48_r(
    ffi.Pointer<ffi.Uint16> __param,
    ffi.Pointer<drand48_data> __buffer,
  ) {
    return _lcong48_r(
      __param,
      __buffer,
    );
  }

  late final _lcong48_r_ptr =
      _lookup<ffi.NativeFunction<_c_lcong48_r>>('lcong48_r');
  late final _dart_lcong48_r _lcong48_r =
      _lcong48_r_ptr.asFunction<_dart_lcong48_r>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _malloc_ptr = _lookup<ffi.NativeFunction<_c_malloc>>('malloc');
  late final _dart_malloc _malloc = _malloc_ptr.asFunction<_dart_malloc>();

  ffi.Pointer<ffi.Void> calloc(
    int __nmemb,
    int __size,
  ) {
    return _calloc(
      __nmemb,
      __size,
    );
  }

  late final _calloc_ptr = _lookup<ffi.NativeFunction<_c_calloc>>('calloc');
  late final _dart_calloc _calloc = _calloc_ptr.asFunction<_dart_calloc>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _realloc_ptr = _lookup<ffi.NativeFunction<_c_realloc>>('realloc');
  late final _dart_realloc _realloc = _realloc_ptr.asFunction<_dart_realloc>();

  ffi.Pointer<ffi.Void> reallocarray(
    ffi.Pointer<ffi.Void> __ptr,
    int __nmemb,
    int __size,
  ) {
    return _reallocarray(
      __ptr,
      __nmemb,
      __size,
    );
  }

  late final _reallocarray_ptr =
      _lookup<ffi.NativeFunction<_c_reallocarray>>('reallocarray');
  late final _dart_reallocarray _reallocarray =
      _reallocarray_ptr.asFunction<_dart_reallocarray>();

  void free(
    ffi.Pointer<ffi.Void> __ptr,
  ) {
    return _free(
      __ptr,
    );
  }

  late final _free_ptr = _lookup<ffi.NativeFunction<_c_free>>('free');
  late final _dart_free _free = _free_ptr.asFunction<_dart_free>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _alloca_ptr = _lookup<ffi.NativeFunction<_c_alloca>>('alloca');
  late final _dart_alloca _alloca = _alloca_ptr.asFunction<_dart_alloca>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _valloc_ptr = _lookup<ffi.NativeFunction<_c_valloc>>('valloc');
  late final _dart_valloc _valloc = _valloc_ptr.asFunction<_dart_valloc>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalign_ptr =
      _lookup<ffi.NativeFunction<_c_posix_memalign>>('posix_memalign');
  late final _dart_posix_memalign _posix_memalign =
      _posix_memalign_ptr.asFunction<_dart_posix_memalign>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_alloc_ptr =
      _lookup<ffi.NativeFunction<_c_aligned_alloc>>('aligned_alloc');
  late final _dart_aligned_alloc _aligned_alloc =
      _aligned_alloc_ptr.asFunction<_dart_aligned_alloc>();

  void abort() {
    return _abort();
  }

  late final _abort_ptr = _lookup<ffi.NativeFunction<_c_abort>>('abort');
  late final _dart_abort _abort = _abort_ptr.asFunction<_dart_abort>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<_typedefC_1>> __func,
  ) {
    return _atexit(
      __func,
    );
  }

  late final _atexit_ptr = _lookup<ffi.NativeFunction<_c_atexit>>('atexit');
  late final _dart_atexit _atexit = _atexit_ptr.asFunction<_dart_atexit>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<_typedefC_2>> __func,
  ) {
    return _at_quick_exit(
      __func,
    );
  }

  late final _at_quick_exit_ptr =
      _lookup<ffi.NativeFunction<_c_at_quick_exit>>('at_quick_exit');
  late final _dart_at_quick_exit _at_quick_exit =
      _at_quick_exit_ptr.asFunction<_dart_at_quick_exit>();

  int on_exit(
    ffi.Pointer<ffi.NativeFunction<_typedefC_3>> __func,
    ffi.Pointer<ffi.Void> __arg,
  ) {
    return _on_exit(
      __func,
      __arg,
    );
  }

  late final _on_exit_ptr = _lookup<ffi.NativeFunction<_c_on_exit>>('on_exit');
  late final _dart_on_exit _on_exit = _on_exit_ptr.asFunction<_dart_on_exit>();

  void exit(
    int __status,
  ) {
    return _exit(
      __status,
    );
  }

  late final _exit_ptr = _lookup<ffi.NativeFunction<_c_exit>>('exit');
  late final _dart_exit _exit = _exit_ptr.asFunction<_dart_exit>();

  void quick_exit(
    int __status,
  ) {
    return _quick_exit(
      __status,
    );
  }

  late final _quick_exit_ptr =
      _lookup<ffi.NativeFunction<_c_quick_exit>>('quick_exit');
  late final _dart_quick_exit _quick_exit =
      _quick_exit_ptr.asFunction<_dart_quick_exit>();

  void _Exit(
    int __status,
  ) {
    return __Exit(
      __status,
    );
  }

  late final __Exit_ptr = _lookup<ffi.NativeFunction<_c__Exit>>('_Exit');
  late final _dart__Exit __Exit = __Exit_ptr.asFunction<_dart__Exit>();

  ffi.Pointer<ffi.Int8> getenv(
    ffi.Pointer<ffi.Int8> __name,
  ) {
    return _getenv(
      __name,
    );
  }

  late final _getenv_ptr = _lookup<ffi.NativeFunction<_c_getenv>>('getenv');
  late final _dart_getenv _getenv = _getenv_ptr.asFunction<_dart_getenv>();

  int putenv(
    ffi.Pointer<ffi.Int8> __string,
  ) {
    return _putenv(
      __string,
    );
  }

  late final _putenv_ptr = _lookup<ffi.NativeFunction<_c_putenv>>('putenv');
  late final _dart_putenv _putenv = _putenv_ptr.asFunction<_dart_putenv>();

  int setenv(
    ffi.Pointer<ffi.Int8> __name,
    ffi.Pointer<ffi.Int8> __value,
    int __replace,
  ) {
    return _setenv(
      __name,
      __value,
      __replace,
    );
  }

  late final _setenv_ptr = _lookup<ffi.NativeFunction<_c_setenv>>('setenv');
  late final _dart_setenv _setenv = _setenv_ptr.asFunction<_dart_setenv>();

  int unsetenv(
    ffi.Pointer<ffi.Int8> __name,
  ) {
    return _unsetenv(
      __name,
    );
  }

  late final _unsetenv_ptr =
      _lookup<ffi.NativeFunction<_c_unsetenv>>('unsetenv');
  late final _dart_unsetenv _unsetenv =
      _unsetenv_ptr.asFunction<_dart_unsetenv>();

  int clearenv() {
    return _clearenv();
  }

  late final _clearenv_ptr =
      _lookup<ffi.NativeFunction<_c_clearenv>>('clearenv');
  late final _dart_clearenv _clearenv =
      _clearenv_ptr.asFunction<_dart_clearenv>();

  ffi.Pointer<ffi.Int8> mktemp(
    ffi.Pointer<ffi.Int8> __template,
  ) {
    return _mktemp(
      __template,
    );
  }

  late final _mktemp_ptr = _lookup<ffi.NativeFunction<_c_mktemp>>('mktemp');
  late final _dart_mktemp _mktemp = _mktemp_ptr.asFunction<_dart_mktemp>();

  int mkstemp(
    ffi.Pointer<ffi.Int8> __template,
  ) {
    return _mkstemp(
      __template,
    );
  }

  late final _mkstemp_ptr = _lookup<ffi.NativeFunction<_c_mkstemp>>('mkstemp');
  late final _dart_mkstemp _mkstemp = _mkstemp_ptr.asFunction<_dart_mkstemp>();

  int mkstemps(
    ffi.Pointer<ffi.Int8> __template,
    int __suffixlen,
  ) {
    return _mkstemps(
      __template,
      __suffixlen,
    );
  }

  late final _mkstemps_ptr =
      _lookup<ffi.NativeFunction<_c_mkstemps>>('mkstemps');
  late final _dart_mkstemps _mkstemps =
      _mkstemps_ptr.asFunction<_dart_mkstemps>();

  ffi.Pointer<ffi.Int8> mkdtemp(
    ffi.Pointer<ffi.Int8> __template,
  ) {
    return _mkdtemp(
      __template,
    );
  }

  late final _mkdtemp_ptr = _lookup<ffi.NativeFunction<_c_mkdtemp>>('mkdtemp');
  late final _dart_mkdtemp _mkdtemp = _mkdtemp_ptr.asFunction<_dart_mkdtemp>();

  int system(
    ffi.Pointer<ffi.Int8> __command,
  ) {
    return _system(
      __command,
    );
  }

  late final _system_ptr = _lookup<ffi.NativeFunction<_c_system>>('system');
  late final _dart_system _system = _system_ptr.asFunction<_dart_system>();

  ffi.Pointer<ffi.Int8> realpath(
    ffi.Pointer<ffi.Int8> __name,
    ffi.Pointer<ffi.Int8> __resolved,
  ) {
    return _realpath(
      __name,
      __resolved,
    );
  }

  late final _realpath_ptr =
      _lookup<ffi.NativeFunction<_c_realpath>>('realpath');
  late final _dart_realpath _realpath =
      _realpath_ptr.asFunction<_dart_realpath>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _bsearch_ptr = _lookup<ffi.NativeFunction<_c_bsearch>>('bsearch');
  late final _dart_bsearch _bsearch = _bsearch_ptr.asFunction<_dart_bsearch>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nmemb,
    int __size,
    ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
  ) {
    return _qsort(
      __base,
      __nmemb,
      __size,
      __compar,
    );
  }

  late final _qsort_ptr = _lookup<ffi.NativeFunction<_c_qsort>>('qsort');
  late final _dart_qsort _qsort = _qsort_ptr.asFunction<_dart_qsort>();

  int abs(
    int __x,
  ) {
    return _abs(
      __x,
    );
  }

  late final _abs_ptr = _lookup<ffi.NativeFunction<_c_abs>>('abs');
  late final _dart_abs _abs = _abs_ptr.asFunction<_dart_abs>();

  int labs(
    int __x,
  ) {
    return _labs(
      __x,
    );
  }

  late final _labs_ptr = _lookup<ffi.NativeFunction<_c_labs>>('labs');
  late final _dart_labs _labs = _labs_ptr.asFunction<_dart_labs>();

  int llabs(
    int __x,
  ) {
    return _llabs(
      __x,
    );
  }

  late final _llabs_ptr = _lookup<ffi.NativeFunction<_c_llabs>>('llabs');
  late final _dart_llabs _llabs = _llabs_ptr.asFunction<_dart_llabs>();

  div_t div(
    int __numer,
    int __denom,
  ) {
    return _div(
      __numer,
      __denom,
    );
  }

  late final _div_ptr = _lookup<ffi.NativeFunction<_c_div>>('div');
  late final _dart_div _div = _div_ptr.asFunction<_dart_div>();

  ldiv_t ldiv(
    int __numer,
    int __denom,
  ) {
    return _ldiv(
      __numer,
      __denom,
    );
  }

  late final _ldiv_ptr = _lookup<ffi.NativeFunction<_c_ldiv>>('ldiv');
  late final _dart_ldiv _ldiv = _ldiv_ptr.asFunction<_dart_ldiv>();

  lldiv_t lldiv(
    int __numer,
    int __denom,
  ) {
    return _lldiv(
      __numer,
      __denom,
    );
  }

  late final _lldiv_ptr = _lookup<ffi.NativeFunction<_c_lldiv>>('lldiv');
  late final _dart_lldiv _lldiv = _lldiv_ptr.asFunction<_dart_lldiv>();

  ffi.Pointer<ffi.Int8> ecvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int32> __decpt,
    ffi.Pointer<ffi.Int32> __sign,
  ) {
    return _ecvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _ecvt_ptr = _lookup<ffi.NativeFunction<_c_ecvt>>('ecvt');
  late final _dart_ecvt _ecvt = _ecvt_ptr.asFunction<_dart_ecvt>();

  ffi.Pointer<ffi.Int8> fcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int32> __decpt,
    ffi.Pointer<ffi.Int32> __sign,
  ) {
    return _fcvt(
      __value,
      __ndigit,
      __decpt,
      __sign,
    );
  }

  late final _fcvt_ptr = _lookup<ffi.NativeFunction<_c_fcvt>>('fcvt');
  late final _dart_fcvt _fcvt = _fcvt_ptr.asFunction<_dart_fcvt>();

  ffi.Pointer<ffi.Int8> gcvt(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int8> __buf,
  ) {
    return _gcvt(
      __value,
      __ndigit,
      __buf,
    );
  }

  late final _gcvt_ptr = _lookup<ffi.NativeFunction<_c_gcvt>>('gcvt');
  late final _dart_gcvt _gcvt = _gcvt_ptr.asFunction<_dart_gcvt>();

  int ecvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int32> __decpt,
    ffi.Pointer<ffi.Int32> __sign,
    ffi.Pointer<ffi.Int8> __buf,
    int __len,
  ) {
    return _ecvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _ecvt_r_ptr = _lookup<ffi.NativeFunction<_c_ecvt_r>>('ecvt_r');
  late final _dart_ecvt_r _ecvt_r = _ecvt_r_ptr.asFunction<_dart_ecvt_r>();

  int fcvt_r(
    double __value,
    int __ndigit,
    ffi.Pointer<ffi.Int32> __decpt,
    ffi.Pointer<ffi.Int32> __sign,
    ffi.Pointer<ffi.Int8> __buf,
    int __len,
  ) {
    return _fcvt_r(
      __value,
      __ndigit,
      __decpt,
      __sign,
      __buf,
      __len,
    );
  }

  late final _fcvt_r_ptr = _lookup<ffi.NativeFunction<_c_fcvt_r>>('fcvt_r');
  late final _dart_fcvt_r _fcvt_r = _fcvt_r_ptr.asFunction<_dart_fcvt_r>();

  int mblen(
    ffi.Pointer<ffi.Int8> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblen_ptr = _lookup<ffi.NativeFunction<_c_mblen>>('mblen');
  late final _dart_mblen _mblen = _mblen_ptr.asFunction<_dart_mblen>();

  int mbtowc(
    ffi.Pointer<ffi.Int32> __pwc,
    ffi.Pointer<ffi.Int8> __s,
    int __n,
  ) {
    return _mbtowc(
      __pwc,
      __s,
      __n,
    );
  }

  late final _mbtowc_ptr = _lookup<ffi.NativeFunction<_c_mbtowc>>('mbtowc');
  late final _dart_mbtowc _mbtowc = _mbtowc_ptr.asFunction<_dart_mbtowc>();

  int wctomb(
    ffi.Pointer<ffi.Int8> __s,
    int __wchar,
  ) {
    return _wctomb(
      __s,
      __wchar,
    );
  }

  late final _wctomb_ptr = _lookup<ffi.NativeFunction<_c_wctomb>>('wctomb');
  late final _dart_wctomb _wctomb = _wctomb_ptr.asFunction<_dart_wctomb>();

  int mbstowcs(
    ffi.Pointer<ffi.Int32> __pwcs,
    ffi.Pointer<ffi.Int8> __s,
    int __n,
  ) {
    return _mbstowcs(
      __pwcs,
      __s,
      __n,
    );
  }

  late final _mbstowcs_ptr =
      _lookup<ffi.NativeFunction<_c_mbstowcs>>('mbstowcs');
  late final _dart_mbstowcs _mbstowcs =
      _mbstowcs_ptr.asFunction<_dart_mbstowcs>();

  int wcstombs(
    ffi.Pointer<ffi.Int8> __s,
    ffi.Pointer<ffi.Int32> __pwcs,
    int __n,
  ) {
    return _wcstombs(
      __s,
      __pwcs,
      __n,
    );
  }

  late final _wcstombs_ptr =
      _lookup<ffi.NativeFunction<_c_wcstombs>>('wcstombs');
  late final _dart_wcstombs _wcstombs =
      _wcstombs_ptr.asFunction<_dart_wcstombs>();

  int rpmatch(
    ffi.Pointer<ffi.Int8> __response,
  ) {
    return _rpmatch(
      __response,
    );
  }

  late final _rpmatch_ptr = _lookup<ffi.NativeFunction<_c_rpmatch>>('rpmatch');
  late final _dart_rpmatch _rpmatch = _rpmatch_ptr.asFunction<_dart_rpmatch>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __optionp,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __tokens,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __valuep,
  ) {
    return _getsubopt(
      __optionp,
      __tokens,
      __valuep,
    );
  }

  late final _getsubopt_ptr =
      _lookup<ffi.NativeFunction<_c_getsubopt>>('getsubopt');
  late final _dart_getsubopt _getsubopt =
      _getsubopt_ptr.asFunction<_dart_getsubopt>();

  int getloadavg(
    ffi.Pointer<ffi.Double> __loadavg,
    int __nelem,
  ) {
    return _getloadavg(
      __loadavg,
      __nelem,
    );
  }

  late final _getloadavg_ptr =
      _lookup<ffi.NativeFunction<_c_getloadavg>>('getloadavg');
  late final _dart_getloadavg _getloadavg =
      _getloadavg_ptr.asFunction<_dart_getloadavg>();

  int imaxabs(
    int __n,
  ) {
    return _imaxabs(
      __n,
    );
  }

  late final _imaxabs_ptr = _lookup<ffi.NativeFunction<_c_imaxabs>>('imaxabs');
  late final _dart_imaxabs _imaxabs = _imaxabs_ptr.asFunction<_dart_imaxabs>();

  imaxdiv_t imaxdiv(
    int __numer,
    int __denom,
  ) {
    return _imaxdiv(
      __numer,
      __denom,
    );
  }

  late final _imaxdiv_ptr = _lookup<ffi.NativeFunction<_c_imaxdiv>>('imaxdiv');
  late final _dart_imaxdiv _imaxdiv = _imaxdiv_ptr.asFunction<_dart_imaxdiv>();

  int strtoimax(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoimax_ptr =
      _lookup<ffi.NativeFunction<_c_strtoimax>>('strtoimax');
  late final _dart_strtoimax _strtoimax =
      _strtoimax_ptr.asFunction<_dart_strtoimax>();

  int strtoumax(
    ffi.Pointer<ffi.Int8> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
    int __base,
  ) {
    return _strtoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _strtoumax_ptr =
      _lookup<ffi.NativeFunction<_c_strtoumax>>('strtoumax');
  late final _dart_strtoumax _strtoumax =
      _strtoumax_ptr.asFunction<_dart_strtoumax>();

  int wcstoimax(
    ffi.Pointer<ffi.Int32> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int32>> __endptr,
    int __base,
  ) {
    return _wcstoimax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoimax_ptr =
      _lookup<ffi.NativeFunction<_c_wcstoimax>>('wcstoimax');
  late final _dart_wcstoimax _wcstoimax =
      _wcstoimax_ptr.asFunction<_dart_wcstoimax>();

  int wcstoumax(
    ffi.Pointer<ffi.Int32> __nptr,
    ffi.Pointer<ffi.Pointer<ffi.Int32>> __endptr,
    int __base,
  ) {
    return _wcstoumax(
      __nptr,
      __endptr,
      __base,
    );
  }

  late final _wcstoumax_ptr =
      _lookup<ffi.NativeFunction<_c_wcstoumax>>('wcstoumax');
  late final _dart_wcstoumax _wcstoumax =
      _wcstoumax_ptr.asFunction<_dart_wcstoumax>();

  /// Return the version of the libgit2 library
  /// being currently used.
  ///
  /// @param major Store the major version number
  /// @param minor Store the minor version number
  /// @param rev Store the revision (patch) number
  /// @return 0 on success or an error code on failure
  int git_libgit2_version(
    ffi.Pointer<ffi.Int32> major,
    ffi.Pointer<ffi.Int32> minor,
    ffi.Pointer<ffi.Int32> rev,
  ) {
    return _git_libgit2_version(
      major,
      minor,
      rev,
    );
  }

  late final _git_libgit2_version_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_version>>(
          'git_libgit2_version');
  late final _dart_git_libgit2_version _git_libgit2_version =
      _git_libgit2_version_ptr.asFunction<_dart_git_libgit2_version>();

  /// Query compile time options for libgit2.
  ///
  /// @return A combination of GIT_FEATURE_* values.
  ///
  /// - GIT_FEATURE_THREADS
  /// Libgit2 was compiled with thread support. Note that thread support is
  /// still to be seen as a 'work in progress' - basic object lookups are
  /// believed to be threadsafe, but other operations may not be.
  ///
  /// - GIT_FEATURE_HTTPS
  /// Libgit2 supports the https:// protocol. This requires the openssl
  /// library to be found when compiling libgit2.
  ///
  /// - GIT_FEATURE_SSH
  /// Libgit2 supports the SSH protocol for network operations. This requires
  /// the libssh2 library to be found when compiling libgit2
  int git_libgit2_features() {
    return _git_libgit2_features();
  }

  late final _git_libgit2_features_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_features>>(
          'git_libgit2_features');
  late final _dart_git_libgit2_features _git_libgit2_features =
      _git_libgit2_features_ptr.asFunction<_dart_git_libgit2_features>();

  /// Set or query a library global option
  ///
  /// Available options:
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_SIZE, size_t *):
  ///
  /// > Get the maximum mmap window size
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_SIZE, size_t):
  ///
  /// > Set the maximum mmap window size
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_MAPPED_LIMIT, size_t *):
  ///
  /// > Get the maximum memory that will be mapped in total by the library
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_MAPPED_LIMIT, size_t):
  ///
  /// > Set the maximum amount of memory that can be mapped at any time
  /// > by the library
  ///
  /// * opts(GIT_OPT_GET_MWINDOW_FILE_LIMIT, size_t *):
  ///
  /// > Get the maximum number of files that will be mapped at any time by the
  /// > library
  ///
  /// * opts(GIT_OPT_SET_MWINDOW_FILE_LIMIT, size_t):
  ///
  /// > Set the maximum number of files that can be mapped at any time
  /// > by the library. The default (0) is unlimited.
  ///
  /// * opts(GIT_OPT_GET_SEARCH_PATH, int level, git_buf *buf)
  ///
  /// > Get the search path for a given level of config data.  "level" must
  /// > be one of `GIT_CONFIG_LEVEL_SYSTEM`, `GIT_CONFIG_LEVEL_GLOBAL`,
  /// > `GIT_CONFIG_LEVEL_XDG`, or `GIT_CONFIG_LEVEL_PROGRAMDATA`.
  /// > The search path is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_SEARCH_PATH, int level, const char *path)
  ///
  /// > Set the search path for a level of config data.  The search path
  /// > applied to shared attributes and ignore files, too.
  /// >
  /// > - `path` lists directories delimited by GIT_PATH_LIST_SEPARATOR.
  /// >   Pass NULL to reset to the default (generally based on environment
  /// >   variables).  Use magic path `$PATH` to include the old value
  /// >   of the path (if you want to prepend or append, for instance).
  /// >
  /// > - `level` must be `GIT_CONFIG_LEVEL_SYSTEM`,
  /// >   `GIT_CONFIG_LEVEL_GLOBAL`, `GIT_CONFIG_LEVEL_XDG`, or
  /// >   `GIT_CONFIG_LEVEL_PROGRAMDATA`.
  ///
  /// * opts(GIT_OPT_SET_CACHE_OBJECT_LIMIT, git_object_t type, size_t size)
  ///
  /// > Set the maximum data size for the given type of object to be
  /// > considered eligible for caching in memory.  Setting to value to
  /// > zero means that that type of object will not be cached.
  /// > Defaults to 0 for GIT_OBJECT_BLOB (i.e. won't cache blobs) and 4k
  /// > for GIT_OBJECT_COMMIT, GIT_OBJECT_TREE, and GIT_OBJECT_TAG.
  ///
  /// * opts(GIT_OPT_SET_CACHE_MAX_SIZE, ssize_t max_storage_bytes)
  ///
  /// > Set the maximum total data size that will be cached in memory
  /// > across all repositories before libgit2 starts evicting objects
  /// > from the cache.  This is a soft limit, in that the library might
  /// > briefly exceed it, but will start aggressively evicting objects
  /// > from cache when that happens.  The default cache size is 256MB.
  ///
  /// * opts(GIT_OPT_ENABLE_CACHING, int enabled)
  ///
  /// > Enable or disable caching completely.
  /// >
  /// > Because caches are repository-specific, disabling the cache
  /// > cannot immediately clear all cached objects, but each cache will
  /// > be cleared on the next attempt to update anything in it.
  ///
  /// * opts(GIT_OPT_GET_CACHED_MEMORY, ssize_t *current, ssize_t *allowed)
  ///
  /// > Get the current bytes in cache and the maximum that would be
  /// > allowed in the cache.
  ///
  /// * opts(GIT_OPT_GET_TEMPLATE_PATH, git_buf *out)
  ///
  /// > Get the default template path.
  /// > The path is written to the `out` buffer.
  ///
  /// * opts(GIT_OPT_SET_TEMPLATE_PATH, const char *path)
  ///
  /// > Set the default template path.
  /// >
  /// > - `path` directory of template.
  ///
  /// * opts(GIT_OPT_SET_SSL_CERT_LOCATIONS, const char *file, const char *path)
  ///
  /// > Set the SSL certificate-authority locations.
  /// >
  /// > - `file` is the location of a file containing several
  /// >   certificates concatenated together.
  /// > - `path` is the location of a directory holding several
  /// >   certificates, one per file.
  /// >
  /// > Either parameter may be `NULL`, but not both.
  ///
  /// * opts(GIT_OPT_SET_USER_AGENT, const char *user_agent)
  ///
  /// > Set the value of the User-Agent header.  This value will be
  /// > appended to "git/1.0", for compatibility with other git clients.
  /// >
  /// > - `user_agent` is the value that will be delivered as the
  /// >   User-Agent header on HTTP requests.
  ///
  /// * opts(GIT_OPT_SET_WINDOWS_SHAREMODE, unsigned long value)
  ///
  /// > Set the share mode used when opening files on Windows.
  /// > For more information, see the documentation for CreateFile.
  /// > The default is: FILE_SHARE_READ | FILE_SHARE_WRITE.  This is
  /// > ignored and unused on non-Windows platforms.
  ///
  /// * opts(GIT_OPT_GET_WINDOWS_SHAREMODE, unsigned long *value)
  ///
  /// > Get the share mode used when opening files on Windows.
  ///
  /// * opts(GIT_OPT_ENABLE_STRICT_OBJECT_CREATION, int enabled)
  ///
  /// > Enable strict input validation when creating new objects
  /// > to ensure that all inputs to the new objects are valid.  For
  /// > example, when this is enabled, the parent(s) and tree inputs
  /// > will be validated when creating a new commit.  This defaults
  /// > to enabled.
  ///
  /// * opts(GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION, int enabled)
  ///
  /// > Validate the target of a symbolic ref when creating it.  For
  /// > example, `foobar` is not a valid ref, therefore `foobar` is
  /// > not a valid target for a symbolic ref by default, whereas
  /// > `refs/heads/foobar` is.  Disabling this bypasses validation
  /// > so that an arbitrary strings such as `foobar` can be used
  /// > for a symbolic ref target.  This defaults to enabled.
  ///
  /// * opts(GIT_OPT_SET_SSL_CIPHERS, const char *ciphers)
  ///
  /// > Set the SSL ciphers use for HTTPS connections.
  /// >
  /// > - `ciphers` is the list of ciphers that are eanbled.
  ///
  /// * opts(GIT_OPT_ENABLE_OFS_DELTA, int enabled)
  ///
  /// > Enable or disable the use of "offset deltas" when creating packfiles,
  /// > and the negotiation of them when talking to a remote server.
  /// > Offset deltas store a delta base location as an offset into the
  /// > packfile from the current location, which provides a shorter encoding
  /// > and thus smaller resultant packfiles.
  /// > Packfiles containing offset deltas can still be read.
  /// > This defaults to enabled.
  ///
  /// * opts(GIT_OPT_ENABLE_FSYNC_GITDIR, int enabled)
  ///
  /// > Enable synchronized writes of files in the gitdir using `fsync`
  /// > (or the platform equivalent) to ensure that new object data
  /// > is written to permanent storage, not simply cached.  This
  /// > defaults to disabled.
  ///
  /// opts(GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION, int enabled)
  ///
  /// > Enable strict verification of object hashsums when reading
  /// > objects from disk. This may impact performance due to an
  /// > additional checksum calculation on each object. This defaults
  /// > to enabled.
  ///
  /// opts(GIT_OPT_SET_ALLOCATOR, git_allocator *allocator)
  ///
  /// > Set the memory allocator to a different memory allocator. This
  /// > allocator will then be used to make all memory allocations for
  /// > libgit2 operations.  If the given `allocator` is NULL, then the
  /// > system default will be restored.
  ///
  /// opts(GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY, int enabled)
  ///
  /// > Ensure that there are no unsaved changes in the index before
  /// > beginning any operation that reloads the index from disk (eg,
  /// > checkout).  If there are unsaved changes, the instruction will
  /// > fail.  (Using the FORCE flag to checkout will still overwrite
  /// > these changes.)
  ///
  /// opts(GIT_OPT_GET_PACK_MAX_OBJECTS, size_t *out)
  ///
  /// > Get the maximum number of objects libgit2 will allow in a pack
  /// > file when downloading a pack file from a remote. This can be
  /// > used to limit maximum memory usage when fetching from an untrusted
  /// > remote.
  ///
  /// opts(GIT_OPT_SET_PACK_MAX_OBJECTS, size_t objects)
  ///
  /// > Set the maximum number of objects libgit2 will allow in a pack
  /// > file when downloading a pack file from a remote.
  ///
  /// opts(GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS, int enabled)
  /// > This will cause .keep file existence checks to be skipped when
  /// > accessing packfiles, which can help performance with remote filesystems.
  ///
  /// opts(GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE, int enabled)
  /// > When connecting to a server using NTLM or Negotiate
  /// > authentication, use expect/continue when POSTing data.
  /// > This option is not available on Windows.
  ///
  /// @param option Option key
  /// @param ... value to set the option
  /// @return 0 on success, <0 on failure
  int git_libgit2_opts(
    int option,
  ) {
    return _git_libgit2_opts(
      option,
    );
  }

  late final _git_libgit2_opts_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_opts>>('git_libgit2_opts');
  late final _dart_git_libgit2_opts _git_libgit2_opts =
      _git_libgit2_opts_ptr.asFunction<_dart_git_libgit2_opts>();

  /// Free the memory referred to by the git_buf.
  ///
  /// Note that this does not free the `git_buf` itself, just the memory
  /// pointed to by `buffer->ptr`.  This will not free the memory if it looks
  /// like it was not allocated internally, but it will clear the buffer back
  /// to the empty state.
  ///
  /// @param buffer The buffer to deallocate
  void git_buf_dispose(
    ffi.Pointer<git_buf> buffer,
  ) {
    return _git_buf_dispose(
      buffer,
    );
  }

  late final _git_buf_dispose_ptr =
      _lookup<ffi.NativeFunction<_c_git_buf_dispose>>('git_buf_dispose');
  late final _dart_git_buf_dispose _git_buf_dispose =
      _git_buf_dispose_ptr.asFunction<_dart_git_buf_dispose>();

  /// Resize the buffer allocation to make more space.
  ///
  /// This will attempt to grow the buffer to accommodate the target size.
  ///
  /// If the buffer refers to memory that was not allocated by libgit2 (i.e.
  /// the `asize` field is zero), then `ptr` will be replaced with a newly
  /// allocated block of data.  Be careful so that memory allocated by the
  /// caller is not lost.  As a special variant, if you pass `target_size` as
  /// 0 and the memory is not allocated by libgit2, this will allocate a new
  /// buffer of size `size` and copy the external data into it.
  ///
  /// Currently, this will never shrink a buffer, only expand it.
  ///
  /// If the allocation fails, this will return an error and the buffer will be
  /// marked as invalid for future operations, invaliding the contents.
  ///
  /// @param buffer The buffer to be resized; may or may not be allocated yet
  /// @param target_size The desired available size
  /// @return 0 on success, -1 on allocation failure
  int git_buf_grow(
    ffi.Pointer<git_buf> buffer,
    int target_size,
  ) {
    return _git_buf_grow(
      buffer,
      target_size,
    );
  }

  late final _git_buf_grow_ptr =
      _lookup<ffi.NativeFunction<_c_git_buf_grow>>('git_buf_grow');
  late final _dart_git_buf_grow _git_buf_grow =
      _git_buf_grow_ptr.asFunction<_dart_git_buf_grow>();

  /// Set buffer to a copy of some raw data.
  ///
  /// @param buffer The buffer to set
  /// @param data The data to copy into the buffer
  /// @param datalen The length of the data to copy into the buffer
  /// @return 0 on success, -1 on allocation failure
  int git_buf_set(
    ffi.Pointer<git_buf> buffer,
    ffi.Pointer<ffi.Void> data,
    int datalen,
  ) {
    return _git_buf_set(
      buffer,
      data,
      datalen,
    );
  }

  late final _git_buf_set_ptr =
      _lookup<ffi.NativeFunction<_c_git_buf_set>>('git_buf_set');
  late final _dart_git_buf_set _git_buf_set =
      _git_buf_set_ptr.asFunction<_dart_git_buf_set>();

  /// Check quickly if buffer looks like it contains binary data
  ///
  /// @param buf Buffer to check
  /// @return 1 if buffer looks like non-text data
  int git_buf_is_binary(
    ffi.Pointer<git_buf> buf,
  ) {
    return _git_buf_is_binary(
      buf,
    );
  }

  late final _git_buf_is_binary_ptr =
      _lookup<ffi.NativeFunction<_c_git_buf_is_binary>>('git_buf_is_binary');
  late final _dart_git_buf_is_binary _git_buf_is_binary =
      _git_buf_is_binary_ptr.asFunction<_dart_git_buf_is_binary>();

  /// Check quickly if buffer contains a NUL byte
  ///
  /// @param buf Buffer to check
  /// @return 1 if buffer contains a NUL byte
  int git_buf_contains_nul(
    ffi.Pointer<git_buf> buf,
  ) {
    return _git_buf_contains_nul(
      buf,
    );
  }

  late final _git_buf_contains_nul_ptr =
      _lookup<ffi.NativeFunction<_c_git_buf_contains_nul>>(
          'git_buf_contains_nul');
  late final _dart_git_buf_contains_nul _git_buf_contains_nul =
      _git_buf_contains_nul_ptr.asFunction<_dart_git_buf_contains_nul>();

  /// Parse a hex formatted object id into a git_oid.
  ///
  /// @param out oid structure the result is written into.
  /// @param str input hex string; must be pointing at the start of
  /// the hex sequence and have at least the number of bytes
  /// needed for an oid encoded in hex (40 bytes).
  /// @return 0 or an error code
  int git_oid_fromstr(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _git_oid_fromstr(
      out,
      str,
    );
  }

  late final _git_oid_fromstr_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_fromstr>>('git_oid_fromstr');
  late final _dart_git_oid_fromstr _git_oid_fromstr =
      _git_oid_fromstr_ptr.asFunction<_dart_git_oid_fromstr>();

  /// Parse a hex formatted null-terminated string into a git_oid.
  ///
  /// @param out oid structure the result is written into.
  /// @param str input hex string; must be null-terminated.
  /// @return 0 or an error code
  int git_oid_fromstrp(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _git_oid_fromstrp(
      out,
      str,
    );
  }

  late final _git_oid_fromstrp_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_fromstrp>>('git_oid_fromstrp');
  late final _dart_git_oid_fromstrp _git_oid_fromstrp =
      _git_oid_fromstrp_ptr.asFunction<_dart_git_oid_fromstrp>();

  /// Parse N characters of a hex formatted object id into a git_oid.
  ///
  /// If N is odd, the last byte's high nibble will be read in and the
  /// low nibble set to zero.
  ///
  /// @param out oid structure the result is written into.
  /// @param str input hex string of at least size `length`
  /// @param length length of the input string
  /// @return 0 or an error code
  int git_oid_fromstrn(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Int8> str,
    int length,
  ) {
    return _git_oid_fromstrn(
      out,
      str,
      length,
    );
  }

  late final _git_oid_fromstrn_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_fromstrn>>('git_oid_fromstrn');
  late final _dart_git_oid_fromstrn _git_oid_fromstrn =
      _git_oid_fromstrn_ptr.asFunction<_dart_git_oid_fromstrn>();

  /// Copy an already raw oid into a git_oid structure.
  ///
  /// @param out oid structure the result is written into.
  /// @param raw the raw input bytes to be copied.
  /// @return 0 on success or error code
  int git_oid_fromraw(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Uint8> raw,
  ) {
    return _git_oid_fromraw(
      out,
      raw,
    );
  }

  late final _git_oid_fromraw_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_fromraw>>('git_oid_fromraw');
  late final _dart_git_oid_fromraw _git_oid_fromraw =
      _git_oid_fromraw_ptr.asFunction<_dart_git_oid_fromraw>();

  /// Format a git_oid into a hex string.
  ///
  /// @param out output hex string; must be pointing at the start of
  /// the hex sequence and have at least the number of bytes
  /// needed for an oid encoded in hex (40 bytes). Only the
  /// oid digits are written; a '\\0' terminator must be added
  /// by the caller if it is required.
  /// @param id oid structure to format.
  /// @return 0 on success or error code
  int git_oid_fmt(
    ffi.Pointer<ffi.Int8> out,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_fmt(
      out,
      id,
    );
  }

  late final _git_oid_fmt_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_fmt>>('git_oid_fmt');
  late final _dart_git_oid_fmt _git_oid_fmt =
      _git_oid_fmt_ptr.asFunction<_dart_git_oid_fmt>();

  /// Format a git_oid into a partial hex string.
  ///
  /// @param out output hex string; you say how many bytes to write.
  /// If the number of bytes is > GIT_OID_HEXSZ, extra bytes
  /// will be zeroed; if not, a '\0' terminator is NOT added.
  /// @param n number of characters to write into out string
  /// @param id oid structure to format.
  /// @return 0 on success or error code
  int git_oid_nfmt(
    ffi.Pointer<ffi.Int8> out,
    int n,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_nfmt(
      out,
      n,
      id,
    );
  }

  late final _git_oid_nfmt_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_nfmt>>('git_oid_nfmt');
  late final _dart_git_oid_nfmt _git_oid_nfmt =
      _git_oid_nfmt_ptr.asFunction<_dart_git_oid_nfmt>();

  /// Format a git_oid into a loose-object path string.
  ///
  /// The resulting string is "aa/...", where "aa" is the first two
  /// hex digits of the oid and "..." is the remaining 38 digits.
  ///
  /// @param out output hex string; must be pointing at the start of
  /// the hex sequence and have at least the number of bytes
  /// needed for an oid encoded in hex (41 bytes). Only the
  /// oid digits are written; a '\\0' terminator must be added
  /// by the caller if it is required.
  /// @param id oid structure to format.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_oid_pathfmt(
    ffi.Pointer<ffi.Int8> out,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_pathfmt(
      out,
      id,
    );
  }

  late final _git_oid_pathfmt_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_pathfmt>>('git_oid_pathfmt');
  late final _dart_git_oid_pathfmt _git_oid_pathfmt =
      _git_oid_pathfmt_ptr.asFunction<_dart_git_oid_pathfmt>();

  /// Format a git_oid into a statically allocated c-string.
  ///
  /// The c-string is owned by the library and should not be freed
  /// by the user. If libgit2 is built with thread support, the string
  /// will be stored in TLS (i.e. one buffer per thread) to allow for
  /// concurrent calls of the function.
  ///
  /// @param oid The oid structure to format
  /// @return the c-string
  ffi.Pointer<ffi.Int8> git_oid_tostr_s(
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_oid_tostr_s(
      oid,
    );
  }

  late final _git_oid_tostr_s_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_tostr_s>>('git_oid_tostr_s');
  late final _dart_git_oid_tostr_s _git_oid_tostr_s =
      _git_oid_tostr_s_ptr.asFunction<_dart_git_oid_tostr_s>();

  /// Format a git_oid into a buffer as a hex format c-string.
  ///
  /// If the buffer is smaller than GIT_OID_HEXSZ+1, then the resulting
  /// oid c-string will be truncated to n-1 characters (but will still be
  /// NUL-byte terminated).
  ///
  /// If there are any input parameter errors (out == NULL, n == 0, oid ==
  /// NULL), then a pointer to an empty string is returned, so that the
  /// return value can always be printed.
  ///
  /// @param out the buffer into which the oid string is output.
  /// @param n the size of the out buffer.
  /// @param id the oid structure to format.
  /// @return the out buffer pointer, assuming no input parameter
  /// errors, otherwise a pointer to an empty string.
  ffi.Pointer<ffi.Int8> git_oid_tostr(
    ffi.Pointer<ffi.Int8> out,
    int n,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_tostr(
      out,
      n,
      id,
    );
  }

  late final _git_oid_tostr_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_tostr>>('git_oid_tostr');
  late final _dart_git_oid_tostr _git_oid_tostr =
      _git_oid_tostr_ptr.asFunction<_dart_git_oid_tostr>();

  /// Copy an oid from one structure to another.
  ///
  /// @param out oid structure the result is written into.
  /// @param src oid structure to copy from.
  /// @return 0 on success or error code
  int git_oid_cpy(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_oid> src,
  ) {
    return _git_oid_cpy(
      out,
      src,
    );
  }

  late final _git_oid_cpy_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_cpy>>('git_oid_cpy');
  late final _dart_git_oid_cpy _git_oid_cpy =
      _git_oid_cpy_ptr.asFunction<_dart_git_oid_cpy>();

  /// Compare two oid structures.
  ///
  /// @param a first oid structure.
  /// @param b second oid structure.
  /// @return <0, 0, >0 if a < b, a == b, a > b.
  int git_oid_cmp(
    ffi.Pointer<git_oid> a,
    ffi.Pointer<git_oid> b,
  ) {
    return _git_oid_cmp(
      a,
      b,
    );
  }

  late final _git_oid_cmp_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_cmp>>('git_oid_cmp');
  late final _dart_git_oid_cmp _git_oid_cmp =
      _git_oid_cmp_ptr.asFunction<_dart_git_oid_cmp>();

  /// Compare two oid structures for equality
  ///
  /// @param a first oid structure.
  /// @param b second oid structure.
  /// @return true if equal, false otherwise
  int git_oid_equal(
    ffi.Pointer<git_oid> a,
    ffi.Pointer<git_oid> b,
  ) {
    return _git_oid_equal(
      a,
      b,
    );
  }

  late final _git_oid_equal_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_equal>>('git_oid_equal');
  late final _dart_git_oid_equal _git_oid_equal =
      _git_oid_equal_ptr.asFunction<_dart_git_oid_equal>();

  /// Compare the first 'len' hexadecimal characters (packets of 4 bits)
  /// of two oid structures.
  ///
  /// @param a first oid structure.
  /// @param b second oid structure.
  /// @param len the number of hex chars to compare
  /// @return 0 in case of a match
  int git_oid_ncmp(
    ffi.Pointer<git_oid> a,
    ffi.Pointer<git_oid> b,
    int len,
  ) {
    return _git_oid_ncmp(
      a,
      b,
      len,
    );
  }

  late final _git_oid_ncmp_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_ncmp>>('git_oid_ncmp');
  late final _dart_git_oid_ncmp _git_oid_ncmp =
      _git_oid_ncmp_ptr.asFunction<_dart_git_oid_ncmp>();

  /// Check if an oid equals an hex formatted object id.
  ///
  /// @param id oid structure.
  /// @param str input hex string of an object id.
  /// @return 0 in case of a match, -1 otherwise.
  int git_oid_streq(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _git_oid_streq(
      id,
      str,
    );
  }

  late final _git_oid_streq_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_streq>>('git_oid_streq');
  late final _dart_git_oid_streq _git_oid_streq =
      _git_oid_streq_ptr.asFunction<_dart_git_oid_streq>();

  /// Compare an oid to an hex formatted object id.
  ///
  /// @param id oid structure.
  /// @param str input hex string of an object id.
  /// @return -1 if str is not valid, <0 if id sorts before str,
  /// 0 if id matches str, >0 if id sorts after str.
  int git_oid_strcmp(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _git_oid_strcmp(
      id,
      str,
    );
  }

  late final _git_oid_strcmp_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_strcmp>>('git_oid_strcmp');
  late final _dart_git_oid_strcmp _git_oid_strcmp =
      _git_oid_strcmp_ptr.asFunction<_dart_git_oid_strcmp>();

  /// Check is an oid is all zeros.
  ///
  /// @return 1 if all zeros, 0 otherwise.
  int git_oid_is_zero(
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_is_zero(
      id,
    );
  }

  late final _git_oid_is_zero_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_is_zero>>('git_oid_is_zero');
  late final _dart_git_oid_is_zero _git_oid_is_zero =
      _git_oid_is_zero_ptr.asFunction<_dart_git_oid_is_zero>();

  /// Create a new OID shortener.
  ///
  /// The OID shortener is used to process a list of OIDs
  /// in text form and return the shortest length that would
  /// uniquely identify all of them.
  ///
  /// E.g. look at the result of `git log --abbrev`.
  ///
  /// @param min_length The minimal length for all identifiers,
  /// which will be used even if shorter OIDs would still
  /// be unique.
  /// @return a `git_oid_shorten` instance, NULL if OOM
  ffi.Pointer<git_oid_shorten> git_oid_shorten_new(
    int min_length,
  ) {
    return _git_oid_shorten_new(
      min_length,
    );
  }

  late final _git_oid_shorten_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_shorten_new>>(
          'git_oid_shorten_new');
  late final _dart_git_oid_shorten_new _git_oid_shorten_new =
      _git_oid_shorten_new_ptr.asFunction<_dart_git_oid_shorten_new>();

  /// Add a new OID to set of shortened OIDs and calculate
  /// the minimal length to uniquely identify all the OIDs in
  /// the set.
  ///
  /// The OID is expected to be a 40-char hexadecimal string.
  /// The OID is owned by the user and will not be modified
  /// or freed.
  ///
  /// For performance reasons, there is a hard-limit of how many
  /// OIDs can be added to a single set (around ~32000, assuming
  /// a mostly randomized distribution), which should be enough
  /// for any kind of program, and keeps the algorithm fast and
  /// memory-efficient.
  ///
  /// Attempting to add more than those OIDs will result in a
  /// GIT_ERROR_INVALID error
  ///
  /// @param os a `git_oid_shorten` instance
  /// @param text_id an OID in text form
  /// @return the minimal length to uniquely identify all OIDs
  /// added so far to the set; or an error code (<0) if an
  /// error occurs.
  int git_oid_shorten_add(
    ffi.Pointer<git_oid_shorten> os,
    ffi.Pointer<ffi.Int8> text_id,
  ) {
    return _git_oid_shorten_add(
      os,
      text_id,
    );
  }

  late final _git_oid_shorten_add_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_shorten_add>>(
          'git_oid_shorten_add');
  late final _dart_git_oid_shorten_add _git_oid_shorten_add =
      _git_oid_shorten_add_ptr.asFunction<_dart_git_oid_shorten_add>();

  /// Free an OID shortener instance
  ///
  /// @param os a `git_oid_shorten` instance
  void git_oid_shorten_free(
    ffi.Pointer<git_oid_shorten> os,
  ) {
    return _git_oid_shorten_free(
      os,
    );
  }

  late final _git_oid_shorten_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_shorten_free>>(
          'git_oid_shorten_free');
  late final _dart_git_oid_shorten_free _git_oid_shorten_free =
      _git_oid_shorten_free_ptr.asFunction<_dart_git_oid_shorten_free>();

  /// Open a git repository.
  ///
  /// The 'path' argument must point to either a git repository
  /// folder, or an existing work dir.
  ///
  /// The method will automatically detect if 'path' is a normal
  /// or bare repository or fail is 'path' is neither.
  ///
  /// @param out pointer to the repo which will be opened
  /// @param path the path to the repository
  /// @return 0 or an error code
  int git_repository_open(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_repository_open(
      out,
      path,
    );
  }

  late final _git_repository_open_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_open>>(
          'git_repository_open');
  late final _dart_git_repository_open _git_repository_open =
      _git_repository_open_ptr.asFunction<_dart_git_repository_open>();

  /// Open working tree as a repository
  ///
  /// Open the working directory of the working tree as a normal
  /// repository that can then be worked on.
  ///
  /// @param out Output pointer containing opened repository
  /// @param wt Working tree to open
  /// @return 0 or an error code
  int git_repository_open_from_worktree(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_repository_open_from_worktree(
      out,
      wt,
    );
  }

  late final _git_repository_open_from_worktree_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_open_from_worktree>>(
          'git_repository_open_from_worktree');
  late final _dart_git_repository_open_from_worktree
      _git_repository_open_from_worktree =
      _git_repository_open_from_worktree_ptr
          .asFunction<_dart_git_repository_open_from_worktree>();

  /// Create a "fake" repository to wrap an object database
  ///
  /// Create a repository object to wrap an object database to be used
  /// with the API when all you have is an object database. This doesn't
  /// have any paths associated with it, so use with care.
  ///
  /// @param out pointer to the repo
  /// @param odb the object database to wrap
  /// @return 0 or an error code
  int git_repository_wrap_odb(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_odb> odb,
  ) {
    return _git_repository_wrap_odb(
      out,
      odb,
    );
  }

  late final _git_repository_wrap_odb_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_wrap_odb>>(
          'git_repository_wrap_odb');
  late final _dart_git_repository_wrap_odb _git_repository_wrap_odb =
      _git_repository_wrap_odb_ptr.asFunction<_dart_git_repository_wrap_odb>();

  /// Look for a git repository and copy its path in the given buffer.
  /// The lookup start from base_path and walk across parent directories
  /// if nothing has been found. The lookup ends when the first repository
  /// is found, or when reaching a directory referenced in ceiling_dirs
  /// or when the filesystem changes (in case across_fs is true).
  ///
  /// The method will automatically detect if the repository is bare
  /// (if there is a repository).
  ///
  /// @param out A pointer to a user-allocated git_buf which will contain
  /// the found path.
  ///
  /// @param start_path The base path where the lookup starts.
  ///
  /// @param across_fs If true, then the lookup will not stop when a
  /// filesystem device change is detected while exploring parent directories.
  ///
  /// @param ceiling_dirs A GIT_PATH_LIST_SEPARATOR separated list of
  /// absolute symbolic link free paths. The lookup will stop when any
  /// of this paths is reached. Note that the lookup always performs on
  /// start_path no matter start_path appears in ceiling_dirs ceiling_dirs
  /// might be NULL (which is equivalent to an empty string)
  ///
  /// @return 0 or an error code
  int git_repository_discover(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<ffi.Int8> start_path,
    int across_fs,
    ffi.Pointer<ffi.Int8> ceiling_dirs,
  ) {
    return _git_repository_discover(
      out,
      start_path,
      across_fs,
      ceiling_dirs,
    );
  }

  late final _git_repository_discover_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_discover>>(
          'git_repository_discover');
  late final _dart_git_repository_discover _git_repository_discover =
      _git_repository_discover_ptr.asFunction<_dart_git_repository_discover>();

  /// Find and open a repository with extended controls.
  ///
  /// @param out Pointer to the repo which will be opened.  This can
  /// actually be NULL if you only want to use the error code to
  /// see if a repo at this path could be opened.
  /// @param path Path to open as git repository.  If the flags
  /// permit "searching", then this can be a path to a subdirectory
  /// inside the working directory of the repository. May be NULL if
  /// flags is GIT_REPOSITORY_OPEN_FROM_ENV.
  /// @param flags A combination of the GIT_REPOSITORY_OPEN flags above.
  /// @param ceiling_dirs A GIT_PATH_LIST_SEPARATOR delimited list of path
  /// prefixes at which the search for a containing repository should
  /// terminate.
  /// @return 0 on success, GIT_ENOTFOUND if no repository could be found,
  /// or -1 if there was a repository but open failed for some reason
  /// (such as repo corruption or system errors).
  int git_repository_open_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
    int flags,
    ffi.Pointer<ffi.Int8> ceiling_dirs,
  ) {
    return _git_repository_open_ext(
      out,
      path,
      flags,
      ceiling_dirs,
    );
  }

  late final _git_repository_open_ext_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_open_ext>>(
          'git_repository_open_ext');
  late final _dart_git_repository_open_ext _git_repository_open_ext =
      _git_repository_open_ext_ptr.asFunction<_dart_git_repository_open_ext>();

  /// Open a bare repository on the serverside.
  ///
  /// This is a fast open for bare repositories that will come in handy
  /// if you're e.g. hosting git repositories and need to access them
  /// efficiently
  ///
  /// @param out Pointer to the repo which will be opened.
  /// @param bare_path Direct path to the bare repository
  /// @return 0 on success, or an error code
  int git_repository_open_bare(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> bare_path,
  ) {
    return _git_repository_open_bare(
      out,
      bare_path,
    );
  }

  late final _git_repository_open_bare_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_open_bare>>(
          'git_repository_open_bare');
  late final _dart_git_repository_open_bare _git_repository_open_bare =
      _git_repository_open_bare_ptr
          .asFunction<_dart_git_repository_open_bare>();

  /// Free a previously allocated repository
  ///
  /// Note that after a repository is free'd, all the objects it has spawned
  /// will still exist until they are manually closed by the user
  /// with `git_object_free`, but accessing any of the attributes of
  /// an object without a backing repository will result in undefined
  /// behavior
  ///
  /// @param repo repository handle to close. If NULL nothing occurs.
  void git_repository_free(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_free(
      repo,
    );
  }

  late final _git_repository_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_free>>(
          'git_repository_free');
  late final _dart_git_repository_free _git_repository_free =
      _git_repository_free_ptr.asFunction<_dart_git_repository_free>();

  /// Creates a new Git repository in the given folder.
  ///
  /// TODO:
  /// - Reinit the repository
  ///
  /// @param out pointer to the repo which will be created or reinitialized
  /// @param path the path to the repository
  /// @param is_bare if true, a Git repository without a working directory is
  /// created at the pointed path. If false, provided path will be
  /// considered as the working directory into which the .git directory
  /// will be created.
  ///
  /// @return 0 or an error code
  int git_repository_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> path,
    int is_bare,
  ) {
    return _git_repository_init(
      out,
      path,
      is_bare,
    );
  }

  late final _git_repository_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_init>>(
          'git_repository_init');
  late final _dart_git_repository_init _git_repository_init =
      _git_repository_init_ptr.asFunction<_dart_git_repository_init>();

  /// Initialize git_repository_init_options structure
  ///
  /// Initializes a `git_repository_init_options` with default values. Equivalent to
  /// creating an instance with `GIT_REPOSITORY_INIT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_repository_init_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REPOSITORY_INIT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_repository_init_options_init(
    ffi.Pointer<git_repository_init_options> opts,
    int version,
  ) {
    return _git_repository_init_options_init(
      opts,
      version,
    );
  }

  late final _git_repository_init_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_init_options_init>>(
          'git_repository_init_options_init');
  late final _dart_git_repository_init_options_init
      _git_repository_init_options_init = _git_repository_init_options_init_ptr
          .asFunction<_dart_git_repository_init_options_init>();

  /// Create a new Git repository in the given folder with extended controls.
  ///
  /// This will initialize a new git repository (creating the repo_path
  /// if requested by flags) and working directory as needed.  It will
  /// auto-detect the case sensitivity of the file system and if the
  /// file system supports file mode bits correctly.
  ///
  /// @param out Pointer to the repo which will be created or reinitialized.
  /// @param repo_path The path to the repository.
  /// @param opts Pointer to git_repository_init_options struct.
  /// @return 0 or an error code on failure.
  int git_repository_init_ext(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> repo_path,
    ffi.Pointer<git_repository_init_options> opts,
  ) {
    return _git_repository_init_ext(
      out,
      repo_path,
      opts,
    );
  }

  late final _git_repository_init_ext_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_init_ext>>(
          'git_repository_init_ext');
  late final _dart_git_repository_init_ext _git_repository_init_ext =
      _git_repository_init_ext_ptr.asFunction<_dart_git_repository_init_ext>();

  /// Retrieve and resolve the reference pointed at by HEAD.
  ///
  /// The returned `git_reference` will be owned by caller and
  /// `git_reference_free()` must be called when done with it to release the
  /// allocated memory and prevent a leak.
  ///
  /// @param out pointer to the reference which will be retrieved
  /// @param repo a repository object
  ///
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch, GIT_ENOTFOUND when HEAD is missing; an error code otherwise
  int git_repository_head(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head(
      out,
      repo,
    );
  }

  late final _git_repository_head_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_head>>(
          'git_repository_head');
  late final _dart_git_repository_head _git_repository_head =
      _git_repository_head_ptr.asFunction<_dart_git_repository_head>();

  /// Retrieve the referenced HEAD for the worktree
  ///
  /// @param out pointer to the reference which will be retrieved
  /// @param repo a repository object
  /// @param name name of the worktree to retrieve HEAD for
  /// @return 0 when successful, error-code otherwise
  int git_repository_head_for_worktree(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_repository_head_for_worktree(
      out,
      repo,
      name,
    );
  }

  late final _git_repository_head_for_worktree_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_head_for_worktree>>(
          'git_repository_head_for_worktree');
  late final _dart_git_repository_head_for_worktree
      _git_repository_head_for_worktree = _git_repository_head_for_worktree_ptr
          .asFunction<_dart_git_repository_head_for_worktree>();

  /// Check if a repository's HEAD is detached
  ///
  /// A repository's HEAD is detached when it points directly to a commit
  /// instead of a branch.
  ///
  /// @param repo Repo to test
  /// @return 1 if HEAD is detached, 0 if it's not; error code if there
  /// was an error.
  int git_repository_head_detached(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head_detached(
      repo,
    );
  }

  late final _git_repository_head_detached_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_head_detached>>(
          'git_repository_head_detached');
  late final _dart_git_repository_head_detached _git_repository_head_detached =
      _git_repository_head_detached_ptr
          .asFunction<_dart_git_repository_head_detached>();

  /// Check if a worktree's HEAD is detached
  ///
  /// A worktree's HEAD is detached when it points directly to a
  /// commit instead of a branch.
  ///
  /// @param repo a repository object
  /// @param name name of the worktree to retrieve HEAD for
  /// @return 1 if HEAD is detached, 0 if its not; error code if
  /// there was an error
  int git_repository_head_detached_for_worktree(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_repository_head_detached_for_worktree(
      repo,
      name,
    );
  }

  late final _git_repository_head_detached_for_worktree_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_head_detached_for_worktree>>(
          'git_repository_head_detached_for_worktree');
  late final _dart_git_repository_head_detached_for_worktree
      _git_repository_head_detached_for_worktree =
      _git_repository_head_detached_for_worktree_ptr
          .asFunction<_dart_git_repository_head_detached_for_worktree>();

  /// Check if the current branch is unborn
  ///
  /// An unborn branch is one named from HEAD but which doesn't exist in
  /// the refs namespace, because it doesn't have any commit to point to.
  ///
  /// @param repo Repo to test
  /// @return 1 if the current branch is unborn, 0 if it's not; error
  /// code if there was an error
  int git_repository_head_unborn(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_head_unborn(
      repo,
    );
  }

  late final _git_repository_head_unborn_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_head_unborn>>(
          'git_repository_head_unborn');
  late final _dart_git_repository_head_unborn _git_repository_head_unborn =
      _git_repository_head_unborn_ptr
          .asFunction<_dart_git_repository_head_unborn>();

  /// Check if a repository is empty
  ///
  /// An empty repository has just been initialized and contains no references
  /// apart from HEAD, which must be pointing to the unborn master branch.
  ///
  /// @param repo Repo to test
  /// @return 1 if the repository is empty, 0 if it isn't, error code
  /// if the repository is corrupted
  int git_repository_is_empty(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_empty(
      repo,
    );
  }

  late final _git_repository_is_empty_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_is_empty>>(
          'git_repository_is_empty');
  late final _dart_git_repository_is_empty _git_repository_is_empty =
      _git_repository_is_empty_ptr.asFunction<_dart_git_repository_is_empty>();

  /// Get the location of a specific repository file or directory
  ///
  /// This function will retrieve the path of a specific repository
  /// item. It will thereby honor things like the repository's
  /// common directory, gitdir, etc. In case a file path cannot
  /// exist for a given item (e.g. the working directory of a bare
  /// repository), GIT_ENOTFOUND is returned.
  ///
  /// @param out Buffer to store the path at
  /// @param repo Repository to get path for
  /// @param item The repository item for which to retrieve the path
  /// @return 0, GIT_ENOTFOUND if the path cannot exist or an error code
  int git_repository_item_path(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    int item,
  ) {
    return _git_repository_item_path(
      out,
      repo,
      item,
    );
  }

  late final _git_repository_item_path_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_item_path>>(
          'git_repository_item_path');
  late final _dart_git_repository_item_path _git_repository_item_path =
      _git_repository_item_path_ptr
          .asFunction<_dart_git_repository_item_path>();

  /// Get the path of this repository
  ///
  /// This is the path of the `.git` folder for normal repositories,
  /// or of the repository itself for bare repositories.
  ///
  /// @param repo A repository object
  /// @return the path to the repository
  ffi.Pointer<ffi.Int8> git_repository_path(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_path(
      repo,
    );
  }

  late final _git_repository_path_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_path>>(
          'git_repository_path');
  late final _dart_git_repository_path _git_repository_path =
      _git_repository_path_ptr.asFunction<_dart_git_repository_path>();

  /// Get the path of the working directory for this repository
  ///
  /// If the repository is bare, this function will always return
  /// NULL.
  ///
  /// @param repo A repository object
  /// @return the path to the working dir, if it exists
  ffi.Pointer<ffi.Int8> git_repository_workdir(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_workdir(
      repo,
    );
  }

  late final _git_repository_workdir_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_workdir>>(
          'git_repository_workdir');
  late final _dart_git_repository_workdir _git_repository_workdir =
      _git_repository_workdir_ptr.asFunction<_dart_git_repository_workdir>();

  /// Get the path of the shared common directory for this repository.
  ///
  /// If the repository is bare, it is the root directory for the repository.
  /// If the repository is a worktree, it is the parent repo's gitdir.
  /// Otherwise, it is the gitdir.
  ///
  /// @param repo A repository object
  /// @return the path to the common dir
  ffi.Pointer<ffi.Int8> git_repository_commondir(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_commondir(
      repo,
    );
  }

  late final _git_repository_commondir_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_commondir>>(
          'git_repository_commondir');
  late final _dart_git_repository_commondir _git_repository_commondir =
      _git_repository_commondir_ptr
          .asFunction<_dart_git_repository_commondir>();

  /// Set the path to the working directory for this repository
  ///
  /// The working directory doesn't need to be the same one
  /// that contains the `.git` folder for this repository.
  ///
  /// If this repository is bare, setting its working directory
  /// will turn it into a normal repository, capable of performing
  /// all the common workdir operations (checkout, status, index
  /// manipulation, etc).
  ///
  /// @param repo A repository object
  /// @param workdir The path to a working directory
  /// @param update_gitlink Create/update gitlink in workdir and set config
  /// "core.worktree" (if workdir is not the parent of the .git directory)
  /// @return 0, or an error code
  int git_repository_set_workdir(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> workdir,
    int update_gitlink,
  ) {
    return _git_repository_set_workdir(
      repo,
      workdir,
      update_gitlink,
    );
  }

  late final _git_repository_set_workdir_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_set_workdir>>(
          'git_repository_set_workdir');
  late final _dart_git_repository_set_workdir _git_repository_set_workdir =
      _git_repository_set_workdir_ptr
          .asFunction<_dart_git_repository_set_workdir>();

  /// Check if a repository is bare
  ///
  /// @param repo Repo to test
  /// @return 1 if the repository is bare, 0 otherwise.
  int git_repository_is_bare(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_bare(
      repo,
    );
  }

  late final _git_repository_is_bare_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_is_bare>>(
          'git_repository_is_bare');
  late final _dart_git_repository_is_bare _git_repository_is_bare =
      _git_repository_is_bare_ptr.asFunction<_dart_git_repository_is_bare>();

  /// Check if a repository is a linked work tree
  ///
  /// @param repo Repo to test
  /// @return 1 if the repository is a linked work tree, 0 otherwise.
  int git_repository_is_worktree(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_worktree(
      repo,
    );
  }

  late final _git_repository_is_worktree_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_is_worktree>>(
          'git_repository_is_worktree');
  late final _dart_git_repository_is_worktree _git_repository_is_worktree =
      _git_repository_is_worktree_ptr
          .asFunction<_dart_git_repository_is_worktree>();

  /// Get the configuration file for this repository.
  ///
  /// If a configuration file has not been set, the default
  /// config set for the repository will be returned, including
  /// global and system configurations (if they are available).
  ///
  /// The configuration file must be freed once it's no longer
  /// being used by the user.
  ///
  /// @param out Pointer to store the loaded configuration
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_config(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_config(
      out,
      repo,
    );
  }

  late final _git_repository_config_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_config>>(
          'git_repository_config');
  late final _dart_git_repository_config _git_repository_config =
      _git_repository_config_ptr.asFunction<_dart_git_repository_config>();

  /// Get a snapshot of the repository's configuration
  ///
  /// Convenience function to take a snapshot from the repository's
  /// configuration.  The contents of this snapshot will not change,
  /// even if the underlying config files are modified.
  ///
  /// The configuration file must be freed once it's no longer
  /// being used by the user.
  ///
  /// @param out Pointer to store the loaded configuration
  /// @param repo the repository
  /// @return 0, or an error code
  int git_repository_config_snapshot(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_config_snapshot(
      out,
      repo,
    );
  }

  late final _git_repository_config_snapshot_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_config_snapshot>>(
          'git_repository_config_snapshot');
  late final _dart_git_repository_config_snapshot
      _git_repository_config_snapshot = _git_repository_config_snapshot_ptr
          .asFunction<_dart_git_repository_config_snapshot>();

  /// Get the Object Database for this repository.
  ///
  /// If a custom ODB has not been set, the default
  /// database for the repository will be returned (the one
  /// located in `.git/objects`).
  ///
  /// The ODB must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param out Pointer to store the loaded ODB
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_odb(
    ffi.Pointer<ffi.Pointer<git_odb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_odb(
      out,
      repo,
    );
  }

  late final _git_repository_odb_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_odb>>('git_repository_odb');
  late final _dart_git_repository_odb _git_repository_odb =
      _git_repository_odb_ptr.asFunction<_dart_git_repository_odb>();

  /// Get the Reference Database Backend for this repository.
  ///
  /// If a custom refsdb has not been set, the default database for
  /// the repository will be returned (the one that manipulates loose
  /// and packed references in the `.git` directory).
  ///
  /// The refdb must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param out Pointer to store the loaded refdb
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_refdb(
    ffi.Pointer<ffi.Pointer<git_refdb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_refdb(
      out,
      repo,
    );
  }

  late final _git_repository_refdb_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_refdb>>(
          'git_repository_refdb');
  late final _dart_git_repository_refdb _git_repository_refdb =
      _git_repository_refdb_ptr.asFunction<_dart_git_repository_refdb>();

  /// Get the Index file for this repository.
  ///
  /// If a custom index has not been set, the default
  /// index for the repository will be returned (the one
  /// located in `.git/index`).
  ///
  /// The index must be freed once it's no longer being used by
  /// the user.
  ///
  /// @param out Pointer to store the loaded index
  /// @param repo A repository object
  /// @return 0, or an error code
  int git_repository_index(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_index(
      out,
      repo,
    );
  }

  late final _git_repository_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_index>>(
          'git_repository_index');
  late final _dart_git_repository_index _git_repository_index =
      _git_repository_index_ptr.asFunction<_dart_git_repository_index>();

  /// Retrieve git's prepared message
  ///
  /// Operations such as git revert/cherry-pick/merge with the -n option
  /// stop just short of creating a commit with the changes and save
  /// their prepared message in .git/MERGE_MSG so the next git-commit
  /// execution can present it to the user for them to amend if they
  /// wish.
  ///
  /// Use this function to get the contents of this file. Don't forget to
  /// remove the file after you create the commit.
  ///
  /// @param out git_buf to write data into
  /// @param repo Repository to read prepared message from
  /// @return 0, GIT_ENOTFOUND if no message exists or an error code
  int git_repository_message(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_message(
      out,
      repo,
    );
  }

  late final _git_repository_message_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_message>>(
          'git_repository_message');
  late final _dart_git_repository_message _git_repository_message =
      _git_repository_message_ptr.asFunction<_dart_git_repository_message>();

  /// Remove git's prepared message.
  ///
  /// Remove the message that `git_repository_message` retrieves.
  int git_repository_message_remove(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_message_remove(
      repo,
    );
  }

  late final _git_repository_message_remove_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_message_remove>>(
          'git_repository_message_remove');
  late final _dart_git_repository_message_remove
      _git_repository_message_remove = _git_repository_message_remove_ptr
          .asFunction<_dart_git_repository_message_remove>();

  /// Remove all the metadata associated with an ongoing command like merge,
  /// revert, cherry-pick, etc.  For example: MERGE_HEAD, MERGE_MSG, etc.
  ///
  /// @param repo A repository object
  /// @return 0 on success, or error
  int git_repository_state_cleanup(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state_cleanup(
      repo,
    );
  }

  late final _git_repository_state_cleanup_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_state_cleanup>>(
          'git_repository_state_cleanup');
  late final _dart_git_repository_state_cleanup _git_repository_state_cleanup =
      _git_repository_state_cleanup_ptr
          .asFunction<_dart_git_repository_state_cleanup>();

  /// Invoke 'callback' for each entry in the given FETCH_HEAD file.
  ///
  /// Return a non-zero value from the callback to stop the loop.
  ///
  /// @param repo A repository object
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  /// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
  /// there is no FETCH_HEAD file, or other error code.
  int git_repository_fetchhead_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.NativeFunction<git_repository_fetchhead_foreach_cb>>
        callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_repository_fetchhead_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_repository_fetchhead_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_fetchhead_foreach>>(
          'git_repository_fetchhead_foreach');
  late final _dart_git_repository_fetchhead_foreach
      _git_repository_fetchhead_foreach = _git_repository_fetchhead_foreach_ptr
          .asFunction<_dart_git_repository_fetchhead_foreach>();

  /// If a merge is in progress, invoke 'callback' for each commit ID in the
  /// MERGE_HEAD file.
  ///
  /// Return a non-zero value from the callback to stop the loop.
  ///
  /// @param repo A repository object
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  /// @return 0 on success, non-zero callback return value, GIT_ENOTFOUND if
  /// there is no MERGE_HEAD file, or other error code.
  int git_repository_mergehead_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.NativeFunction<git_repository_mergehead_foreach_cb>>
        callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_repository_mergehead_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_repository_mergehead_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_mergehead_foreach>>(
          'git_repository_mergehead_foreach');
  late final _dart_git_repository_mergehead_foreach
      _git_repository_mergehead_foreach = _git_repository_mergehead_foreach_ptr
          .asFunction<_dart_git_repository_mergehead_foreach>();

  /// Calculate hash of file using repository filtering rules.
  ///
  /// If you simply want to calculate the hash of a file on disk with no filters,
  /// you can just use the `git_odb_hashfile()` API.  However, if you want to
  /// hash a file in the repository and you want to apply filtering rules (e.g.
  /// crlf filters) before generating the SHA, then use this function.
  ///
  /// Note: if the repository has `core.safecrlf` set to fail and the
  /// filtering triggers that failure, then this function will return an
  /// error and not calculate the hash of the file.
  ///
  /// @param out Output value of calculated SHA
  /// @param repo Repository pointer
  /// @param path Path to file on disk whose contents should be hashed. If the
  /// repository is not NULL, this can be a relative path.
  /// @param type The object type to hash as (e.g. GIT_OBJECT_BLOB)
  /// @param as_path The path to use to look up filtering rules. If this is
  /// NULL, then the `path` parameter will be used instead. If
  /// this is passed as the empty string, then no filters will be
  /// applied when calculating the hash.
  /// @return 0 on success, or an error code
  int git_repository_hashfile(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> path,
    int type,
    ffi.Pointer<ffi.Int8> as_path,
  ) {
    return _git_repository_hashfile(
      out,
      repo,
      path,
      type,
      as_path,
    );
  }

  late final _git_repository_hashfile_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_hashfile>>(
          'git_repository_hashfile');
  late final _dart_git_repository_hashfile _git_repository_hashfile =
      _git_repository_hashfile_ptr.asFunction<_dart_git_repository_hashfile>();

  /// Make the repository HEAD point to the specified reference.
  ///
  /// If the provided reference points to a Tree or a Blob, the HEAD is
  /// unaltered and -1 is returned.
  ///
  /// If the provided reference points to a branch, the HEAD will point
  /// to that branch, staying attached, or become attached if it isn't yet.
  /// If the branch doesn't exist yet, no error will be return. The HEAD
  /// will then be attached to an unborn branch.
  ///
  /// Otherwise, the HEAD will be detached and will directly point to
  /// the Commit.
  ///
  /// @param repo Repository pointer
  /// @param refname Canonical name of the reference the HEAD should point at
  /// @return 0 on success, or an error code
  int git_repository_set_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_repository_set_head(
      repo,
      refname,
    );
  }

  late final _git_repository_set_head_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_set_head>>(
          'git_repository_set_head');
  late final _dart_git_repository_set_head _git_repository_set_head =
      _git_repository_set_head_ptr.asFunction<_dart_git_repository_set_head>();

  /// Make the repository HEAD directly point to the Commit.
  ///
  /// If the provided committish cannot be found in the repository, the HEAD
  /// is unaltered and GIT_ENOTFOUND is returned.
  ///
  /// If the provided commitish cannot be peeled into a commit, the HEAD
  /// is unaltered and -1 is returned.
  ///
  /// Otherwise, the HEAD will eventually be detached and will directly point to
  /// the peeled Commit.
  ///
  /// @param repo Repository pointer
  /// @param commitish Object id of the Commit the HEAD should point to
  /// @return 0 on success, or an error code
  int git_repository_set_head_detached(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> commitish,
  ) {
    return _git_repository_set_head_detached(
      repo,
      commitish,
    );
  }

  late final _git_repository_set_head_detached_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_set_head_detached>>(
          'git_repository_set_head_detached');
  late final _dart_git_repository_set_head_detached
      _git_repository_set_head_detached = _git_repository_set_head_detached_ptr
          .asFunction<_dart_git_repository_set_head_detached>();

  /// Make the repository HEAD directly point to the Commit.
  ///
  /// This behaves like `git_repository_set_head_detached()` but takes an
  /// annotated commit, which lets you specify which extended sha syntax
  /// string was specified by a user, allowing for more exact reflog
  /// messages.
  ///
  /// See the documentation for `git_repository_set_head_detached()`.
  ///
  /// @see git_repository_set_head_detached
  int git_repository_set_head_detached_from_annotated(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_annotated_commit> commitish,
  ) {
    return _git_repository_set_head_detached_from_annotated(
      repo,
      commitish,
    );
  }

  late final _git_repository_set_head_detached_from_annotated_ptr = _lookup<
          ffi.NativeFunction<
              _c_git_repository_set_head_detached_from_annotated>>(
      'git_repository_set_head_detached_from_annotated');
  late final _dart_git_repository_set_head_detached_from_annotated
      _git_repository_set_head_detached_from_annotated =
      _git_repository_set_head_detached_from_annotated_ptr
          .asFunction<_dart_git_repository_set_head_detached_from_annotated>();

  /// Detach the HEAD.
  ///
  /// If the HEAD is already detached and points to a Commit, 0 is returned.
  ///
  /// If the HEAD is already detached and points to a Tag, the HEAD is
  /// updated into making it point to the peeled Commit, and 0 is returned.
  ///
  /// If the HEAD is already detached and points to a non commitish, the HEAD is
  /// unaltered, and -1 is returned.
  ///
  /// Otherwise, the HEAD will be detached and point to the peeled Commit.
  ///
  /// @param repo Repository pointer
  /// @return 0 on success, GIT_EUNBORNBRANCH when HEAD points to a non existing
  /// branch or an error code
  int git_repository_detach_head(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_detach_head(
      repo,
    );
  }

  late final _git_repository_detach_head_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_detach_head>>(
          'git_repository_detach_head');
  late final _dart_git_repository_detach_head _git_repository_detach_head =
      _git_repository_detach_head_ptr
          .asFunction<_dart_git_repository_detach_head>();

  /// Determines the status of a git repository - ie, whether an operation
  /// (merge, cherry-pick, etc) is in progress.
  ///
  /// @param repo Repository pointer
  /// @return The state of the repository
  int git_repository_state(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_state(
      repo,
    );
  }

  late final _git_repository_state_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_state>>(
          'git_repository_state');
  late final _dart_git_repository_state _git_repository_state =
      _git_repository_state_ptr.asFunction<_dart_git_repository_state>();

  /// Sets the active namespace for this Git Repository
  ///
  /// This namespace affects all reference operations for the repo.
  /// See `man gitnamespaces`
  ///
  /// @param repo The repo
  /// @param nmspace The namespace. This should not include the refs
  /// folder, e.g. to namespace all references under `refs/namespaces/foo/`,
  /// use `foo` as the namespace.
  /// @return 0 on success, -1 on error
  int git_repository_set_namespace(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> nmspace,
  ) {
    return _git_repository_set_namespace(
      repo,
      nmspace,
    );
  }

  late final _git_repository_set_namespace_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_set_namespace>>(
          'git_repository_set_namespace');
  late final _dart_git_repository_set_namespace _git_repository_set_namespace =
      _git_repository_set_namespace_ptr
          .asFunction<_dart_git_repository_set_namespace>();

  /// Get the currently active namespace for this repository
  ///
  /// @param repo The repo
  /// @return the active namespace, or NULL if there isn't one
  ffi.Pointer<ffi.Int8> git_repository_get_namespace(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_get_namespace(
      repo,
    );
  }

  late final _git_repository_get_namespace_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_get_namespace>>(
          'git_repository_get_namespace');
  late final _dart_git_repository_get_namespace _git_repository_get_namespace =
      _git_repository_get_namespace_ptr
          .asFunction<_dart_git_repository_get_namespace>();

  /// Determine if the repository was a shallow clone
  ///
  /// @param repo The repository
  /// @return 1 if shallow, zero if not
  int git_repository_is_shallow(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_is_shallow(
      repo,
    );
  }

  late final _git_repository_is_shallow_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_is_shallow>>(
          'git_repository_is_shallow');
  late final _dart_git_repository_is_shallow _git_repository_is_shallow =
      _git_repository_is_shallow_ptr
          .asFunction<_dart_git_repository_is_shallow>();

  /// Retrieve the configured identity to use for reflogs
  ///
  /// The memory is owned by the repository and must not be freed by the
  /// user.
  ///
  /// @param name where to store the pointer to the name
  /// @param email where to store the pointer to the email
  /// @param repo the repository
  int git_repository_ident(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> name,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> email,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_repository_ident(
      name,
      email,
      repo,
    );
  }

  late final _git_repository_ident_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_ident>>(
          'git_repository_ident');
  late final _dart_git_repository_ident _git_repository_ident =
      _git_repository_ident_ptr.asFunction<_dart_git_repository_ident>();

  /// Set the identity to be used for writing reflogs
  ///
  /// If both are set, this name and email will be used to write to the
  /// reflog. Pass NULL to unset. When unset, the identity will be taken
  /// from the repository's configuration.
  ///
  /// @param repo the repository to configure
  /// @param name the name to use for the reflog entries
  /// @param email the email to use for the reflog entries
  int git_repository_set_ident(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> email,
  ) {
    return _git_repository_set_ident(
      repo,
      name,
      email,
    );
  }

  late final _git_repository_set_ident_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_set_ident>>(
          'git_repository_set_ident');
  late final _dart_git_repository_set_ident _git_repository_set_ident =
      _git_repository_set_ident_ptr
          .asFunction<_dart_git_repository_set_ident>();

  /// Creates a `git_annotated_commit` from the given reference.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given reference
  /// @param ref reference to use to lookup the git_annotated_commit
  /// @return 0 on success or error code
  int git_annotated_commit_from_ref(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_annotated_commit_from_ref(
      out,
      repo,
      ref,
    );
  }

  late final _git_annotated_commit_from_ref_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_from_ref>>(
          'git_annotated_commit_from_ref');
  late final _dart_git_annotated_commit_from_ref
      _git_annotated_commit_from_ref = _git_annotated_commit_from_ref_ptr
          .asFunction<_dart_git_annotated_commit_from_ref>();

  /// Creates a `git_annotated_commit` from the given fetch head data.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given commit
  /// @param branch_name name of the (remote) branch
  /// @param remote_url url of the remote
  /// @param id the commit object id of the remote branch
  /// @return 0 on success or error code
  int git_annotated_commit_from_fetchhead(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> branch_name,
    ffi.Pointer<ffi.Int8> remote_url,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_annotated_commit_from_fetchhead(
      out,
      repo,
      branch_name,
      remote_url,
      id,
    );
  }

  late final _git_annotated_commit_from_fetchhead_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_from_fetchhead>>(
          'git_annotated_commit_from_fetchhead');
  late final _dart_git_annotated_commit_from_fetchhead
      _git_annotated_commit_from_fetchhead =
      _git_annotated_commit_from_fetchhead_ptr
          .asFunction<_dart_git_annotated_commit_from_fetchhead>();

  /// Creates a `git_annotated_commit` from the given commit id.
  /// The resulting git_annotated_commit must be freed with
  /// `git_annotated_commit_free`.
  ///
  /// An annotated commit contains information about how it was
  /// looked up, which may be useful for functions like merge or
  /// rebase to provide context to the operation.  For example,
  /// conflict files will include the name of the source or target
  /// branches being merged.  It is therefore preferable to use the
  /// most specific function (eg `git_annotated_commit_from_ref`)
  /// instead of this one when that data is known.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given commit
  /// @param id the commit object id to lookup
  /// @return 0 on success or error code
  int git_annotated_commit_lookup(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_annotated_commit_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_annotated_commit_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_lookup>>(
          'git_annotated_commit_lookup');
  late final _dart_git_annotated_commit_lookup _git_annotated_commit_lookup =
      _git_annotated_commit_lookup_ptr
          .asFunction<_dart_git_annotated_commit_lookup>();

  /// Creates a `git_annotated_commit` from a revision string.
  ///
  /// See `man gitrevisions`, or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// @param out pointer to store the git_annotated_commit result in
  /// @param repo repository that contains the given commit
  /// @param revspec the extended sha syntax string to use to lookup the commit
  /// @return 0 on success or error code
  int git_annotated_commit_from_revspec(
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> revspec,
  ) {
    return _git_annotated_commit_from_revspec(
      out,
      repo,
      revspec,
    );
  }

  late final _git_annotated_commit_from_revspec_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_from_revspec>>(
          'git_annotated_commit_from_revspec');
  late final _dart_git_annotated_commit_from_revspec
      _git_annotated_commit_from_revspec =
      _git_annotated_commit_from_revspec_ptr
          .asFunction<_dart_git_annotated_commit_from_revspec>();

  /// Gets the commit ID that the given `git_annotated_commit` refers to.
  ///
  /// @param commit the given annotated commit
  /// @return commit id
  ffi.Pointer<git_oid> git_annotated_commit_id(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_id(
      commit,
    );
  }

  late final _git_annotated_commit_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_id>>(
          'git_annotated_commit_id');
  late final _dart_git_annotated_commit_id _git_annotated_commit_id =
      _git_annotated_commit_id_ptr.asFunction<_dart_git_annotated_commit_id>();

  /// Get the refname that the given `git_annotated_commit` refers to.
  ///
  /// @param commit the given annotated commit
  /// @return ref name.
  ffi.Pointer<ffi.Int8> git_annotated_commit_ref(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_ref(
      commit,
    );
  }

  late final _git_annotated_commit_ref_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_ref>>(
          'git_annotated_commit_ref');
  late final _dart_git_annotated_commit_ref _git_annotated_commit_ref =
      _git_annotated_commit_ref_ptr
          .asFunction<_dart_git_annotated_commit_ref>();

  /// Frees a `git_annotated_commit`.
  ///
  /// @param commit annotated commit to free
  void git_annotated_commit_free(
    ffi.Pointer<git_annotated_commit> commit,
  ) {
    return _git_annotated_commit_free(
      commit,
    );
  }

  late final _git_annotated_commit_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_annotated_commit_free>>(
          'git_annotated_commit_free');
  late final _dart_git_annotated_commit_free _git_annotated_commit_free =
      _git_annotated_commit_free_ptr
          .asFunction<_dart_git_annotated_commit_free>();

  /// Lookup a reference to one of the objects in a repository.
  ///
  /// The generated reference is owned by the repository and
  /// should be closed with the `git_object_free` method
  /// instead of free'd manually.
  ///
  /// The 'type' parameter must match the type of the object
  /// in the odb; the method will fail otherwise.
  /// The special value 'GIT_OBJECT_ANY' may be passed to let
  /// the method guess the object's type.
  ///
  /// @param object pointer to the looked-up object
  /// @param repo the repository to look up the object
  /// @param id the unique identifier for the object
  /// @param type the type of the object
  /// @return 0 or an error code
  int git_object_lookup(
    ffi.Pointer<ffi.Pointer<git_object>> object,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int type,
  ) {
    return _git_object_lookup(
      object,
      repo,
      id,
      type,
    );
  }

  late final _git_object_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_lookup>>('git_object_lookup');
  late final _dart_git_object_lookup _git_object_lookup =
      _git_object_lookup_ptr.asFunction<_dart_git_object_lookup>();

  /// Lookup a reference to one of the objects in a repository,
  /// given a prefix of its identifier (short id).
  ///
  /// The object obtained will be so that its identifier
  /// matches the first 'len' hexadecimal characters
  /// (packets of 4 bits) of the given 'id'.
  /// 'len' must be at least GIT_OID_MINPREFIXLEN, and
  /// long enough to identify a unique object matching
  /// the prefix; otherwise the method will fail.
  ///
  /// The generated reference is owned by the repository and
  /// should be closed with the `git_object_free` method
  /// instead of free'd manually.
  ///
  /// The 'type' parameter must match the type of the object
  /// in the odb; the method will fail otherwise.
  /// The special value 'GIT_OBJECT_ANY' may be passed to let
  /// the method guess the object's type.
  ///
  /// @param object_out pointer where to store the looked-up object
  /// @param repo the repository to look up the object
  /// @param id a short identifier for the object
  /// @param len the length of the short identifier
  /// @param type the type of the object
  /// @return 0 or an error code
  int git_object_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_object>> object_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
    int type,
  ) {
    return _git_object_lookup_prefix(
      object_out,
      repo,
      id,
      len,
      type,
    );
  }

  late final _git_object_lookup_prefix_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_lookup_prefix>>(
          'git_object_lookup_prefix');
  late final _dart_git_object_lookup_prefix _git_object_lookup_prefix =
      _git_object_lookup_prefix_ptr
          .asFunction<_dart_git_object_lookup_prefix>();

  /// Lookup an object that represents a tree entry.
  ///
  /// @param out buffer that receives a pointer to the object (which must be freed
  /// by the caller)
  /// @param treeish root object that can be peeled to a tree
  /// @param path relative path from the root object to the desired object
  /// @param type type of object desired
  /// @return 0 on success, or an error code
  int git_object_lookup_bypath(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_object> treeish,
    ffi.Pointer<ffi.Int8> path,
    int type,
  ) {
    return _git_object_lookup_bypath(
      out,
      treeish,
      path,
      type,
    );
  }

  late final _git_object_lookup_bypath_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_lookup_bypath>>(
          'git_object_lookup_bypath');
  late final _dart_git_object_lookup_bypath _git_object_lookup_bypath =
      _git_object_lookup_bypath_ptr
          .asFunction<_dart_git_object_lookup_bypath>();

  /// Get the id (SHA1) of a repository object
  ///
  /// @param obj the repository object
  /// @return the SHA1 id
  ffi.Pointer<git_oid> git_object_id(
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_id(
      obj,
    );
  }

  late final _git_object_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_id>>('git_object_id');
  late final _dart_git_object_id _git_object_id =
      _git_object_id_ptr.asFunction<_dart_git_object_id>();

  /// Get a short abbreviated OID string for the object
  ///
  /// This starts at the "core.abbrev" length (default 7 characters) and
  /// iteratively extends to a longer string if that length is ambiguous.
  /// The result will be unambiguous (at least until new objects are added to
  /// the repository).
  ///
  /// @param out Buffer to write string into
  /// @param obj The object to get an ID for
  /// @return 0 on success, <0 for error
  int git_object_short_id(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_short_id(
      out,
      obj,
    );
  }

  late final _git_object_short_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_short_id>>(
          'git_object_short_id');
  late final _dart_git_object_short_id _git_object_short_id =
      _git_object_short_id_ptr.asFunction<_dart_git_object_short_id>();

  /// Get the object type of an object
  ///
  /// @param obj the repository object
  /// @return the object's type
  int git_object_type(
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_type(
      obj,
    );
  }

  late final _git_object_type_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_type>>('git_object_type');
  late final _dart_git_object_type _git_object_type =
      _git_object_type_ptr.asFunction<_dart_git_object_type>();

  /// Get the repository that owns this object
  ///
  /// Freeing or calling `git_repository_close` on the
  /// returned pointer will invalidate the actual object.
  ///
  /// Any other operation may be run on the repository without
  /// affecting the object.
  ///
  /// @param obj the object
  /// @return the repository who owns this object
  ffi.Pointer<git_repository> git_object_owner(
    ffi.Pointer<git_object> obj,
  ) {
    return _git_object_owner(
      obj,
    );
  }

  late final _git_object_owner_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_owner>>('git_object_owner');
  late final _dart_git_object_owner _git_object_owner =
      _git_object_owner_ptr.asFunction<_dart_git_object_owner>();

  /// Close an open object
  ///
  /// This method instructs the library to close an existing
  /// object; note that git_objects are owned and cached by the repository
  /// so the object may or may not be freed after this library call,
  /// depending on how aggressive is the caching mechanism used
  /// by the repository.
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop using
  /// an object. Failure to do so will cause a memory leak.
  ///
  /// @param object the object to close
  void git_object_free(
    ffi.Pointer<git_object> object,
  ) {
    return _git_object_free(
      object,
    );
  }

  late final _git_object_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_free>>('git_object_free');
  late final _dart_git_object_free _git_object_free =
      _git_object_free_ptr.asFunction<_dart_git_object_free>();

  /// Convert an object type to its string representation.
  ///
  /// The result is a pointer to a string in static memory and
  /// should not be free()'ed.
  ///
  /// @param type object type to convert.
  /// @return the corresponding string representation.
  ffi.Pointer<ffi.Int8> git_object_type2string(
    int type,
  ) {
    return _git_object_type2string(
      type,
    );
  }

  late final _git_object_type2string_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_type2string>>(
          'git_object_type2string');
  late final _dart_git_object_type2string _git_object_type2string =
      _git_object_type2string_ptr.asFunction<_dart_git_object_type2string>();

  /// Convert a string object type representation to it's git_object_t.
  ///
  /// @param str the string to convert.
  /// @return the corresponding git_object_t.
  int git_object_string2type(
    ffi.Pointer<ffi.Int8> str,
  ) {
    return _git_object_string2type(
      str,
    );
  }

  late final _git_object_string2type_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_string2type>>(
          'git_object_string2type');
  late final _dart_git_object_string2type _git_object_string2type =
      _git_object_string2type_ptr.asFunction<_dart_git_object_string2type>();

  /// Determine if the given git_object_t is a valid loose object type.
  ///
  /// @param type object type to test.
  /// @return true if the type represents a valid loose object type,
  /// false otherwise.
  int git_object_typeisloose(
    int type,
  ) {
    return _git_object_typeisloose(
      type,
    );
  }

  late final _git_object_typeisloose_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_typeisloose>>(
          'git_object_typeisloose');
  late final _dart_git_object_typeisloose _git_object_typeisloose =
      _git_object_typeisloose_ptr.asFunction<_dart_git_object_typeisloose>();

  /// Recursively peel an object until an object of the specified type is met.
  ///
  /// If the query cannot be satisfied due to the object model,
  /// GIT_EINVALIDSPEC will be returned (e.g. trying to peel a blob to a
  /// tree).
  ///
  /// If you pass `GIT_OBJECT_ANY` as the target type, then the object will
  /// be peeled until the type changes. A tag will be peeled until the
  /// referenced object is no longer a tag, and a commit will be peeled
  /// to a tree. Any other object type will return GIT_EINVALIDSPEC.
  ///
  /// If peeling a tag we discover an object which cannot be peeled to
  /// the target type due to the object model, GIT_EPEEL will be
  /// returned.
  ///
  /// You must free the returned object.
  ///
  /// @param peeled Pointer to the peeled git_object
  /// @param object The object to be processed
  /// @param target_type The type of the requested object (a GIT_OBJECT_ value)
  /// @return 0 on success, GIT_EINVALIDSPEC, GIT_EPEEL, or an error code
  int git_object_peel(
    ffi.Pointer<ffi.Pointer<git_object>> peeled,
    ffi.Pointer<git_object> object,
    int target_type,
  ) {
    return _git_object_peel(
      peeled,
      object,
      target_type,
    );
  }

  late final _git_object_peel_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_peel>>('git_object_peel');
  late final _dart_git_object_peel _git_object_peel =
      _git_object_peel_ptr.asFunction<_dart_git_object_peel>();

  /// Create an in-memory copy of a Git object. The copy must be
  /// explicitly free'd or it will leak.
  ///
  /// @param dest Pointer to store the copy of the object
  /// @param source Original object to copy
  int git_object_dup(
    ffi.Pointer<ffi.Pointer<git_object>> dest,
    ffi.Pointer<git_object> source,
  ) {
    return _git_object_dup(
      dest,
      source,
    );
  }

  late final _git_object_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_object_dup>>('git_object_dup');
  late final _dart_git_object_dup _git_object_dup =
      _git_object_dup_ptr.asFunction<_dart_git_object_dup>();

  /// Lookup a tree object from the repository.
  ///
  /// @param out Pointer to the looked up tree
  /// @param repo The repo to use when locating the tree.
  /// @param id Identity of the tree to locate.
  /// @return 0 or an error code
  int git_tree_lookup(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tree_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_tree_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_lookup>>('git_tree_lookup');
  late final _dart_git_tree_lookup _git_tree_lookup =
      _git_tree_lookup_ptr.asFunction<_dart_git_tree_lookup>();

  /// Lookup a tree object from the repository,
  /// given a prefix of its identifier (short id).
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param out pointer to the looked up tree
  /// @param repo the repo to use when locating the tree.
  /// @param id identity of the tree to locate.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_tree_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_tree_lookup_prefix(
      out,
      repo,
      id,
      len,
    );
  }

  late final _git_tree_lookup_prefix_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_lookup_prefix>>(
          'git_tree_lookup_prefix');
  late final _dart_git_tree_lookup_prefix _git_tree_lookup_prefix =
      _git_tree_lookup_prefix_ptr.asFunction<_dart_git_tree_lookup_prefix>();

  /// Close an open tree
  ///
  /// You can no longer use the git_tree pointer after this call.
  ///
  /// IMPORTANT: You MUST call this method when you stop using a tree to
  /// release memory. Failure to do so will cause a memory leak.
  ///
  /// @param tree The tree to close
  void git_tree_free(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_free(
      tree,
    );
  }

  late final _git_tree_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_free>>('git_tree_free');
  late final _dart_git_tree_free _git_tree_free =
      _git_tree_free_ptr.asFunction<_dart_git_tree_free>();

  /// Get the id of a tree.
  ///
  /// @param tree a previously loaded tree.
  /// @return object identity for the tree.
  ffi.Pointer<git_oid> git_tree_id(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_id(
      tree,
    );
  }

  late final _git_tree_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_id>>('git_tree_id');
  late final _dart_git_tree_id _git_tree_id =
      _git_tree_id_ptr.asFunction<_dart_git_tree_id>();

  /// Get the repository that contains the tree.
  ///
  /// @param tree A previously loaded tree.
  /// @return Repository that contains this tree.
  ffi.Pointer<git_repository> git_tree_owner(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_owner(
      tree,
    );
  }

  late final _git_tree_owner_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_owner>>('git_tree_owner');
  late final _dart_git_tree_owner _git_tree_owner =
      _git_tree_owner_ptr.asFunction<_dart_git_tree_owner>();

  /// Get the number of entries listed in a tree
  ///
  /// @param tree a previously loaded tree.
  /// @return the number of entries in the tree
  int git_tree_entrycount(
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_tree_entrycount(
      tree,
    );
  }

  late final _git_tree_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entrycount>>(
          'git_tree_entrycount');
  late final _dart_git_tree_entrycount _git_tree_entrycount =
      _git_tree_entrycount_ptr.asFunction<_dart_git_tree_entrycount>();

  /// Lookup a tree entry by its filename
  ///
  /// This returns a git_tree_entry that is owned by the git_tree.  You don't
  /// have to free it, but you must not use it after the git_tree is released.
  ///
  /// @param tree a previously loaded tree.
  /// @param filename the filename of the desired entry
  /// @return the tree entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_tree_entry_byname(
    ffi.Pointer<git_tree> tree,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    return _git_tree_entry_byname(
      tree,
      filename,
    );
  }

  late final _git_tree_entry_byname_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_byname>>(
          'git_tree_entry_byname');
  late final _dart_git_tree_entry_byname _git_tree_entry_byname =
      _git_tree_entry_byname_ptr.asFunction<_dart_git_tree_entry_byname>();

  /// Lookup a tree entry by its position in the tree
  ///
  /// This returns a git_tree_entry that is owned by the git_tree.  You don't
  /// have to free it, but you must not use it after the git_tree is released.
  ///
  /// @param tree a previously loaded tree.
  /// @param idx the position in the entry list
  /// @return the tree entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_tree_entry_byindex(
    ffi.Pointer<git_tree> tree,
    int idx,
  ) {
    return _git_tree_entry_byindex(
      tree,
      idx,
    );
  }

  late final _git_tree_entry_byindex_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_byindex>>(
          'git_tree_entry_byindex');
  late final _dart_git_tree_entry_byindex _git_tree_entry_byindex =
      _git_tree_entry_byindex_ptr.asFunction<_dart_git_tree_entry_byindex>();

  /// Lookup a tree entry by SHA value.
  ///
  /// This returns a git_tree_entry that is owned by the git_tree.  You don't
  /// have to free it, but you must not use it after the git_tree is released.
  ///
  /// Warning: this must examine every entry in the tree, so it is not fast.
  ///
  /// @param tree a previously loaded tree.
  /// @param id the sha being looked for
  /// @return the tree entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_tree_entry_byid(
    ffi.Pointer<git_tree> tree,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tree_entry_byid(
      tree,
      id,
    );
  }

  late final _git_tree_entry_byid_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_byid>>(
          'git_tree_entry_byid');
  late final _dart_git_tree_entry_byid _git_tree_entry_byid =
      _git_tree_entry_byid_ptr.asFunction<_dart_git_tree_entry_byid>();

  /// Retrieve a tree entry contained in a tree or in any of its subtrees,
  /// given its relative path.
  ///
  /// Unlike the other lookup functions, the returned tree entry is owned by
  /// the user and must be freed explicitly with `git_tree_entry_free()`.
  ///
  /// @param out Pointer where to store the tree entry
  /// @param root Previously loaded tree which is the root of the relative path
  /// @param path Path to the contained entry
  /// @return 0 on success; GIT_ENOTFOUND if the path does not exist
  int git_tree_entry_bypath(
    ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
    ffi.Pointer<git_tree> root,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_tree_entry_bypath(
      out,
      root,
      path,
    );
  }

  late final _git_tree_entry_bypath_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_bypath>>(
          'git_tree_entry_bypath');
  late final _dart_git_tree_entry_bypath _git_tree_entry_bypath =
      _git_tree_entry_bypath_ptr.asFunction<_dart_git_tree_entry_bypath>();

  /// Duplicate a tree entry
  ///
  /// Create a copy of a tree entry. The returned copy is owned by the user,
  /// and must be freed explicitly with `git_tree_entry_free()`.
  ///
  /// @param dest pointer where to store the copy
  /// @param source tree entry to duplicate
  /// @return 0 or an error code
  int git_tree_entry_dup(
    ffi.Pointer<ffi.Pointer<git_tree_entry>> dest,
    ffi.Pointer<git_tree_entry> source,
  ) {
    return _git_tree_entry_dup(
      dest,
      source,
    );
  }

  late final _git_tree_entry_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_dup>>('git_tree_entry_dup');
  late final _dart_git_tree_entry_dup _git_tree_entry_dup =
      _git_tree_entry_dup_ptr.asFunction<_dart_git_tree_entry_dup>();

  /// Free a user-owned tree entry
  ///
  /// IMPORTANT: This function is only needed for tree entries owned by the
  /// user, such as the ones returned by `git_tree_entry_dup()` or
  /// `git_tree_entry_bypath()`.
  ///
  /// @param entry The entry to free
  void git_tree_entry_free(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_free(
      entry,
    );
  }

  late final _git_tree_entry_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_free>>(
          'git_tree_entry_free');
  late final _dart_git_tree_entry_free _git_tree_entry_free =
      _git_tree_entry_free_ptr.asFunction<_dart_git_tree_entry_free>();

  /// Get the filename of a tree entry
  ///
  /// @param entry a tree entry
  /// @return the name of the file
  ffi.Pointer<ffi.Int8> git_tree_entry_name(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_name(
      entry,
    );
  }

  late final _git_tree_entry_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_name>>(
          'git_tree_entry_name');
  late final _dart_git_tree_entry_name _git_tree_entry_name =
      _git_tree_entry_name_ptr.asFunction<_dart_git_tree_entry_name>();

  /// Get the id of the object pointed by the entry
  ///
  /// @param entry a tree entry
  /// @return the oid of the object
  ffi.Pointer<git_oid> git_tree_entry_id(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_id(
      entry,
    );
  }

  late final _git_tree_entry_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_id>>('git_tree_entry_id');
  late final _dart_git_tree_entry_id _git_tree_entry_id =
      _git_tree_entry_id_ptr.asFunction<_dart_git_tree_entry_id>();

  /// Get the type of the object pointed by the entry
  ///
  /// @param entry a tree entry
  /// @return the type of the pointed object
  int git_tree_entry_type(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_type(
      entry,
    );
  }

  late final _git_tree_entry_type_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_type>>(
          'git_tree_entry_type');
  late final _dart_git_tree_entry_type _git_tree_entry_type =
      _git_tree_entry_type_ptr.asFunction<_dart_git_tree_entry_type>();

  /// Get the UNIX file attributes of a tree entry
  ///
  /// @param entry a tree entry
  /// @return filemode as an integer
  int git_tree_entry_filemode(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_filemode(
      entry,
    );
  }

  late final _git_tree_entry_filemode_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_filemode>>(
          'git_tree_entry_filemode');
  late final _dart_git_tree_entry_filemode _git_tree_entry_filemode =
      _git_tree_entry_filemode_ptr.asFunction<_dart_git_tree_entry_filemode>();

  /// Get the raw UNIX file attributes of a tree entry
  ///
  /// This function does not perform any normalization and is only useful
  /// if you need to be able to recreate the original tree object.
  ///
  /// @param entry a tree entry
  /// @return filemode as an integer
  int git_tree_entry_filemode_raw(
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_filemode_raw(
      entry,
    );
  }

  late final _git_tree_entry_filemode_raw_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_filemode_raw>>(
          'git_tree_entry_filemode_raw');
  late final _dart_git_tree_entry_filemode_raw _git_tree_entry_filemode_raw =
      _git_tree_entry_filemode_raw_ptr
          .asFunction<_dart_git_tree_entry_filemode_raw>();

  /// Compare two tree entries
  ///
  /// @param e1 first tree entry
  /// @param e2 second tree entry
  /// @return <0 if e1 is before e2, 0 if e1 == e2, >0 if e1 is after e2
  int git_tree_entry_cmp(
    ffi.Pointer<git_tree_entry> e1,
    ffi.Pointer<git_tree_entry> e2,
  ) {
    return _git_tree_entry_cmp(
      e1,
      e2,
    );
  }

  late final _git_tree_entry_cmp_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_cmp>>('git_tree_entry_cmp');
  late final _dart_git_tree_entry_cmp _git_tree_entry_cmp =
      _git_tree_entry_cmp_ptr.asFunction<_dart_git_tree_entry_cmp>();

  /// Convert a tree entry to the git_object it points to.
  ///
  /// You must call `git_object_free()` on the object when you are done with it.
  ///
  /// @param object_out pointer to the converted object
  /// @param repo repository where to lookup the pointed object
  /// @param entry a tree entry
  /// @return 0 or an error code
  int git_tree_entry_to_object(
    ffi.Pointer<ffi.Pointer<git_object>> object_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree_entry> entry,
  ) {
    return _git_tree_entry_to_object(
      object_out,
      repo,
      entry,
    );
  }

  late final _git_tree_entry_to_object_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_entry_to_object>>(
          'git_tree_entry_to_object');
  late final _dart_git_tree_entry_to_object _git_tree_entry_to_object =
      _git_tree_entry_to_object_ptr
          .asFunction<_dart_git_tree_entry_to_object>();

  /// Create a new tree builder.
  ///
  /// The tree builder can be used to create or modify trees in memory and
  /// write them as tree objects to the database.
  ///
  /// If the `source` parameter is not NULL, the tree builder will be
  /// initialized with the entries of the given tree.
  ///
  /// If the `source` parameter is NULL, the tree builder will start with no
  /// entries and will have to be filled manually.
  ///
  /// @param out Pointer where to store the tree builder
  /// @param repo Repository in which to store the object
  /// @param source Source tree to initialize the builder (optional)
  /// @return 0 on success; error code otherwise
  int git_treebuilder_new(
    ffi.Pointer<ffi.Pointer<git_treebuilder>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> source,
  ) {
    return _git_treebuilder_new(
      out,
      repo,
      source,
    );
  }

  late final _git_treebuilder_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_new>>(
          'git_treebuilder_new');
  late final _dart_git_treebuilder_new _git_treebuilder_new =
      _git_treebuilder_new_ptr.asFunction<_dart_git_treebuilder_new>();

  /// Clear all the entires in the builder
  ///
  /// @param bld Builder to clear
  /// @return 0 on success; error code otherwise
  int git_treebuilder_clear(
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_clear(
      bld,
    );
  }

  late final _git_treebuilder_clear_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_clear>>(
          'git_treebuilder_clear');
  late final _dart_git_treebuilder_clear _git_treebuilder_clear =
      _git_treebuilder_clear_ptr.asFunction<_dart_git_treebuilder_clear>();

  /// Get the number of entries listed in a treebuilder
  ///
  /// @param bld a previously loaded treebuilder.
  /// @return the number of entries in the treebuilder
  int git_treebuilder_entrycount(
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_entrycount(
      bld,
    );
  }

  late final _git_treebuilder_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_entrycount>>(
          'git_treebuilder_entrycount');
  late final _dart_git_treebuilder_entrycount _git_treebuilder_entrycount =
      _git_treebuilder_entrycount_ptr
          .asFunction<_dart_git_treebuilder_entrycount>();

  /// Free a tree builder
  ///
  /// This will clear all the entries and free to builder.
  /// Failing to free the builder after you're done using it
  /// will result in a memory leak
  ///
  /// @param bld Builder to free
  void git_treebuilder_free(
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_free(
      bld,
    );
  }

  late final _git_treebuilder_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_free>>(
          'git_treebuilder_free');
  late final _dart_git_treebuilder_free _git_treebuilder_free =
      _git_treebuilder_free_ptr.asFunction<_dart_git_treebuilder_free>();

  /// Get an entry from the builder from its filename
  ///
  /// The returned entry is owned by the builder and should
  /// not be freed manually.
  ///
  /// @param bld Tree builder
  /// @param filename Name of the entry
  /// @return pointer to the entry; NULL if not found
  ffi.Pointer<git_tree_entry> git_treebuilder_get(
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    return _git_treebuilder_get(
      bld,
      filename,
    );
  }

  late final _git_treebuilder_get_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_get>>(
          'git_treebuilder_get');
  late final _dart_git_treebuilder_get _git_treebuilder_get =
      _git_treebuilder_get_ptr.asFunction<_dart_git_treebuilder_get>();

  /// Add or update an entry to the builder
  ///
  /// Insert a new entry for `filename` in the builder with the
  /// given attributes.
  ///
  /// If an entry named `filename` already exists, its attributes
  /// will be updated with the given ones.
  ///
  /// The optional pointer `out` can be used to retrieve a pointer to the
  /// newly created/updated entry.  Pass NULL if you do not need it. The
  /// pointer may not be valid past the next operation in this
  /// builder. Duplicate the entry if you want to keep it.
  ///
  /// By default the entry that you are inserting will be checked for
  /// validity; that it exists in the object database and is of the
  /// correct type.  If you do not want this behavior, set the
  /// `GIT_OPT_ENABLE_STRICT_OBJECT_CREATION` library option to false.
  ///
  /// @param out Pointer to store the entry (optional)
  /// @param bld Tree builder
  /// @param filename Filename of the entry
  /// @param id SHA1 oid of the entry
  /// @param filemode Folder attributes of the entry. This parameter must
  /// be valued with one of the following entries: 0040000, 0100644,
  /// 0100755, 0120000 or 0160000.
  /// @return 0 or an error code
  int git_treebuilder_insert(
    ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<git_oid> id,
    int filemode,
  ) {
    return _git_treebuilder_insert(
      out,
      bld,
      filename,
      id,
      filemode,
    );
  }

  late final _git_treebuilder_insert_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_insert>>(
          'git_treebuilder_insert');
  late final _dart_git_treebuilder_insert _git_treebuilder_insert =
      _git_treebuilder_insert_ptr.asFunction<_dart_git_treebuilder_insert>();

  /// Remove an entry from the builder by its filename
  ///
  /// @param bld Tree builder
  /// @param filename Filename of the entry to remove
  int git_treebuilder_remove(
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    return _git_treebuilder_remove(
      bld,
      filename,
    );
  }

  late final _git_treebuilder_remove_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_remove>>(
          'git_treebuilder_remove');
  late final _dart_git_treebuilder_remove _git_treebuilder_remove =
      _git_treebuilder_remove_ptr.asFunction<_dart_git_treebuilder_remove>();

  /// Selectively remove entries in the tree
  ///
  /// The `filter` callback will be called for each entry in the tree with a
  /// pointer to the entry and the provided `payload`; if the callback returns
  /// non-zero, the entry will be filtered (removed from the builder).
  ///
  /// @param bld Tree builder
  /// @param filter Callback to filter entries
  /// @param payload Extra data to pass to filter callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_treebuilder_filter(
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<ffi.NativeFunction<git_treebuilder_filter_cb>> filter,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_treebuilder_filter(
      bld,
      filter,
      payload,
    );
  }

  late final _git_treebuilder_filter_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_filter>>(
          'git_treebuilder_filter');
  late final _dart_git_treebuilder_filter _git_treebuilder_filter =
      _git_treebuilder_filter_ptr.asFunction<_dart_git_treebuilder_filter>();

  /// Write the contents of the tree builder as a tree object
  ///
  /// The tree builder will be written to the given `repo`, and its
  /// identifying SHA1 hash will be stored in the `id` pointer.
  ///
  /// @param id Pointer to store the OID of the newly written tree
  /// @param bld Tree builder to write
  /// @return 0 or an error code
  int git_treebuilder_write(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_treebuilder> bld,
  ) {
    return _git_treebuilder_write(
      id,
      bld,
    );
  }

  late final _git_treebuilder_write_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_write>>(
          'git_treebuilder_write');
  late final _dart_git_treebuilder_write _git_treebuilder_write =
      _git_treebuilder_write_ptr.asFunction<_dart_git_treebuilder_write>();

  /// Write the contents of the tree builder as a tree object
  /// using a shared git_buf.
  ///
  /// @see git_treebuilder_write
  ///
  /// @param oid Pointer to store the OID of the newly written tree
  /// @param bld Tree builder to write
  /// @param tree Shared buffer for writing the tree. Will be grown as necessary.
  /// @return 0 or an error code
  int git_treebuilder_write_with_buffer(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_treebuilder> bld,
    ffi.Pointer<git_buf> tree,
  ) {
    return _git_treebuilder_write_with_buffer(
      oid,
      bld,
      tree,
    );
  }

  late final _git_treebuilder_write_with_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_treebuilder_write_with_buffer>>(
          'git_treebuilder_write_with_buffer');
  late final _dart_git_treebuilder_write_with_buffer
      _git_treebuilder_write_with_buffer =
      _git_treebuilder_write_with_buffer_ptr
          .asFunction<_dart_git_treebuilder_write_with_buffer>();

  /// Traverse the entries in a tree and its subtrees in post or pre order.
  ///
  /// The entries will be traversed in the specified order, children subtrees
  /// will be automatically loaded as required, and the `callback` will be
  /// called once per entry with the current (relative) root for the entry and
  /// the entry data itself.
  ///
  /// If the callback returns a positive value, the passed entry will be
  /// skipped on the traversal (in pre mode). A negative value stops the walk.
  ///
  /// @param tree The tree to walk
  /// @param mode Traversal mode (pre or post-order)
  /// @param callback Function to call on each tree entry
  /// @param payload Opaque pointer to be passed on each callback
  /// @return 0 or an error code
  int git_tree_walk(
    ffi.Pointer<git_tree> tree,
    int mode,
    ffi.Pointer<ffi.NativeFunction<git_treewalk_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_tree_walk(
      tree,
      mode,
      callback,
      payload,
    );
  }

  late final _git_tree_walk_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_walk>>('git_tree_walk');
  late final _dart_git_tree_walk _git_tree_walk =
      _git_tree_walk_ptr.asFunction<_dart_git_tree_walk>();

  /// Create an in-memory copy of a tree. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the tree
  /// @param source Original tree to copy
  int git_tree_dup(
    ffi.Pointer<ffi.Pointer<git_tree>> out,
    ffi.Pointer<git_tree> source,
  ) {
    return _git_tree_dup(
      out,
      source,
    );
  }

  late final _git_tree_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_dup>>('git_tree_dup');
  late final _dart_git_tree_dup _git_tree_dup =
      _git_tree_dup_ptr.asFunction<_dart_git_tree_dup>();

  /// Create a tree based on another one with the specified modifications
  ///
  /// Given the `baseline` perform the changes described in the list of
  /// `updates` and create a new tree.
  ///
  /// This function is optimized for common file/directory addition, removal and
  /// replacement in trees. It is much more efficient than reading the tree into a
  /// `git_index` and modifying that, but in exchange it is not as flexible.
  ///
  /// Deleting and adding the same entry is undefined behaviour, changing
  /// a tree to a blob or viceversa is not supported.
  ///
  /// @param out id of the new tree
  /// @param repo the repository in which to create the tree, must be the
  /// same as for `baseline`
  /// @param baseline the tree to base these changes on
  /// @param nupdates the number of elements in the update list
  /// @param updates the list of updates to perform
  int git_tree_create_updated(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> baseline,
    int nupdates,
    ffi.Pointer<git_tree_update> updates,
  ) {
    return _git_tree_create_updated(
      out,
      repo,
      baseline,
      nupdates,
      updates,
    );
  }

  late final _git_tree_create_updated_ptr =
      _lookup<ffi.NativeFunction<_c_git_tree_create_updated>>(
          'git_tree_create_updated');
  late final _dart_git_tree_create_updated _git_tree_create_updated =
      _git_tree_create_updated_ptr.asFunction<_dart_git_tree_create_updated>();

  /// Free the strings contained in a string array.  This method should
  /// be called on `git_strarray` objects that were provided by the
  /// library.  Not doing so, will result in a memory leak.
  ///
  /// This does not free the `git_strarray` itself, since the library will
  /// never allocate that object directly itself.
  ///
  /// @param array The git_strarray that contains strings to free
  void git_strarray_dispose(
    ffi.Pointer<git_strarray> array,
  ) {
    return _git_strarray_dispose(
      array,
    );
  }

  late final _git_strarray_dispose_ptr =
      _lookup<ffi.NativeFunction<_c_git_strarray_dispose>>(
          'git_strarray_dispose');
  late final _dart_git_strarray_dispose _git_strarray_dispose =
      _git_strarray_dispose_ptr.asFunction<_dart_git_strarray_dispose>();

  /// Copy a string array object from source to target.
  ///
  /// Note: target is overwritten and hence should be empty, otherwise its
  /// contents are leaked.  Call git_strarray_free() if necessary.
  ///
  /// @param tgt target
  /// @param src source
  /// @return 0 on success, < 0 on allocation failure
  int git_strarray_copy(
    ffi.Pointer<git_strarray> tgt,
    ffi.Pointer<git_strarray> src,
  ) {
    return _git_strarray_copy(
      tgt,
      src,
    );
  }

  late final _git_strarray_copy_ptr =
      _lookup<ffi.NativeFunction<_c_git_strarray_copy>>('git_strarray_copy');
  late final _dart_git_strarray_copy _git_strarray_copy =
      _git_strarray_copy_ptr.asFunction<_dart_git_strarray_copy>();

  /// Lookup a reference by name in a repository.
  ///
  /// The returned reference must be freed by the user.
  ///
  /// The name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param out pointer to the looked-up reference
  /// @param repo the repository to look up the reference
  /// @param name the long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
  int git_reference_lookup(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_reference_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_reference_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_lookup>>(
          'git_reference_lookup');
  late final _dart_git_reference_lookup _git_reference_lookup =
      _git_reference_lookup_ptr.asFunction<_dart_git_reference_lookup>();

  /// Lookup a reference by name and resolve immediately to OID.
  ///
  /// This function provides a quick way to resolve a reference name straight
  /// through to the object id that it refers to.  This avoids having to
  /// allocate or free any `git_reference` objects for simple situations.
  ///
  /// The name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param out Pointer to oid to be filled in
  /// @param repo The repository in which to look up the reference
  /// @param name The long name for the reference (e.g. HEAD, refs/heads/master, refs/tags/v0.1.0, ...)
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code.
  int git_reference_name_to_id(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_reference_name_to_id(
      out,
      repo,
      name,
    );
  }

  late final _git_reference_name_to_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_name_to_id>>(
          'git_reference_name_to_id');
  late final _dart_git_reference_name_to_id _git_reference_name_to_id =
      _git_reference_name_to_id_ptr
          .asFunction<_dart_git_reference_name_to_id>();

  /// Lookup a reference by DWIMing its short name
  ///
  /// Apply the git precendence rules to the given shorthand to determine
  /// which reference the user is referring to.
  ///
  /// @param out pointer in which to store the reference
  /// @param repo the repository in which to look
  /// @param shorthand the short name for the reference
  /// @return 0 or an error code
  int git_reference_dwim(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> shorthand,
  ) {
    return _git_reference_dwim(
      out,
      repo,
      shorthand,
    );
  }

  late final _git_reference_dwim_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_dwim>>('git_reference_dwim');
  late final _dart_git_reference_dwim _git_reference_dwim =
      _git_reference_dwim_ptr.asFunction<_dart_git_reference_dwim>();

  /// Conditionally create a new symbolic reference.
  ///
  /// A symbolic reference is a reference name that refers to another
  /// reference name.  If the other name moves, the symbolic name will move,
  /// too.  As a simple example, the "HEAD" reference might refer to
  /// "refs/heads/master" while on the "master" branch of a repository.
  ///
  /// The symbolic reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// It will return GIT_EMODIFIED if the reference's value at the time
  /// of updating does not match the one passed through `current_value`
  /// (i.e. if the ref has changed since the user read it).
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param target The target of the reference
  /// @param force Overwrite existing references
  /// @param current_value The expected value of the reference when updating
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC, GIT_EMODIFIED or an error code
  int git_reference_symbolic_create_matching(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> target,
    int force,
    ffi.Pointer<ffi.Int8> current_value,
    ffi.Pointer<ffi.Int8> log_message,
  ) {
    return _git_reference_symbolic_create_matching(
      out,
      repo,
      name,
      target,
      force,
      current_value,
      log_message,
    );
  }

  late final _git_reference_symbolic_create_matching_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_symbolic_create_matching>>(
          'git_reference_symbolic_create_matching');
  late final _dart_git_reference_symbolic_create_matching
      _git_reference_symbolic_create_matching =
      _git_reference_symbolic_create_matching_ptr
          .asFunction<_dart_git_reference_symbolic_create_matching>();

  /// Create a new symbolic reference.
  ///
  /// A symbolic reference is a reference name that refers to another
  /// reference name.  If the other name moves, the symbolic name will move,
  /// too.  As a simple example, the "HEAD" reference might refer to
  /// "refs/heads/master" while on the "master" branch of a repository.
  ///
  /// The symbolic reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and it does not have a reflog.
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param target The target of the reference
  /// @param force Overwrite existing references
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
  int git_reference_symbolic_create(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> target,
    int force,
    ffi.Pointer<ffi.Int8> log_message,
  ) {
    return _git_reference_symbolic_create(
      out,
      repo,
      name,
      target,
      force,
      log_message,
    );
  }

  late final _git_reference_symbolic_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_symbolic_create>>(
          'git_reference_symbolic_create');
  late final _dart_git_reference_symbolic_create
      _git_reference_symbolic_create = _git_reference_symbolic_create_ptr
          .asFunction<_dart_git_reference_symbolic_create>();

  /// Create a new direct reference.
  ///
  /// A direct reference (also called an object id reference) refers directly
  /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
  /// permanently refers to the object (although the reference itself can be
  /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
  /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.
  ///
  /// The direct reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and and it does not have a reflog.
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param id The object id pointed to by the reference.
  /// @param force Overwrite existing references
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
  int git_reference_create(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<git_oid> id,
    int force,
    ffi.Pointer<ffi.Int8> log_message,
  ) {
    return _git_reference_create(
      out,
      repo,
      name,
      id,
      force,
      log_message,
    );
  }

  late final _git_reference_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_create>>(
          'git_reference_create');
  late final _dart_git_reference_create _git_reference_create =
      _git_reference_create_ptr.asFunction<_dart_git_reference_create>();

  /// Conditionally create new direct reference
  ///
  /// A direct reference (also called an object id reference) refers directly
  /// to a specific object id (a.k.a. OID or SHA) in the repository.  The id
  /// permanently refers to the object (although the reference itself can be
  /// moved).  For example, in libgit2 the direct ref "refs/tags/v0.17.0"
  /// refers to OID 5b9fac39d8a76b9139667c26a63e6b3f204b3977.
  ///
  /// The direct reference will be created in the repository and written to
  /// the disk.  The generated reference object must be freed by the user.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// This function will return an error if a reference already exists with the
  /// given name unless `force` is true, in which case it will be overwritten.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and and it does not have a reflog.
  ///
  /// It will return GIT_EMODIFIED if the reference's value at the time
  /// of updating does not match the one passed through `current_id`
  /// (i.e. if the ref has changed since the user read it).
  ///
  /// @param out Pointer to the newly created reference
  /// @param repo Repository where that reference will live
  /// @param name The name of the reference
  /// @param id The object id pointed to by the reference.
  /// @param force Overwrite existing references
  /// @param current_id The expected value of the reference at the time of update
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EMODIFIED if the value of the reference
  /// has changed, GIT_EEXISTS, GIT_EINVALIDSPEC or an error code
  int git_reference_create_matching(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<git_oid> id,
    int force,
    ffi.Pointer<git_oid> current_id,
    ffi.Pointer<ffi.Int8> log_message,
  ) {
    return _git_reference_create_matching(
      out,
      repo,
      name,
      id,
      force,
      current_id,
      log_message,
    );
  }

  late final _git_reference_create_matching_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_create_matching>>(
          'git_reference_create_matching');
  late final _dart_git_reference_create_matching
      _git_reference_create_matching = _git_reference_create_matching_ptr
          .asFunction<_dart_git_reference_create_matching>();

  /// Get the OID pointed to by a direct reference.
  ///
  /// Only available if the reference is direct (i.e. an object id reference,
  /// not a symbolic one).
  ///
  /// To find the OID of a symbolic ref, call `git_reference_resolve()` and
  /// then this function (or maybe use `git_reference_name_to_id()` to
  /// directly resolve a reference name all the way through to an OID).
  ///
  /// @param ref The reference
  /// @return a pointer to the oid if available, NULL otherwise
  ffi.Pointer<git_oid> git_reference_target(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_target(
      ref,
    );
  }

  late final _git_reference_target_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_target>>(
          'git_reference_target');
  late final _dart_git_reference_target _git_reference_target =
      _git_reference_target_ptr.asFunction<_dart_git_reference_target>();

  /// Return the peeled OID target of this reference.
  ///
  /// This peeled OID only applies to direct references that point to
  /// a hard Tag object: it is the result of peeling such Tag.
  ///
  /// @param ref The reference
  /// @return a pointer to the oid if available, NULL otherwise
  ffi.Pointer<git_oid> git_reference_target_peel(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_target_peel(
      ref,
    );
  }

  late final _git_reference_target_peel_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_target_peel>>(
          'git_reference_target_peel');
  late final _dart_git_reference_target_peel _git_reference_target_peel =
      _git_reference_target_peel_ptr
          .asFunction<_dart_git_reference_target_peel>();

  /// Get full name to the reference pointed to by a symbolic reference.
  ///
  /// Only available if the reference is symbolic.
  ///
  /// @param ref The reference
  /// @return a pointer to the name if available, NULL otherwise
  ffi.Pointer<ffi.Int8> git_reference_symbolic_target(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_symbolic_target(
      ref,
    );
  }

  late final _git_reference_symbolic_target_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_symbolic_target>>(
          'git_reference_symbolic_target');
  late final _dart_git_reference_symbolic_target
      _git_reference_symbolic_target = _git_reference_symbolic_target_ptr
          .asFunction<_dart_git_reference_symbolic_target>();

  /// Get the type of a reference.
  ///
  /// Either direct (GIT_REFERENCE_DIRECT) or symbolic (GIT_REFERENCE_SYMBOLIC)
  ///
  /// @param ref The reference
  /// @return the type
  int git_reference_type(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_type(
      ref,
    );
  }

  late final _git_reference_type_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_type>>('git_reference_type');
  late final _dart_git_reference_type _git_reference_type =
      _git_reference_type_ptr.asFunction<_dart_git_reference_type>();

  /// Get the full name of a reference.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param ref The reference
  /// @return the full name for the ref
  ffi.Pointer<ffi.Int8> git_reference_name(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_name(
      ref,
    );
  }

  late final _git_reference_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_name>>('git_reference_name');
  late final _dart_git_reference_name _git_reference_name =
      _git_reference_name_ptr.asFunction<_dart_git_reference_name>();

  /// Resolve a symbolic reference to a direct reference.
  ///
  /// This method iteratively peels a symbolic reference until it resolves to
  /// a direct reference to an OID.
  ///
  /// The peeled reference is returned in the `resolved_ref` argument, and
  /// must be freed manually once it's no longer needed.
  ///
  /// If a direct reference is passed as an argument, a copy of that
  /// reference is returned. This copy must be manually freed too.
  ///
  /// @param out Pointer to the peeled reference
  /// @param ref The reference
  /// @return 0 or an error code
  int git_reference_resolve(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_resolve(
      out,
      ref,
    );
  }

  late final _git_reference_resolve_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_resolve>>(
          'git_reference_resolve');
  late final _dart_git_reference_resolve _git_reference_resolve =
      _git_reference_resolve_ptr.asFunction<_dart_git_reference_resolve>();

  /// Get the repository where a reference resides.
  ///
  /// @param ref The reference
  /// @return a pointer to the repo
  ffi.Pointer<git_repository> git_reference_owner(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_owner(
      ref,
    );
  }

  late final _git_reference_owner_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_owner>>(
          'git_reference_owner');
  late final _dart_git_reference_owner _git_reference_owner =
      _git_reference_owner_ptr.asFunction<_dart_git_reference_owner>();

  /// Create a new reference with the same name as the given reference but a
  /// different symbolic target. The reference must be a symbolic reference,
  /// otherwise this will fail.
  ///
  /// The new reference will be written to disk, overwriting the given reference.
  ///
  /// The target name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// The message for the reflog will be ignored if the reference does
  /// not belong in the standard set (HEAD, branches and remote-tracking
  /// branches) and and it does not have a reflog.
  ///
  /// @param out Pointer to the newly created reference
  /// @param ref The reference
  /// @param target The new target for the reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  int git_reference_symbolic_set_target(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<ffi.Int8> target,
    ffi.Pointer<ffi.Int8> log_message,
  ) {
    return _git_reference_symbolic_set_target(
      out,
      ref,
      target,
      log_message,
    );
  }

  late final _git_reference_symbolic_set_target_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_symbolic_set_target>>(
          'git_reference_symbolic_set_target');
  late final _dart_git_reference_symbolic_set_target
      _git_reference_symbolic_set_target =
      _git_reference_symbolic_set_target_ptr
          .asFunction<_dart_git_reference_symbolic_set_target>();

  /// Conditionally create a new reference with the same name as the given reference but a
  /// different OID target. The reference must be a direct reference, otherwise
  /// this will fail.
  ///
  /// The new reference will be written to disk, overwriting the given reference.
  ///
  /// @param out Pointer to the newly created reference
  /// @param ref The reference
  /// @param id The new target OID for the reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EMODIFIED if the value of the reference
  /// has changed since it was read, or an error code
  int git_reference_set_target(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Int8> log_message,
  ) {
    return _git_reference_set_target(
      out,
      ref,
      id,
      log_message,
    );
  }

  late final _git_reference_set_target_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_set_target>>(
          'git_reference_set_target');
  late final _dart_git_reference_set_target _git_reference_set_target =
      _git_reference_set_target_ptr
          .asFunction<_dart_git_reference_set_target>();

  /// Rename an existing reference.
  ///
  /// This method works for both direct and symbolic references.
  ///
  /// The new name will be checked for validity.
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// If the `force` flag is not enabled, and there's already
  /// a reference with the given name, the renaming will fail.
  ///
  /// IMPORTANT:
  /// The user needs to write a proper reflog entry if the
  /// reflog is enabled for the repository. We only rename
  /// the reflog if it exists.
  ///
  /// @param ref The reference to rename
  /// @param new_name The new name for the reference
  /// @param force Overwrite an existing reference
  /// @param log_message The one line long message to be appended to the reflog
  /// @return 0 on success, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_reference_rename(
    ffi.Pointer<ffi.Pointer<git_reference>> new_ref,
    ffi.Pointer<git_reference> ref,
    ffi.Pointer<ffi.Int8> new_name,
    int force,
    ffi.Pointer<ffi.Int8> log_message,
  ) {
    return _git_reference_rename(
      new_ref,
      ref,
      new_name,
      force,
      log_message,
    );
  }

  late final _git_reference_rename_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_rename>>(
          'git_reference_rename');
  late final _dart_git_reference_rename _git_reference_rename =
      _git_reference_rename_ptr.asFunction<_dart_git_reference_rename>();

  /// Delete an existing reference.
  ///
  /// This method works for both direct and symbolic references.  The reference
  /// will be immediately removed on disk but the memory will not be freed.
  /// Callers must call `git_reference_free`.
  ///
  /// This function will return an error if the reference has changed
  /// from the time it was looked up.
  ///
  /// @param ref The reference to remove
  /// @return 0, GIT_EMODIFIED or an error code
  int git_reference_delete(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_delete(
      ref,
    );
  }

  late final _git_reference_delete_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_delete>>(
          'git_reference_delete');
  late final _dart_git_reference_delete _git_reference_delete =
      _git_reference_delete_ptr.asFunction<_dart_git_reference_delete>();

  /// Delete an existing reference by name
  ///
  /// This method removes the named reference from the repository without
  /// looking at its old value.
  ///
  /// @param name The reference to remove
  /// @return 0 or an error code
  int git_reference_remove(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_reference_remove(
      repo,
      name,
    );
  }

  late final _git_reference_remove_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_remove>>(
          'git_reference_remove');
  late final _dart_git_reference_remove _git_reference_remove =
      _git_reference_remove_ptr.asFunction<_dart_git_reference_remove>();

  /// Fill a list with all the references that can be found in a repository.
  ///
  /// The string array will be filled with the names of all references; these
  /// values are owned by the user and should be free'd manually when no
  /// longer needed, using `git_strarray_free()`.
  ///
  /// @param array Pointer to a git_strarray structure where
  /// the reference names will be stored
  /// @param repo Repository where to find the refs
  /// @return 0 or an error code
  int git_reference_list(
    ffi.Pointer<git_strarray> array,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_reference_list(
      array,
      repo,
    );
  }

  late final _git_reference_list_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_list>>('git_reference_list');
  late final _dart_git_reference_list _git_reference_list =
      _git_reference_list_ptr.asFunction<_dart_git_reference_list>();

  /// Perform a callback on each reference in the repository.
  ///
  /// The `callback` function will be called for each reference in the
  /// repository, receiving the reference object and the `payload` value
  /// passed to this method.  Returning a non-zero value from the callback
  /// will terminate the iteration.
  ///
  /// Note that the callback function is responsible to call `git_reference_free`
  /// on each reference passed to it.
  ///
  /// @param repo Repository where to find the refs
  /// @param callback Function which will be called for every listed ref
  /// @param payload Additional data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_reference_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.NativeFunction<git_reference_foreach_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_reference_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_reference_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_foreach>>(
          'git_reference_foreach');
  late final _dart_git_reference_foreach _git_reference_foreach =
      _git_reference_foreach_ptr.asFunction<_dart_git_reference_foreach>();

  /// Perform a callback on the fully-qualified name of each reference.
  ///
  /// The `callback` function will be called for each reference in the
  /// repository, receiving the name of the reference and the `payload` value
  /// passed to this method.  Returning a non-zero value from the callback
  /// will terminate the iteration.
  ///
  /// @param repo Repository where to find the refs
  /// @param callback Function which will be called for every listed ref name
  /// @param payload Additional data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_reference_foreach_name(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.NativeFunction<git_reference_foreach_name_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_reference_foreach_name(
      repo,
      callback,
      payload,
    );
  }

  late final _git_reference_foreach_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_foreach_name>>(
          'git_reference_foreach_name');
  late final _dart_git_reference_foreach_name _git_reference_foreach_name =
      _git_reference_foreach_name_ptr
          .asFunction<_dart_git_reference_foreach_name>();

  /// Create a copy of an existing reference.
  ///
  /// Call `git_reference_free` to free the data.
  ///
  /// @param dest pointer where to store the copy
  /// @param source object to copy
  /// @return 0 or an error code
  int git_reference_dup(
    ffi.Pointer<ffi.Pointer<git_reference>> dest,
    ffi.Pointer<git_reference> source,
  ) {
    return _git_reference_dup(
      dest,
      source,
    );
  }

  late final _git_reference_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_dup>>('git_reference_dup');
  late final _dart_git_reference_dup _git_reference_dup =
      _git_reference_dup_ptr.asFunction<_dart_git_reference_dup>();

  /// Free the given reference.
  ///
  /// @param ref git_reference
  void git_reference_free(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_free(
      ref,
    );
  }

  late final _git_reference_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_free>>('git_reference_free');
  late final _dart_git_reference_free _git_reference_free =
      _git_reference_free_ptr.asFunction<_dart_git_reference_free>();

  /// Compare two references.
  ///
  /// @param ref1 The first git_reference
  /// @param ref2 The second git_reference
  /// @return 0 if the same, else a stable but meaningless ordering.
  int git_reference_cmp(
    ffi.Pointer<git_reference> ref1,
    ffi.Pointer<git_reference> ref2,
  ) {
    return _git_reference_cmp(
      ref1,
      ref2,
    );
  }

  late final _git_reference_cmp_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_cmp>>('git_reference_cmp');
  late final _dart_git_reference_cmp _git_reference_cmp =
      _git_reference_cmp_ptr.asFunction<_dart_git_reference_cmp>();

  /// Create an iterator for the repo's references
  ///
  /// @param out pointer in which to store the iterator
  /// @param repo the repository
  /// @return 0 or an error code
  int git_reference_iterator_new(
    ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_reference_iterator_new(
      out,
      repo,
    );
  }

  late final _git_reference_iterator_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_iterator_new>>(
          'git_reference_iterator_new');
  late final _dart_git_reference_iterator_new _git_reference_iterator_new =
      _git_reference_iterator_new_ptr
          .asFunction<_dart_git_reference_iterator_new>();

  /// Create an iterator for the repo's references that match the
  /// specified glob
  ///
  /// @param out pointer in which to store the iterator
  /// @param repo the repository
  /// @param glob the glob to match against the reference names
  /// @return 0 or an error code
  int git_reference_iterator_glob_new(
    ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> glob,
  ) {
    return _git_reference_iterator_glob_new(
      out,
      repo,
      glob,
    );
  }

  late final _git_reference_iterator_glob_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_iterator_glob_new>>(
          'git_reference_iterator_glob_new');
  late final _dart_git_reference_iterator_glob_new
      _git_reference_iterator_glob_new = _git_reference_iterator_glob_new_ptr
          .asFunction<_dart_git_reference_iterator_glob_new>();

  /// Get the next reference
  ///
  /// @param out pointer in which to store the reference
  /// @param iter the iterator
  /// @return 0, GIT_ITEROVER if there are no more; or an error code
  int git_reference_next(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference_iterator> iter,
  ) {
    return _git_reference_next(
      out,
      iter,
    );
  }

  late final _git_reference_next_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_next>>('git_reference_next');
  late final _dart_git_reference_next _git_reference_next =
      _git_reference_next_ptr.asFunction<_dart_git_reference_next>();

  /// Get the next reference's name
  ///
  /// This function is provided for convenience in case only the names
  /// are interesting as it avoids the allocation of the `git_reference`
  /// object which `git_reference_next()` needs.
  ///
  /// @param out pointer in which to store the string
  /// @param iter the iterator
  /// @return 0, GIT_ITEROVER if there are no more; or an error code
  int git_reference_next_name(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
    ffi.Pointer<git_reference_iterator> iter,
  ) {
    return _git_reference_next_name(
      out,
      iter,
    );
  }

  late final _git_reference_next_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_next_name>>(
          'git_reference_next_name');
  late final _dart_git_reference_next_name _git_reference_next_name =
      _git_reference_next_name_ptr.asFunction<_dart_git_reference_next_name>();

  /// Free the iterator and its associated resources
  ///
  /// @param iter the iterator to free
  void git_reference_iterator_free(
    ffi.Pointer<git_reference_iterator> iter,
  ) {
    return _git_reference_iterator_free(
      iter,
    );
  }

  late final _git_reference_iterator_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_iterator_free>>(
          'git_reference_iterator_free');
  late final _dart_git_reference_iterator_free _git_reference_iterator_free =
      _git_reference_iterator_free_ptr
          .asFunction<_dart_git_reference_iterator_free>();

  /// Perform a callback on each reference in the repository whose name
  /// matches the given pattern.
  ///
  /// This function acts like `git_reference_foreach()` with an additional
  /// pattern match being applied to the reference name before issuing the
  /// callback function.  See that function for more information.
  ///
  /// The pattern is matched using fnmatch or "glob" style where a '*' matches
  /// any sequence of letters, a '?' matches any letter, and square brackets
  /// can be used to define character ranges (such as "[0-9]" for digits).
  ///
  /// @param repo Repository where to find the refs
  /// @param glob Pattern to match (fnmatch-style) against reference name.
  /// @param callback Function which will be called for every listed ref
  /// @param payload Additional data to pass to the callback
  /// @return 0 on success, GIT_EUSER on non-zero callback, or error code
  int git_reference_foreach_glob(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> glob,
    ffi.Pointer<ffi.NativeFunction<git_reference_foreach_name_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_reference_foreach_glob(
      repo,
      glob,
      callback,
      payload,
    );
  }

  late final _git_reference_foreach_glob_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_foreach_glob>>(
          'git_reference_foreach_glob');
  late final _dart_git_reference_foreach_glob _git_reference_foreach_glob =
      _git_reference_foreach_glob_ptr
          .asFunction<_dart_git_reference_foreach_glob>();

  /// Check if a reflog exists for the specified reference.
  ///
  /// @param repo the repository
  /// @param refname the reference's name
  /// @return 0 when no reflog can be found, 1 when it exists;
  /// otherwise an error code.
  int git_reference_has_log(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_reference_has_log(
      repo,
      refname,
    );
  }

  late final _git_reference_has_log_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_has_log>>(
          'git_reference_has_log');
  late final _dart_git_reference_has_log _git_reference_has_log =
      _git_reference_has_log_ptr.asFunction<_dart_git_reference_has_log>();

  /// Ensure there is a reflog for a particular reference.
  ///
  /// Make sure that successive updates to the reference will append to
  /// its log.
  ///
  /// @param repo the repository
  /// @param refname the reference's name
  /// @return 0 or an error code.
  int git_reference_ensure_log(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_reference_ensure_log(
      repo,
      refname,
    );
  }

  late final _git_reference_ensure_log_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_ensure_log>>(
          'git_reference_ensure_log');
  late final _dart_git_reference_ensure_log _git_reference_ensure_log =
      _git_reference_ensure_log_ptr
          .asFunction<_dart_git_reference_ensure_log>();

  /// Check if a reference is a local branch.
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/heads
  /// namespace; 0 otherwise.
  int git_reference_is_branch(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_branch(
      ref,
    );
  }

  late final _git_reference_is_branch_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_is_branch>>(
          'git_reference_is_branch');
  late final _dart_git_reference_is_branch _git_reference_is_branch =
      _git_reference_is_branch_ptr.asFunction<_dart_git_reference_is_branch>();

  /// Check if a reference is a remote tracking branch
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/remotes
  /// namespace; 0 otherwise.
  int git_reference_is_remote(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_remote(
      ref,
    );
  }

  late final _git_reference_is_remote_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_is_remote>>(
          'git_reference_is_remote');
  late final _dart_git_reference_is_remote _git_reference_is_remote =
      _git_reference_is_remote_ptr.asFunction<_dart_git_reference_is_remote>();

  /// Check if a reference is a tag
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/tags
  /// namespace; 0 otherwise.
  int git_reference_is_tag(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_tag(
      ref,
    );
  }

  late final _git_reference_is_tag_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_is_tag>>(
          'git_reference_is_tag');
  late final _dart_git_reference_is_tag _git_reference_is_tag =
      _git_reference_is_tag_ptr.asFunction<_dart_git_reference_is_tag>();

  /// Check if a reference is a note
  ///
  /// @param ref A git reference
  ///
  /// @return 1 when the reference lives in the refs/notes
  /// namespace; 0 otherwise.
  int git_reference_is_note(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_is_note(
      ref,
    );
  }

  late final _git_reference_is_note_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_is_note>>(
          'git_reference_is_note');
  late final _dart_git_reference_is_note _git_reference_is_note =
      _git_reference_is_note_ptr.asFunction<_dart_git_reference_is_note>();

  /// Normalize reference name and check validity.
  ///
  /// This will normalize the reference name by removing any leading slash
  /// '/' characters and collapsing runs of adjacent slashes between name
  /// components into a single slash.
  ///
  /// Once normalized, if the reference name is valid, it will be returned in
  /// the user allocated buffer.
  ///
  /// See `git_reference_symbolic_create()` for rules about valid names.
  ///
  /// @param buffer_out User allocated buffer to store normalized name
  /// @param buffer_size Size of buffer_out
  /// @param name Reference name to be checked.
  /// @param flags Flags to constrain name validation rules - see the
  /// GIT_REFERENCE_FORMAT constants above.
  /// @return 0 on success, GIT_EBUFS if buffer is too small, GIT_EINVALIDSPEC
  /// or an error code.
  int git_reference_normalize_name(
    ffi.Pointer<ffi.Int8> buffer_out,
    int buffer_size,
    ffi.Pointer<ffi.Int8> name,
    int flags,
  ) {
    return _git_reference_normalize_name(
      buffer_out,
      buffer_size,
      name,
      flags,
    );
  }

  late final _git_reference_normalize_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_normalize_name>>(
          'git_reference_normalize_name');
  late final _dart_git_reference_normalize_name _git_reference_normalize_name =
      _git_reference_normalize_name_ptr
          .asFunction<_dart_git_reference_normalize_name>();

  /// Recursively peel reference until object of the specified type is found.
  ///
  /// The retrieved `peeled` object is owned by the repository
  /// and should be closed with the `git_object_free` method.
  ///
  /// If you pass `GIT_OBJECT_ANY` as the target type, then the object
  /// will be peeled until a non-tag object is met.
  ///
  /// @param out Pointer to the peeled git_object
  /// @param ref The reference to be processed
  /// @param type The type of the requested object (GIT_OBJECT_COMMIT,
  /// GIT_OBJECT_TAG, GIT_OBJECT_TREE, GIT_OBJECT_BLOB or GIT_OBJECT_ANY).
  /// @return 0 on success, GIT_EAMBIGUOUS, GIT_ENOTFOUND or an error code
  int git_reference_peel(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_reference> ref,
    int type,
  ) {
    return _git_reference_peel(
      out,
      ref,
      type,
    );
  }

  late final _git_reference_peel_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_peel>>('git_reference_peel');
  late final _dart_git_reference_peel _git_reference_peel =
      _git_reference_peel_ptr.asFunction<_dart_git_reference_peel>();

  /// Ensure the reference name is well-formed.
  ///
  /// Valid reference names must follow one of two patterns:
  ///
  /// 1. Top-level names must contain only capital letters and underscores,
  /// and must begin and end with a letter. (e.g. "HEAD", "ORIG_HEAD").
  /// 2. Names prefixed with "refs/" can be almost anything.  You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// @param refname name to be checked.
  /// @return 1 if the reference name is acceptable; 0 if it isn't
  int git_reference_is_valid_name(
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_reference_is_valid_name(
      refname,
    );
  }

  late final _git_reference_is_valid_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_is_valid_name>>(
          'git_reference_is_valid_name');
  late final _dart_git_reference_is_valid_name _git_reference_is_valid_name =
      _git_reference_is_valid_name_ptr
          .asFunction<_dart_git_reference_is_valid_name>();

  /// Get the reference's short name
  ///
  /// This will transform the reference name into a name "human-readable"
  /// version. If no shortname is appropriate, it will return the full
  /// name.
  ///
  /// The memory is owned by the reference and must not be freed.
  ///
  /// @param ref a reference
  /// @return the human-readable version of the name
  ffi.Pointer<ffi.Int8> git_reference_shorthand(
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_reference_shorthand(
      ref,
    );
  }

  late final _git_reference_shorthand_ptr =
      _lookup<ffi.NativeFunction<_c_git_reference_shorthand>>(
          'git_reference_shorthand');
  late final _dart_git_reference_shorthand _git_reference_shorthand =
      _git_reference_shorthand_ptr.asFunction<_dart_git_reference_shorthand>();

  /// Initialize git_diff_options structure
  ///
  /// Initializes a `git_diff_options` with default values. Equivalent to creating
  /// an instance with GIT_DIFF_OPTIONS_INIT.
  ///
  /// @param opts The `git_diff_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_options_init(
    ffi.Pointer<git_diff_options> opts,
    int version,
  ) {
    return _git_diff_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_options_init>>(
          'git_diff_options_init');
  late final _dart_git_diff_options_init _git_diff_options_init =
      _git_diff_options_init_ptr.asFunction<_dart_git_diff_options_init>();

  /// Initialize git_diff_find_options structure
  ///
  /// Initializes a `git_diff_find_options` with default values. Equivalent to creating
  /// an instance with GIT_DIFF_FIND_OPTIONS_INIT.
  ///
  /// @param opts The `git_diff_find_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_FIND_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_find_options_init(
    ffi.Pointer<git_diff_find_options> opts,
    int version,
  ) {
    return _git_diff_find_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_find_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_find_options_init>>(
          'git_diff_find_options_init');
  late final _dart_git_diff_find_options_init _git_diff_find_options_init =
      _git_diff_find_options_init_ptr
          .asFunction<_dart_git_diff_find_options_init>();

  /// Deallocate a diff.
  ///
  /// @param diff The previously created diff; cannot be used after free.
  void git_diff_free(
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_free(
      diff,
    );
  }

  late final _git_diff_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_free>>('git_diff_free');
  late final _dart_git_diff_free _git_diff_free =
      _git_diff_free_ptr.asFunction<_dart_git_diff_free>();

  /// Create a diff with the difference between two tree objects.
  ///
  /// This is equivalent to `git diff <old-tree> <new-tree>`
  ///
  /// The first tree will be used for the "old_file" side of the delta and the
  /// second tree will be used for the "new_file" side of the delta.  You can
  /// pass NULL to indicate an empty tree, although it is an error to pass
  /// NULL for both the `old_tree` and `new_tree`.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository containing the trees.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param new_tree A git_tree object to diff to, or NULL for empty tree.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  int git_diff_tree_to_tree(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_tree> new_tree,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_tree(
      diff,
      repo,
      old_tree,
      new_tree,
      opts,
    );
  }

  late final _git_diff_tree_to_tree_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_tree_to_tree>>(
          'git_diff_tree_to_tree');
  late final _dart_git_diff_tree_to_tree _git_diff_tree_to_tree =
      _git_diff_tree_to_tree_ptr.asFunction<_dart_git_diff_tree_to_tree>();

  /// Create a diff between a tree and repository index.
  ///
  /// This is equivalent to `git diff --cached <treeish>` or if you pass
  /// the HEAD tree, then like `git diff --cached`.
  ///
  /// The tree you pass will be used for the "old_file" side of the delta, and
  /// the index will be used for the "new_file" side of the delta.
  ///
  /// If you pass NULL for the index, then the existing index of the `repo`
  /// will be used.  In this case, the index will be refreshed from disk
  /// (if it has changed) before the diff is generated.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository containing the tree and index.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param index The index to diff with; repo index used if NULL.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  int git_diff_tree_to_index(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_index(
      diff,
      repo,
      old_tree,
      index,
      opts,
    );
  }

  late final _git_diff_tree_to_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_tree_to_index>>(
          'git_diff_tree_to_index');
  late final _dart_git_diff_tree_to_index _git_diff_tree_to_index =
      _git_diff_tree_to_index_ptr.asFunction<_dart_git_diff_tree_to_index>();

  /// Create a diff between the repository index and the workdir directory.
  ///
  /// This matches the `git diff` command.  See the note below on
  /// `git_diff_tree_to_workdir` for a discussion of the difference between
  /// `git diff` and `git diff HEAD` and how to emulate a `git diff <treeish>`
  /// using libgit2.
  ///
  /// The index will be used for the "old_file" side of the delta, and the
  /// working directory will be used for the "new_file" side of the delta.
  ///
  /// If you pass NULL for the index, then the existing index of the `repo`
  /// will be used.  In this case, the index will be refreshed from disk
  /// (if it has changed) before the diff is generated.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository.
  /// @param index The index to diff from; repo index used if NULL.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  int git_diff_index_to_workdir(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_index_to_workdir(
      diff,
      repo,
      index,
      opts,
    );
  }

  late final _git_diff_index_to_workdir_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_index_to_workdir>>(
          'git_diff_index_to_workdir');
  late final _dart_git_diff_index_to_workdir _git_diff_index_to_workdir =
      _git_diff_index_to_workdir_ptr
          .asFunction<_dart_git_diff_index_to_workdir>();

  /// Create a diff between a tree and the working directory.
  ///
  /// The tree you provide will be used for the "old_file" side of the delta,
  /// and the working directory will be used for the "new_file" side.
  ///
  /// This is not the same as `git diff <treeish>` or `git diff-index
  /// <treeish>`.  Those commands use information from the index, whereas this
  /// function strictly returns the differences between the tree and the files
  /// in the working directory, regardless of the state of the index.  Use
  /// `git_diff_tree_to_workdir_with_index` to emulate those commands.
  ///
  /// To see difference between this and `git_diff_tree_to_workdir_with_index`,
  /// consider the example of a staged file deletion where the file has then
  /// been put back into the working dir and further modified.  The
  /// tree-to-workdir diff for that file is 'modified', but `git diff` would
  /// show status 'deleted' since there is a staged delete.
  ///
  /// @param diff A pointer to a git_diff pointer that will be allocated.
  /// @param repo The repository containing the tree.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  int git_diff_tree_to_workdir(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_workdir(
      diff,
      repo,
      old_tree,
      opts,
    );
  }

  late final _git_diff_tree_to_workdir_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_tree_to_workdir>>(
          'git_diff_tree_to_workdir');
  late final _dart_git_diff_tree_to_workdir _git_diff_tree_to_workdir =
      _git_diff_tree_to_workdir_ptr
          .asFunction<_dart_git_diff_tree_to_workdir>();

  /// Create a diff between a tree and the working directory using index data
  /// to account for staged deletes, tracked files, etc.
  ///
  /// This emulates `git diff <tree>` by diffing the tree to the index and
  /// the index to the working directory and blending the results into a
  /// single diff that includes staged deleted, etc.
  ///
  /// @param diff A pointer to a git_diff pointer that will be allocated.
  /// @param repo The repository containing the tree.
  /// @param old_tree A git_tree object to diff from, or NULL for empty tree.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  int git_diff_tree_to_workdir_with_index(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> old_tree,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_tree_to_workdir_with_index(
      diff,
      repo,
      old_tree,
      opts,
    );
  }

  late final _git_diff_tree_to_workdir_with_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_tree_to_workdir_with_index>>(
          'git_diff_tree_to_workdir_with_index');
  late final _dart_git_diff_tree_to_workdir_with_index
      _git_diff_tree_to_workdir_with_index =
      _git_diff_tree_to_workdir_with_index_ptr
          .asFunction<_dart_git_diff_tree_to_workdir_with_index>();

  /// Create a diff with the difference between two index objects.
  ///
  /// The first index will be used for the "old_file" side of the delta and the
  /// second index will be used for the "new_file" side of the delta.
  ///
  /// @param diff Output pointer to a git_diff pointer to be allocated.
  /// @param repo The repository containing the indexes.
  /// @param old_index A git_index object to diff from.
  /// @param new_index A git_index object to diff to.
  /// @param opts Structure with options to influence diff or NULL for defaults.
  int git_diff_index_to_index(
    ffi.Pointer<ffi.Pointer<git_diff>> diff,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> old_index,
    ffi.Pointer<git_index> new_index,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_diff_index_to_index(
      diff,
      repo,
      old_index,
      new_index,
      opts,
    );
  }

  late final _git_diff_index_to_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_index_to_index>>(
          'git_diff_index_to_index');
  late final _dart_git_diff_index_to_index _git_diff_index_to_index =
      _git_diff_index_to_index_ptr.asFunction<_dart_git_diff_index_to_index>();

  /// Merge one diff into another.
  ///
  /// This merges items from the "from" list into the "onto" list.  The
  /// resulting diff will have all items that appear in either list.
  /// If an item appears in both lists, then it will be "merged" to appear
  /// as if the old version was from the "onto" list and the new version
  /// is from the "from" list (with the exception that if the item has a
  /// pending DELETE in the middle, then it will show as deleted).
  ///
  /// @param onto Diff to merge into.
  /// @param from Diff to merge.
  int git_diff_merge(
    ffi.Pointer<git_diff> onto,
    ffi.Pointer<git_diff> from,
  ) {
    return _git_diff_merge(
      onto,
      from,
    );
  }

  late final _git_diff_merge_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_merge>>('git_diff_merge');
  late final _dart_git_diff_merge _git_diff_merge =
      _git_diff_merge_ptr.asFunction<_dart_git_diff_merge>();

  /// Transform a diff marking file renames, copies, etc.
  ///
  /// This modifies a diff in place, replacing old entries that look
  /// like renames or copies with new entries reflecting those changes.
  /// This also will, if requested, break modified files into add/remove
  /// pairs if the amount of change is above a threshold.
  ///
  /// @param diff diff to run detection algorithms on
  /// @param options Control how detection should be run, NULL for defaults
  /// @return 0 on success, -1 on failure
  int git_diff_find_similar(
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_diff_find_options> options,
  ) {
    return _git_diff_find_similar(
      diff,
      options,
    );
  }

  late final _git_diff_find_similar_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_find_similar>>(
          'git_diff_find_similar');
  late final _dart_git_diff_find_similar _git_diff_find_similar =
      _git_diff_find_similar_ptr.asFunction<_dart_git_diff_find_similar>();

  /// Query how many diff records are there in a diff.
  ///
  /// @param diff A git_diff generated by one of the above functions
  /// @return Count of number of deltas in the list
  int git_diff_num_deltas(
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_num_deltas(
      diff,
    );
  }

  late final _git_diff_num_deltas_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_num_deltas>>(
          'git_diff_num_deltas');
  late final _dart_git_diff_num_deltas _git_diff_num_deltas =
      _git_diff_num_deltas_ptr.asFunction<_dart_git_diff_num_deltas>();

  /// Query how many diff deltas are there in a diff filtered by type.
  ///
  /// This works just like `git_diff_entrycount()` with an extra parameter
  /// that is a `git_delta_t` and returns just the count of how many deltas
  /// match that particular type.
  ///
  /// @param diff A git_diff generated by one of the above functions
  /// @param type A git_delta_t value to filter the count
  /// @return Count of number of deltas matching delta_t type
  int git_diff_num_deltas_of_type(
    ffi.Pointer<git_diff> diff,
    int type,
  ) {
    return _git_diff_num_deltas_of_type(
      diff,
      type,
    );
  }

  late final _git_diff_num_deltas_of_type_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_num_deltas_of_type>>(
          'git_diff_num_deltas_of_type');
  late final _dart_git_diff_num_deltas_of_type _git_diff_num_deltas_of_type =
      _git_diff_num_deltas_of_type_ptr
          .asFunction<_dart_git_diff_num_deltas_of_type>();

  /// Return the diff delta for an entry in the diff list.
  ///
  /// The `git_diff_delta` pointer points to internal data and you do not
  /// have to release it when you are done with it.  It will go away when
  /// the * `git_diff` (or any associated `git_patch`) goes away.
  ///
  /// Note that the flags on the delta related to whether it has binary
  /// content or not may not be set if there are no attributes set for the
  /// file and there has been no reason to load the file data at this point.
  /// For now, if you need those flags to be up to date, your only option is
  /// to either use `git_diff_foreach` or create a `git_patch`.
  ///
  /// @param diff Diff list object
  /// @param idx Index into diff list
  /// @return Pointer to git_diff_delta (or NULL if `idx` out of range)
  ffi.Pointer<git_diff_delta> git_diff_get_delta(
    ffi.Pointer<git_diff> diff,
    int idx,
  ) {
    return _git_diff_get_delta(
      diff,
      idx,
    );
  }

  late final _git_diff_get_delta_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_get_delta>>('git_diff_get_delta');
  late final _dart_git_diff_get_delta _git_diff_get_delta =
      _git_diff_get_delta_ptr.asFunction<_dart_git_diff_get_delta>();

  /// Check if deltas are sorted case sensitively or insensitively.
  ///
  /// @param diff diff to check
  /// @return 0 if case sensitive, 1 if case is ignored
  int git_diff_is_sorted_icase(
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_is_sorted_icase(
      diff,
    );
  }

  late final _git_diff_is_sorted_icase_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_is_sorted_icase>>(
          'git_diff_is_sorted_icase');
  late final _dart_git_diff_is_sorted_icase _git_diff_is_sorted_icase =
      _git_diff_is_sorted_icase_ptr
          .asFunction<_dart_git_diff_is_sorted_icase>();

  /// Loop over all deltas in a diff issuing callbacks.
  ///
  /// This will iterate through all of the files described in a diff.  You
  /// should provide a file callback to learn about each file.
  ///
  /// The "hunk" and "line" callbacks are optional, and the text diff of the
  /// files will only be calculated if they are not NULL.  Of course, these
  /// callbacks will not be invoked for binary files on the diff or for
  /// files whose only changed is a file mode change.
  ///
  /// Returning a non-zero value from any of the callbacks will terminate
  /// the iteration and return the value to the user.
  ///
  /// @param diff A git_diff generated by one of the above functions.
  /// @param file_cb Callback function to make per file in the diff.
  /// @param binary_cb Optional callback to make for binary files.
  /// @param hunk_cb Optional callback to make per hunk of text diff.  This
  /// callback is called to describe a range of lines in the
  /// diff.  It will not be issued for binary files.
  /// @param line_cb Optional callback to make per line of diff text.  This
  /// same callback will be made for context lines, added, and
  /// removed lines, and even for a deleted trailing newline.
  /// @param payload Reference pointer that will be passed to your callbacks.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_foreach(
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_foreach(
      diff,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_foreach>>('git_diff_foreach');
  late final _dart_git_diff_foreach _git_diff_foreach =
      _git_diff_foreach_ptr.asFunction<_dart_git_diff_foreach>();

  /// Look up the single character abbreviation for a delta status code.
  ///
  /// When you run `git diff --name-status` it uses single letter codes in
  /// the output such as 'A' for added, 'D' for deleted, 'M' for modified,
  /// etc.  This function converts a git_delta_t value into these letters for
  /// your own purposes.  GIT_DELTA_UNTRACKED will return a space (i.e. ' ').
  ///
  /// @param status The git_delta_t value to look up
  /// @return The single character label for that code
  int git_diff_status_char(
    int status,
  ) {
    return _git_diff_status_char(
      status,
    );
  }

  late final _git_diff_status_char_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_status_char>>(
          'git_diff_status_char');
  late final _dart_git_diff_status_char _git_diff_status_char =
      _git_diff_status_char_ptr.asFunction<_dart_git_diff_status_char>();

  /// Iterate over a diff generating formatted text output.
  ///
  /// Returning a non-zero value from the callbacks will terminate the
  /// iteration and return the non-zero value to the caller.
  ///
  /// @param diff A git_diff generated by one of the above functions.
  /// @param format A git_diff_format_t value to pick the text format.
  /// @param print_cb Callback to make per line of diff text.
  /// @param payload Reference pointer that will be passed to your callback.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_print(
    ffi.Pointer<git_diff> diff,
    int format,
    ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> print_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_print(
      diff,
      format,
      print_cb,
      payload,
    );
  }

  late final _git_diff_print_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_print>>('git_diff_print');
  late final _dart_git_diff_print _git_diff_print =
      _git_diff_print_ptr.asFunction<_dart_git_diff_print>();

  /// Produce the complete formatted text output from a diff into a
  /// buffer.
  ///
  /// @param out A pointer to a user-allocated git_buf that will
  /// contain the diff text
  /// @param diff A git_diff generated by one of the above functions.
  /// @param format A git_diff_format_t value to pick the text format.
  /// @return 0 on success or error code
  int git_diff_to_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff> diff,
    int format,
  ) {
    return _git_diff_to_buf(
      out,
      diff,
      format,
    );
  }

  late final _git_diff_to_buf_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_to_buf>>('git_diff_to_buf');
  late final _dart_git_diff_to_buf _git_diff_to_buf =
      _git_diff_to_buf_ptr.asFunction<_dart_git_diff_to_buf>();

  /// Directly run a diff on two blobs.
  ///
  /// Compared to a file, a blob lacks some contextual information. As such,
  /// the `git_diff_file` given to the callback will have some fake data; i.e.
  /// `mode` will be 0 and `path` will be NULL.
  ///
  /// NULL is allowed for either `old_blob` or `new_blob` and will be treated
  /// as an empty blob, with the `oid` set to NULL in the `git_diff_file` data.
  /// Passing NULL for both blobs is a noop; no callbacks will be made at all.
  ///
  /// We do run a binary content check on the blob content and if either blob
  /// looks like binary data, the `git_diff_delta` binary attribute will be set
  /// to 1 and no call to the hunk_cb nor line_cb will be made (unless you pass
  /// `GIT_DIFF_FORCE_TEXT` of course).
  ///
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param new_blob Blob for new side of diff, or NULL for empty blob
  /// @param new_as_path Treat new blob as if it had this filename; can be NULL
  /// @param options Options for diff, or NULL for default options
  /// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
  /// @param binary_cb Callback for binary files; can be NULL
  /// @param hunk_cb Callback for each hunk in diff; can be NULL
  /// @param line_cb Callback for each line in diff; can be NULL
  /// @param payload Payload passed to each callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_blobs(
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Int8> old_as_path,
    ffi.Pointer<git_blob> new_blob,
    ffi.Pointer<ffi.Int8> new_as_path,
    ffi.Pointer<git_diff_options> options,
    ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_blobs(
      old_blob,
      old_as_path,
      new_blob,
      new_as_path,
      options,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_blobs_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_blobs>>('git_diff_blobs');
  late final _dart_git_diff_blobs _git_diff_blobs =
      _git_diff_blobs_ptr.asFunction<_dart_git_diff_blobs>();

  /// Directly run a diff between a blob and a buffer.
  ///
  /// As with `git_diff_blobs`, comparing a blob and buffer lacks some context,
  /// so the `git_diff_file` parameters to the callbacks will be faked a la the
  /// rules for `git_diff_blobs()`.
  ///
  /// Passing NULL for `old_blob` will be treated as an empty blob (i.e. the
  /// `file_cb` will be invoked with GIT_DELTA_ADDED and the diff will be the
  /// entire content of the buffer added).  Passing NULL to the buffer will do
  /// the reverse, with GIT_DELTA_REMOVED and blob content removed.
  ///
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param buffer Raw data for new side of diff, or NULL for empty
  /// @param buffer_len Length of raw data for new side of diff
  /// @param buffer_as_path Treat buffer as if it had this filename; can be NULL
  /// @param options Options for diff, or NULL for default options
  /// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
  /// @param binary_cb Callback for binary files; can be NULL
  /// @param hunk_cb Callback for each hunk in diff; can be NULL
  /// @param line_cb Callback for each line in diff; can be NULL
  /// @param payload Payload passed to each callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_blob_to_buffer(
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Int8> old_as_path,
    ffi.Pointer<ffi.Int8> buffer,
    int buffer_len,
    ffi.Pointer<ffi.Int8> buffer_as_path,
    ffi.Pointer<git_diff_options> options,
    ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_blob_to_buffer(
      old_blob,
      old_as_path,
      buffer,
      buffer_len,
      buffer_as_path,
      options,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_blob_to_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_blob_to_buffer>>(
          'git_diff_blob_to_buffer');
  late final _dart_git_diff_blob_to_buffer _git_diff_blob_to_buffer =
      _git_diff_blob_to_buffer_ptr.asFunction<_dart_git_diff_blob_to_buffer>();

  /// Directly run a diff between two buffers.
  ///
  /// Even more than with `git_diff_blobs`, comparing two buffer lacks
  /// context, so the `git_diff_file` parameters to the callbacks will be
  /// faked a la the rules for `git_diff_blobs()`.
  ///
  /// @param old_buffer Raw data for old side of diff, or NULL for empty
  /// @param old_len Length of the raw data for old side of the diff
  /// @param old_as_path Treat old buffer as if it had this filename; can be NULL
  /// @param new_buffer Raw data for new side of diff, or NULL for empty
  /// @param new_len Length of raw data for new side of diff
  /// @param new_as_path Treat buffer as if it had this filename; can be NULL
  /// @param options Options for diff, or NULL for default options
  /// @param file_cb Callback for "file"; made once if there is a diff; can be NULL
  /// @param binary_cb Callback for binary files; can be NULL
  /// @param hunk_cb Callback for each hunk in diff; can be NULL
  /// @param line_cb Callback for each line in diff; can be NULL
  /// @param payload Payload passed to each callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_diff_buffers(
    ffi.Pointer<ffi.Void> old_buffer,
    int old_len,
    ffi.Pointer<ffi.Int8> old_as_path,
    ffi.Pointer<ffi.Void> new_buffer,
    int new_len,
    ffi.Pointer<ffi.Int8> new_as_path,
    ffi.Pointer<git_diff_options> options,
    ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
    ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_diff_buffers(
      old_buffer,
      old_len,
      old_as_path,
      new_buffer,
      new_len,
      new_as_path,
      options,
      file_cb,
      binary_cb,
      hunk_cb,
      line_cb,
      payload,
    );
  }

  late final _git_diff_buffers_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_buffers>>('git_diff_buffers');
  late final _dart_git_diff_buffers _git_diff_buffers =
      _git_diff_buffers_ptr.asFunction<_dart_git_diff_buffers>();

  /// Read the contents of a git patch file into a `git_diff` object.
  ///
  /// The diff object produced is similar to the one that would be
  /// produced if you actually produced it computationally by comparing
  /// two trees, however there may be subtle differences.  For example,
  /// a patch file likely contains abbreviated object IDs, so the
  /// object IDs in a `git_diff_delta` produced by this function will
  /// also be abbreviated.
  ///
  /// This function will only read patch files created by a git
  /// implementation, it will not read unified diffs produced by
  /// the `diff` program, nor any other types of patch files.
  ///
  /// @param out A pointer to a git_diff pointer that will be allocated.
  /// @param content The contents of a patch file
  /// @param content_len The length of the patch file contents
  /// @return 0 or an error code
  int git_diff_from_buffer(
    ffi.Pointer<ffi.Pointer<git_diff>> out,
    ffi.Pointer<ffi.Int8> content,
    int content_len,
  ) {
    return _git_diff_from_buffer(
      out,
      content,
      content_len,
    );
  }

  late final _git_diff_from_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_from_buffer>>(
          'git_diff_from_buffer');
  late final _dart_git_diff_from_buffer _git_diff_from_buffer =
      _git_diff_from_buffer_ptr.asFunction<_dart_git_diff_from_buffer>();

  /// Accumulate diff statistics for all patches.
  ///
  /// @param out Structure containg the diff statistics.
  /// @param diff A git_diff generated by one of the above functions.
  /// @return 0 on success; non-zero on error
  int git_diff_get_stats(
    ffi.Pointer<ffi.Pointer<git_diff_stats>> out,
    ffi.Pointer<git_diff> diff,
  ) {
    return _git_diff_get_stats(
      out,
      diff,
    );
  }

  late final _git_diff_get_stats_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_get_stats>>('git_diff_get_stats');
  late final _dart_git_diff_get_stats _git_diff_get_stats =
      _git_diff_get_stats_ptr.asFunction<_dart_git_diff_get_stats>();

  /// Get the total number of files changed in a diff
  ///
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @return total number of files changed in the diff
  int git_diff_stats_files_changed(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_files_changed(
      stats,
    );
  }

  late final _git_diff_stats_files_changed_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_stats_files_changed>>(
          'git_diff_stats_files_changed');
  late final _dart_git_diff_stats_files_changed _git_diff_stats_files_changed =
      _git_diff_stats_files_changed_ptr
          .asFunction<_dart_git_diff_stats_files_changed>();

  /// Get the total number of insertions in a diff
  ///
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @return total number of insertions in the diff
  int git_diff_stats_insertions(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_insertions(
      stats,
    );
  }

  late final _git_diff_stats_insertions_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_stats_insertions>>(
          'git_diff_stats_insertions');
  late final _dart_git_diff_stats_insertions _git_diff_stats_insertions =
      _git_diff_stats_insertions_ptr
          .asFunction<_dart_git_diff_stats_insertions>();

  /// Get the total number of deletions in a diff
  ///
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @return total number of deletions in the diff
  int git_diff_stats_deletions(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_deletions(
      stats,
    );
  }

  late final _git_diff_stats_deletions_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_stats_deletions>>(
          'git_diff_stats_deletions');
  late final _dart_git_diff_stats_deletions _git_diff_stats_deletions =
      _git_diff_stats_deletions_ptr
          .asFunction<_dart_git_diff_stats_deletions>();

  /// Print diff statistics to a `git_buf`.
  ///
  /// @param out buffer to store the formatted diff statistics in.
  /// @param stats A `git_diff_stats` generated by one of the above functions.
  /// @param format Formatting option.
  /// @param width Target width for output (only affects GIT_DIFF_STATS_FULL)
  /// @return 0 on success; non-zero on error
  int git_diff_stats_to_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff_stats> stats,
    int format,
    int width,
  ) {
    return _git_diff_stats_to_buf(
      out,
      stats,
      format,
      width,
    );
  }

  late final _git_diff_stats_to_buf_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_stats_to_buf>>(
          'git_diff_stats_to_buf');
  late final _dart_git_diff_stats_to_buf _git_diff_stats_to_buf =
      _git_diff_stats_to_buf_ptr.asFunction<_dart_git_diff_stats_to_buf>();

  /// Deallocate a `git_diff_stats`.
  ///
  /// @param stats The previously created statistics object;
  /// cannot be used after free.
  void git_diff_stats_free(
    ffi.Pointer<git_diff_stats> stats,
  ) {
    return _git_diff_stats_free(
      stats,
    );
  }

  late final _git_diff_stats_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_stats_free>>(
          'git_diff_stats_free');
  late final _dart_git_diff_stats_free _git_diff_stats_free =
      _git_diff_stats_free_ptr.asFunction<_dart_git_diff_stats_free>();

  /// Create an e-mail ready patch from a diff.
  ///
  /// @param out buffer to store the e-mail patch in
  /// @param diff containing the commit
  /// @param opts structure with options to influence content and formatting.
  /// @return 0 or an error code
  int git_diff_format_email(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_diff_format_email_options> opts,
  ) {
    return _git_diff_format_email(
      out,
      diff,
      opts,
    );
  }

  late final _git_diff_format_email_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_format_email>>(
          'git_diff_format_email');
  late final _dart_git_diff_format_email _git_diff_format_email =
      _git_diff_format_email_ptr.asFunction<_dart_git_diff_format_email>();

  /// Create an e-mail ready patch for a commit.
  ///
  /// Does not support creating patches for merge commits (yet).
  ///
  /// @param out buffer to store the e-mail patch in
  /// @param repo containing the commit
  /// @param commit pointer to up commit
  /// @param patch_no patch number of the commit
  /// @param total_patches total number of patches in the patch set
  /// @param flags determines the formatting of the e-mail
  /// @param diff_opts structure with options to influence diff or NULL for defaults.
  /// @return 0 or an error code
  int git_diff_commit_as_email(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> commit,
    int patch_no,
    int total_patches,
    int flags,
    ffi.Pointer<git_diff_options> diff_opts,
  ) {
    return _git_diff_commit_as_email(
      out,
      repo,
      commit,
      patch_no,
      total_patches,
      flags,
      diff_opts,
    );
  }

  late final _git_diff_commit_as_email_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_commit_as_email>>(
          'git_diff_commit_as_email');
  late final _dart_git_diff_commit_as_email _git_diff_commit_as_email =
      _git_diff_commit_as_email_ptr
          .asFunction<_dart_git_diff_commit_as_email>();

  /// Initialize git_diff_format_email_options structure
  ///
  /// Initializes a `git_diff_format_email_options` with default values. Equivalent
  /// to creating an instance with GIT_DIFF_FORMAT_EMAIL_OPTIONS_INIT.
  ///
  /// @param opts The `git_blame_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_format_email_options_init(
    ffi.Pointer<git_diff_format_email_options> opts,
    int version,
  ) {
    return _git_diff_format_email_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_format_email_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_format_email_options_init>>(
          'git_diff_format_email_options_init');
  late final _dart_git_diff_format_email_options_init
      _git_diff_format_email_options_init =
      _git_diff_format_email_options_init_ptr
          .asFunction<_dart_git_diff_format_email_options_init>();

  /// Initialize git_diff_patchid_options structure
  ///
  /// Initializes a `git_diff_patchid_options` with default values. Equivalent to
  /// creating an instance with `GIT_DIFF_PATCHID_OPTIONS_INIT`.
  ///
  /// @param opts The `git_diff_patchid_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DIFF_PATCHID_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_diff_patchid_options_init(
    ffi.Pointer<git_diff_patchid_options> opts,
    int version,
  ) {
    return _git_diff_patchid_options_init(
      opts,
      version,
    );
  }

  late final _git_diff_patchid_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_patchid_options_init>>(
          'git_diff_patchid_options_init');
  late final _dart_git_diff_patchid_options_init
      _git_diff_patchid_options_init = _git_diff_patchid_options_init_ptr
          .asFunction<_dart_git_diff_patchid_options_init>();

  /// Calculate the patch ID for the given patch.
  ///
  /// Calculate a stable patch ID for the given patch by summing the
  /// hash of the file diffs, ignoring whitespace and line numbers.
  /// This can be used to derive whether two diffs are the same with
  /// a high probability.
  ///
  /// Currently, this function only calculates stable patch IDs, as
  /// defined in git-patch-id(1), and should in fact generate the
  /// same IDs as the upstream git project does.
  ///
  /// @param out Pointer where the calculated patch ID should be stored
  /// @param diff The diff to calculate the ID for
  /// @param opts Options for how to calculate the patch ID. This is
  /// intended for future changes, as currently no options are
  /// available.
  /// @return 0 on success, an error code otherwise.
  int git_diff_patchid(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_diff_patchid_options> opts,
  ) {
    return _git_diff_patchid(
      out,
      diff,
      opts,
    );
  }

  late final _git_diff_patchid_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_patchid>>('git_diff_patchid');
  late final _dart_git_diff_patchid _git_diff_patchid =
      _git_diff_patchid_ptr.asFunction<_dart_git_diff_patchid>();

  int git_apply_options_init(
    ffi.Pointer<git_apply_options> opts,
    int version,
  ) {
    return _git_apply_options_init(
      opts,
      version,
    );
  }

  late final _git_apply_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_apply_options_init>>(
          'git_apply_options_init');
  late final _dart_git_apply_options_init _git_apply_options_init =
      _git_apply_options_init_ptr.asFunction<_dart_git_apply_options_init>();

  /// Apply a `git_diff` to a `git_tree`, and return the resulting image
  /// as an index.
  ///
  /// @param out the postimage of the application
  /// @param repo the repository to apply
  /// @param preimage the tree to apply the diff to
  /// @param diff the diff to apply
  /// @param options the options for the apply (or null for defaults)
  int git_apply_to_tree(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> preimage,
    ffi.Pointer<git_diff> diff,
    ffi.Pointer<git_apply_options> options,
  ) {
    return _git_apply_to_tree(
      out,
      repo,
      preimage,
      diff,
      options,
    );
  }

  late final _git_apply_to_tree_ptr =
      _lookup<ffi.NativeFunction<_c_git_apply_to_tree>>('git_apply_to_tree');
  late final _dart_git_apply_to_tree _git_apply_to_tree =
      _git_apply_to_tree_ptr.asFunction<_dart_git_apply_to_tree>();

  /// Apply a `git_diff` to the given repository, making changes directly
  /// in the working directory, the index, or both.
  ///
  /// @param repo the repository to apply to
  /// @param diff the diff to apply
  /// @param location the location to apply (workdir, index or both)
  /// @param options the options for the apply (or null for defaults)
  int git_apply(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_diff> diff,
    int location,
    ffi.Pointer<git_apply_options> options,
  ) {
    return _git_apply(
      repo,
      diff,
      location,
      options,
    );
  }

  late final _git_apply_ptr =
      _lookup<ffi.NativeFunction<_c_git_apply>>('git_apply');
  late final _dart_git_apply _git_apply =
      _git_apply_ptr.asFunction<_dart_git_apply>();

  /// Return the value type for a given attribute.
  ///
  /// This can be either `TRUE`, `FALSE`, `UNSPECIFIED` (if the attribute
  /// was not set at all), or `VALUE`, if the attribute was set to an
  /// actual string.
  ///
  /// If the attribute has a `VALUE` string, it can be accessed normally
  /// as a NULL-terminated C string.
  ///
  /// @param attr The attribute
  /// @return the value type for the attribute
  int git_attr_value(
    ffi.Pointer<ffi.Int8> attr,
  ) {
    return _git_attr_value(
      attr,
    );
  }

  late final _git_attr_value_ptr =
      _lookup<ffi.NativeFunction<_c_git_attr_value>>('git_attr_value');
  late final _dart_git_attr_value _git_attr_value =
      _git_attr_value_ptr.asFunction<_dart_git_attr_value>();

  /// Look up the value of one git attribute for path.
  ///
  /// @param value_out Output of the value of the attribute.  Use the GIT_ATTR_...
  /// macros to test for TRUE, FALSE, UNSPECIFIED, etc. or just
  /// use the string value for attributes set to a value.  You
  /// should NOT modify or free this value.
  /// @param repo The repository containing the path.
  /// @param flags A combination of GIT_ATTR_CHECK... flags.
  /// @param path The path to check for attributes.  Relative paths are
  /// interpreted relative to the repo root.  The file does
  /// not have to exist, but if it does not, then it will be
  /// treated as a plain file (not a directory).
  /// @param name The name of the attribute to look up.
  int git_attr_get(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> value_out,
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_attr_get(
      value_out,
      repo,
      flags,
      path,
      name,
    );
  }

  late final _git_attr_get_ptr =
      _lookup<ffi.NativeFunction<_c_git_attr_get>>('git_attr_get');
  late final _dart_git_attr_get _git_attr_get =
      _git_attr_get_ptr.asFunction<_dart_git_attr_get>();

  /// Look up a list of git attributes for path.
  ///
  /// Use this if you have a known list of attributes that you want to
  /// look up in a single call.  This is somewhat more efficient than
  /// calling `git_attr_get()` multiple times.
  ///
  /// For example, you might write:
  ///
  /// const char *attrs[] = { "crlf", "diff", "foo" };
  /// const char **values[3];
  /// git_attr_get_many(values, repo, 0, "my/fun/file.c", 3, attrs);
  ///
  /// Then you could loop through the 3 values to get the settings for
  /// the three attributes you asked about.
  ///
  /// @param values_out An array of num_attr entries that will have string
  /// pointers written into it for the values of the attributes.
  /// You should not modify or free the values that are written
  /// into this array (although of course, you should free the
  /// array itself if you allocated it).
  /// @param repo The repository containing the path.
  /// @param flags A combination of GIT_ATTR_CHECK... flags.
  /// @param path The path inside the repo to check attributes.  This
  /// does not have to exist, but if it does not, then
  /// it will be treated as a plain file (i.e. not a directory).
  /// @param num_attr The number of attributes being looked up
  /// @param names An array of num_attr strings containing attribute names.
  int git_attr_get_many(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> values_out,
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<ffi.Int8> path,
    int num_attr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> names,
  ) {
    return _git_attr_get_many(
      values_out,
      repo,
      flags,
      path,
      num_attr,
      names,
    );
  }

  late final _git_attr_get_many_ptr =
      _lookup<ffi.NativeFunction<_c_git_attr_get_many>>('git_attr_get_many');
  late final _dart_git_attr_get_many _git_attr_get_many =
      _git_attr_get_many_ptr.asFunction<_dart_git_attr_get_many>();

  /// Loop over all the git attributes for a path.
  ///
  /// @param repo The repository containing the path.
  /// @param flags A combination of GIT_ATTR_CHECK... flags.
  /// @param path Path inside the repo to check attributes.  This does not have
  /// to exist, but if it does not, then it will be treated as a
  /// plain file (i.e. not a directory).
  /// @param callback Function to invoke on each attribute name and value.
  /// See git_attr_foreach_cb.
  /// @param payload Passed on as extra parameter to callback function.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_attr_foreach(
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.NativeFunction<git_attr_foreach_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_attr_foreach(
      repo,
      flags,
      path,
      callback,
      payload,
    );
  }

  late final _git_attr_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_attr_foreach>>('git_attr_foreach');
  late final _dart_git_attr_foreach _git_attr_foreach =
      _git_attr_foreach_ptr.asFunction<_dart_git_attr_foreach>();

  /// Flush the gitattributes cache.
  ///
  /// Call this if you have reason to believe that the attributes files on
  /// disk no longer match the cached contents of memory.  This will cause
  /// the attributes files to be reloaded the next time that an attribute
  /// access function is called.
  ///
  /// @param repo The repository containing the gitattributes cache
  /// @return 0 on success, or an error code
  int git_attr_cache_flush(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_attr_cache_flush(
      repo,
    );
  }

  late final _git_attr_cache_flush_ptr =
      _lookup<ffi.NativeFunction<_c_git_attr_cache_flush>>(
          'git_attr_cache_flush');
  late final _dart_git_attr_cache_flush _git_attr_cache_flush =
      _git_attr_cache_flush_ptr.asFunction<_dart_git_attr_cache_flush>();

  /// Add a macro definition.
  ///
  /// Macros will automatically be loaded from the top level `.gitattributes`
  /// file of the repository (plus the build-in "binary" macro).  This
  /// function allows you to add others.  For example, to add the default
  /// macro, you would call:
  ///
  /// git_attr_add_macro(repo, "binary", "-diff -crlf");
  int git_attr_add_macro(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> values,
  ) {
    return _git_attr_add_macro(
      repo,
      name,
      values,
    );
  }

  late final _git_attr_add_macro_ptr =
      _lookup<ffi.NativeFunction<_c_git_attr_add_macro>>('git_attr_add_macro');
  late final _dart_git_attr_add_macro _git_attr_add_macro =
      _git_attr_add_macro_ptr.asFunction<_dart_git_attr_add_macro>();

  /// Lookup a blob object from a repository.
  ///
  /// @param blob pointer to the looked up blob
  /// @param repo the repo to use when locating the blob.
  /// @param id identity of the blob to locate.
  /// @return 0 or an error code
  int git_blob_lookup(
    ffi.Pointer<ffi.Pointer<git_blob>> blob,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_blob_lookup(
      blob,
      repo,
      id,
    );
  }

  late final _git_blob_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_lookup>>('git_blob_lookup');
  late final _dart_git_blob_lookup _git_blob_lookup =
      _git_blob_lookup_ptr.asFunction<_dart_git_blob_lookup>();

  /// Lookup a blob object from a repository,
  /// given a prefix of its identifier (short id).
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param blob pointer to the looked up blob
  /// @param repo the repo to use when locating the blob.
  /// @param id identity of the blob to locate.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_blob_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_blob>> blob,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_blob_lookup_prefix(
      blob,
      repo,
      id,
      len,
    );
  }

  late final _git_blob_lookup_prefix_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_lookup_prefix>>(
          'git_blob_lookup_prefix');
  late final _dart_git_blob_lookup_prefix _git_blob_lookup_prefix =
      _git_blob_lookup_prefix_ptr.asFunction<_dart_git_blob_lookup_prefix>();

  /// Close an open blob
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a blob. Failure to do so will cause a memory leak.
  ///
  /// @param blob the blob to close
  void git_blob_free(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_free(
      blob,
    );
  }

  late final _git_blob_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_free>>('git_blob_free');
  late final _dart_git_blob_free _git_blob_free =
      _git_blob_free_ptr.asFunction<_dart_git_blob_free>();

  /// Get the id of a blob.
  ///
  /// @param blob a previously loaded blob.
  /// @return SHA1 hash for this blob.
  ffi.Pointer<git_oid> git_blob_id(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_id(
      blob,
    );
  }

  late final _git_blob_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_id>>('git_blob_id');
  late final _dart_git_blob_id _git_blob_id =
      _git_blob_id_ptr.asFunction<_dart_git_blob_id>();

  /// Get the repository that contains the blob.
  ///
  /// @param blob A previously loaded blob.
  /// @return Repository that contains this blob.
  ffi.Pointer<git_repository> git_blob_owner(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_owner(
      blob,
    );
  }

  late final _git_blob_owner_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_owner>>('git_blob_owner');
  late final _dart_git_blob_owner _git_blob_owner =
      _git_blob_owner_ptr.asFunction<_dart_git_blob_owner>();

  /// Get a read-only buffer with the raw content of a blob.
  ///
  /// A pointer to the raw content of a blob is returned;
  /// this pointer is owned internally by the object and shall
  /// not be free'd. The pointer may be invalidated at a later
  /// time.
  ///
  /// @param blob pointer to the blob
  /// @return the pointer
  ffi.Pointer<ffi.Void> git_blob_rawcontent(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_rawcontent(
      blob,
    );
  }

  late final _git_blob_rawcontent_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_rawcontent>>(
          'git_blob_rawcontent');
  late final _dart_git_blob_rawcontent _git_blob_rawcontent =
      _git_blob_rawcontent_ptr.asFunction<_dart_git_blob_rawcontent>();

  /// Get the size in bytes of the contents of a blob
  ///
  /// @param blob pointer to the blob
  /// @return size on bytes
  int git_blob_rawsize(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_rawsize(
      blob,
    );
  }

  late final _git_blob_rawsize_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_rawsize>>('git_blob_rawsize');
  late final _dart_git_blob_rawsize _git_blob_rawsize =
      _git_blob_rawsize_ptr.asFunction<_dart_git_blob_rawsize>();

  /// Get a buffer with the filtered content of a blob.
  ///
  /// This applies filters as if the blob was being checked out to the
  /// working directory under the specified filename.  This may apply
  /// CRLF filtering or other types of changes depending on the file
  /// attributes set for the blob and the content detected in it.
  ///
  /// The output is written into a `git_buf` which the caller must free
  /// when done (via `git_buf_dispose`).
  ///
  /// If no filters need to be applied, then the `out` buffer will just
  /// be populated with a pointer to the raw content of the blob.  In
  /// that case, be careful to *not* free the blob until done with the
  /// buffer or copy it into memory you own.
  ///
  /// @param out The git_buf to be filled in
  /// @param blob Pointer to the blob
  /// @param as_path Path used for file attribute lookups, etc.
  /// @param opts Options to use for filtering the blob
  /// @return 0 on success or an error code
  int git_blob_filter(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Int8> as_path,
    ffi.Pointer<git_blob_filter_options> opts,
  ) {
    return _git_blob_filter(
      out,
      blob,
      as_path,
      opts,
    );
  }

  late final _git_blob_filter_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_filter>>('git_blob_filter');
  late final _dart_git_blob_filter _git_blob_filter =
      _git_blob_filter_ptr.asFunction<_dart_git_blob_filter>();

  /// Read a file from the working folder of a repository
  /// and write it to the Object Database as a loose blob
  ///
  /// @param id return the id of the written blob
  /// @param repo repository where the blob will be written.
  /// this repository cannot be bare
  /// @param relative_path file from which the blob will be created,
  /// relative to the repository's working dir
  /// @return 0 or an error code
  int git_blob_create_from_workdir(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> relative_path,
  ) {
    return _git_blob_create_from_workdir(
      id,
      repo,
      relative_path,
    );
  }

  late final _git_blob_create_from_workdir_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_from_workdir>>(
          'git_blob_create_from_workdir');
  late final _dart_git_blob_create_from_workdir _git_blob_create_from_workdir =
      _git_blob_create_from_workdir_ptr
          .asFunction<_dart_git_blob_create_from_workdir>();

  /// Read a file from the filesystem and write its content
  /// to the Object Database as a loose blob
  ///
  /// @param id return the id of the written blob
  /// @param repo repository where the blob will be written.
  /// this repository can be bare or not
  /// @param path file from which the blob will be created
  /// @return 0 or an error code
  int git_blob_create_from_disk(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_blob_create_from_disk(
      id,
      repo,
      path,
    );
  }

  late final _git_blob_create_from_disk_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_from_disk>>(
          'git_blob_create_from_disk');
  late final _dart_git_blob_create_from_disk _git_blob_create_from_disk =
      _git_blob_create_from_disk_ptr
          .asFunction<_dart_git_blob_create_from_disk>();

  /// Create a stream to write a new blob into the object db
  ///
  /// This function may need to buffer the data on disk and will in
  /// general not be the right choice if you know the size of the data
  /// to write. If you have data in memory, use
  /// `git_blob_create_from_buffer()`. If you do not, but know the size of
  /// the contents (and don't want/need to perform filtering), use
  /// `git_odb_open_wstream()`.
  ///
  /// Don't close this stream yourself but pass it to
  /// `git_blob_create_from_stream_commit()` to commit the write to the
  /// object db and get the object id.
  ///
  /// If the `hintpath` parameter is filled, it will be used to determine
  /// what git filters should be applied to the object before it is written
  /// to the object database.
  ///
  /// @param out the stream into which to write
  /// @param repo Repository where the blob will be written.
  /// This repository can be bare or not.
  /// @param hintpath If not NULL, will be used to select data filters
  /// to apply onto the content of the blob to be created.
  /// @return 0 or error code
  int git_blob_create_from_stream(
    ffi.Pointer<ffi.Pointer<git_writestream>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> hintpath,
  ) {
    return _git_blob_create_from_stream(
      out,
      repo,
      hintpath,
    );
  }

  late final _git_blob_create_from_stream_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_from_stream>>(
          'git_blob_create_from_stream');
  late final _dart_git_blob_create_from_stream _git_blob_create_from_stream =
      _git_blob_create_from_stream_ptr
          .asFunction<_dart_git_blob_create_from_stream>();

  /// Close the stream and write the blob to the object db
  ///
  /// The stream will be closed and freed.
  ///
  /// @param out the id of the new blob
  /// @param stream the stream to close
  /// @return 0 or an error code
  int git_blob_create_from_stream_commit(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_writestream> stream,
  ) {
    return _git_blob_create_from_stream_commit(
      out,
      stream,
    );
  }

  late final _git_blob_create_from_stream_commit_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_from_stream_commit>>(
          'git_blob_create_from_stream_commit');
  late final _dart_git_blob_create_from_stream_commit
      _git_blob_create_from_stream_commit =
      _git_blob_create_from_stream_commit_ptr
          .asFunction<_dart_git_blob_create_from_stream_commit>();

  /// Write an in-memory buffer to the ODB as a blob
  ///
  /// @param id return the id of the written blob
  /// @param repo repository where to blob will be written
  /// @param buffer data to be written into the blob
  /// @param len length of the data
  /// @return 0 or an error code
  int git_blob_create_from_buffer(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_blob_create_from_buffer(
      id,
      repo,
      buffer,
      len,
    );
  }

  late final _git_blob_create_from_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_from_buffer>>(
          'git_blob_create_from_buffer');
  late final _dart_git_blob_create_from_buffer _git_blob_create_from_buffer =
      _git_blob_create_from_buffer_ptr
          .asFunction<_dart_git_blob_create_from_buffer>();

  /// Determine if the blob content is most certainly binary or not.
  ///
  /// The heuristic used to guess if a file is binary is taken from core git:
  /// Searching for NUL bytes and looking for a reasonable ratio of printable
  /// to non-printable characters among the first 8000 bytes.
  ///
  /// @param blob The blob which content should be analyzed
  /// @return 1 if the content of the blob is detected
  /// as binary; 0 otherwise.
  int git_blob_is_binary(
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_blob_is_binary(
      blob,
    );
  }

  late final _git_blob_is_binary_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_is_binary>>('git_blob_is_binary');
  late final _dart_git_blob_is_binary _git_blob_is_binary =
      _git_blob_is_binary_ptr.asFunction<_dart_git_blob_is_binary>();

  /// Create an in-memory copy of a blob. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the object
  /// @param source Original object to copy
  int git_blob_dup(
    ffi.Pointer<ffi.Pointer<git_blob>> out,
    ffi.Pointer<git_blob> source,
  ) {
    return _git_blob_dup(
      out,
      source,
    );
  }

  late final _git_blob_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_dup>>('git_blob_dup');
  late final _dart_git_blob_dup _git_blob_dup =
      _git_blob_dup_ptr.asFunction<_dart_git_blob_dup>();

  /// Initialize git_blame_options structure
  ///
  /// Initializes a `git_blame_options` with default values. Equivalent to creating
  /// an instance with GIT_BLAME_OPTIONS_INIT.
  ///
  /// @param opts The `git_blame_options` struct to initialize.
  /// @param version The struct version; pass `GIT_BLAME_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_blame_options_init(
    ffi.Pointer<git_blame_options> opts,
    int version,
  ) {
    return _git_blame_options_init(
      opts,
      version,
    );
  }

  late final _git_blame_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_blame_options_init>>(
          'git_blame_options_init');
  late final _dart_git_blame_options_init _git_blame_options_init =
      _git_blame_options_init_ptr.asFunction<_dart_git_blame_options_init>();

  /// Gets the number of hunks that exist in the blame structure.
  int git_blame_get_hunk_count(
    ffi.Pointer<git_blame> blame,
  ) {
    return _git_blame_get_hunk_count(
      blame,
    );
  }

  late final _git_blame_get_hunk_count_ptr =
      _lookup<ffi.NativeFunction<_c_git_blame_get_hunk_count>>(
          'git_blame_get_hunk_count');
  late final _dart_git_blame_get_hunk_count _git_blame_get_hunk_count =
      _git_blame_get_hunk_count_ptr
          .asFunction<_dart_git_blame_get_hunk_count>();

  /// Gets the blame hunk at the given index.
  ///
  /// @param blame the blame structure to query
  /// @param index index of the hunk to retrieve
  /// @return the hunk at the given index, or NULL on error
  ffi.Pointer<git_blame_hunk> git_blame_get_hunk_byindex(
    ffi.Pointer<git_blame> blame,
    int index,
  ) {
    return _git_blame_get_hunk_byindex(
      blame,
      index,
    );
  }

  late final _git_blame_get_hunk_byindex_ptr =
      _lookup<ffi.NativeFunction<_c_git_blame_get_hunk_byindex>>(
          'git_blame_get_hunk_byindex');
  late final _dart_git_blame_get_hunk_byindex _git_blame_get_hunk_byindex =
      _git_blame_get_hunk_byindex_ptr
          .asFunction<_dart_git_blame_get_hunk_byindex>();

  /// Gets the hunk that relates to the given line number in the newest commit.
  ///
  /// @param blame the blame structure to query
  /// @param lineno the (1-based) line number to find a hunk for
  /// @return the hunk that contains the given line, or NULL on error
  ffi.Pointer<git_blame_hunk> git_blame_get_hunk_byline(
    ffi.Pointer<git_blame> blame,
    int lineno,
  ) {
    return _git_blame_get_hunk_byline(
      blame,
      lineno,
    );
  }

  late final _git_blame_get_hunk_byline_ptr =
      _lookup<ffi.NativeFunction<_c_git_blame_get_hunk_byline>>(
          'git_blame_get_hunk_byline');
  late final _dart_git_blame_get_hunk_byline _git_blame_get_hunk_byline =
      _git_blame_get_hunk_byline_ptr
          .asFunction<_dart_git_blame_get_hunk_byline>();

  /// Get the blame for a single file.
  ///
  /// @param out pointer that will receive the blame object
  /// @param repo repository whose history is to be walked
  /// @param path path to file to consider
  /// @param options options for the blame operation.  If NULL, this is treated as
  /// though GIT_BLAME_OPTIONS_INIT were passed.
  /// @return 0 on success, or an error code. (use git_error_last for information
  /// about the error.)
  int git_blame_file(
    ffi.Pointer<ffi.Pointer<git_blame>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<git_blame_options> options,
  ) {
    return _git_blame_file(
      out,
      repo,
      path,
      options,
    );
  }

  late final _git_blame_file_ptr =
      _lookup<ffi.NativeFunction<_c_git_blame_file>>('git_blame_file');
  late final _dart_git_blame_file _git_blame_file =
      _git_blame_file_ptr.asFunction<_dart_git_blame_file>();

  /// Get blame data for a file that has been modified in memory. The `reference`
  /// parameter is a pre-calculated blame for the in-odb history of the file. This
  /// means that once a file blame is completed (which can be expensive), updating
  /// the buffer blame is very fast.
  ///
  /// Lines that differ between the buffer and the committed version are marked as
  /// having a zero OID for their final_commit_id.
  ///
  /// @param out pointer that will receive the resulting blame data
  /// @param reference cached blame from the history of the file (usually the output
  /// from git_blame_file)
  /// @param buffer the (possibly) modified contents of the file
  /// @param buffer_len number of valid bytes in the buffer
  /// @return 0 on success, or an error code. (use git_error_last for information
  /// about the error)
  int git_blame_buffer(
    ffi.Pointer<ffi.Pointer<git_blame>> out,
    ffi.Pointer<git_blame> reference,
    ffi.Pointer<ffi.Int8> buffer,
    int buffer_len,
  ) {
    return _git_blame_buffer(
      out,
      reference,
      buffer,
      buffer_len,
    );
  }

  late final _git_blame_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_blame_buffer>>('git_blame_buffer');
  late final _dart_git_blame_buffer _git_blame_buffer =
      _git_blame_buffer_ptr.asFunction<_dart_git_blame_buffer>();

  /// Free memory allocated by git_blame_file or git_blame_buffer.
  ///
  /// @param blame the blame structure to free
  void git_blame_free(
    ffi.Pointer<git_blame> blame,
  ) {
    return _git_blame_free(
      blame,
    );
  }

  late final _git_blame_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_blame_free>>('git_blame_free');
  late final _dart_git_blame_free _git_blame_free =
      _git_blame_free_ptr.asFunction<_dart_git_blame_free>();

  /// Create a new branch pointing at a target commit
  ///
  /// A new direct reference will be created pointing to
  /// this target commit. If `force` is true and a reference
  /// already exists with the given name, it'll be replaced.
  ///
  /// The returned reference must be freed by the user.
  ///
  /// The branch name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out Pointer where to store the underlying reference.
  ///
  /// @param branch_name Name for the branch; this name is
  /// validated for consistency. It should also not conflict with
  /// an already existing branch name.
  ///
  /// @param target Commit to which this branch should point. This object
  /// must belong to the given `repo`.
  ///
  /// @param force Overwrite existing branch.
  ///
  /// @return 0, GIT_EINVALIDSPEC or an error code.
  /// A proper reference is written in the refs/heads namespace
  /// pointing to the provided target commit.
  int git_branch_create(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> branch_name,
    ffi.Pointer<git_commit> target,
    int force,
  ) {
    return _git_branch_create(
      out,
      repo,
      branch_name,
      target,
      force,
    );
  }

  late final _git_branch_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_create>>('git_branch_create');
  late final _dart_git_branch_create _git_branch_create =
      _git_branch_create_ptr.asFunction<_dart_git_branch_create>();

  /// Create a new branch pointing at a target commit
  ///
  /// This behaves like `git_branch_create()` but takes an annotated
  /// commit, which lets you specify which extended sha syntax string was
  /// specified by a user, allowing for more exact reflog messages.
  ///
  /// See the documentation for `git_branch_create()`.
  ///
  /// @see git_branch_create
  int git_branch_create_from_annotated(
    ffi.Pointer<ffi.Pointer<git_reference>> ref_out,
    ffi.Pointer<git_repository> repository,
    ffi.Pointer<ffi.Int8> branch_name,
    ffi.Pointer<git_annotated_commit> commit,
    int force,
  ) {
    return _git_branch_create_from_annotated(
      ref_out,
      repository,
      branch_name,
      commit,
      force,
    );
  }

  late final _git_branch_create_from_annotated_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_create_from_annotated>>(
          'git_branch_create_from_annotated');
  late final _dart_git_branch_create_from_annotated
      _git_branch_create_from_annotated = _git_branch_create_from_annotated_ptr
          .asFunction<_dart_git_branch_create_from_annotated>();

  /// Delete an existing branch reference.
  ///
  /// Note that if the deletion succeeds, the reference object will not
  /// be valid anymore, and should be freed immediately by the user using
  /// `git_reference_free()`.
  ///
  /// @param branch A valid reference representing a branch
  /// @return 0 on success, or an error code.
  int git_branch_delete(
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_delete(
      branch,
    );
  }

  late final _git_branch_delete_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_delete>>('git_branch_delete');
  late final _dart_git_branch_delete _git_branch_delete =
      _git_branch_delete_ptr.asFunction<_dart_git_branch_delete>();

  /// Create an iterator which loops over the requested branches.
  ///
  /// @param out the iterator
  /// @param repo Repository where to find the branches.
  /// @param list_flags Filtering flags for the branch
  /// listing. Valid values are GIT_BRANCH_LOCAL, GIT_BRANCH_REMOTE
  /// or GIT_BRANCH_ALL.
  ///
  /// @return 0 on success  or an error code
  int git_branch_iterator_new(
    ffi.Pointer<ffi.Pointer<git_branch_iterator>> out,
    ffi.Pointer<git_repository> repo,
    int list_flags,
  ) {
    return _git_branch_iterator_new(
      out,
      repo,
      list_flags,
    );
  }

  late final _git_branch_iterator_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_iterator_new>>(
          'git_branch_iterator_new');
  late final _dart_git_branch_iterator_new _git_branch_iterator_new =
      _git_branch_iterator_new_ptr.asFunction<_dart_git_branch_iterator_new>();

  /// Retrieve the next branch from the iterator
  ///
  /// @param out the reference
  /// @param out_type the type of branch (local or remote-tracking)
  /// @param iter the branch iterator
  /// @return 0 on success, GIT_ITEROVER if there are no more branches or an error code.
  int git_branch_next(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<ffi.Int32> out_type,
    ffi.Pointer<git_branch_iterator> iter,
  ) {
    return _git_branch_next(
      out,
      out_type,
      iter,
    );
  }

  late final _git_branch_next_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_next>>('git_branch_next');
  late final _dart_git_branch_next _git_branch_next =
      _git_branch_next_ptr.asFunction<_dart_git_branch_next>();

  /// Free a branch iterator
  ///
  /// @param iter the iterator to free
  void git_branch_iterator_free(
    ffi.Pointer<git_branch_iterator> iter,
  ) {
    return _git_branch_iterator_free(
      iter,
    );
  }

  late final _git_branch_iterator_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_iterator_free>>(
          'git_branch_iterator_free');
  late final _dart_git_branch_iterator_free _git_branch_iterator_free =
      _git_branch_iterator_free_ptr
          .asFunction<_dart_git_branch_iterator_free>();

  /// Move/rename an existing local branch reference.
  ///
  /// The new branch name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// Note that if the move succeeds, the old reference object will not
  /// + be valid anymore, and should be freed immediately by the user using
  /// + `git_reference_free()`.
  ///
  /// @param out New reference object for the updated name.
  ///
  /// @param branch Current underlying reference of the branch.
  ///
  /// @param new_branch_name Target name of the branch once the move
  /// is performed; this name is validated for consistency.
  ///
  /// @param force Overwrite existing branch.
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code.
  int git_branch_move(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> branch,
    ffi.Pointer<ffi.Int8> new_branch_name,
    int force,
  ) {
    return _git_branch_move(
      out,
      branch,
      new_branch_name,
      force,
    );
  }

  late final _git_branch_move_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_move>>('git_branch_move');
  late final _dart_git_branch_move _git_branch_move =
      _git_branch_move_ptr.asFunction<_dart_git_branch_move>();

  /// Lookup a branch by its name in a repository.
  ///
  /// The generated reference must be freed by the user.
  /// The branch name will be checked for validity.
  ///
  /// @see git_tag_create for rules about valid names.
  ///
  /// @param out pointer to the looked-up branch reference
  /// @param repo the repository to look up the branch
  /// @param branch_name Name of the branch to be looked-up;
  /// this name is validated for consistency.
  /// @param branch_type Type of the considered branch. This should
  /// be valued with either GIT_BRANCH_LOCAL or GIT_BRANCH_REMOTE.
  ///
  /// @return 0 on success; GIT_ENOTFOUND when no matching branch
  /// exists, GIT_EINVALIDSPEC, otherwise an error code.
  int git_branch_lookup(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> branch_name,
    int branch_type,
  ) {
    return _git_branch_lookup(
      out,
      repo,
      branch_name,
      branch_type,
    );
  }

  late final _git_branch_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_lookup>>('git_branch_lookup');
  late final _dart_git_branch_lookup _git_branch_lookup =
      _git_branch_lookup_ptr.asFunction<_dart_git_branch_lookup>();

  /// Get the branch name
  ///
  /// Given a reference object, this will check that it really is a branch (ie.
  /// it lives under "refs/heads/" or "refs/remotes/"), and return the branch part
  /// of it.
  ///
  /// @param out Pointer to the abbreviated reference name.
  /// Owned by ref, do not free.
  ///
  /// @param ref A reference object, ideally pointing to a branch
  ///
  /// @return 0 on success; GIT_EINVALID if the reference isn't either a local or
  /// remote branch, otherwise an error code.
  int git_branch_name(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
    ffi.Pointer<git_reference> ref,
  ) {
    return _git_branch_name(
      out,
      ref,
    );
  }

  late final _git_branch_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_name>>('git_branch_name');
  late final _dart_git_branch_name _git_branch_name =
      _git_branch_name_ptr.asFunction<_dart_git_branch_name>();

  /// Get the upstream of a branch
  ///
  /// Given a reference, this will return a new reference object corresponding
  /// to its remote tracking branch. The reference must be a local branch.
  ///
  /// @see git_branch_upstream_name for details on the resolution.
  ///
  /// @param out Pointer where to store the retrieved reference.
  /// @param branch Current underlying reference of the branch.
  ///
  /// @return 0 on success; GIT_ENOTFOUND when no remote tracking
  /// reference exists, otherwise an error code.
  int git_branch_upstream(
    ffi.Pointer<ffi.Pointer<git_reference>> out,
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_upstream(
      out,
      branch,
    );
  }

  late final _git_branch_upstream_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_upstream>>(
          'git_branch_upstream');
  late final _dart_git_branch_upstream _git_branch_upstream =
      _git_branch_upstream_ptr.asFunction<_dart_git_branch_upstream>();

  /// Set a branch's upstream branch
  ///
  /// This will update the configuration to set the branch named `branch_name` as the upstream of `branch`.
  /// Pass a NULL name to unset the upstream information.
  ///
  /// @note the actual tracking reference must have been already created for the
  /// operation to succeed.
  ///
  /// @param branch the branch to configure
  /// @param branch_name remote-tracking or local branch to set as upstream.
  ///
  /// @return 0 on success; GIT_ENOTFOUND if there's no branch named `branch_name`
  /// or an error code
  int git_branch_set_upstream(
    ffi.Pointer<git_reference> branch,
    ffi.Pointer<ffi.Int8> branch_name,
  ) {
    return _git_branch_set_upstream(
      branch,
      branch_name,
    );
  }

  late final _git_branch_set_upstream_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_set_upstream>>(
          'git_branch_set_upstream');
  late final _dart_git_branch_set_upstream _git_branch_set_upstream =
      _git_branch_set_upstream_ptr.asFunction<_dart_git_branch_set_upstream>();

  /// Get the upstream name of a branch
  ///
  /// Given a local branch, this will return its remote-tracking branch information,
  /// as a full reference name, ie. "feature/nice" would become
  /// "refs/remote/origin/feature/nice", depending on that branch's configuration.
  ///
  /// @param out the buffer into which the name will be written.
  /// @param repo the repository where the branches live.
  /// @param refname reference name of the local branch.
  ///
  /// @return 0 on success, GIT_ENOTFOUND when no remote tracking reference exists,
  /// or an error code.
  int git_branch_upstream_name(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_branch_upstream_name(
      out,
      repo,
      refname,
    );
  }

  late final _git_branch_upstream_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_upstream_name>>(
          'git_branch_upstream_name');
  late final _dart_git_branch_upstream_name _git_branch_upstream_name =
      _git_branch_upstream_name_ptr
          .asFunction<_dart_git_branch_upstream_name>();

  /// Determine if HEAD points to the given branch
  ///
  /// @param branch A reference to a local branch.
  ///
  /// @return 1 if HEAD points at the branch, 0 if it isn't, or a negative value
  /// as an error code.
  int git_branch_is_head(
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_is_head(
      branch,
    );
  }

  late final _git_branch_is_head_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_is_head>>('git_branch_is_head');
  late final _dart_git_branch_is_head _git_branch_is_head =
      _git_branch_is_head_ptr.asFunction<_dart_git_branch_is_head>();

  /// Determine if any HEAD points to the current branch
  ///
  /// This will iterate over all known linked repositories (usually in the form of
  /// worktrees) and report whether any HEAD is pointing at the current branch.
  ///
  /// @param branch A reference to a local branch.
  ///
  /// @return 1 if branch is checked out, 0 if it isn't, an error code otherwise.
  int git_branch_is_checked_out(
    ffi.Pointer<git_reference> branch,
  ) {
    return _git_branch_is_checked_out(
      branch,
    );
  }

  late final _git_branch_is_checked_out_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_is_checked_out>>(
          'git_branch_is_checked_out');
  late final _dart_git_branch_is_checked_out _git_branch_is_checked_out =
      _git_branch_is_checked_out_ptr
          .asFunction<_dart_git_branch_is_checked_out>();

  /// Find the remote name of a remote-tracking branch
  ///
  /// This will return the name of the remote whose fetch refspec is matching
  /// the given branch. E.g. given a branch "refs/remotes/test/master", it will
  /// extract the "test" part. If refspecs from multiple remotes match,
  /// the function will return GIT_EAMBIGUOUS.
  ///
  /// @param out The buffer into which the name will be written.
  /// @param repo The repository where the branch lives.
  /// @param refname complete name of the remote tracking branch.
  ///
  /// @return 0 on success, GIT_ENOTFOUND when no matching remote was found,
  /// GIT_EAMBIGUOUS when the branch maps to several remotes,
  /// otherwise an error code.
  int git_branch_remote_name(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_branch_remote_name(
      out,
      repo,
      refname,
    );
  }

  late final _git_branch_remote_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_remote_name>>(
          'git_branch_remote_name');
  late final _dart_git_branch_remote_name _git_branch_remote_name =
      _git_branch_remote_name_ptr.asFunction<_dart_git_branch_remote_name>();

  /// Retrieve the upstream remote of a local branch
  ///
  /// This will return the currently configured "branch.*.remote" for a given
  /// branch. This branch must be local.
  ///
  /// @param buf the buffer into which to write the name
  /// @param repo the repository in which to look
  /// @param refname the full name of the branch
  /// @return 0 or an error code
  int git_branch_upstream_remote(
    ffi.Pointer<git_buf> buf,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_branch_upstream_remote(
      buf,
      repo,
      refname,
    );
  }

  late final _git_branch_upstream_remote_ptr =
      _lookup<ffi.NativeFunction<_c_git_branch_upstream_remote>>(
          'git_branch_upstream_remote');
  late final _dart_git_branch_upstream_remote _git_branch_upstream_remote =
      _git_branch_upstream_remote_ptr
          .asFunction<_dart_git_branch_upstream_remote>();

  /// Initialize git_checkout_options structure
  ///
  /// Initializes a `git_checkout_options` with default values. Equivalent to creating
  /// an instance with GIT_CHECKOUT_OPTIONS_INIT.
  ///
  /// @param opts The `git_checkout_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CHECKOUT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_checkout_options_init(
    ffi.Pointer<git_checkout_options> opts,
    int version,
  ) {
    return _git_checkout_options_init(
      opts,
      version,
    );
  }

  late final _git_checkout_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_checkout_options_init>>(
          'git_checkout_options_init');
  late final _dart_git_checkout_options_init _git_checkout_options_init =
      _git_checkout_options_init_ptr
          .asFunction<_dart_git_checkout_options_init>();

  /// Updates files in the index and the working tree to match the content of
  /// the commit pointed at by HEAD.
  ///
  /// Note that this is _not_ the correct mechanism used to switch branches;
  /// do not change your `HEAD` and then call this method, that would leave
  /// you with checkout conflicts since your working directory would then
  /// appear to be dirty.  Instead, checkout the target of the branch and
  /// then update `HEAD` using `git_repository_set_head` to point to the
  /// branch you checked out.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, GIT_EUNBORNBRANCH if HEAD points to a non
  /// existing branch, non-zero value returned by `notify_cb`, or
  /// other error code < 0 (use git_error_last for error details)
  int git_checkout_head(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _git_checkout_head(
      repo,
      opts,
    );
  }

  late final _git_checkout_head_ptr =
      _lookup<ffi.NativeFunction<_c_git_checkout_head>>('git_checkout_head');
  late final _dart_git_checkout_head _git_checkout_head =
      _git_checkout_head_ptr.asFunction<_dart_git_checkout_head>();

  /// Updates files in the working tree to match the content of the index.
  ///
  /// @param repo repository into which to check out (must be non-bare)
  /// @param index index to be checked out (or NULL to use repository index)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, non-zero return value from `notify_cb`, or error
  /// code < 0 (use git_error_last for error details)
  int git_checkout_index(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _git_checkout_index(
      repo,
      index,
      opts,
    );
  }

  late final _git_checkout_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_checkout_index>>('git_checkout_index');
  late final _dart_git_checkout_index _git_checkout_index =
      _git_checkout_index_ptr.asFunction<_dart_git_checkout_index>();

  /// Updates files in the index and working tree to match the content of the
  /// tree pointed at by the treeish.
  ///
  /// @param repo repository to check out (must be non-bare)
  /// @param treeish a commit, tag or tree which content will be used to update
  /// the working directory (or NULL to use HEAD)
  /// @param opts specifies checkout options (may be NULL)
  /// @return 0 on success, non-zero return value from `notify_cb`, or error
  /// code < 0 (use git_error_last for error details)
  int git_checkout_tree(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> treeish,
    ffi.Pointer<git_checkout_options> opts,
  ) {
    return _git_checkout_tree(
      repo,
      treeish,
      opts,
    );
  }

  late final _git_checkout_tree_ptr =
      _lookup<ffi.NativeFunction<_c_git_checkout_tree>>('git_checkout_tree');
  late final _dart_git_checkout_tree _git_checkout_tree =
      _git_checkout_tree_ptr.asFunction<_dart_git_checkout_tree>();

  /// Free the OID array
  ///
  /// This method must (and must only) be called on `git_oidarray`
  /// objects where the array is allocated by the library. Not doing so,
  /// will result in a memory leak.
  ///
  /// This does not free the `git_oidarray` itself, since the library will
  /// never allocate that object directly itself (it is more commonly embedded
  /// inside another struct or created on the stack).
  ///
  /// @param array git_oidarray from which to free oid data
  void git_oidarray_free(
    ffi.Pointer<git_oidarray> array,
  ) {
    return _git_oidarray_free(
      array,
    );
  }

  late final _git_oidarray_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_oidarray_free>>('git_oidarray_free');
  late final _dart_git_oidarray_free _git_oidarray_free =
      _git_oidarray_free_ptr.asFunction<_dart_git_oidarray_free>();

  /// Initializes a `git_indexer_options` with default values. Equivalent to
  /// creating an instance with GIT_INDEXER_OPTIONS_INIT.
  ///
  /// @param opts the `git_indexer_options` struct to initialize.
  /// @param version Version of struct; pass `GIT_INDEXER_OPTIONS_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_indexer_options_init(
    ffi.Pointer<git_indexer_options> opts,
    int version,
  ) {
    return _git_indexer_options_init(
      opts,
      version,
    );
  }

  late final _git_indexer_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_indexer_options_init>>(
          'git_indexer_options_init');
  late final _dart_git_indexer_options_init _git_indexer_options_init =
      _git_indexer_options_init_ptr
          .asFunction<_dart_git_indexer_options_init>();

  /// Create a new indexer instance
  ///
  /// @param out where to store the indexer instance
  /// @param path to the directory where the packfile should be stored
  /// @param mode permissions to use creating packfile or 0 for defaults
  /// @param odb object database from which to read base objects when
  /// fixing thin packs. Pass NULL if no thin pack is expected (an error
  /// will be returned if there are bases missing)
  /// @param opts Optional structure containing additional options. See
  /// `git_indexer_options` above.
  int git_indexer_new(
    ffi.Pointer<ffi.Pointer<git_indexer>> out,
    ffi.Pointer<ffi.Int8> path,
    int mode,
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_indexer_options> opts,
  ) {
    return _git_indexer_new(
      out,
      path,
      mode,
      odb,
      opts,
    );
  }

  late final _git_indexer_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_indexer_new>>('git_indexer_new');
  late final _dart_git_indexer_new _git_indexer_new =
      _git_indexer_new_ptr.asFunction<_dart_git_indexer_new>();

  /// Add data to the indexer
  ///
  /// @param idx the indexer
  /// @param data the data to add
  /// @param size the size of the data in bytes
  /// @param stats stat storage
  int git_indexer_append(
    ffi.Pointer<git_indexer> idx,
    ffi.Pointer<ffi.Void> data,
    int size,
    ffi.Pointer<git_indexer_progress> stats,
  ) {
    return _git_indexer_append(
      idx,
      data,
      size,
      stats,
    );
  }

  late final _git_indexer_append_ptr =
      _lookup<ffi.NativeFunction<_c_git_indexer_append>>('git_indexer_append');
  late final _dart_git_indexer_append _git_indexer_append =
      _git_indexer_append_ptr.asFunction<_dart_git_indexer_append>();

  /// Finalize the pack and index
  ///
  /// Resolve any pending deltas and write out the index file
  ///
  /// @param idx the indexer
  int git_indexer_commit(
    ffi.Pointer<git_indexer> idx,
    ffi.Pointer<git_indexer_progress> stats,
  ) {
    return _git_indexer_commit(
      idx,
      stats,
    );
  }

  late final _git_indexer_commit_ptr =
      _lookup<ffi.NativeFunction<_c_git_indexer_commit>>('git_indexer_commit');
  late final _dart_git_indexer_commit _git_indexer_commit =
      _git_indexer_commit_ptr.asFunction<_dart_git_indexer_commit>();

  /// Get the packfile's hash
  ///
  /// A packfile's name is derived from the sorted hashing of all object
  /// names. This is only correct after the index has been finalized.
  ///
  /// @param idx the indexer instance
  ffi.Pointer<git_oid> git_indexer_hash(
    ffi.Pointer<git_indexer> idx,
  ) {
    return _git_indexer_hash(
      idx,
    );
  }

  late final _git_indexer_hash_ptr =
      _lookup<ffi.NativeFunction<_c_git_indexer_hash>>('git_indexer_hash');
  late final _dart_git_indexer_hash _git_indexer_hash =
      _git_indexer_hash_ptr.asFunction<_dart_git_indexer_hash>();

  /// Free the indexer and its resources
  ///
  /// @param idx the indexer to free
  void git_indexer_free(
    ffi.Pointer<git_indexer> idx,
  ) {
    return _git_indexer_free(
      idx,
    );
  }

  late final _git_indexer_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_indexer_free>>('git_indexer_free');
  late final _dart_git_indexer_free _git_indexer_free =
      _git_indexer_free_ptr.asFunction<_dart_git_indexer_free>();

  /// Create a new bare Git index object as a memory representation
  /// of the Git index file in 'index_path', without a repository
  /// to back it.
  ///
  /// Since there is no ODB or working directory behind this index,
  /// any Index methods which rely on these (e.g. index_add_bypath)
  /// will fail with the GIT_ERROR error code.
  ///
  /// If you need to access the index of an actual repository,
  /// use the `git_repository_index` wrapper.
  ///
  /// The index must be freed once it's no longer in use.
  ///
  /// @param out the pointer for the new index
  /// @param index_path the path to the index file in disk
  /// @return 0 or an error code
  int git_index_open(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<ffi.Int8> index_path,
  ) {
    return _git_index_open(
      out,
      index_path,
    );
  }

  late final _git_index_open_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_open>>('git_index_open');
  late final _dart_git_index_open _git_index_open =
      _git_index_open_ptr.asFunction<_dart_git_index_open>();

  /// Create an in-memory index object.
  ///
  /// This index object cannot be read/written to the filesystem,
  /// but may be used to perform in-memory index operations.
  ///
  /// The index must be freed once it's no longer in use.
  ///
  /// @param out the pointer for the new index
  /// @return 0 or an error code
  int git_index_new(
    ffi.Pointer<ffi.Pointer<git_index>> out,
  ) {
    return _git_index_new(
      out,
    );
  }

  late final _git_index_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_new>>('git_index_new');
  late final _dart_git_index_new _git_index_new =
      _git_index_new_ptr.asFunction<_dart_git_index_new>();

  /// Free an existing index object.
  ///
  /// @param index an existing index object
  void git_index_free(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_free(
      index,
    );
  }

  late final _git_index_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_free>>('git_index_free');
  late final _dart_git_index_free _git_index_free =
      _git_index_free_ptr.asFunction<_dart_git_index_free>();

  /// Get the repository this index relates to
  ///
  /// @param index The index
  /// @return A pointer to the repository
  ffi.Pointer<git_repository> git_index_owner(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_owner(
      index,
    );
  }

  late final _git_index_owner_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_owner>>('git_index_owner');
  late final _dart_git_index_owner _git_index_owner =
      _git_index_owner_ptr.asFunction<_dart_git_index_owner>();

  /// Read index capabilities flags.
  ///
  /// @param index An existing index object
  /// @return A combination of GIT_INDEX_CAPABILITY values
  int git_index_caps(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_caps(
      index,
    );
  }

  late final _git_index_caps_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_caps>>('git_index_caps');
  late final _dart_git_index_caps _git_index_caps =
      _git_index_caps_ptr.asFunction<_dart_git_index_caps>();

  /// Set index capabilities flags.
  ///
  /// If you pass `GIT_INDEX_CAPABILITY_FROM_OWNER` for the caps, then
  /// capabilities will be read from the config of the owner object,
  /// looking at `core.ignorecase`, `core.filemode`, `core.symlinks`.
  ///
  /// @param index An existing index object
  /// @param caps A combination of GIT_INDEX_CAPABILITY values
  /// @return 0 on success, -1 on failure
  int git_index_set_caps(
    ffi.Pointer<git_index> index,
    int caps,
  ) {
    return _git_index_set_caps(
      index,
      caps,
    );
  }

  late final _git_index_set_caps_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_set_caps>>('git_index_set_caps');
  late final _dart_git_index_set_caps _git_index_set_caps =
      _git_index_set_caps_ptr.asFunction<_dart_git_index_set_caps>();

  /// Get index on-disk version.
  ///
  /// Valid return values are 2, 3, or 4.  If 3 is returned, an index
  /// with version 2 may be written instead, if the extension data in
  /// version 3 is not necessary.
  ///
  /// @param index An existing index object
  /// @return the index version
  int git_index_version(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_version(
      index,
    );
  }

  late final _git_index_version_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_version>>('git_index_version');
  late final _dart_git_index_version _git_index_version =
      _git_index_version_ptr.asFunction<_dart_git_index_version>();

  /// Set index on-disk version.
  ///
  /// Valid values are 2, 3, or 4.  If 2 is given, git_index_write may
  /// write an index with version 3 instead, if necessary to accurately
  /// represent the index.
  ///
  /// @param index An existing index object
  /// @param version The new version number
  /// @return 0 on success, -1 on failure
  int git_index_set_version(
    ffi.Pointer<git_index> index,
    int version,
  ) {
    return _git_index_set_version(
      index,
      version,
    );
  }

  late final _git_index_set_version_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_set_version>>(
          'git_index_set_version');
  late final _dart_git_index_set_version _git_index_set_version =
      _git_index_set_version_ptr.asFunction<_dart_git_index_set_version>();

  /// Update the contents of an existing index object in memory by reading
  /// from the hard disk.
  ///
  /// If `force` is true, this performs a "hard" read that discards in-memory
  /// changes and always reloads the on-disk index data.  If there is no
  /// on-disk version, the index will be cleared.
  ///
  /// If `force` is false, this does a "soft" read that reloads the index
  /// data from disk only if it has changed since the last time it was
  /// loaded.  Purely in-memory index data will be untouched.  Be aware: if
  /// there are changes on disk, unwritten in-memory changes are discarded.
  ///
  /// @param index an existing index object
  /// @param force if true, always reload, vs. only read if file has changed
  /// @return 0 or an error code
  int git_index_read(
    ffi.Pointer<git_index> index,
    int force,
  ) {
    return _git_index_read(
      index,
      force,
    );
  }

  late final _git_index_read_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_read>>('git_index_read');
  late final _dart_git_index_read _git_index_read =
      _git_index_read_ptr.asFunction<_dart_git_index_read>();

  /// Write an existing index object from memory back to disk
  /// using an atomic file lock.
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int git_index_write(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_write(
      index,
    );
  }

  late final _git_index_write_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_write>>('git_index_write');
  late final _dart_git_index_write _git_index_write =
      _git_index_write_ptr.asFunction<_dart_git_index_write>();

  /// Get the full path to the index file on disk.
  ///
  /// @param index an existing index object
  /// @return path to index file or NULL for in-memory index
  ffi.Pointer<ffi.Int8> git_index_path(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_path(
      index,
    );
  }

  late final _git_index_path_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_path>>('git_index_path');
  late final _dart_git_index_path _git_index_path =
      _git_index_path_ptr.asFunction<_dart_git_index_path>();

  /// Get the checksum of the index
  ///
  /// This checksum is the SHA-1 hash over the index file (except the
  /// last 20 bytes which are the checksum itself). In cases where the
  /// index does not exist on-disk, it will be zeroed out.
  ///
  /// @param index an existing index object
  /// @return a pointer to the checksum of the index
  ffi.Pointer<git_oid> git_index_checksum(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_checksum(
      index,
    );
  }

  late final _git_index_checksum_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_checksum>>('git_index_checksum');
  late final _dart_git_index_checksum _git_index_checksum =
      _git_index_checksum_ptr.asFunction<_dart_git_index_checksum>();

  /// Read a tree into the index file with stats
  ///
  /// The current index contents will be replaced by the specified tree.
  ///
  /// @param index an existing index object
  /// @param tree tree to read
  /// @return 0 or an error code
  int git_index_read_tree(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_index_read_tree(
      index,
      tree,
    );
  }

  late final _git_index_read_tree_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_read_tree>>(
          'git_index_read_tree');
  late final _dart_git_index_read_tree _git_index_read_tree =
      _git_index_read_tree_ptr.asFunction<_dart_git_index_read_tree>();

  /// Write the index as a tree
  ///
  /// This method will scan the index and write a representation
  /// of its current state back to disk; it recursively creates
  /// tree objects for each of the subtrees stored in the index,
  /// but only returns the OID of the root tree. This is the OID
  /// that can be used e.g. to create a commit.
  ///
  /// The index instance cannot be bare, and needs to be associated
  /// to an existing repository.
  ///
  /// The index must not contain any file in conflict.
  ///
  /// @param out Pointer where to store the OID of the written tree
  /// @param index Index to write
  /// @return 0 on success, GIT_EUNMERGED when the index is not clean
  /// or an error code
  int git_index_write_tree(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_write_tree(
      out,
      index,
    );
  }

  late final _git_index_write_tree_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_write_tree>>(
          'git_index_write_tree');
  late final _dart_git_index_write_tree _git_index_write_tree =
      _git_index_write_tree_ptr.asFunction<_dart_git_index_write_tree>();

  /// Write the index as a tree to the given repository
  ///
  /// This method will do the same as `git_index_write_tree`, but
  /// letting the user choose the repository where the tree will
  /// be written.
  ///
  /// The index must not contain any file in conflict.
  ///
  /// @param out Pointer where to store OID of the the written tree
  /// @param index Index to write
  /// @param repo Repository where to write the tree
  /// @return 0 on success, GIT_EUNMERGED when the index is not clean
  /// or an error code
  int git_index_write_tree_to(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_index_write_tree_to(
      out,
      index,
      repo,
    );
  }

  late final _git_index_write_tree_to_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_write_tree_to>>(
          'git_index_write_tree_to');
  late final _dart_git_index_write_tree_to _git_index_write_tree_to =
      _git_index_write_tree_to_ptr.asFunction<_dart_git_index_write_tree_to>();

  /// Get the count of entries currently in the index
  ///
  /// @param index an existing index object
  /// @return integer of count of current entries
  int git_index_entrycount(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_entrycount(
      index,
    );
  }

  late final _git_index_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_entrycount>>(
          'git_index_entrycount');
  late final _dart_git_index_entrycount _git_index_entrycount =
      _git_index_entrycount_ptr.asFunction<_dart_git_index_entrycount>();

  /// Clear the contents (all the entries) of an index object.
  ///
  /// This clears the index object in memory; changes must be explicitly
  /// written to disk for them to take effect persistently.
  ///
  /// @param index an existing index object
  /// @return 0 on success, error code < 0 on failure
  int git_index_clear(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_clear(
      index,
    );
  }

  late final _git_index_clear_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_clear>>('git_index_clear');
  late final _dart_git_index_clear _git_index_clear =
      _git_index_clear_ptr.asFunction<_dart_git_index_clear>();

  /// Get a pointer to one of the entries in the index
  ///
  /// The entry is not modifiable and should not be freed.  Because the
  /// `git_index_entry` struct is a publicly defined struct, you should
  /// be able to make your own permanent copy of the data if necessary.
  ///
  /// @param index an existing index object
  /// @param n the position of the entry
  /// @return a pointer to the entry; NULL if out of bounds
  ffi.Pointer<git_index_entry> git_index_get_byindex(
    ffi.Pointer<git_index> index,
    int n,
  ) {
    return _git_index_get_byindex(
      index,
      n,
    );
  }

  late final _git_index_get_byindex_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_get_byindex>>(
          'git_index_get_byindex');
  late final _dart_git_index_get_byindex _git_index_get_byindex =
      _git_index_get_byindex_ptr.asFunction<_dart_git_index_get_byindex>();

  /// Get a pointer to one of the entries in the index
  ///
  /// The entry is not modifiable and should not be freed.  Because the
  /// `git_index_entry` struct is a publicly defined struct, you should
  /// be able to make your own permanent copy of the data if necessary.
  ///
  /// @param index an existing index object
  /// @param path path to search
  /// @param stage stage to search
  /// @return a pointer to the entry; NULL if it was not found
  ffi.Pointer<git_index_entry> git_index_get_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
    int stage,
  ) {
    return _git_index_get_bypath(
      index,
      path,
      stage,
    );
  }

  late final _git_index_get_bypath_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_get_bypath>>(
          'git_index_get_bypath');
  late final _dart_git_index_get_bypath _git_index_get_bypath =
      _git_index_get_bypath_ptr.asFunction<_dart_git_index_get_bypath>();

  /// Remove an entry from the index
  ///
  /// @param index an existing index object
  /// @param path path to search
  /// @param stage stage to search
  /// @return 0 or an error code
  int git_index_remove(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
    int stage,
  ) {
    return _git_index_remove(
      index,
      path,
      stage,
    );
  }

  late final _git_index_remove_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_remove>>('git_index_remove');
  late final _dart_git_index_remove _git_index_remove =
      _git_index_remove_ptr.asFunction<_dart_git_index_remove>();

  /// Remove all entries from the index under a given directory
  ///
  /// @param index an existing index object
  /// @param dir container directory path
  /// @param stage stage to search
  /// @return 0 or an error code
  int git_index_remove_directory(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> dir,
    int stage,
  ) {
    return _git_index_remove_directory(
      index,
      dir,
      stage,
    );
  }

  late final _git_index_remove_directory_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_remove_directory>>(
          'git_index_remove_directory');
  late final _dart_git_index_remove_directory _git_index_remove_directory =
      _git_index_remove_directory_ptr
          .asFunction<_dart_git_index_remove_directory>();

  /// Add or update an index entry from an in-memory struct
  ///
  /// If a previous index entry exists that has the same path and stage
  /// as the given 'source_entry', it will be replaced.  Otherwise, the
  /// 'source_entry' will be added.
  ///
  /// A full copy (including the 'path' string) of the given
  /// 'source_entry' will be inserted on the index.
  ///
  /// @param index an existing index object
  /// @param source_entry new entry object
  /// @return 0 or an error code
  int git_index_add(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> source_entry,
  ) {
    return _git_index_add(
      index,
      source_entry,
    );
  }

  late final _git_index_add_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_add>>('git_index_add');
  late final _dart_git_index_add _git_index_add =
      _git_index_add_ptr.asFunction<_dart_git_index_add>();

  /// Return the stage number from a git index entry
  ///
  /// This entry is calculated from the entry's flag attribute like this:
  ///
  /// (entry->flags & GIT_INDEX_ENTRY_STAGEMASK) >> GIT_INDEX_ENTRY_STAGESHIFT
  ///
  /// @param entry The entry
  /// @return the stage number
  int git_index_entry_stage(
    ffi.Pointer<git_index_entry> entry,
  ) {
    return _git_index_entry_stage(
      entry,
    );
  }

  late final _git_index_entry_stage_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_entry_stage>>(
          'git_index_entry_stage');
  late final _dart_git_index_entry_stage _git_index_entry_stage =
      _git_index_entry_stage_ptr.asFunction<_dart_git_index_entry_stage>();

  /// Return whether the given index entry is a conflict (has a high stage
  /// entry).  This is simply shorthand for `git_index_entry_stage > 0`.
  ///
  /// @param entry The entry
  /// @return 1 if the entry is a conflict entry, 0 otherwise
  int git_index_entry_is_conflict(
    ffi.Pointer<git_index_entry> entry,
  ) {
    return _git_index_entry_is_conflict(
      entry,
    );
  }

  late final _git_index_entry_is_conflict_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_entry_is_conflict>>(
          'git_index_entry_is_conflict');
  late final _dart_git_index_entry_is_conflict _git_index_entry_is_conflict =
      _git_index_entry_is_conflict_ptr
          .asFunction<_dart_git_index_entry_is_conflict>();

  /// Create an iterator that will return every entry contained in the
  /// index at the time of creation.  Entries are returned in order,
  /// sorted by path.  This iterator is backed by a snapshot that allows
  /// callers to modify the index while iterating without affecting the
  /// iterator.
  ///
  /// @param iterator_out The newly created iterator
  /// @param index The index to iterate
  int git_index_iterator_new(
    ffi.Pointer<ffi.Pointer<git_index_iterator>> iterator_out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_iterator_new(
      iterator_out,
      index,
    );
  }

  late final _git_index_iterator_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_iterator_new>>(
          'git_index_iterator_new');
  late final _dart_git_index_iterator_new _git_index_iterator_new =
      _git_index_iterator_new_ptr.asFunction<_dart_git_index_iterator_new>();

  /// Return the next index entry in-order from the iterator.
  ///
  /// @param out Pointer to store the index entry in
  /// @param iterator The iterator
  /// @return 0, GIT_ITEROVER on iteration completion or an error code
  int git_index_iterator_next(
    ffi.Pointer<ffi.Pointer<git_index_entry>> out,
    ffi.Pointer<git_index_iterator> iterator,
  ) {
    return _git_index_iterator_next(
      out,
      iterator,
    );
  }

  late final _git_index_iterator_next_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_iterator_next>>(
          'git_index_iterator_next');
  late final _dart_git_index_iterator_next _git_index_iterator_next =
      _git_index_iterator_next_ptr.asFunction<_dart_git_index_iterator_next>();

  /// Free the index iterator
  ///
  /// @param iterator The iterator to free
  void git_index_iterator_free(
    ffi.Pointer<git_index_iterator> iterator,
  ) {
    return _git_index_iterator_free(
      iterator,
    );
  }

  late final _git_index_iterator_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_iterator_free>>(
          'git_index_iterator_free');
  late final _dart_git_index_iterator_free _git_index_iterator_free =
      _git_index_iterator_free_ptr.asFunction<_dart_git_index_iterator_free>();

  /// Add or update an index entry from a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder and must be readable.
  ///
  /// This method will fail in bare index instances.
  ///
  /// This forces the file to be added to the index, not looking
  /// at gitignore rules.  Those rules can be evaluated through
  /// the git_status APIs (in status.h) before calling this.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to add
  /// @return 0 or an error code
  int git_index_add_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_index_add_bypath(
      index,
      path,
    );
  }

  late final _git_index_add_bypath_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_add_bypath>>(
          'git_index_add_bypath');
  late final _dart_git_index_add_bypath _git_index_add_bypath =
      _git_index_add_bypath_ptr.asFunction<_dart_git_index_add_bypath>();

  /// Add or update an index entry from a buffer in memory
  ///
  /// This method will create a blob in the repository that owns the
  /// index and then add the index entry to the index.  The `path` of the
  /// entry represents the position of the blob relative to the
  /// repository's root folder.
  ///
  /// If a previous index entry exists that has the same path as the
  /// given 'entry', it will be replaced.  Otherwise, the 'entry' will be
  /// added.
  ///
  /// This forces the file to be added to the index, not looking
  /// at gitignore rules.  Those rules can be evaluated through
  /// the git_status APIs (in status.h) before calling this.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param entry filename to add
  /// @param buffer data to be written into the blob
  /// @param len length of the data
  /// @return 0 or an error code
  int git_index_add_from_buffer(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> entry,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_index_add_from_buffer(
      index,
      entry,
      buffer,
      len,
    );
  }

  late final _git_index_add_from_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_add_from_buffer>>(
          'git_index_add_from_buffer');
  late final _dart_git_index_add_from_buffer _git_index_add_from_buffer =
      _git_index_add_from_buffer_ptr
          .asFunction<_dart_git_index_add_from_buffer>();

  /// Remove an index entry corresponding to a file on disk
  ///
  /// The file `path` must be relative to the repository's
  /// working folder.  It may exist.
  ///
  /// If this file currently is the result of a merge conflict, this
  /// file will no longer be marked as conflicting.  The data about
  /// the conflict will be moved to the "resolve undo" (REUC) section.
  ///
  /// @param index an existing index object
  /// @param path filename to remove
  /// @return 0 or an error code
  int git_index_remove_bypath(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_index_remove_bypath(
      index,
      path,
    );
  }

  late final _git_index_remove_bypath_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_remove_bypath>>(
          'git_index_remove_bypath');
  late final _dart_git_index_remove_bypath _git_index_remove_bypath =
      _git_index_remove_bypath_ptr.asFunction<_dart_git_index_remove_bypath>();

  /// Add or update index entries matching files in the working directory.
  ///
  /// This method will fail in bare index instances.
  ///
  /// The `pathspec` is a list of file names or shell glob patterns that will
  /// be matched against files in the repository's working directory.  Each
  /// file that matches will be added to the index (either updating an
  /// existing entry or adding a new entry).  You can disable glob expansion
  /// and force exact matching with the `GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH`
  /// flag.
  ///
  /// Files that are ignored will be skipped (unlike `git_index_add_bypath`).
  /// If a file is already tracked in the index, then it *will* be updated
  /// even if it is ignored.  Pass the `GIT_INDEX_ADD_FORCE` flag to skip
  /// the checking of ignore rules.
  ///
  /// To emulate `git add -A` and generate an error if the pathspec contains
  /// the exact path of an ignored file (when not using FORCE), add the
  /// `GIT_INDEX_ADD_CHECK_PATHSPEC` flag.  This checks that each entry
  /// in the `pathspec` that is an exact match to a filename on disk is
  /// either not ignored or already in the index.  If this check fails, the
  /// function will return GIT_EINVALIDSPEC.
  ///
  /// To emulate `git add -A` with the "dry-run" option, just use a callback
  /// function that always returns a positive value.  See below for details.
  ///
  /// If any files are currently the result of a merge conflict, those files
  /// will no longer be marked as conflicting.  The data about the conflicts
  /// will be moved to the "resolve undo" (REUC) section.
  ///
  /// If you provide a callback function, it will be invoked on each matching
  /// item in the working directory immediately *before* it is added to /
  /// updated in the index.  Returning zero will add the item to the index,
  /// greater than zero will skip the item, and less than zero will abort the
  /// scan and return that value to the caller.
  ///
  /// @param index an existing index object
  /// @param pathspec array of path patterns
  /// @param flags combination of git_index_add_option_t flags
  /// @param callback notification callback for each added/updated path (also
  /// gets index of matching pathspec entry); can be NULL;
  /// return 0 to add, >0 to skip, <0 to abort scan.
  /// @param payload payload passed through to callback function
  /// @return 0 on success, negative callback return value, or error code
  int git_index_add_all(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_strarray> pathspec,
    int flags,
    ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_index_add_all(
      index,
      pathspec,
      flags,
      callback,
      payload,
    );
  }

  late final _git_index_add_all_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_add_all>>('git_index_add_all');
  late final _dart_git_index_add_all _git_index_add_all =
      _git_index_add_all_ptr.asFunction<_dart_git_index_add_all>();

  /// Remove all matching index entries.
  ///
  /// If you provide a callback function, it will be invoked on each matching
  /// item in the index immediately *before* it is removed.  Return 0 to
  /// remove the item, > 0 to skip the item, and < 0 to abort the scan.
  ///
  /// @param index An existing index object
  /// @param pathspec array of path patterns
  /// @param callback notification callback for each removed path (also
  /// gets index of matching pathspec entry); can be NULL;
  /// return 0 to add, >0 to skip, <0 to abort scan.
  /// @param payload payload passed through to callback function
  /// @return 0 on success, negative callback return value, or error code
  int git_index_remove_all(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_strarray> pathspec,
    ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_index_remove_all(
      index,
      pathspec,
      callback,
      payload,
    );
  }

  late final _git_index_remove_all_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_remove_all>>(
          'git_index_remove_all');
  late final _dart_git_index_remove_all _git_index_remove_all =
      _git_index_remove_all_ptr.asFunction<_dart_git_index_remove_all>();

  /// Update all index entries to match the working directory
  ///
  /// This method will fail in bare index instances.
  ///
  /// This scans the existing index entries and synchronizes them with the
  /// working directory, deleting them if the corresponding working directory
  /// file no longer exists otherwise updating the information (including
  /// adding the latest version of file to the ODB if needed).
  ///
  /// If you provide a callback function, it will be invoked on each matching
  /// item in the index immediately *before* it is updated (either refreshed
  /// or removed depending on working directory state).  Return 0 to proceed
  /// with updating the item, > 0 to skip the item, and < 0 to abort the scan.
  ///
  /// @param index An existing index object
  /// @param pathspec array of path patterns
  /// @param callback notification callback for each updated path (also
  /// gets index of matching pathspec entry); can be NULL;
  /// return 0 to add, >0 to skip, <0 to abort scan.
  /// @param payload payload passed through to callback function
  /// @return 0 on success, negative callback return value, or error code
  int git_index_update_all(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_strarray> pathspec,
    ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_index_update_all(
      index,
      pathspec,
      callback,
      payload,
    );
  }

  late final _git_index_update_all_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_update_all>>(
          'git_index_update_all');
  late final _dart_git_index_update_all _git_index_update_all =
      _git_index_update_all_ptr.asFunction<_dart_git_index_update_all>();

  /// Find the first position of any entries which point to given
  /// path in the Git index.
  ///
  /// @param at_pos the address to which the position of the index entry is written (optional)
  /// @param index an existing index object
  /// @param path path to search
  /// @return a zero-based position in the index if found; GIT_ENOTFOUND otherwise
  int git_index_find(
    ffi.Pointer<ffi.Int32> at_pos,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_index_find(
      at_pos,
      index,
      path,
    );
  }

  late final _git_index_find_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_find>>('git_index_find');
  late final _dart_git_index_find _git_index_find =
      _git_index_find_ptr.asFunction<_dart_git_index_find>();

  /// Find the first position of any entries matching a prefix. To find the first position
  /// of a path inside a given folder, suffix the prefix with a '/'.
  ///
  /// @param at_pos the address to which the position of the index entry is written (optional)
  /// @param index an existing index object
  /// @param prefix the prefix to search for
  /// @return 0 with valid value in at_pos; an error code otherwise
  int git_index_find_prefix(
    ffi.Pointer<ffi.Int32> at_pos,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> prefix,
  ) {
    return _git_index_find_prefix(
      at_pos,
      index,
      prefix,
    );
  }

  late final _git_index_find_prefix_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_find_prefix>>(
          'git_index_find_prefix');
  late final _dart_git_index_find_prefix _git_index_find_prefix =
      _git_index_find_prefix_ptr.asFunction<_dart_git_index_find_prefix>();

  /// Add or update index entries to represent a conflict.  Any staged
  /// entries that exist at the given paths will be removed.
  ///
  /// The entries are the entries from the tree included in the merge.  Any
  /// entry may be null to indicate that that file was not present in the
  /// trees during the merge.  For example, ancestor_entry may be NULL to
  /// indicate that a file was added in both branches and must be resolved.
  ///
  /// @param index an existing index object
  /// @param ancestor_entry the entry data for the ancestor of the conflict
  /// @param our_entry the entry data for our side of the merge conflict
  /// @param their_entry the entry data for their side of the merge conflict
  /// @return 0 or an error code
  int git_index_conflict_add(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> ancestor_entry,
    ffi.Pointer<git_index_entry> our_entry,
    ffi.Pointer<git_index_entry> their_entry,
  ) {
    return _git_index_conflict_add(
      index,
      ancestor_entry,
      our_entry,
      their_entry,
    );
  }

  late final _git_index_conflict_add_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_conflict_add>>(
          'git_index_conflict_add');
  late final _dart_git_index_conflict_add _git_index_conflict_add =
      _git_index_conflict_add_ptr.asFunction<_dart_git_index_conflict_add>();

  /// Get the index entries that represent a conflict of a single file.
  ///
  /// The entries are not modifiable and should not be freed.  Because the
  /// `git_index_entry` struct is a publicly defined struct, you should
  /// be able to make your own permanent copy of the data if necessary.
  ///
  /// @param ancestor_out Pointer to store the ancestor entry
  /// @param our_out Pointer to store the our entry
  /// @param their_out Pointer to store the their entry
  /// @param index an existing index object
  /// @param path path to search
  /// @return 0 or an error code
  int git_index_conflict_get(
    ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_index_conflict_get(
      ancestor_out,
      our_out,
      their_out,
      index,
      path,
    );
  }

  late final _git_index_conflict_get_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_conflict_get>>(
          'git_index_conflict_get');
  late final _dart_git_index_conflict_get _git_index_conflict_get =
      _git_index_conflict_get_ptr.asFunction<_dart_git_index_conflict_get>();

  /// Removes the index entries that represent a conflict of a single file.
  ///
  /// @param index an existing index object
  /// @param path path to remove conflicts for
  /// @return 0 or an error code
  int git_index_conflict_remove(
    ffi.Pointer<git_index> index,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_index_conflict_remove(
      index,
      path,
    );
  }

  late final _git_index_conflict_remove_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_conflict_remove>>(
          'git_index_conflict_remove');
  late final _dart_git_index_conflict_remove _git_index_conflict_remove =
      _git_index_conflict_remove_ptr
          .asFunction<_dart_git_index_conflict_remove>();

  /// Remove all conflicts in the index (entries with a stage greater than 0).
  ///
  /// @param index an existing index object
  /// @return 0 or an error code
  int git_index_conflict_cleanup(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_conflict_cleanup(
      index,
    );
  }

  late final _git_index_conflict_cleanup_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_conflict_cleanup>>(
          'git_index_conflict_cleanup');
  late final _dart_git_index_conflict_cleanup _git_index_conflict_cleanup =
      _git_index_conflict_cleanup_ptr
          .asFunction<_dart_git_index_conflict_cleanup>();

  /// Determine if the index contains entries representing file conflicts.
  ///
  /// @return 1 if at least one conflict is found, 0 otherwise.
  int git_index_has_conflicts(
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_has_conflicts(
      index,
    );
  }

  late final _git_index_has_conflicts_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_has_conflicts>>(
          'git_index_has_conflicts');
  late final _dart_git_index_has_conflicts _git_index_has_conflicts =
      _git_index_has_conflicts_ptr.asFunction<_dart_git_index_has_conflicts>();

  /// Create an iterator for the conflicts in the index.
  ///
  /// The index must not be modified while iterating; the results are undefined.
  ///
  /// @param iterator_out The newly created conflict iterator
  /// @param index The index to scan
  /// @return 0 or an error code
  int git_index_conflict_iterator_new(
    ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>> iterator_out,
    ffi.Pointer<git_index> index,
  ) {
    return _git_index_conflict_iterator_new(
      iterator_out,
      index,
    );
  }

  late final _git_index_conflict_iterator_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_conflict_iterator_new>>(
          'git_index_conflict_iterator_new');
  late final _dart_git_index_conflict_iterator_new
      _git_index_conflict_iterator_new = _git_index_conflict_iterator_new_ptr
          .asFunction<_dart_git_index_conflict_iterator_new>();

  /// Returns the current conflict (ancestor, ours and theirs entry) and
  /// advance the iterator internally to the next value.
  ///
  /// @param ancestor_out Pointer to store the ancestor side of the conflict
  /// @param our_out Pointer to store our side of the conflict
  /// @param their_out Pointer to store their side of the conflict
  /// @return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
  /// (negative value)
  int git_index_conflict_next(
    ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
    ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
    ffi.Pointer<git_index_conflict_iterator> iterator,
  ) {
    return _git_index_conflict_next(
      ancestor_out,
      our_out,
      their_out,
      iterator,
    );
  }

  late final _git_index_conflict_next_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_conflict_next>>(
          'git_index_conflict_next');
  late final _dart_git_index_conflict_next _git_index_conflict_next =
      _git_index_conflict_next_ptr.asFunction<_dart_git_index_conflict_next>();

  /// Frees a `git_index_conflict_iterator`.
  ///
  /// @param iterator pointer to the iterator
  void git_index_conflict_iterator_free(
    ffi.Pointer<git_index_conflict_iterator> iterator,
  ) {
    return _git_index_conflict_iterator_free(
      iterator,
    );
  }

  late final _git_index_conflict_iterator_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_conflict_iterator_free>>(
          'git_index_conflict_iterator_free');
  late final _dart_git_index_conflict_iterator_free
      _git_index_conflict_iterator_free = _git_index_conflict_iterator_free_ptr
          .asFunction<_dart_git_index_conflict_iterator_free>();

  /// Initializes a `git_merge_file_input` with default values. Equivalent to
  /// creating an instance with GIT_MERGE_FILE_INPUT_INIT.
  ///
  /// @param opts the `git_merge_file_input` instance to initialize.
  /// @param version the version of the struct; you should pass
  /// `GIT_MERGE_FILE_INPUT_VERSION` here.
  /// @return Zero on success; -1 on failure.
  int git_merge_file_input_init(
    ffi.Pointer<git_merge_file_input> opts,
    int version,
  ) {
    return _git_merge_file_input_init(
      opts,
      version,
    );
  }

  late final _git_merge_file_input_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_file_input_init>>(
          'git_merge_file_input_init');
  late final _dart_git_merge_file_input_init _git_merge_file_input_init =
      _git_merge_file_input_init_ptr
          .asFunction<_dart_git_merge_file_input_init>();

  /// Initialize git_merge_file_options structure
  ///
  /// Initializes a `git_merge_file_options` with default values. Equivalent to
  /// creating an instance with `GIT_MERGE_FILE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_merge_file_options` struct to initialize.
  /// @param version The struct version; pass `GIT_MERGE_FILE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_merge_file_options_init(
    ffi.Pointer<git_merge_file_options> opts,
    int version,
  ) {
    return _git_merge_file_options_init(
      opts,
      version,
    );
  }

  late final _git_merge_file_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_file_options_init>>(
          'git_merge_file_options_init');
  late final _dart_git_merge_file_options_init _git_merge_file_options_init =
      _git_merge_file_options_init_ptr
          .asFunction<_dart_git_merge_file_options_init>();

  /// Initialize git_merge_options structure
  ///
  /// Initializes a `git_merge_options` with default values. Equivalent to
  /// creating an instance with `GIT_MERGE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_merge_options` struct to initialize.
  /// @param version The struct version; pass `GIT_MERGE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_merge_options_init(
    ffi.Pointer<git_merge_options> opts,
    int version,
  ) {
    return _git_merge_options_init(
      opts,
      version,
    );
  }

  late final _git_merge_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_options_init>>(
          'git_merge_options_init');
  late final _dart_git_merge_options_init _git_merge_options_init =
      _git_merge_options_init_ptr.asFunction<_dart_git_merge_options_init>();

  /// Analyzes the given branch(es) and determines the opportunities for
  /// merging them into the HEAD of the repository.
  ///
  /// @param analysis_out analysis enumeration that the result is written into
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @return 0 on success or error code
  int git_merge_analysis(
    ffi.Pointer<ffi.Int32> analysis_out,
    ffi.Pointer<ffi.Int32> preference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
  ) {
    return _git_merge_analysis(
      analysis_out,
      preference_out,
      repo,
      their_heads,
      their_heads_len,
    );
  }

  late final _git_merge_analysis_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_analysis>>('git_merge_analysis');
  late final _dart_git_merge_analysis _git_merge_analysis =
      _git_merge_analysis_ptr.asFunction<_dart_git_merge_analysis>();

  /// Analyzes the given branch(es) and determines the opportunities for
  /// merging them into a reference.
  ///
  /// @param analysis_out analysis enumeration that the result is written into
  /// @param repo the repository to merge
  /// @param our_ref the reference to perform the analysis from
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @return 0 on success or error code
  int git_merge_analysis_for_ref(
    ffi.Pointer<ffi.Int32> analysis_out,
    ffi.Pointer<ffi.Int32> preference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_reference> our_ref,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
  ) {
    return _git_merge_analysis_for_ref(
      analysis_out,
      preference_out,
      repo,
      our_ref,
      their_heads,
      their_heads_len,
    );
  }

  late final _git_merge_analysis_for_ref_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_analysis_for_ref>>(
          'git_merge_analysis_for_ref');
  late final _dart_git_merge_analysis_for_ref _git_merge_analysis_for_ref =
      _git_merge_analysis_for_ref_ptr
          .asFunction<_dart_git_merge_analysis_for_ref>();

  /// Find a merge base between two commits
  ///
  /// @param out the OID of a merge base between 'one' and 'two'
  /// @param repo the repository where the commits exist
  /// @param one one of the commits
  /// @param two the other commit
  /// @return 0 on success, GIT_ENOTFOUND if not found or error code
  int git_merge_base(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> one,
    ffi.Pointer<git_oid> two,
  ) {
    return _git_merge_base(
      out,
      repo,
      one,
      two,
    );
  }

  late final _git_merge_base_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_base>>('git_merge_base');
  late final _dart_git_merge_base _git_merge_base =
      _git_merge_base_ptr.asFunction<_dart_git_merge_base>();

  /// Find merge bases between two commits
  ///
  /// @param out array in which to store the resulting ids
  /// @param repo the repository where the commits exist
  /// @param one one of the commits
  /// @param two the other commit
  /// @return 0 on success, GIT_ENOTFOUND if not found or error code
  int git_merge_bases(
    ffi.Pointer<git_oidarray> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> one,
    ffi.Pointer<git_oid> two,
  ) {
    return _git_merge_bases(
      out,
      repo,
      one,
      two,
    );
  }

  late final _git_merge_bases_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_bases>>('git_merge_bases');
  late final _dart_git_merge_bases _git_merge_bases =
      _git_merge_bases_ptr.asFunction<_dart_git_merge_bases>();

  /// Find a merge base given a list of commits
  ///
  /// @param out the OID of a merge base considering all the commits
  /// @param repo the repository where the commits exist
  /// @param length The number of commits in the provided `input_array`
  /// @param input_array oids of the commits
  /// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
  int git_merge_base_many(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    int length,
    ffi.Pointer<git_oid> input_array,
  ) {
    return _git_merge_base_many(
      out,
      repo,
      length,
      input_array,
    );
  }

  late final _git_merge_base_many_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_base_many>>(
          'git_merge_base_many');
  late final _dart_git_merge_base_many _git_merge_base_many =
      _git_merge_base_many_ptr.asFunction<_dart_git_merge_base_many>();

  /// Find all merge bases given a list of commits
  ///
  /// @param out array in which to store the resulting ids
  /// @param repo the repository where the commits exist
  /// @param length The number of commits in the provided `input_array`
  /// @param input_array oids of the commits
  /// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
  int git_merge_bases_many(
    ffi.Pointer<git_oidarray> out,
    ffi.Pointer<git_repository> repo,
    int length,
    ffi.Pointer<git_oid> input_array,
  ) {
    return _git_merge_bases_many(
      out,
      repo,
      length,
      input_array,
    );
  }

  late final _git_merge_bases_many_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_bases_many>>(
          'git_merge_bases_many');
  late final _dart_git_merge_bases_many _git_merge_bases_many =
      _git_merge_bases_many_ptr.asFunction<_dart_git_merge_bases_many>();

  /// Find a merge base in preparation for an octopus merge
  ///
  /// @param out the OID of a merge base considering all the commits
  /// @param repo the repository where the commits exist
  /// @param length The number of commits in the provided `input_array`
  /// @param input_array oids of the commits
  /// @return Zero on success; GIT_ENOTFOUND or -1 on failure.
  int git_merge_base_octopus(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    int length,
    ffi.Pointer<git_oid> input_array,
  ) {
    return _git_merge_base_octopus(
      out,
      repo,
      length,
      input_array,
    );
  }

  late final _git_merge_base_octopus_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_base_octopus>>(
          'git_merge_base_octopus');
  late final _dart_git_merge_base_octopus _git_merge_base_octopus =
      _git_merge_base_octopus_ptr.asFunction<_dart_git_merge_base_octopus>();

  /// Merge two files as they exist in the in-memory data structures, using
  /// the given common ancestor as the baseline, producing a
  /// `git_merge_file_result` that reflects the merge result.  The
  /// `git_merge_file_result` must be freed with `git_merge_file_result_free`.
  ///
  /// Note that this function does not reference a repository and any
  /// configuration must be passed as `git_merge_file_options`.
  ///
  /// @param out The git_merge_file_result to be filled in
  /// @param ancestor The contents of the ancestor file
  /// @param ours The contents of the file in "our" side
  /// @param theirs The contents of the file in "their" side
  /// @param opts The merge file options or `NULL` for defaults
  /// @return 0 on success or error code
  int git_merge_file(
    ffi.Pointer<git_merge_file_result> out,
    ffi.Pointer<git_merge_file_input> ancestor,
    ffi.Pointer<git_merge_file_input> ours,
    ffi.Pointer<git_merge_file_input> theirs,
    ffi.Pointer<git_merge_file_options> opts,
  ) {
    return _git_merge_file(
      out,
      ancestor,
      ours,
      theirs,
      opts,
    );
  }

  late final _git_merge_file_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_file>>('git_merge_file');
  late final _dart_git_merge_file _git_merge_file =
      _git_merge_file_ptr.asFunction<_dart_git_merge_file>();

  /// Merge two files as they exist in the index, using the given common
  /// ancestor as the baseline, producing a `git_merge_file_result` that
  /// reflects the merge result.  The `git_merge_file_result` must be freed with
  /// `git_merge_file_result_free`.
  ///
  /// @param out The git_merge_file_result to be filled in
  /// @param repo The repository
  /// @param ancestor The index entry for the ancestor file (stage level 1)
  /// @param ours The index entry for our file (stage level 2)
  /// @param theirs The index entry for their file (stage level 3)
  /// @param opts The merge file options or NULL
  /// @return 0 on success or error code
  int git_merge_file_from_index(
    ffi.Pointer<git_merge_file_result> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_index_entry> ancestor,
    ffi.Pointer<git_index_entry> ours,
    ffi.Pointer<git_index_entry> theirs,
    ffi.Pointer<git_merge_file_options> opts,
  ) {
    return _git_merge_file_from_index(
      out,
      repo,
      ancestor,
      ours,
      theirs,
      opts,
    );
  }

  late final _git_merge_file_from_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_file_from_index>>(
          'git_merge_file_from_index');
  late final _dart_git_merge_file_from_index _git_merge_file_from_index =
      _git_merge_file_from_index_ptr
          .asFunction<_dart_git_merge_file_from_index>();

  /// Frees a `git_merge_file_result`.
  ///
  /// @param result The result to free or `NULL`
  void git_merge_file_result_free(
    ffi.Pointer<git_merge_file_result> result,
  ) {
    return _git_merge_file_result_free(
      result,
    );
  }

  late final _git_merge_file_result_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_file_result_free>>(
          'git_merge_file_result_free');
  late final _dart_git_merge_file_result_free _git_merge_file_result_free =
      _git_merge_file_result_free_ptr
          .asFunction<_dart_git_merge_file_result_free>();

  /// Merge two trees, producing a `git_index` that reflects the result of
  /// the merge.  The index may be written as-is to the working directory
  /// or checked out.  If the index is to be converted to a tree, the caller
  /// should resolve any conflicts that arose as part of the merge.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo repository that contains the given trees
  /// @param ancestor_tree the common ancestor between the trees (or null if none)
  /// @param our_tree the tree that reflects the destination tree
  /// @param their_tree the tree to merge in to `our_tree`
  /// @param opts the merge tree options (or null for defaults)
  /// @return 0 on success or error code
  int git_merge_trees(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_tree> ancestor_tree,
    ffi.Pointer<git_tree> our_tree,
    ffi.Pointer<git_tree> their_tree,
    ffi.Pointer<git_merge_options> opts,
  ) {
    return _git_merge_trees(
      out,
      repo,
      ancestor_tree,
      our_tree,
      their_tree,
      opts,
    );
  }

  late final _git_merge_trees_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_trees>>('git_merge_trees');
  late final _dart_git_merge_trees _git_merge_trees =
      _git_merge_trees_ptr.asFunction<_dart_git_merge_trees>();

  /// Merge two commits, producing a `git_index` that reflects the result of
  /// the merge.  The index may be written as-is to the working directory
  /// or checked out.  If the index is to be converted to a tree, the caller
  /// should resolve any conflicts that arose as part of the merge.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo repository that contains the given trees
  /// @param our_commit the commit that reflects the destination tree
  /// @param their_commit the commit to merge in to `our_commit`
  /// @param opts the merge tree options (or null for defaults)
  /// @return 0 on success or error code
  int git_merge_commits(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> our_commit,
    ffi.Pointer<git_commit> their_commit,
    ffi.Pointer<git_merge_options> opts,
  ) {
    return _git_merge_commits(
      out,
      repo,
      our_commit,
      their_commit,
      opts,
    );
  }

  late final _git_merge_commits_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_commits>>('git_merge_commits');
  late final _dart_git_merge_commits _git_merge_commits =
      _git_merge_commits_ptr.asFunction<_dart_git_merge_commits>();

  /// Merges the given commit(s) into HEAD, writing the results into the working
  /// directory.  Any changes are staged for commit and any conflicts are written
  /// to the index.  Callers should inspect the repository's index after this
  /// completes, resolve any conflicts and prepare a commit.
  ///
  /// For compatibility with git, the repository is put into a merging
  /// state. Once the commit is done (or if the uses wishes to abort),
  /// you should clear this state by calling
  /// `git_repository_state_cleanup()`.
  ///
  /// @param repo the repository to merge
  /// @param their_heads the heads to merge into
  /// @param their_heads_len the number of heads to merge
  /// @param merge_opts merge options
  /// @param checkout_opts checkout options
  /// @return 0 on success or error code
  int git_merge(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
    int their_heads_len,
    ffi.Pointer<git_merge_options> merge_opts,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _git_merge(
      repo,
      their_heads,
      their_heads_len,
      merge_opts,
      checkout_opts,
    );
  }

  late final _git_merge_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge>>('git_merge');
  late final _dart_git_merge _git_merge =
      _git_merge_ptr.asFunction<_dart_git_merge>();

  /// Initialize git_cherrypick_options structure
  ///
  /// Initializes a `git_cherrypick_options` with default values. Equivalent to creating
  /// an instance with GIT_CHERRYPICK_OPTIONS_INIT.
  ///
  /// @param opts The `git_cherrypick_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CHERRYPICK_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_cherrypick_options_init(
    ffi.Pointer<git_cherrypick_options> opts,
    int version,
  ) {
    return _git_cherrypick_options_init(
      opts,
      version,
    );
  }

  late final _git_cherrypick_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_cherrypick_options_init>>(
          'git_cherrypick_options_init');
  late final _dart_git_cherrypick_options_init _git_cherrypick_options_init =
      _git_cherrypick_options_init_ptr
          .asFunction<_dart_git_cherrypick_options_init>();

  /// Cherry-picks the given commit against the given "our" commit, producing an
  /// index that reflects the result of the cherry-pick.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo the repository that contains the given commits
  /// @param cherrypick_commit the commit to cherry-pick
  /// @param our_commit the commit to cherry-pick against (eg, HEAD)
  /// @param mainline the parent of the `cherrypick_commit`, if it is a merge
  /// @param merge_options the merge options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_cherrypick_commit(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> cherrypick_commit,
    ffi.Pointer<git_commit> our_commit,
    int mainline,
    ffi.Pointer<git_merge_options> merge_options,
  ) {
    return _git_cherrypick_commit(
      out,
      repo,
      cherrypick_commit,
      our_commit,
      mainline,
      merge_options,
    );
  }

  late final _git_cherrypick_commit_ptr =
      _lookup<ffi.NativeFunction<_c_git_cherrypick_commit>>(
          'git_cherrypick_commit');
  late final _dart_git_cherrypick_commit _git_cherrypick_commit =
      _git_cherrypick_commit_ptr.asFunction<_dart_git_cherrypick_commit>();

  /// Cherry-pick the given commit, producing changes in the index and working directory.
  ///
  /// @param repo the repository to cherry-pick
  /// @param commit the commit to cherry-pick
  /// @param cherrypick_options the cherry-pick options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_cherrypick(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_cherrypick_options> cherrypick_options,
  ) {
    return _git_cherrypick(
      repo,
      commit,
      cherrypick_options,
    );
  }

  late final _git_cherrypick_ptr =
      _lookup<ffi.NativeFunction<_c_git_cherrypick>>('git_cherrypick');
  late final _dart_git_cherrypick _git_cherrypick =
      _git_cherrypick_ptr.asFunction<_dart_git_cherrypick>();

  /// Parse a given refspec string
  ///
  /// @param refspec a pointer to hold the refspec handle
  /// @param input the refspec string
  /// @param is_fetch is this a refspec for a fetch
  /// @return 0 if the refspec string could be parsed, -1 otherwise
  int git_refspec_parse(
    ffi.Pointer<ffi.Pointer<git_refspec>> refspec,
    ffi.Pointer<ffi.Int8> input,
    int is_fetch,
  ) {
    return _git_refspec_parse(
      refspec,
      input,
      is_fetch,
    );
  }

  late final _git_refspec_parse_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_parse>>('git_refspec_parse');
  late final _dart_git_refspec_parse _git_refspec_parse =
      _git_refspec_parse_ptr.asFunction<_dart_git_refspec_parse>();

  /// Free a refspec object which has been created by git_refspec_parse
  ///
  /// @param refspec the refspec object
  void git_refspec_free(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_free(
      refspec,
    );
  }

  late final _git_refspec_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_free>>('git_refspec_free');
  late final _dart_git_refspec_free _git_refspec_free =
      _git_refspec_free_ptr.asFunction<_dart_git_refspec_free>();

  /// Get the source specifier
  ///
  /// @param refspec the refspec
  /// @return the refspec's source specifier
  ffi.Pointer<ffi.Int8> git_refspec_src(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_src(
      refspec,
    );
  }

  late final _git_refspec_src_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_src>>('git_refspec_src');
  late final _dart_git_refspec_src _git_refspec_src =
      _git_refspec_src_ptr.asFunction<_dart_git_refspec_src>();

  /// Get the destination specifier
  ///
  /// @param refspec the refspec
  /// @return the refspec's destination specifier
  ffi.Pointer<ffi.Int8> git_refspec_dst(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_dst(
      refspec,
    );
  }

  late final _git_refspec_dst_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_dst>>('git_refspec_dst');
  late final _dart_git_refspec_dst _git_refspec_dst =
      _git_refspec_dst_ptr.asFunction<_dart_git_refspec_dst>();

  /// Get the refspec's string
  ///
  /// @param refspec the refspec
  /// @returns the refspec's original string
  ffi.Pointer<ffi.Int8> git_refspec_string(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_string(
      refspec,
    );
  }

  late final _git_refspec_string_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_string>>('git_refspec_string');
  late final _dart_git_refspec_string _git_refspec_string =
      _git_refspec_string_ptr.asFunction<_dart_git_refspec_string>();

  /// Get the force update setting
  ///
  /// @param refspec the refspec
  /// @return 1 if force update has been set, 0 otherwise
  int git_refspec_force(
    ffi.Pointer<git_refspec> refspec,
  ) {
    return _git_refspec_force(
      refspec,
    );
  }

  late final _git_refspec_force_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_force>>('git_refspec_force');
  late final _dart_git_refspec_force _git_refspec_force =
      _git_refspec_force_ptr.asFunction<_dart_git_refspec_force>();

  /// Get the refspec's direction.
  ///
  /// @param spec refspec
  /// @return GIT_DIRECTION_FETCH or GIT_DIRECTION_PUSH
  int git_refspec_direction(
    ffi.Pointer<git_refspec> spec,
  ) {
    return _git_refspec_direction(
      spec,
    );
  }

  late final _git_refspec_direction_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_direction>>(
          'git_refspec_direction');
  late final _dart_git_refspec_direction _git_refspec_direction =
      _git_refspec_direction_ptr.asFunction<_dart_git_refspec_direction>();

  /// Check if a refspec's source descriptor matches a reference
  ///
  /// @param refspec the refspec
  /// @param refname the name of the reference to check
  /// @return 1 if the refspec matches, 0 otherwise
  int git_refspec_src_matches(
    ffi.Pointer<git_refspec> refspec,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_refspec_src_matches(
      refspec,
      refname,
    );
  }

  late final _git_refspec_src_matches_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_src_matches>>(
          'git_refspec_src_matches');
  late final _dart_git_refspec_src_matches _git_refspec_src_matches =
      _git_refspec_src_matches_ptr.asFunction<_dart_git_refspec_src_matches>();

  /// Check if a refspec's destination descriptor matches a reference
  ///
  /// @param refspec the refspec
  /// @param refname the name of the reference to check
  /// @return 1 if the refspec matches, 0 otherwise
  int git_refspec_dst_matches(
    ffi.Pointer<git_refspec> refspec,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_refspec_dst_matches(
      refspec,
      refname,
    );
  }

  late final _git_refspec_dst_matches_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_dst_matches>>(
          'git_refspec_dst_matches');
  late final _dart_git_refspec_dst_matches _git_refspec_dst_matches =
      _git_refspec_dst_matches_ptr.asFunction<_dart_git_refspec_dst_matches>();

  /// Transform a reference to its target following the refspec's rules
  ///
  /// @param out where to store the target name
  /// @param spec the refspec
  /// @param name the name of the reference to transform
  /// @return 0, GIT_EBUFS or another error
  int git_refspec_transform(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_refspec> spec,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_refspec_transform(
      out,
      spec,
      name,
    );
  }

  late final _git_refspec_transform_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_transform>>(
          'git_refspec_transform');
  late final _dart_git_refspec_transform _git_refspec_transform =
      _git_refspec_transform_ptr.asFunction<_dart_git_refspec_transform>();

  /// Transform a target reference to its source reference following the refspec's rules
  ///
  /// @param out where to store the source reference name
  /// @param spec the refspec
  /// @param name the name of the reference to transform
  /// @return 0, GIT_EBUFS or another error
  int git_refspec_rtransform(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_refspec> spec,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_refspec_rtransform(
      out,
      spec,
      name,
    );
  }

  late final _git_refspec_rtransform_ptr =
      _lookup<ffi.NativeFunction<_c_git_refspec_rtransform>>(
          'git_refspec_rtransform');
  late final _dart_git_refspec_rtransform _git_refspec_rtransform =
      _git_refspec_rtransform_ptr.asFunction<_dart_git_refspec_rtransform>();

  /// Free a credential.
  ///
  /// This is only necessary if you own the object; that is, if you are a
  /// transport.
  ///
  /// @param cred the object to free
  void git_credential_free(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_credential_free(
      cred,
    );
  }

  late final _git_credential_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_free>>(
          'git_credential_free');
  late final _dart_git_credential_free _git_credential_free =
      _git_credential_free_ptr.asFunction<_dart_git_credential_free>();

  /// Check whether a credential object contains username information.
  ///
  /// @param cred object to check
  /// @return 1 if the credential object has non-NULL username, 0 otherwise
  int git_credential_has_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_credential_has_username(
      cred,
    );
  }

  late final _git_credential_has_username_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_has_username>>(
          'git_credential_has_username');
  late final _dart_git_credential_has_username _git_credential_has_username =
      _git_credential_has_username_ptr
          .asFunction<_dart_git_credential_has_username>();

  /// Return the username associated with a credential object.
  ///
  /// @param cred object to check
  /// @return the credential username, or NULL if not applicable
  ffi.Pointer<ffi.Int8> git_credential_get_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_credential_get_username(
      cred,
    );
  }

  late final _git_credential_get_username_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_get_username>>(
          'git_credential_get_username');
  late final _dart_git_credential_get_username _git_credential_get_username =
      _git_credential_get_username_ptr
          .asFunction<_dart_git_credential_get_username>();

  /// Create a new plain-text username and password credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username The username of the credential.
  /// @param password The password of the credential.
  /// @return 0 for success or an error code for failure
  int git_credential_userpass_plaintext_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> password,
  ) {
    return _git_credential_userpass_plaintext_new(
      out,
      username,
      password,
    );
  }

  late final _git_credential_userpass_plaintext_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_userpass_plaintext_new>>(
          'git_credential_userpass_plaintext_new');
  late final _dart_git_credential_userpass_plaintext_new
      _git_credential_userpass_plaintext_new =
      _git_credential_userpass_plaintext_new_ptr
          .asFunction<_dart_git_credential_userpass_plaintext_new>();

  /// Create a "default" credential usable for Negotiate mechanisms like NTLM
  /// or Kerberos authentication.
  ///
  /// @param out The newly created credential object.
  /// @return 0 for success or an error code for failure
  int git_credential_default_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
  ) {
    return _git_credential_default_new(
      out,
    );
  }

  late final _git_credential_default_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_default_new>>(
          'git_credential_default_new');
  late final _dart_git_credential_default_new _git_credential_default_new =
      _git_credential_default_new_ptr
          .asFunction<_dart_git_credential_default_new>();

  /// Create a credential to specify a username.
  ///
  /// This is used with ssh authentication to query for the username if
  /// none is specified in the url.
  ///
  /// @param out The newly created credential object.
  /// @param username The username to authenticate with
  /// @return 0 for success or an error code for failure
  int git_credential_username_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
  ) {
    return _git_credential_username_new(
      out,
      username,
    );
  }

  late final _git_credential_username_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_username_new>>(
          'git_credential_username_new');
  late final _dart_git_credential_username_new _git_credential_username_new =
      _git_credential_username_new_ptr
          .asFunction<_dart_git_credential_username_new>();

  /// Create a new passphrase-protected ssh key credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate
  /// @param publickey The path to the public key of the credential.
  /// @param privatekey The path to the private key of the credential.
  /// @param passphrase The passphrase of the credential.
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_key_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> publickey,
    ffi.Pointer<ffi.Int8> privatekey,
    ffi.Pointer<ffi.Int8> passphrase,
  ) {
    return _git_credential_ssh_key_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_credential_ssh_key_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_ssh_key_new>>(
          'git_credential_ssh_key_new');
  late final _dart_git_credential_ssh_key_new _git_credential_ssh_key_new =
      _git_credential_ssh_key_new_ptr
          .asFunction<_dart_git_credential_ssh_key_new>();

  /// Create a new ssh key credential object reading the keys from memory.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate.
  /// @param publickey The public key of the credential.
  /// @param privatekey The private key of the credential.
  /// @param passphrase The passphrase of the credential.
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_key_memory_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> publickey,
    ffi.Pointer<ffi.Int8> privatekey,
    ffi.Pointer<ffi.Int8> passphrase,
  ) {
    return _git_credential_ssh_key_memory_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_credential_ssh_key_memory_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_ssh_key_memory_new>>(
          'git_credential_ssh_key_memory_new');
  late final _dart_git_credential_ssh_key_memory_new
      _git_credential_ssh_key_memory_new =
      _git_credential_ssh_key_memory_new_ptr
          .asFunction<_dart_git_credential_ssh_key_memory_new>();

  /// Create a new ssh keyboard-interactive based credential object.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param username Username to use to authenticate.
  /// @param prompt_callback The callback method used for prompts.
  /// @param payload Additional data to pass to the callback.
  /// @return 0 for success or an error code for failure.
  int git_credential_ssh_interactive_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.NativeFunction<git_credential_ssh_interactive_cb>>
        prompt_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_credential_ssh_interactive_new(
      out,
      username,
      prompt_callback,
      payload,
    );
  }

  late final _git_credential_ssh_interactive_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_ssh_interactive_new>>(
          'git_credential_ssh_interactive_new');
  late final _dart_git_credential_ssh_interactive_new
      _git_credential_ssh_interactive_new =
      _git_credential_ssh_interactive_new_ptr
          .asFunction<_dart_git_credential_ssh_interactive_new>();

  /// Create a new ssh key credential object used for querying an ssh-agent.
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_key_from_agent(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
  ) {
    return _git_credential_ssh_key_from_agent(
      out,
      username,
    );
  }

  late final _git_credential_ssh_key_from_agent_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_ssh_key_from_agent>>(
          'git_credential_ssh_key_from_agent');
  late final _dart_git_credential_ssh_key_from_agent
      _git_credential_ssh_key_from_agent =
      _git_credential_ssh_key_from_agent_ptr
          .asFunction<_dart_git_credential_ssh_key_from_agent>();

  /// Create an ssh key credential with a custom signing function.
  ///
  /// This lets you use your own function to sign the challenge.
  ///
  /// This function and its credential type is provided for completeness
  /// and wraps `libssh2_userauth_publickey()`, which is undocumented.
  ///
  /// The supplied credential parameter will be internally duplicated.
  ///
  /// @param out The newly created credential object.
  /// @param username username to use to authenticate
  /// @param publickey The bytes of the public key.
  /// @param publickey_len The length of the public key in bytes.
  /// @param sign_callback The callback method to sign the data during the challenge.
  /// @param payload Additional data to pass to the callback.
  /// @return 0 for success or an error code for failure
  int git_credential_ssh_custom_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> publickey,
    int publickey_len,
    ffi.Pointer<ffi.NativeFunction<git_credential_sign_cb>> sign_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_credential_ssh_custom_new(
      out,
      username,
      publickey,
      publickey_len,
      sign_callback,
      payload,
    );
  }

  late final _git_credential_ssh_custom_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_ssh_custom_new>>(
          'git_credential_ssh_custom_new');
  late final _dart_git_credential_ssh_custom_new
      _git_credential_ssh_custom_new = _git_credential_ssh_custom_new_ptr
          .asFunction<_dart_git_credential_ssh_custom_new>();

  /// Initialize a new packbuilder
  ///
  /// @param out The new packbuilder object
  /// @param repo The repository
  ///
  /// @return 0 or an error code
  int git_packbuilder_new(
    ffi.Pointer<ffi.Pointer<git_packbuilder>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_packbuilder_new(
      out,
      repo,
    );
  }

  late final _git_packbuilder_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_new>>(
          'git_packbuilder_new');
  late final _dart_git_packbuilder_new _git_packbuilder_new =
      _git_packbuilder_new_ptr.asFunction<_dart_git_packbuilder_new>();

  /// Set number of threads to spawn
  ///
  /// By default, libgit2 won't spawn any threads at all;
  /// when set to 0, libgit2 will autodetect the number of
  /// CPUs.
  ///
  /// @param pb The packbuilder
  /// @param n Number of threads to spawn
  /// @return number of actual threads to be used
  int git_packbuilder_set_threads(
    ffi.Pointer<git_packbuilder> pb,
    int n,
  ) {
    return _git_packbuilder_set_threads(
      pb,
      n,
    );
  }

  late final _git_packbuilder_set_threads_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_set_threads>>(
          'git_packbuilder_set_threads');
  late final _dart_git_packbuilder_set_threads _git_packbuilder_set_threads =
      _git_packbuilder_set_threads_ptr
          .asFunction<_dart_git_packbuilder_set_threads>();

  /// Insert a single object
  ///
  /// For an optimal pack it's mandatory to insert objects in recency order,
  /// commits followed by trees and blobs.
  ///
  /// @param pb The packbuilder
  /// @param id The oid of the commit
  /// @param name The name; might be NULL
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_packbuilder_insert(
      pb,
      id,
      name,
    );
  }

  late final _git_packbuilder_insert_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_insert>>(
          'git_packbuilder_insert');
  late final _dart_git_packbuilder_insert _git_packbuilder_insert =
      _git_packbuilder_insert_ptr.asFunction<_dart_git_packbuilder_insert>();

  /// Insert a root tree object
  ///
  /// This will add the tree as well as all referenced trees and blobs.
  ///
  /// @param pb The packbuilder
  /// @param id The oid of the root tree
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert_tree(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_packbuilder_insert_tree(
      pb,
      id,
    );
  }

  late final _git_packbuilder_insert_tree_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_insert_tree>>(
          'git_packbuilder_insert_tree');
  late final _dart_git_packbuilder_insert_tree _git_packbuilder_insert_tree =
      _git_packbuilder_insert_tree_ptr
          .asFunction<_dart_git_packbuilder_insert_tree>();

  /// Insert a commit object
  ///
  /// This will add a commit as well as the completed referenced tree.
  ///
  /// @param pb The packbuilder
  /// @param id The oid of the commit
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert_commit(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_packbuilder_insert_commit(
      pb,
      id,
    );
  }

  late final _git_packbuilder_insert_commit_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_insert_commit>>(
          'git_packbuilder_insert_commit');
  late final _dart_git_packbuilder_insert_commit
      _git_packbuilder_insert_commit = _git_packbuilder_insert_commit_ptr
          .asFunction<_dart_git_packbuilder_insert_commit>();

  /// Insert objects as given by the walk
  ///
  /// Those commits and all objects they reference will be inserted into
  /// the packbuilder.
  ///
  /// @param pb the packbuilder
  /// @param walk the revwalk to use to fill the packbuilder
  ///
  /// @return 0 or an error code
  int git_packbuilder_insert_walk(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_packbuilder_insert_walk(
      pb,
      walk,
    );
  }

  late final _git_packbuilder_insert_walk_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_insert_walk>>(
          'git_packbuilder_insert_walk');
  late final _dart_git_packbuilder_insert_walk _git_packbuilder_insert_walk =
      _git_packbuilder_insert_walk_ptr
          .asFunction<_dart_git_packbuilder_insert_walk>();

  /// Recursively insert an object and its referenced objects
  ///
  /// Insert the object as well as any object it references.
  ///
  /// @param pb the packbuilder
  /// @param id the id of the root object to insert
  /// @param name optional name for the object
  /// @return 0 or an error code
  int git_packbuilder_insert_recur(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_packbuilder_insert_recur(
      pb,
      id,
      name,
    );
  }

  late final _git_packbuilder_insert_recur_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_insert_recur>>(
          'git_packbuilder_insert_recur');
  late final _dart_git_packbuilder_insert_recur _git_packbuilder_insert_recur =
      _git_packbuilder_insert_recur_ptr
          .asFunction<_dart_git_packbuilder_insert_recur>();

  /// Write the contents of the packfile to an in-memory buffer
  ///
  /// The contents of the buffer will become a valid packfile, even though there
  /// will be no attached index
  ///
  /// @param buf Buffer where to write the packfile
  /// @param pb The packbuilder
  int git_packbuilder_write_buf(
    ffi.Pointer<git_buf> buf,
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_write_buf(
      buf,
      pb,
    );
  }

  late final _git_packbuilder_write_buf_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_write_buf>>(
          'git_packbuilder_write_buf');
  late final _dart_git_packbuilder_write_buf _git_packbuilder_write_buf =
      _git_packbuilder_write_buf_ptr
          .asFunction<_dart_git_packbuilder_write_buf>();

  /// Write the new pack and corresponding index file to path.
  ///
  /// @param pb The packbuilder
  /// @param path Path to the directory where the packfile and index should be stored, or NULL for default location
  /// @param mode permissions to use creating a packfile or 0 for defaults
  /// @param progress_cb function to call with progress information from the indexer (optional)
  /// @param progress_cb_payload payload for the progress callback (optional)
  ///
  /// @return 0 or an error code
  int git_packbuilder_write(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<ffi.Int8> path,
    int mode,
    ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>> progress_cb,
    ffi.Pointer<ffi.Void> progress_cb_payload,
  ) {
    return _git_packbuilder_write(
      pb,
      path,
      mode,
      progress_cb,
      progress_cb_payload,
    );
  }

  late final _git_packbuilder_write_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_write>>(
          'git_packbuilder_write');
  late final _dart_git_packbuilder_write _git_packbuilder_write =
      _git_packbuilder_write_ptr.asFunction<_dart_git_packbuilder_write>();

  /// Get the packfile's hash
  ///
  /// A packfile's name is derived from the sorted hashing of all object
  /// names. This is only correct after the packfile has been written.
  ///
  /// @param pb The packbuilder object
  ffi.Pointer<git_oid> git_packbuilder_hash(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_hash(
      pb,
    );
  }

  late final _git_packbuilder_hash_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_hash>>(
          'git_packbuilder_hash');
  late final _dart_git_packbuilder_hash _git_packbuilder_hash =
      _git_packbuilder_hash_ptr.asFunction<_dart_git_packbuilder_hash>();

  /// Create the new pack and pass each object to the callback
  ///
  /// @param pb the packbuilder
  /// @param cb the callback to call with each packed object's buffer
  /// @param payload the callback's data
  /// @return 0 or an error code
  int git_packbuilder_foreach(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<ffi.NativeFunction<git_packbuilder_foreach_cb>> cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_packbuilder_foreach(
      pb,
      cb,
      payload,
    );
  }

  late final _git_packbuilder_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_foreach>>(
          'git_packbuilder_foreach');
  late final _dart_git_packbuilder_foreach _git_packbuilder_foreach =
      _git_packbuilder_foreach_ptr.asFunction<_dart_git_packbuilder_foreach>();

  /// Get the total number of objects the packbuilder will write out
  ///
  /// @param pb the packbuilder
  /// @return the number of objects in the packfile
  int git_packbuilder_object_count(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_object_count(
      pb,
    );
  }

  late final _git_packbuilder_object_count_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_object_count>>(
          'git_packbuilder_object_count');
  late final _dart_git_packbuilder_object_count _git_packbuilder_object_count =
      _git_packbuilder_object_count_ptr
          .asFunction<_dart_git_packbuilder_object_count>();

  /// Get the number of objects the packbuilder has already written out
  ///
  /// @param pb the packbuilder
  /// @return the number of objects which have already been written
  int git_packbuilder_written(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_written(
      pb,
    );
  }

  late final _git_packbuilder_written_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_written>>(
          'git_packbuilder_written');
  late final _dart_git_packbuilder_written _git_packbuilder_written =
      _git_packbuilder_written_ptr.asFunction<_dart_git_packbuilder_written>();

  /// Set the callbacks for a packbuilder
  ///
  /// @param pb The packbuilder object
  /// @param progress_cb Function to call with progress information during
  /// pack building. Be aware that this is called inline with pack building
  /// operations, so performance may be affected.
  /// @param progress_cb_payload Payload for progress callback.
  /// @return 0 or an error code
  int git_packbuilder_set_callbacks(
    ffi.Pointer<git_packbuilder> pb,
    ffi.Pointer<ffi.NativeFunction<git_packbuilder_progress>> progress_cb,
    ffi.Pointer<ffi.Void> progress_cb_payload,
  ) {
    return _git_packbuilder_set_callbacks(
      pb,
      progress_cb,
      progress_cb_payload,
    );
  }

  late final _git_packbuilder_set_callbacks_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_set_callbacks>>(
          'git_packbuilder_set_callbacks');
  late final _dart_git_packbuilder_set_callbacks
      _git_packbuilder_set_callbacks = _git_packbuilder_set_callbacks_ptr
          .asFunction<_dart_git_packbuilder_set_callbacks>();

  /// Free the packbuilder and all associated data
  ///
  /// @param pb The packbuilder
  void git_packbuilder_free(
    ffi.Pointer<git_packbuilder> pb,
  ) {
    return _git_packbuilder_free(
      pb,
    );
  }

  late final _git_packbuilder_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_packbuilder_free>>(
          'git_packbuilder_free');
  late final _dart_git_packbuilder_free _git_packbuilder_free =
      _git_packbuilder_free_ptr.asFunction<_dart_git_packbuilder_free>();

  /// Initialize git_proxy_options structure
  ///
  /// Initializes a `git_proxy_options` with default values. Equivalent to
  /// creating an instance with `GIT_PROXY_OPTIONS_INIT`.
  ///
  /// @param opts The `git_proxy_options` struct to initialize.
  /// @param version The struct version; pass `GIT_PROXY_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_proxy_options_init(
    ffi.Pointer<git_proxy_options> opts,
    int version,
  ) {
    return _git_proxy_options_init(
      opts,
      version,
    );
  }

  late final _git_proxy_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_proxy_options_init>>(
          'git_proxy_options_init');
  late final _dart_git_proxy_options_init _git_proxy_options_init =
      _git_proxy_options_init_ptr.asFunction<_dart_git_proxy_options_init>();

  /// Add a remote with the default fetch refspec to the repository's configuration.
  ///
  /// @param out the resulting remote
  /// @param repo the repository in which to create the remote
  /// @param name the remote's name
  /// @param url the remote's url
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _git_remote_create(
      out,
      repo,
      name,
      url,
    );
  }

  late final _git_remote_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_create>>('git_remote_create');
  late final _dart_git_remote_create _git_remote_create =
      _git_remote_create_ptr.asFunction<_dart_git_remote_create>();

  /// Initialize git_remote_create_options structure
  ///
  /// Initializes a `git_remote_create_options` with default values. Equivalent to
  /// creating an instance with `GIT_REMOTE_CREATE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_remote_create_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REMOTE_CREATE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_remote_create_options_init(
    ffi.Pointer<git_remote_create_options> opts,
    int version,
  ) {
    return _git_remote_create_options_init(
      opts,
      version,
    );
  }

  late final _git_remote_create_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_create_options_init>>(
          'git_remote_create_options_init');
  late final _dart_git_remote_create_options_init
      _git_remote_create_options_init = _git_remote_create_options_init_ptr
          .asFunction<_dart_git_remote_create_options_init>();

  /// Create a remote, with options.
  ///
  /// This function allows more fine-grained control over the remote creation.
  ///
  /// Passing NULL as the opts argument will result in a detached remote.
  ///
  /// @param out the resulting remote
  /// @param url the remote's url
  /// @param opts the remote creation options
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create_with_opts(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<git_remote_create_options> opts,
  ) {
    return _git_remote_create_with_opts(
      out,
      url,
      opts,
    );
  }

  late final _git_remote_create_with_opts_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_create_with_opts>>(
          'git_remote_create_with_opts');
  late final _dart_git_remote_create_with_opts _git_remote_create_with_opts =
      _git_remote_create_with_opts_ptr
          .asFunction<_dart_git_remote_create_with_opts>();

  /// Add a remote with the provided fetch refspec (or default if NULL) to the repository's
  /// configuration.
  ///
  /// @param out the resulting remote
  /// @param repo the repository in which to create the remote
  /// @param name the remote's name
  /// @param url the remote's url
  /// @param fetch the remote fetch value
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_create_with_fetchspec(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Int8> fetch,
  ) {
    return _git_remote_create_with_fetchspec(
      out,
      repo,
      name,
      url,
      fetch,
    );
  }

  late final _git_remote_create_with_fetchspec_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_create_with_fetchspec>>(
          'git_remote_create_with_fetchspec');
  late final _dart_git_remote_create_with_fetchspec
      _git_remote_create_with_fetchspec = _git_remote_create_with_fetchspec_ptr
          .asFunction<_dart_git_remote_create_with_fetchspec>();

  /// Create an anonymous remote
  ///
  /// Create a remote with the given url in-memory. You can use this when
  /// you have a URL instead of a remote's name.
  ///
  /// @param out pointer to the new remote objects
  /// @param repo the associated repository
  /// @param url the remote repository's URL
  /// @return 0 or an error code
  int git_remote_create_anonymous(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _git_remote_create_anonymous(
      out,
      repo,
      url,
    );
  }

  late final _git_remote_create_anonymous_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_create_anonymous>>(
          'git_remote_create_anonymous');
  late final _dart_git_remote_create_anonymous _git_remote_create_anonymous =
      _git_remote_create_anonymous_ptr
          .asFunction<_dart_git_remote_create_anonymous>();

  /// Create a remote without a connected local repo
  ///
  /// Create a remote with the given url in-memory. You can use this when
  /// you have a URL instead of a remote's name.
  ///
  /// Contrasted with git_remote_create_anonymous, a detached remote
  /// will not consider any repo configuration values (such as insteadof url
  /// substitutions).
  ///
  /// @param out pointer to the new remote objects
  /// @param url the remote repository's URL
  /// @return 0 or an error code
  int git_remote_create_detached(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _git_remote_create_detached(
      out,
      url,
    );
  }

  late final _git_remote_create_detached_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_create_detached>>(
          'git_remote_create_detached');
  late final _dart_git_remote_create_detached _git_remote_create_detached =
      _git_remote_create_detached_ptr
          .asFunction<_dart_git_remote_create_detached>();

  /// Get the information for a particular remote
  ///
  /// The name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param out pointer to the new remote object
  /// @param repo the associated repository
  /// @param name the remote's name
  /// @return 0, GIT_ENOTFOUND, GIT_EINVALIDSPEC or an error code
  int git_remote_lookup(
    ffi.Pointer<ffi.Pointer<git_remote>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_remote_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_remote_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_lookup>>('git_remote_lookup');
  late final _dart_git_remote_lookup _git_remote_lookup =
      _git_remote_lookup_ptr.asFunction<_dart_git_remote_lookup>();

  /// Create a copy of an existing remote.  All internal strings are also
  /// duplicated. Callbacks are not duplicated.
  ///
  /// Call `git_remote_free` to free the data.
  ///
  /// @param dest pointer where to store the copy
  /// @param source object to copy
  /// @return 0 or an error code
  int git_remote_dup(
    ffi.Pointer<ffi.Pointer<git_remote>> dest,
    ffi.Pointer<git_remote> source,
  ) {
    return _git_remote_dup(
      dest,
      source,
    );
  }

  late final _git_remote_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_dup>>('git_remote_dup');
  late final _dart_git_remote_dup _git_remote_dup =
      _git_remote_dup_ptr.asFunction<_dart_git_remote_dup>();

  /// Get the remote's repository
  ///
  /// @param remote the remote
  /// @return a pointer to the repository
  ffi.Pointer<git_repository> git_remote_owner(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_owner(
      remote,
    );
  }

  late final _git_remote_owner_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_owner>>('git_remote_owner');
  late final _dart_git_remote_owner _git_remote_owner =
      _git_remote_owner_ptr.asFunction<_dart_git_remote_owner>();

  /// Get the remote's name
  ///
  /// @param remote the remote
  /// @return a pointer to the name or NULL for in-memory remotes
  ffi.Pointer<ffi.Int8> git_remote_name(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_name(
      remote,
    );
  }

  late final _git_remote_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_name>>('git_remote_name');
  late final _dart_git_remote_name _git_remote_name =
      _git_remote_name_ptr.asFunction<_dart_git_remote_name>();

  /// Get the remote's url
  ///
  /// If url.*.insteadOf has been configured for this URL, it will
  /// return the modified URL.
  ///
  /// @param remote the remote
  /// @return a pointer to the url
  ffi.Pointer<ffi.Int8> git_remote_url(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_url(
      remote,
    );
  }

  late final _git_remote_url_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_url>>('git_remote_url');
  late final _dart_git_remote_url _git_remote_url =
      _git_remote_url_ptr.asFunction<_dart_git_remote_url>();

  /// Get the remote's url for pushing
  ///
  /// If url.*.pushInsteadOf has been configured for this URL, it
  /// will return the modified URL.
  ///
  /// @param remote the remote
  /// @return a pointer to the url or NULL if no special url for pushing is set
  ffi.Pointer<ffi.Int8> git_remote_pushurl(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_pushurl(
      remote,
    );
  }

  late final _git_remote_pushurl_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_pushurl>>('git_remote_pushurl');
  late final _dart_git_remote_pushurl _git_remote_pushurl =
      _git_remote_pushurl_ptr.asFunction<_dart_git_remote_pushurl>();

  /// Set the remote's url in the configuration
  ///
  /// Remote objects already in memory will not be affected. This assumes
  /// the common case of a single-url remote and will otherwise return an error.
  ///
  /// @param repo the repository in which to perform the change
  /// @param remote the remote's name
  /// @param url the url to set
  /// @return 0 or an error value
  int git_remote_set_url(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> remote,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _git_remote_set_url(
      repo,
      remote,
      url,
    );
  }

  late final _git_remote_set_url_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_set_url>>('git_remote_set_url');
  late final _dart_git_remote_set_url _git_remote_set_url =
      _git_remote_set_url_ptr.asFunction<_dart_git_remote_set_url>();

  /// Set the remote's url for pushing in the configuration.
  ///
  /// Remote objects already in memory will not be affected. This assumes
  /// the common case of a single-url remote and will otherwise return an error.
  ///
  ///
  /// @param repo the repository in which to perform the change
  /// @param remote the remote's name
  /// @param url the url to set
  int git_remote_set_pushurl(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> remote,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _git_remote_set_pushurl(
      repo,
      remote,
      url,
    );
  }

  late final _git_remote_set_pushurl_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_set_pushurl>>(
          'git_remote_set_pushurl');
  late final _dart_git_remote_set_pushurl _git_remote_set_pushurl =
      _git_remote_set_pushurl_ptr.asFunction<_dart_git_remote_set_pushurl>();

  /// Add a fetch refspec to the remote's configuration
  ///
  /// Add the given refspec to the fetch list in the configuration. No
  /// loaded remote instances will be affected.
  ///
  /// @param repo the repository in which to change the configuration
  /// @param remote the name of the remote to change
  /// @param refspec the new fetch refspec
  /// @return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value
  int git_remote_add_fetch(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> remote,
    ffi.Pointer<ffi.Int8> refspec,
  ) {
    return _git_remote_add_fetch(
      repo,
      remote,
      refspec,
    );
  }

  late final _git_remote_add_fetch_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_add_fetch>>(
          'git_remote_add_fetch');
  late final _dart_git_remote_add_fetch _git_remote_add_fetch =
      _git_remote_add_fetch_ptr.asFunction<_dart_git_remote_add_fetch>();

  /// Get the remote's list of fetch refspecs
  ///
  /// The memory is owned by the user and should be freed with
  /// `git_strarray_free`.
  ///
  /// @param array pointer to the array in which to store the strings
  /// @param remote the remote to query
  int git_remote_get_fetch_refspecs(
    ffi.Pointer<git_strarray> array,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_get_fetch_refspecs(
      array,
      remote,
    );
  }

  late final _git_remote_get_fetch_refspecs_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_get_fetch_refspecs>>(
          'git_remote_get_fetch_refspecs');
  late final _dart_git_remote_get_fetch_refspecs
      _git_remote_get_fetch_refspecs = _git_remote_get_fetch_refspecs_ptr
          .asFunction<_dart_git_remote_get_fetch_refspecs>();

  /// Add a push refspec to the remote's configuration
  ///
  /// Add the given refspec to the push list in the configuration. No
  /// loaded remote instances will be affected.
  ///
  /// @param repo the repository in which to change the configuration
  /// @param remote the name of the remote to change
  /// @param refspec the new push refspec
  /// @return 0, GIT_EINVALIDSPEC if refspec is invalid or an error value
  int git_remote_add_push(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> remote,
    ffi.Pointer<ffi.Int8> refspec,
  ) {
    return _git_remote_add_push(
      repo,
      remote,
      refspec,
    );
  }

  late final _git_remote_add_push_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_add_push>>(
          'git_remote_add_push');
  late final _dart_git_remote_add_push _git_remote_add_push =
      _git_remote_add_push_ptr.asFunction<_dart_git_remote_add_push>();

  /// Get the remote's list of push refspecs
  ///
  /// The memory is owned by the user and should be freed with
  /// `git_strarray_free`.
  ///
  /// @param array pointer to the array in which to store the strings
  /// @param remote the remote to query
  int git_remote_get_push_refspecs(
    ffi.Pointer<git_strarray> array,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_get_push_refspecs(
      array,
      remote,
    );
  }

  late final _git_remote_get_push_refspecs_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_get_push_refspecs>>(
          'git_remote_get_push_refspecs');
  late final _dart_git_remote_get_push_refspecs _git_remote_get_push_refspecs =
      _git_remote_get_push_refspecs_ptr
          .asFunction<_dart_git_remote_get_push_refspecs>();

  /// Get the number of refspecs for a remote
  ///
  /// @param remote the remote
  /// @return the amount of refspecs configured in this remote
  int git_remote_refspec_count(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_refspec_count(
      remote,
    );
  }

  late final _git_remote_refspec_count_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_refspec_count>>(
          'git_remote_refspec_count');
  late final _dart_git_remote_refspec_count _git_remote_refspec_count =
      _git_remote_refspec_count_ptr
          .asFunction<_dart_git_remote_refspec_count>();

  /// Get a refspec from the remote
  ///
  /// @param remote the remote to query
  /// @param n the refspec to get
  /// @return the nth refspec
  ffi.Pointer<git_refspec> git_remote_get_refspec(
    ffi.Pointer<git_remote> remote,
    int n,
  ) {
    return _git_remote_get_refspec(
      remote,
      n,
    );
  }

  late final _git_remote_get_refspec_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_get_refspec>>(
          'git_remote_get_refspec');
  late final _dart_git_remote_get_refspec _git_remote_get_refspec =
      _git_remote_get_refspec_ptr.asFunction<_dart_git_remote_get_refspec>();

  /// Open a connection to a remote
  ///
  /// The transport is selected based on the URL. The direction argument
  /// is due to a limitation of the git protocol (over TCP or SSH) which
  /// starts up a specific binary which can only do the one or the other.
  ///
  /// @param remote the remote to connect to
  /// @param direction GIT_DIRECTION_FETCH if you want to fetch or
  /// GIT_DIRECTION_PUSH if you want to push
  /// @param callbacks the callbacks to use for this connection
  /// @param proxy_opts proxy settings
  /// @param custom_headers extra HTTP headers to use in this connection
  /// @return 0 or an error code
  int git_remote_connect(
    ffi.Pointer<git_remote> remote,
    int direction,
    ffi.Pointer<git_remote_callbacks> callbacks,
    ffi.Pointer<git_proxy_options> proxy_opts,
    ffi.Pointer<git_strarray> custom_headers,
  ) {
    return _git_remote_connect(
      remote,
      direction,
      callbacks,
      proxy_opts,
      custom_headers,
    );
  }

  late final _git_remote_connect_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_connect>>('git_remote_connect');
  late final _dart_git_remote_connect _git_remote_connect =
      _git_remote_connect_ptr.asFunction<_dart_git_remote_connect>();

  /// Get the remote repository's reference advertisement list
  ///
  /// Get the list of references with which the server responds to a new
  /// connection.
  ///
  /// The remote (or more exactly its transport) must have connected to
  /// the remote repository. This list is available as soon as the
  /// connection to the remote is initiated and it remains available
  /// after disconnecting.
  ///
  /// The memory belongs to the remote. The pointer will be valid as long
  /// as a new connection is not initiated, but it is recommended that
  /// you make a copy in order to make use of the data.
  ///
  /// @param out pointer to the array
  /// @param size the number of remote heads
  /// @param remote the remote
  /// @return 0 on success, or an error code
  int git_remote_ls(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>> out,
    ffi.Pointer<ffi.Int32> size,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_ls(
      out,
      size,
      remote,
    );
  }

  late final _git_remote_ls_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_ls>>('git_remote_ls');
  late final _dart_git_remote_ls _git_remote_ls =
      _git_remote_ls_ptr.asFunction<_dart_git_remote_ls>();

  /// Check whether the remote is connected
  ///
  /// Check whether the remote's underlying transport is connected to the
  /// remote host.
  ///
  /// @param remote the remote
  /// @return 1 if it's connected, 0 otherwise.
  int git_remote_connected(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_connected(
      remote,
    );
  }

  late final _git_remote_connected_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_connected>>(
          'git_remote_connected');
  late final _dart_git_remote_connected _git_remote_connected =
      _git_remote_connected_ptr.asFunction<_dart_git_remote_connected>();

  /// Cancel the operation
  ///
  /// At certain points in its operation, the network code checks whether
  /// the operation has been cancelled and if so stops the operation.
  ///
  /// @param remote the remote
  /// @return 0 on success, or an error code
  int git_remote_stop(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_stop(
      remote,
    );
  }

  late final _git_remote_stop_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_stop>>('git_remote_stop');
  late final _dart_git_remote_stop _git_remote_stop =
      _git_remote_stop_ptr.asFunction<_dart_git_remote_stop>();

  /// Disconnect from the remote
  ///
  /// Close the connection to the remote.
  ///
  /// @param remote the remote to disconnect from
  /// @return 0 on success, or an error code
  int git_remote_disconnect(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_disconnect(
      remote,
    );
  }

  late final _git_remote_disconnect_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_disconnect>>(
          'git_remote_disconnect');
  late final _dart_git_remote_disconnect _git_remote_disconnect =
      _git_remote_disconnect_ptr.asFunction<_dart_git_remote_disconnect>();

  /// Free the memory associated with a remote
  ///
  /// This also disconnects from the remote, if the connection
  /// has not been closed yet (using git_remote_disconnect).
  ///
  /// @param remote the remote to free
  void git_remote_free(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_free(
      remote,
    );
  }

  late final _git_remote_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_free>>('git_remote_free');
  late final _dart_git_remote_free _git_remote_free =
      _git_remote_free_ptr.asFunction<_dart_git_remote_free>();

  /// Get a list of the configured remotes for a repo
  ///
  /// The string array must be freed by the user.
  ///
  /// @param out a string array which receives the names of the remotes
  /// @param repo the repository to query
  /// @return 0 or an error code
  int git_remote_list(
    ffi.Pointer<git_strarray> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_remote_list(
      out,
      repo,
    );
  }

  late final _git_remote_list_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_list>>('git_remote_list');
  late final _dart_git_remote_list _git_remote_list =
      _git_remote_list_ptr.asFunction<_dart_git_remote_list>();

  /// Initializes a `git_remote_callbacks` with default values. Equivalent to
  /// creating an instance with GIT_REMOTE_CALLBACKS_INIT.
  ///
  /// @param opts the `git_remote_callbacks` struct to initialize
  /// @param version Version of struct; pass `GIT_REMOTE_CALLBACKS_VERSION`
  /// @return Zero on success; -1 on failure.
  int git_remote_init_callbacks(
    ffi.Pointer<git_remote_callbacks> opts,
    int version,
  ) {
    return _git_remote_init_callbacks(
      opts,
      version,
    );
  }

  late final _git_remote_init_callbacks_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_init_callbacks>>(
          'git_remote_init_callbacks');
  late final _dart_git_remote_init_callbacks _git_remote_init_callbacks =
      _git_remote_init_callbacks_ptr
          .asFunction<_dart_git_remote_init_callbacks>();

  /// Initialize git_fetch_options structure
  ///
  /// Initializes a `git_fetch_options` with default values. Equivalent to
  /// creating an instance with `GIT_FETCH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_fetch_options` struct to initialize.
  /// @param version The struct version; pass `GIT_FETCH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_fetch_options_init(
    ffi.Pointer<git_fetch_options> opts,
    int version,
  ) {
    return _git_fetch_options_init(
      opts,
      version,
    );
  }

  late final _git_fetch_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_fetch_options_init>>(
          'git_fetch_options_init');
  late final _dart_git_fetch_options_init _git_fetch_options_init =
      _git_fetch_options_init_ptr.asFunction<_dart_git_fetch_options_init>();

  /// Initialize git_push_options structure
  ///
  /// Initializes a `git_push_options` with default values. Equivalent to
  /// creating an instance with `GIT_PUSH_OPTIONS_INIT`.
  ///
  /// @param opts The `git_push_options` struct to initialize.
  /// @param version The struct version; pass `GIT_PUSH_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_push_options_init(
    ffi.Pointer<git_push_options> opts,
    int version,
  ) {
    return _git_push_options_init(
      opts,
      version,
    );
  }

  late final _git_push_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_push_options_init>>(
          'git_push_options_init');
  late final _dart_git_push_options_init _git_push_options_init =
      _git_push_options_init_ptr.asFunction<_dart_git_push_options_init>();

  /// Download and index the packfile
  ///
  /// Connect to the remote if it hasn't been done yet, negotiate with
  /// the remote git which objects are missing, download and index the
  /// packfile.
  ///
  /// The .idx file will be created and both it and the packfile with be
  /// renamed to their final name.
  ///
  /// @param remote the remote
  /// @param refspecs the refspecs to use for this negotiation and
  /// download. Use NULL or an empty array to use the base refspecs
  /// @param opts the options to use for this fetch
  /// @return 0 or an error code
  int git_remote_download(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_fetch_options> opts,
  ) {
    return _git_remote_download(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_download_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_download>>(
          'git_remote_download');
  late final _dart_git_remote_download _git_remote_download =
      _git_remote_download_ptr.asFunction<_dart_git_remote_download>();

  /// Create a packfile and send it to the server
  ///
  /// Connect to the remote if it hasn't been done yet, negotiate with
  /// the remote git which objects are missing, create a packfile with the missing objects and send it.
  ///
  /// @param remote the remote
  /// @param refspecs the refspecs to use for this negotiation and
  /// upload. Use NULL or an empty array to use the base refspecs
  /// @param opts the options to use for this push
  /// @return 0 or an error code
  int git_remote_upload(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_push_options> opts,
  ) {
    return _git_remote_upload(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_upload_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_upload>>('git_remote_upload');
  late final _dart_git_remote_upload _git_remote_upload =
      _git_remote_upload_ptr.asFunction<_dart_git_remote_upload>();

  /// Update the tips to the new state
  ///
  /// @param remote the remote to update
  /// @param reflog_message The message to insert into the reflogs. If
  /// NULL and fetching, the default is "fetch <name>", where <name> is
  /// the name of the remote (or its url, for in-memory remotes). This
  /// parameter is ignored when pushing.
  /// @param callbacks  pointer to the callback structure to use
  /// @param update_fetchhead whether to write to FETCH_HEAD. Pass 1 to behave like git.
  /// @param download_tags what the behaviour for downloading tags is for this fetch. This is
  /// ignored for push. This must be the same value passed to `git_remote_download()`.
  /// @return 0 or an error code
  int git_remote_update_tips(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_remote_callbacks> callbacks,
    int update_fetchhead,
    int download_tags,
    ffi.Pointer<ffi.Int8> reflog_message,
  ) {
    return _git_remote_update_tips(
      remote,
      callbacks,
      update_fetchhead,
      download_tags,
      reflog_message,
    );
  }

  late final _git_remote_update_tips_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_update_tips>>(
          'git_remote_update_tips');
  late final _dart_git_remote_update_tips _git_remote_update_tips =
      _git_remote_update_tips_ptr.asFunction<_dart_git_remote_update_tips>();

  /// Download new data and update tips
  ///
  /// Convenience function to connect to a remote, download the data,
  /// disconnect and update the remote-tracking branches.
  ///
  /// @param remote the remote to fetch from
  /// @param refspecs the refspecs to use for this fetch. Pass NULL or an
  /// empty array to use the base refspecs.
  /// @param opts options to use for this fetch
  /// @param reflog_message The message to insert into the reflogs. If NULL, the
  /// default is "fetch"
  /// @return 0 or an error code
  int git_remote_fetch(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_fetch_options> opts,
    ffi.Pointer<ffi.Int8> reflog_message,
  ) {
    return _git_remote_fetch(
      remote,
      refspecs,
      opts,
      reflog_message,
    );
  }

  late final _git_remote_fetch_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_fetch>>('git_remote_fetch');
  late final _dart_git_remote_fetch _git_remote_fetch =
      _git_remote_fetch_ptr.asFunction<_dart_git_remote_fetch>();

  /// Prune tracking refs that are no longer present on remote
  ///
  /// @param remote the remote to prune
  /// @param callbacks callbacks to use for this prune
  /// @return 0 or an error code
  int git_remote_prune(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_remote_callbacks> callbacks,
  ) {
    return _git_remote_prune(
      remote,
      callbacks,
    );
  }

  late final _git_remote_prune_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_prune>>('git_remote_prune');
  late final _dart_git_remote_prune _git_remote_prune =
      _git_remote_prune_ptr.asFunction<_dart_git_remote_prune>();

  /// Perform a push
  ///
  /// Peform all the steps from a push.
  ///
  /// @param remote the remote to push to
  /// @param refspecs the refspecs to use for pushing. If NULL or an empty
  /// array, the configured refspecs will be used
  /// @param opts options to use for this push
  int git_remote_push(
    ffi.Pointer<git_remote> remote,
    ffi.Pointer<git_strarray> refspecs,
    ffi.Pointer<git_push_options> opts,
  ) {
    return _git_remote_push(
      remote,
      refspecs,
      opts,
    );
  }

  late final _git_remote_push_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_push>>('git_remote_push');
  late final _dart_git_remote_push _git_remote_push =
      _git_remote_push_ptr.asFunction<_dart_git_remote_push>();

  /// Get the statistics structure that is filled in by the fetch operation.
  ffi.Pointer<git_indexer_progress> git_remote_stats(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_stats(
      remote,
    );
  }

  late final _git_remote_stats_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_stats>>('git_remote_stats');
  late final _dart_git_remote_stats _git_remote_stats =
      _git_remote_stats_ptr.asFunction<_dart_git_remote_stats>();

  /// Retrieve the tag auto-follow setting
  ///
  /// @param remote the remote to query
  /// @return the auto-follow setting
  int git_remote_autotag(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_autotag(
      remote,
    );
  }

  late final _git_remote_autotag_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_autotag>>('git_remote_autotag');
  late final _dart_git_remote_autotag _git_remote_autotag =
      _git_remote_autotag_ptr.asFunction<_dart_git_remote_autotag>();

  /// Set the remote's tag following setting.
  ///
  /// The change will be made in the configuration. No loaded remotes
  /// will be affected.
  ///
  /// @param repo the repository in which to make the change
  /// @param remote the name of the remote
  /// @param value the new value to take.
  int git_remote_set_autotag(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> remote,
    int value,
  ) {
    return _git_remote_set_autotag(
      repo,
      remote,
      value,
    );
  }

  late final _git_remote_set_autotag_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_set_autotag>>(
          'git_remote_set_autotag');
  late final _dart_git_remote_set_autotag _git_remote_set_autotag =
      _git_remote_set_autotag_ptr.asFunction<_dart_git_remote_set_autotag>();

  /// Retrieve the ref-prune setting
  ///
  /// @param remote the remote to query
  /// @return the ref-prune setting
  int git_remote_prune_refs(
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_prune_refs(
      remote,
    );
  }

  late final _git_remote_prune_refs_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_prune_refs>>(
          'git_remote_prune_refs');
  late final _dart_git_remote_prune_refs _git_remote_prune_refs =
      _git_remote_prune_refs_ptr.asFunction<_dart_git_remote_prune_refs>();

  /// Give the remote a new name
  ///
  /// All remote-tracking branches and configuration settings
  /// for the remote are updated.
  ///
  /// The new name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// No loaded instances of a the remote with the old name will change
  /// their name or their list of refspecs.
  ///
  /// @param problems non-default refspecs cannot be renamed and will be
  /// stored here for further processing by the caller. Always free this
  /// strarray on successful return.
  /// @param repo the repository in which to rename
  /// @param name the current name of the remote
  /// @param new_name the new name the remote should bear
  /// @return 0, GIT_EINVALIDSPEC, GIT_EEXISTS or an error code
  int git_remote_rename(
    ffi.Pointer<git_strarray> problems,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> new_name,
  ) {
    return _git_remote_rename(
      problems,
      repo,
      name,
      new_name,
    );
  }

  late final _git_remote_rename_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_rename>>('git_remote_rename');
  late final _dart_git_remote_rename _git_remote_rename =
      _git_remote_rename_ptr.asFunction<_dart_git_remote_rename>();

  /// Ensure the remote name is well-formed.
  ///
  /// @param remote_name name to be checked.
  /// @return 1 if the reference name is acceptable; 0 if it isn't
  int git_remote_is_valid_name(
    ffi.Pointer<ffi.Int8> remote_name,
  ) {
    return _git_remote_is_valid_name(
      remote_name,
    );
  }

  late final _git_remote_is_valid_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_is_valid_name>>(
          'git_remote_is_valid_name');
  late final _dart_git_remote_is_valid_name _git_remote_is_valid_name =
      _git_remote_is_valid_name_ptr
          .asFunction<_dart_git_remote_is_valid_name>();

  /// Delete an existing persisted remote.
  ///
  /// All remote-tracking branches and configuration settings
  /// for the remote will be removed.
  ///
  /// @param repo the repository in which to act
  /// @param name the name of the remote to delete
  /// @return 0 on success, or an error code.
  int git_remote_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_remote_delete(
      repo,
      name,
    );
  }

  late final _git_remote_delete_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_delete>>('git_remote_delete');
  late final _dart_git_remote_delete _git_remote_delete =
      _git_remote_delete_ptr.asFunction<_dart_git_remote_delete>();

  /// Retrieve the name of the remote's default branch
  ///
  /// The default branch of a repository is the branch which HEAD points
  /// to. If the remote does not support reporting this information
  /// directly, it performs the guess as git does; that is, if there are
  /// multiple branches which point to the same commit, the first one is
  /// chosen. If the master branch is a candidate, it wins.
  ///
  /// This function must only be called after connecting.
  ///
  /// @param out the buffern in which to store the reference name
  /// @param remote the remote
  /// @return 0, GIT_ENOTFOUND if the remote does not have any references
  /// or none of them point to HEAD's commit, or an error message.
  int git_remote_default_branch(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_remote> remote,
  ) {
    return _git_remote_default_branch(
      out,
      remote,
    );
  }

  late final _git_remote_default_branch_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_default_branch>>(
          'git_remote_default_branch');
  late final _dart_git_remote_default_branch _git_remote_default_branch =
      _git_remote_default_branch_ptr
          .asFunction<_dart_git_remote_default_branch>();

  /// Initialize git_clone_options structure
  ///
  /// Initializes a `git_clone_options` with default values. Equivalent to creating
  /// an instance with GIT_CLONE_OPTIONS_INIT.
  ///
  /// @param opts The `git_clone_options` struct to initialize.
  /// @param version The struct version; pass `GIT_CLONE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_clone_options_init(
    ffi.Pointer<git_clone_options> opts,
    int version,
  ) {
    return _git_clone_options_init(
      opts,
      version,
    );
  }

  late final _git_clone_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_clone_options_init>>(
          'git_clone_options_init');
  late final _dart_git_clone_options_init _git_clone_options_init =
      _git_clone_options_init_ptr.asFunction<_dart_git_clone_options_init>();

  /// Clone a remote repository.
  ///
  /// By default this creates its repository and initial remote to match
  /// git's defaults. You can use the options in the callback to
  /// customize how these are created.
  ///
  /// @param out pointer that will receive the resulting repository object
  /// @param url the remote repository to clone
  /// @param local_path local directory to clone to
  /// @param options configuration options for the clone.  If NULL, the
  /// function works as though GIT_OPTIONS_INIT were passed.
  /// @return 0 on success, any non-zero return value from a callback
  /// function, or a negative value to indicate an error (use
  /// `git_error_last` for a detailed error message)
  int git_clone(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Int8> local_path,
    ffi.Pointer<git_clone_options> options,
  ) {
    return _git_clone(
      out,
      url,
      local_path,
      options,
    );
  }

  late final _git_clone_ptr =
      _lookup<ffi.NativeFunction<_c_git_clone>>('git_clone');
  late final _dart_git_clone _git_clone =
      _git_clone_ptr.asFunction<_dart_git_clone>();

  /// Lookup a commit object from a repository.
  ///
  /// The returned object should be released with `git_commit_free` when no
  /// longer needed.
  ///
  /// @param commit pointer to the looked up commit
  /// @param repo the repo to use when locating the commit.
  /// @param id identity of the commit to locate. If the object is
  /// an annotated tag it will be peeled back to the commit.
  /// @return 0 or an error code
  int git_commit_lookup(
    ffi.Pointer<ffi.Pointer<git_commit>> commit,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_commit_lookup(
      commit,
      repo,
      id,
    );
  }

  late final _git_commit_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_lookup>>('git_commit_lookup');
  late final _dart_git_commit_lookup _git_commit_lookup =
      _git_commit_lookup_ptr.asFunction<_dart_git_commit_lookup>();

  /// Lookup a commit object from a repository, given a prefix of its
  /// identifier (short id).
  ///
  /// The returned object should be released with `git_commit_free` when no
  /// longer needed.
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param commit pointer to the looked up commit
  /// @param repo the repo to use when locating the commit.
  /// @param id identity of the commit to locate. If the object is
  /// an annotated tag it will be peeled back to the commit.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_commit_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_commit>> commit,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_commit_lookup_prefix(
      commit,
      repo,
      id,
      len,
    );
  }

  late final _git_commit_lookup_prefix_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_lookup_prefix>>(
          'git_commit_lookup_prefix');
  late final _dart_git_commit_lookup_prefix _git_commit_lookup_prefix =
      _git_commit_lookup_prefix_ptr
          .asFunction<_dart_git_commit_lookup_prefix>();

  /// Close an open commit
  ///
  /// This is a wrapper around git_object_free()
  ///
  /// IMPORTANT:
  /// It *is* necessary to call this method when you stop
  /// using a commit. Failure to do so will cause a memory leak.
  ///
  /// @param commit the commit to close
  void git_commit_free(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_free(
      commit,
    );
  }

  late final _git_commit_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_free>>('git_commit_free');
  late final _dart_git_commit_free _git_commit_free =
      _git_commit_free_ptr.asFunction<_dart_git_commit_free>();

  /// Get the id of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return object identity for the commit.
  ffi.Pointer<git_oid> git_commit_id(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_id(
      commit,
    );
  }

  late final _git_commit_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_id>>('git_commit_id');
  late final _dart_git_commit_id _git_commit_id =
      _git_commit_id_ptr.asFunction<_dart_git_commit_id>();

  /// Get the repository that contains the commit.
  ///
  /// @param commit A previously loaded commit.
  /// @return Repository that contains this commit.
  ffi.Pointer<git_repository> git_commit_owner(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_owner(
      commit,
    );
  }

  late final _git_commit_owner_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_owner>>('git_commit_owner');
  late final _dart_git_commit_owner _git_commit_owner =
      _git_commit_owner_ptr.asFunction<_dart_git_commit_owner>();

  /// Get the encoding for the message of a commit,
  /// as a string representing a standard encoding name.
  ///
  /// The encoding may be NULL if the `encoding` header
  /// in the commit is missing; in that case UTF-8 is assumed.
  ///
  /// @param commit a previously loaded commit.
  /// @return NULL, or the encoding
  ffi.Pointer<ffi.Int8> git_commit_message_encoding(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_message_encoding(
      commit,
    );
  }

  late final _git_commit_message_encoding_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_message_encoding>>(
          'git_commit_message_encoding');
  late final _dart_git_commit_message_encoding _git_commit_message_encoding =
      _git_commit_message_encoding_ptr
          .asFunction<_dart_git_commit_message_encoding>();

  /// Get the full message of a commit.
  ///
  /// The returned message will be slightly prettified by removing any
  /// potential leading newlines.
  ///
  /// @param commit a previously loaded commit.
  /// @return the message of a commit
  ffi.Pointer<ffi.Int8> git_commit_message(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_message(
      commit,
    );
  }

  late final _git_commit_message_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_message>>('git_commit_message');
  late final _dart_git_commit_message _git_commit_message =
      _git_commit_message_ptr.asFunction<_dart_git_commit_message>();

  /// Get the full raw message of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the raw message of a commit
  ffi.Pointer<ffi.Int8> git_commit_message_raw(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_message_raw(
      commit,
    );
  }

  late final _git_commit_message_raw_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_message_raw>>(
          'git_commit_message_raw');
  late final _dart_git_commit_message_raw _git_commit_message_raw =
      _git_commit_message_raw_ptr.asFunction<_dart_git_commit_message_raw>();

  /// Get the short "summary" of the git commit message.
  ///
  /// The returned message is the summary of the commit, comprising the
  /// first paragraph of the message with whitespace trimmed and squashed.
  ///
  /// @param commit a previously loaded commit.
  /// @return the summary of a commit or NULL on error
  ffi.Pointer<ffi.Int8> git_commit_summary(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_summary(
      commit,
    );
  }

  late final _git_commit_summary_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_summary>>('git_commit_summary');
  late final _dart_git_commit_summary _git_commit_summary =
      _git_commit_summary_ptr.asFunction<_dart_git_commit_summary>();

  /// Get the long "body" of the git commit message.
  ///
  /// The returned message is the body of the commit, comprising
  /// everything but the first paragraph of the message. Leading and
  /// trailing whitespaces are trimmed.
  ///
  /// @param commit a previously loaded commit.
  /// @return the body of a commit or NULL when no the message only
  /// consists of a summary
  ffi.Pointer<ffi.Int8> git_commit_body(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_body(
      commit,
    );
  }

  late final _git_commit_body_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_body>>('git_commit_body');
  late final _dart_git_commit_body _git_commit_body =
      _git_commit_body_ptr.asFunction<_dart_git_commit_body>();

  /// Get the commit time (i.e. committer time) of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the time of a commit
  int git_commit_time(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_time(
      commit,
    );
  }

  late final _git_commit_time_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_time>>('git_commit_time');
  late final _dart_git_commit_time _git_commit_time =
      _git_commit_time_ptr.asFunction<_dart_git_commit_time>();

  /// Get the commit timezone offset (i.e. committer's preferred timezone) of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return positive or negative timezone offset, in minutes from UTC
  int git_commit_time_offset(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_time_offset(
      commit,
    );
  }

  late final _git_commit_time_offset_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_time_offset>>(
          'git_commit_time_offset');
  late final _dart_git_commit_time_offset _git_commit_time_offset =
      _git_commit_time_offset_ptr.asFunction<_dart_git_commit_time_offset>();

  /// Get the committer of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the committer of a commit
  ffi.Pointer<git_signature> git_commit_committer(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_committer(
      commit,
    );
  }

  late final _git_commit_committer_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_committer>>(
          'git_commit_committer');
  late final _dart_git_commit_committer _git_commit_committer =
      _git_commit_committer_ptr.asFunction<_dart_git_commit_committer>();

  /// Get the author of a commit.
  ///
  /// @param commit a previously loaded commit.
  /// @return the author of a commit
  ffi.Pointer<git_signature> git_commit_author(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_author(
      commit,
    );
  }

  late final _git_commit_author_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_author>>('git_commit_author');
  late final _dart_git_commit_author _git_commit_author =
      _git_commit_author_ptr.asFunction<_dart_git_commit_author>();

  /// Get the committer of a commit, using the mailmap to map names and email
  /// addresses to canonical real names and email addresses.
  ///
  /// Call `git_signature_free` to free the signature.
  ///
  /// @param out a pointer to store the resolved signature.
  /// @param commit a previously loaded commit.
  /// @param mailmap the mailmap to resolve with. (may be NULL)
  /// @return 0 or an error code
  int git_commit_committer_with_mailmap(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_mailmap> mailmap,
  ) {
    return _git_commit_committer_with_mailmap(
      out,
      commit,
      mailmap,
    );
  }

  late final _git_commit_committer_with_mailmap_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_committer_with_mailmap>>(
          'git_commit_committer_with_mailmap');
  late final _dart_git_commit_committer_with_mailmap
      _git_commit_committer_with_mailmap =
      _git_commit_committer_with_mailmap_ptr
          .asFunction<_dart_git_commit_committer_with_mailmap>();

  /// Get the author of a commit, using the mailmap to map names and email
  /// addresses to canonical real names and email addresses.
  ///
  /// Call `git_signature_free` to free the signature.
  ///
  /// @param out a pointer to store the resolved signature.
  /// @param commit a previously loaded commit.
  /// @param mailmap the mailmap to resolve with. (may be NULL)
  /// @return 0 or an error code
  int git_commit_author_with_mailmap(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_mailmap> mailmap,
  ) {
    return _git_commit_author_with_mailmap(
      out,
      commit,
      mailmap,
    );
  }

  late final _git_commit_author_with_mailmap_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_author_with_mailmap>>(
          'git_commit_author_with_mailmap');
  late final _dart_git_commit_author_with_mailmap
      _git_commit_author_with_mailmap = _git_commit_author_with_mailmap_ptr
          .asFunction<_dart_git_commit_author_with_mailmap>();

  /// Get the full raw text of the commit header.
  ///
  /// @param commit a previously loaded commit
  /// @return the header text of the commit
  ffi.Pointer<ffi.Int8> git_commit_raw_header(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_raw_header(
      commit,
    );
  }

  late final _git_commit_raw_header_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_raw_header>>(
          'git_commit_raw_header');
  late final _dart_git_commit_raw_header _git_commit_raw_header =
      _git_commit_raw_header_ptr.asFunction<_dart_git_commit_raw_header>();

  /// Get the tree pointed to by a commit.
  ///
  /// @param tree_out pointer where to store the tree object
  /// @param commit a previously loaded commit.
  /// @return 0 or an error code
  int git_commit_tree(
    ffi.Pointer<ffi.Pointer<git_tree>> tree_out,
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_tree(
      tree_out,
      commit,
    );
  }

  late final _git_commit_tree_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_tree>>('git_commit_tree');
  late final _dart_git_commit_tree _git_commit_tree =
      _git_commit_tree_ptr.asFunction<_dart_git_commit_tree>();

  /// Get the id of the tree pointed to by a commit. This differs from
  /// `git_commit_tree` in that no attempts are made to fetch an object
  /// from the ODB.
  ///
  /// @param commit a previously loaded commit.
  /// @return the id of tree pointed to by commit.
  ffi.Pointer<git_oid> git_commit_tree_id(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_tree_id(
      commit,
    );
  }

  late final _git_commit_tree_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_tree_id>>('git_commit_tree_id');
  late final _dart_git_commit_tree_id _git_commit_tree_id =
      _git_commit_tree_id_ptr.asFunction<_dart_git_commit_tree_id>();

  /// Get the number of parents of this commit
  ///
  /// @param commit a previously loaded commit.
  /// @return integer of count of parents
  int git_commit_parentcount(
    ffi.Pointer<git_commit> commit,
  ) {
    return _git_commit_parentcount(
      commit,
    );
  }

  late final _git_commit_parentcount_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_parentcount>>(
          'git_commit_parentcount');
  late final _dart_git_commit_parentcount _git_commit_parentcount =
      _git_commit_parentcount_ptr.asFunction<_dart_git_commit_parentcount>();

  /// Get the specified parent of the commit.
  ///
  /// @param out Pointer where to store the parent commit
  /// @param commit a previously loaded commit.
  /// @param n the position of the parent (from 0 to `parentcount`)
  /// @return 0 or an error code
  int git_commit_parent(
    ffi.Pointer<ffi.Pointer<git_commit>> out,
    ffi.Pointer<git_commit> commit,
    int n,
  ) {
    return _git_commit_parent(
      out,
      commit,
      n,
    );
  }

  late final _git_commit_parent_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_parent>>('git_commit_parent');
  late final _dart_git_commit_parent _git_commit_parent =
      _git_commit_parent_ptr.asFunction<_dart_git_commit_parent>();

  /// Get the oid of a specified parent for a commit. This is different from
  /// `git_commit_parent`, which will attempt to load the parent commit from
  /// the ODB.
  ///
  /// @param commit a previously loaded commit.
  /// @param n the position of the parent (from 0 to `parentcount`)
  /// @return the id of the parent, NULL on error.
  ffi.Pointer<git_oid> git_commit_parent_id(
    ffi.Pointer<git_commit> commit,
    int n,
  ) {
    return _git_commit_parent_id(
      commit,
      n,
    );
  }

  late final _git_commit_parent_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_parent_id>>(
          'git_commit_parent_id');
  late final _dart_git_commit_parent_id _git_commit_parent_id =
      _git_commit_parent_id_ptr.asFunction<_dart_git_commit_parent_id>();

  /// Get the commit object that is the <n>th generation ancestor
  /// of the named commit object, following only the first parents.
  /// The returned commit has to be freed by the caller.
  ///
  /// Passing `0` as the generation number returns another instance of the
  /// base commit itself.
  ///
  /// @param ancestor Pointer where to store the ancestor commit
  /// @param commit a previously loaded commit.
  /// @param n the requested generation
  /// @return 0 on success; GIT_ENOTFOUND if no matching ancestor exists
  /// or an error code
  int git_commit_nth_gen_ancestor(
    ffi.Pointer<ffi.Pointer<git_commit>> ancestor,
    ffi.Pointer<git_commit> commit,
    int n,
  ) {
    return _git_commit_nth_gen_ancestor(
      ancestor,
      commit,
      n,
    );
  }

  late final _git_commit_nth_gen_ancestor_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_nth_gen_ancestor>>(
          'git_commit_nth_gen_ancestor');
  late final _dart_git_commit_nth_gen_ancestor _git_commit_nth_gen_ancestor =
      _git_commit_nth_gen_ancestor_ptr
          .asFunction<_dart_git_commit_nth_gen_ancestor>();

  /// Get an arbitrary header field
  ///
  /// @param out the buffer to fill; existing content will be
  /// overwritten
  /// @param commit the commit to look in
  /// @param field the header field to return
  /// @return 0 on succeess, GIT_ENOTFOUND if the field does not exist,
  /// or an error code
  int git_commit_header_field(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<ffi.Int8> field,
  ) {
    return _git_commit_header_field(
      out,
      commit,
      field,
    );
  }

  late final _git_commit_header_field_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_header_field>>(
          'git_commit_header_field');
  late final _dart_git_commit_header_field _git_commit_header_field =
      _git_commit_header_field_ptr.asFunction<_dart_git_commit_header_field>();

  /// Extract the signature from a commit
  ///
  /// If the id is not for a commit, the error class will be
  /// `GIT_ERROR_INVALID`. If the commit does not have a signature, the
  /// error class will be `GIT_ERROR_OBJECT`.
  ///
  /// @param signature the signature block; existing content will be
  /// overwritten
  /// @param signed_data signed data; this is the commit contents minus the signature block;
  /// existing content will be overwritten
  /// @param repo the repository in which the commit exists
  /// @param commit_id the commit from which to extract the data
  /// @param field the name of the header field containing the signature
  /// block; pass `NULL` to extract the default 'gpgsig'
  /// @return 0 on success, GIT_ENOTFOUND if the id is not for a commit
  /// or the commit does not have a signature.
  int git_commit_extract_signature(
    ffi.Pointer<git_buf> signature,
    ffi.Pointer<git_buf> signed_data,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> commit_id,
    ffi.Pointer<ffi.Int8> field,
  ) {
    return _git_commit_extract_signature(
      signature,
      signed_data,
      repo,
      commit_id,
      field,
    );
  }

  late final _git_commit_extract_signature_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_extract_signature>>(
          'git_commit_extract_signature');
  late final _dart_git_commit_extract_signature _git_commit_extract_signature =
      _git_commit_extract_signature_ptr
          .asFunction<_dart_git_commit_extract_signature>();

  /// Create new commit in the repository from a list of `git_object` pointers
  ///
  /// The message will **not** be cleaned up automatically. You can do that
  /// with the `git_message_prettify()` function.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  ///
  /// @param repo Repository where to store the commit
  ///
  /// @param update_ref If not NULL, name of the reference that
  /// will be updated to point to this commit. If the reference
  /// is not direct, it will be resolved to a direct reference.
  /// Use "HEAD" to update the HEAD of the current branch and
  /// make it point to this commit. If the reference doesn't
  /// exist yet, it will be created. If it does exist, the first
  /// parent must be the tip of this branch.
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @param parents Array of `parent_count` pointers to `git_commit`
  /// objects that will be used as the parents for this commit. This
  /// array may be NULL if `parent_count` is 0 (root commit). All the
  /// given commits must be owned by the `repo`.
  ///
  /// @return 0 or an error code
  /// The created commit will be written to the Object Database and
  /// the given reference will be updated to point to it
  int git_commit_create(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Int8> message_encoding,
    ffi.Pointer<ffi.Int8> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
  ) {
    return _git_commit_create(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
      parents,
    );
  }

  late final _git_commit_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_create>>('git_commit_create');
  late final _dart_git_commit_create _git_commit_create =
      _git_commit_create_ptr.asFunction<_dart_git_commit_create>();

  /// Create new commit in the repository using a variable argument list.
  ///
  /// The message will **not** be cleaned up automatically. You can do that
  /// with the `git_message_prettify()` function.
  ///
  /// The parents for the commit are specified as a variable list of pointers
  /// to `const git_commit *`. Note that this is a convenience method which may
  /// not be safe to export for certain languages or compilers
  ///
  /// All other parameters remain the same as `git_commit_create()`.
  ///
  /// @see git_commit_create
  int git_commit_create_v(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Int8> message_encoding,
    ffi.Pointer<ffi.Int8> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
  ) {
    return _git_commit_create_v(
      id,
      repo,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
    );
  }

  late final _git_commit_create_v_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_create_v>>(
          'git_commit_create_v');
  late final _dart_git_commit_create_v _git_commit_create_v =
      _git_commit_create_v_ptr.asFunction<_dart_git_commit_create_v>();

  /// Amend an existing commit by replacing only non-NULL values.
  ///
  /// This creates a new commit that is exactly the same as the old commit,
  /// except that any non-NULL values will be updated.  The new commit has
  /// the same parents as the old commit.
  ///
  /// The `update_ref` value works as in the regular `git_commit_create()`,
  /// updating the ref to point to the newly rewritten commit.  If you want
  /// to amend a commit that is not currently the tip of the branch and then
  /// rewrite the following commits to reach a ref, pass this as NULL and
  /// update the rest of the commit chain and ref separately.
  ///
  /// Unlike `git_commit_create()`, the `author`, `committer`, `message`,
  /// `message_encoding`, and `tree` parameters can be NULL in which case this
  /// will use the values from the original `commit_to_amend`.
  ///
  /// All parameters have the same meanings as in `git_commit_create()`.
  ///
  /// @see git_commit_create
  int git_commit_amend(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_commit> commit_to_amend,
    ffi.Pointer<ffi.Int8> update_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Int8> message_encoding,
    ffi.Pointer<ffi.Int8> message,
    ffi.Pointer<git_tree> tree,
  ) {
    return _git_commit_amend(
      id,
      commit_to_amend,
      update_ref,
      author,
      committer,
      message_encoding,
      message,
      tree,
    );
  }

  late final _git_commit_amend_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_amend>>('git_commit_amend');
  late final _dart_git_commit_amend _git_commit_amend =
      _git_commit_amend_ptr.asFunction<_dart_git_commit_amend>();

  /// Create a commit and write it into a buffer
  ///
  /// Create a commit as with `git_commit_create()` but instead of
  /// writing it to the objectdb, write the contents of the object into a
  /// buffer.
  ///
  /// @param out the buffer into which to write the commit object content
  ///
  /// @param repo Repository where the referenced tree and parents live
  ///
  /// @param author Signature with author and author time of commit
  ///
  /// @param committer Signature with committer and * commit time of commit
  ///
  /// @param message_encoding The encoding for the message in the
  /// commit, represented with a standard encoding name.
  /// E.g. "UTF-8". If NULL, no encoding header is written and
  /// UTF-8 is assumed.
  ///
  /// @param message Full message for this commit
  ///
  /// @param tree An instance of a `git_tree` object that will
  /// be used as the tree for the commit. This tree object must
  /// also be owned by the given `repo`.
  ///
  /// @param parent_count Number of parents for this commit
  ///
  /// @param parents Array of `parent_count` pointers to `git_commit`
  /// objects that will be used as the parents for this commit. This
  /// array may be NULL if `parent_count` is 0 (root commit). All the
  /// given commits must be owned by the `repo`.
  ///
  /// @return 0 or an error code
  int git_commit_create_buffer(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Int8> message_encoding,
    ffi.Pointer<ffi.Int8> message,
    ffi.Pointer<git_tree> tree,
    int parent_count,
    ffi.Pointer<ffi.Pointer<git_commit>> parents,
  ) {
    return _git_commit_create_buffer(
      out,
      repo,
      author,
      committer,
      message_encoding,
      message,
      tree,
      parent_count,
      parents,
    );
  }

  late final _git_commit_create_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_create_buffer>>(
          'git_commit_create_buffer');
  late final _dart_git_commit_create_buffer _git_commit_create_buffer =
      _git_commit_create_buffer_ptr
          .asFunction<_dart_git_commit_create_buffer>();

  /// Create a commit object from the given buffer and signature
  ///
  /// Given the unsigned commit object's contents, its signature and the
  /// header field in which to store the signature, attach the signature
  /// to the commit and write it into the given repository.
  ///
  /// @param out the resulting commit id
  /// @param commit_content the content of the unsigned commit object
  /// @param signature the signature to add to the commit. Leave `NULL`
  /// to create a commit without adding a signature field.
  /// @param signature_field which header field should contain this
  /// signature. Leave `NULL` for the default of "gpgsig"
  /// @return 0 or an error code
  int git_commit_create_with_signature(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> commit_content,
    ffi.Pointer<ffi.Int8> signature,
    ffi.Pointer<ffi.Int8> signature_field,
  ) {
    return _git_commit_create_with_signature(
      out,
      repo,
      commit_content,
      signature,
      signature_field,
    );
  }

  late final _git_commit_create_with_signature_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_create_with_signature>>(
          'git_commit_create_with_signature');
  late final _dart_git_commit_create_with_signature
      _git_commit_create_with_signature = _git_commit_create_with_signature_ptr
          .asFunction<_dart_git_commit_create_with_signature>();

  /// Create an in-memory copy of a commit. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the commit
  /// @param source Original commit to copy
  int git_commit_dup(
    ffi.Pointer<ffi.Pointer<git_commit>> out,
    ffi.Pointer<git_commit> source,
  ) {
    return _git_commit_dup(
      out,
      source,
    );
  }

  late final _git_commit_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_commit_dup>>('git_commit_dup');
  late final _dart_git_commit_dup _git_commit_dup =
      _git_commit_dup_ptr.asFunction<_dart_git_commit_dup>();

  /// Free a config entry
  void git_config_entry_free(
    ffi.Pointer<git_config_entry> arg0,
  ) {
    return _git_config_entry_free(
      arg0,
    );
  }

  late final _git_config_entry_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_entry_free>>(
          'git_config_entry_free');
  late final _dart_git_config_entry_free _git_config_entry_free =
      _git_config_entry_free_ptr.asFunction<_dart_git_config_entry_free>();

  /// Locate the path to the global configuration file
  ///
  /// The user or global configuration file is usually
  /// located in `$HOME/.gitconfig`.
  ///
  /// This method will try to guess the full path to that
  /// file, if the file exists. The returned path
  /// may be used on any `git_config` call to load the
  /// global configuration file.
  ///
  /// This method will not guess the path to the xdg compatible
  /// config file (.config/git/config).
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a global configuration file has been found. Its path will be stored in `out`.
  int git_config_find_global(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_global(
      out,
    );
  }

  late final _git_config_find_global_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_find_global>>(
          'git_config_find_global');
  late final _dart_git_config_find_global _git_config_find_global =
      _git_config_find_global_ptr.asFunction<_dart_git_config_find_global>();

  /// Locate the path to the global xdg compatible configuration file
  ///
  /// The xdg compatible configuration file is usually
  /// located in `$HOME/.config/git/config`.
  ///
  /// This method will try to guess the full path to that
  /// file, if the file exists. The returned path
  /// may be used on any `git_config` call to load the
  /// xdg compatible configuration file.
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a xdg compatible configuration file has been
  /// found. Its path will be stored in `out`.
  int git_config_find_xdg(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_xdg(
      out,
    );
  }

  late final _git_config_find_xdg_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_find_xdg>>(
          'git_config_find_xdg');
  late final _dart_git_config_find_xdg _git_config_find_xdg =
      _git_config_find_xdg_ptr.asFunction<_dart_git_config_find_xdg>();

  /// Locate the path to the system configuration file
  ///
  /// If /etc/gitconfig doesn't exist, it will look for
  /// %PROGRAMFILES%\Git\etc\gitconfig.
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a system configuration file has been
  /// found. Its path will be stored in `out`.
  int git_config_find_system(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_system(
      out,
    );
  }

  late final _git_config_find_system_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_find_system>>(
          'git_config_find_system');
  late final _dart_git_config_find_system _git_config_find_system =
      _git_config_find_system_ptr.asFunction<_dart_git_config_find_system>();

  /// Locate the path to the configuration file in ProgramData
  ///
  /// Look for the file in %PROGRAMDATA%\Git\config used by portable git.
  ///
  /// @param out Pointer to a user-allocated git_buf in which to store the path
  /// @return 0 if a ProgramData configuration file has been
  /// found. Its path will be stored in `out`.
  int git_config_find_programdata(
    ffi.Pointer<git_buf> out,
  ) {
    return _git_config_find_programdata(
      out,
    );
  }

  late final _git_config_find_programdata_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_find_programdata>>(
          'git_config_find_programdata');
  late final _dart_git_config_find_programdata _git_config_find_programdata =
      _git_config_find_programdata_ptr
          .asFunction<_dart_git_config_find_programdata>();

  /// Open the global, XDG and system configuration files
  ///
  /// Utility wrapper that finds the global, XDG and system configuration files
  /// and opens them into a single prioritized config object that can be
  /// used when accessing default config data outside a repository.
  ///
  /// @param out Pointer to store the config instance
  /// @return 0 or an error code
  int git_config_open_default(
    ffi.Pointer<ffi.Pointer<git_config>> out,
  ) {
    return _git_config_open_default(
      out,
    );
  }

  late final _git_config_open_default_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_open_default>>(
          'git_config_open_default');
  late final _dart_git_config_open_default _git_config_open_default =
      _git_config_open_default_ptr.asFunction<_dart_git_config_open_default>();

  /// Allocate a new configuration object
  ///
  /// This object is empty, so you have to add a file to it before you
  /// can do anything with it.
  ///
  /// @param out pointer to the new configuration
  /// @return 0 or an error code
  int git_config_new(
    ffi.Pointer<ffi.Pointer<git_config>> out,
  ) {
    return _git_config_new(
      out,
    );
  }

  late final _git_config_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_new>>('git_config_new');
  late final _dart_git_config_new _git_config_new =
      _git_config_new_ptr.asFunction<_dart_git_config_new>();

  /// Add an on-disk config file instance to an existing config
  ///
  /// The on-disk file pointed at by `path` will be opened and
  /// parsed; it's expected to be a native Git config file following
  /// the default Git config syntax (see man git-config).
  ///
  /// If the file does not exist, the file will still be added and it
  /// will be created the first time we write to it.
  ///
  /// Note that the configuration object will free the file
  /// automatically.
  ///
  /// Further queries on this config object will access each
  /// of the config file instances in order (instances with
  /// a higher priority level will be accessed first).
  ///
  /// @param cfg the configuration to add the file to
  /// @param path path to the configuration file to add
  /// @param level the priority level of the backend
  /// @param force replace config file at the given priority level
  /// @param repo optional repository to allow parsing of
  /// conditional includes
  /// @return 0 on success, GIT_EEXISTS when adding more than one file
  /// for a given priority level (and force_replace set to 0),
  /// GIT_ENOTFOUND when the file doesn't exist or error code
  int git_config_add_file_ondisk(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> path,
    int level,
    ffi.Pointer<git_repository> repo,
    int force,
  ) {
    return _git_config_add_file_ondisk(
      cfg,
      path,
      level,
      repo,
      force,
    );
  }

  late final _git_config_add_file_ondisk_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_add_file_ondisk>>(
          'git_config_add_file_ondisk');
  late final _dart_git_config_add_file_ondisk _git_config_add_file_ondisk =
      _git_config_add_file_ondisk_ptr
          .asFunction<_dart_git_config_add_file_ondisk>();

  /// Create a new config instance containing a single on-disk file
  ///
  /// This method is a simple utility wrapper for the following sequence
  /// of calls:
  /// - git_config_new
  /// - git_config_add_file_ondisk
  ///
  /// @param out The configuration instance to create
  /// @param path Path to the on-disk file to open
  /// @return 0 on success, or an error code
  int git_config_open_ondisk(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_config_open_ondisk(
      out,
      path,
    );
  }

  late final _git_config_open_ondisk_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_open_ondisk>>(
          'git_config_open_ondisk');
  late final _dart_git_config_open_ondisk _git_config_open_ondisk =
      _git_config_open_ondisk_ptr.asFunction<_dart_git_config_open_ondisk>();

  /// Build a single-level focused config object from a multi-level one.
  ///
  /// The returned config object can be used to perform get/set/delete operations
  /// on a single specific level.
  ///
  /// Getting several times the same level from the same parent multi-level config
  /// will return different config instances, but containing the same config_file
  /// instance.
  ///
  /// @param out The configuration instance to create
  /// @param parent Multi-level config to search for the given level
  /// @param level Configuration level to search for
  /// @return 0, GIT_ENOTFOUND if the passed level cannot be found in the
  /// multi-level parent config, or an error code
  int git_config_open_level(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_config> parent,
    int level,
  ) {
    return _git_config_open_level(
      out,
      parent,
      level,
    );
  }

  late final _git_config_open_level_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_open_level>>(
          'git_config_open_level');
  late final _dart_git_config_open_level _git_config_open_level =
      _git_config_open_level_ptr.asFunction<_dart_git_config_open_level>();

  /// Open the global/XDG configuration file according to git's rules
  ///
  /// Git allows you to store your global configuration at
  /// `$HOME/.gitconfig` or `$XDG_CONFIG_HOME/git/config`. For backwards
  /// compatability, the XDG file shouldn't be used unless the use has
  /// created it explicitly. With this function you'll open the correct
  /// one to write to.
  ///
  /// @param out pointer in which to store the config object
  /// @param config the config object in which to look
  int git_config_open_global(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_config> config,
  ) {
    return _git_config_open_global(
      out,
      config,
    );
  }

  late final _git_config_open_global_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_open_global>>(
          'git_config_open_global');
  late final _dart_git_config_open_global _git_config_open_global =
      _git_config_open_global_ptr.asFunction<_dart_git_config_open_global>();

  /// Create a snapshot of the configuration
  ///
  /// Create a snapshot of the current state of a configuration, which
  /// allows you to look into a consistent view of the configuration for
  /// looking up complex values (e.g. a remote, submodule).
  ///
  /// The string returned when querying such a config object is valid
  /// until it is freed.
  ///
  /// @param out pointer in which to store the snapshot config object
  /// @param config configuration to snapshot
  /// @return 0 or an error code
  int git_config_snapshot(
    ffi.Pointer<ffi.Pointer<git_config>> out,
    ffi.Pointer<git_config> config,
  ) {
    return _git_config_snapshot(
      out,
      config,
    );
  }

  late final _git_config_snapshot_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_snapshot>>(
          'git_config_snapshot');
  late final _dart_git_config_snapshot _git_config_snapshot =
      _git_config_snapshot_ptr.asFunction<_dart_git_config_snapshot>();

  /// Free the configuration and its associated memory and files
  ///
  /// @param cfg the configuration to free
  void git_config_free(
    ffi.Pointer<git_config> cfg,
  ) {
    return _git_config_free(
      cfg,
    );
  }

  late final _git_config_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_free>>('git_config_free');
  late final _dart_git_config_free _git_config_free =
      _git_config_free_ptr.asFunction<_dart_git_config_free>();

  /// Get the git_config_entry of a config variable.
  ///
  /// Free the git_config_entry after use with `git_config_entry_free()`.
  ///
  /// @param out pointer to the variable git_config_entry
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_entry(
    ffi.Pointer<ffi.Pointer<git_config_entry>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_config_get_entry(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_entry_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_get_entry>>(
          'git_config_get_entry');
  late final _dart_git_config_get_entry _git_config_get_entry =
      _git_config_get_entry_ptr.asFunction<_dart_git_config_get_entry>();

  /// Get the value of an integer config variable.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the variable where the value should be stored
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_int32(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_config_get_int32(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_int32_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_get_int32>>(
          'git_config_get_int32');
  late final _dart_git_config_get_int32 _git_config_get_int32 =
      _git_config_get_int32_ptr.asFunction<_dart_git_config_get_int32>();

  /// Get the value of a long integer config variable.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the variable where the value should be stored
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_int64(
    ffi.Pointer<ffi.Int64> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_config_get_int64(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_int64_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_get_int64>>(
          'git_config_get_int64');
  late final _dart_git_config_get_int64 _git_config_get_int64 =
      _git_config_get_int64_ptr.asFunction<_dart_git_config_get_int64>();

  /// Get the value of a boolean config variable.
  ///
  /// This function uses the usual C convention of 0 being false and
  /// anything else true.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the variable where the value should be stored
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_bool(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_config_get_bool(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_bool_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_get_bool>>(
          'git_config_get_bool');
  late final _dart_git_config_get_bool _git_config_get_bool =
      _git_config_get_bool_ptr.asFunction<_dart_git_config_get_bool>();

  /// Get the value of a path config variable.
  ///
  /// A leading '~' will be expanded to the global search path (which
  /// defaults to the user's home directory but can be overridden via
  /// `git_libgit2_opts()`.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out the buffer in which to store the result
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_path(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_config_get_path(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_path_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_get_path>>(
          'git_config_get_path');
  late final _dart_git_config_get_path _git_config_get_path =
      _git_config_get_path_ptr.asFunction<_dart_git_config_get_path>();

  /// Get the value of a string config variable.
  ///
  /// This function can only be used on snapshot config objects. The
  /// string is owned by the config and should not be freed by the
  /// user. The pointer will be valid until the config is freed.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out pointer to the string
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_string(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_config_get_string(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_string_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_get_string>>(
          'git_config_get_string');
  late final _dart_git_config_get_string _git_config_get_string =
      _git_config_get_string_ptr.asFunction<_dart_git_config_get_string>();

  /// Get the value of a string config variable.
  ///
  /// The value of the config will be copied into the buffer.
  ///
  /// All config files will be looked into, in the order of their
  /// defined level. A higher level means a higher priority. The
  /// first occurrence of the variable will be returned here.
  ///
  /// @param out buffer in which to store the string
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @return 0 or an error code
  int git_config_get_string_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_config_get_string_buf(
      out,
      cfg,
      name,
    );
  }

  late final _git_config_get_string_buf_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_get_string_buf>>(
          'git_config_get_string_buf');
  late final _dart_git_config_get_string_buf _git_config_get_string_buf =
      _git_config_get_string_buf_ptr
          .asFunction<_dart_git_config_get_string_buf>();

  /// Get each value of a multivar in a foreach callback
  ///
  /// The callback will be called on each variable found
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param regexp regular expression to filter which variables we're
  /// interested in. Use NULL to indicate all
  /// @param callback the function to be called on each value of the variable
  /// @param payload opaque pointer to pass to the callback
  int git_config_get_multivar_foreach(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> regexp,
    ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_get_multivar_foreach(
      cfg,
      name,
      regexp,
      callback,
      payload,
    );
  }

  late final _git_config_get_multivar_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_get_multivar_foreach>>(
          'git_config_get_multivar_foreach');
  late final _dart_git_config_get_multivar_foreach
      _git_config_get_multivar_foreach = _git_config_get_multivar_foreach_ptr
          .asFunction<_dart_git_config_get_multivar_foreach>();

  /// Get each value of a multivar
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param out pointer to store the iterator
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param regexp regular expression to filter which variables we're
  /// interested in. Use NULL to indicate all
  int git_config_multivar_iterator_new(
    ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> regexp,
  ) {
    return _git_config_multivar_iterator_new(
      out,
      cfg,
      name,
      regexp,
    );
  }

  late final _git_config_multivar_iterator_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_multivar_iterator_new>>(
          'git_config_multivar_iterator_new');
  late final _dart_git_config_multivar_iterator_new
      _git_config_multivar_iterator_new = _git_config_multivar_iterator_new_ptr
          .asFunction<_dart_git_config_multivar_iterator_new>();

  /// Return the current entry and advance the iterator
  ///
  /// The pointers returned by this function are valid until the iterator
  /// is freed.
  ///
  /// @param entry pointer to store the entry
  /// @param iter the iterator
  /// @return 0 or an error code. GIT_ITEROVER if the iteration has completed
  int git_config_next(
    ffi.Pointer<ffi.Pointer<git_config_entry>> entry,
    ffi.Pointer<git_config_iterator> iter,
  ) {
    return _git_config_next(
      entry,
      iter,
    );
  }

  late final _git_config_next_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_next>>('git_config_next');
  late final _dart_git_config_next _git_config_next =
      _git_config_next_ptr.asFunction<_dart_git_config_next>();

  /// Free a config iterator
  ///
  /// @param iter the iterator to free
  void git_config_iterator_free(
    ffi.Pointer<git_config_iterator> iter,
  ) {
    return _git_config_iterator_free(
      iter,
    );
  }

  late final _git_config_iterator_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_iterator_free>>(
          'git_config_iterator_free');
  late final _dart_git_config_iterator_free _git_config_iterator_free =
      _git_config_iterator_free_ptr
          .asFunction<_dart_git_config_iterator_free>();

  /// Set the value of an integer config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value Integer value for the variable
  /// @return 0 or an error code
  int git_config_set_int32(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
    int value,
  ) {
    return _git_config_set_int32(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_int32_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_set_int32>>(
          'git_config_set_int32');
  late final _dart_git_config_set_int32 _git_config_set_int32 =
      _git_config_set_int32_ptr.asFunction<_dart_git_config_set_int32>();

  /// Set the value of a long integer config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value Long integer value for the variable
  /// @return 0 or an error code
  int git_config_set_int64(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
    int value,
  ) {
    return _git_config_set_int64(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_int64_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_set_int64>>(
          'git_config_set_int64');
  late final _dart_git_config_set_int64 _git_config_set_int64 =
      _git_config_set_int64_ptr.asFunction<_dart_git_config_set_int64>();

  /// Set the value of a boolean config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value the value to store
  /// @return 0 or an error code
  int git_config_set_bool(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
    int value,
  ) {
    return _git_config_set_bool(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_bool_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_set_bool>>(
          'git_config_set_bool');
  late final _dart_git_config_set_bool _git_config_set_bool =
      _git_config_set_bool_ptr.asFunction<_dart_git_config_set_bool>();

  /// Set the value of a string config variable in the config file
  /// with the highest level (usually the local one).
  ///
  /// A copy of the string is made and the user is free to use it
  /// afterwards.
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param value the string to store.
  /// @return 0 or an error code
  int git_config_set_string(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _git_config_set_string(
      cfg,
      name,
      value,
    );
  }

  late final _git_config_set_string_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_set_string>>(
          'git_config_set_string');
  late final _dart_git_config_set_string _git_config_set_string =
      _git_config_set_string_ptr.asFunction<_dart_git_config_set_string>();

  /// Set a multivar in the local config file.
  ///
  /// The regular expression is applied case-sensitively on the value.
  ///
  /// @param cfg where to look for the variable
  /// @param name the variable's name
  /// @param regexp a regular expression to indicate which values to replace
  /// @param value the new value.
  int git_config_set_multivar(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> regexp,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _git_config_set_multivar(
      cfg,
      name,
      regexp,
      value,
    );
  }

  late final _git_config_set_multivar_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_set_multivar>>(
          'git_config_set_multivar');
  late final _dart_git_config_set_multivar _git_config_set_multivar =
      _git_config_set_multivar_ptr.asFunction<_dart_git_config_set_multivar>();

  /// Delete a config variable from the config file
  /// with the highest level (usually the local one).
  ///
  /// @param cfg the configuration
  /// @param name the variable to delete
  int git_config_delete_entry(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_config_delete_entry(
      cfg,
      name,
    );
  }

  late final _git_config_delete_entry_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_delete_entry>>(
          'git_config_delete_entry');
  late final _dart_git_config_delete_entry _git_config_delete_entry =
      _git_config_delete_entry_ptr.asFunction<_dart_git_config_delete_entry>();

  /// Deletes one or several entries from a multivar in the local config file.
  ///
  /// The regular expression is applied case-sensitively on the value.
  ///
  /// @param cfg where to look for the variables
  /// @param name the variable's name
  /// @param regexp a regular expression to indicate which values to delete
  ///
  /// @return 0 or an error code
  int git_config_delete_multivar(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> regexp,
  ) {
    return _git_config_delete_multivar(
      cfg,
      name,
      regexp,
    );
  }

  late final _git_config_delete_multivar_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_delete_multivar>>(
          'git_config_delete_multivar');
  late final _dart_git_config_delete_multivar _git_config_delete_multivar =
      _git_config_delete_multivar_ptr
          .asFunction<_dart_git_config_delete_multivar>();

  /// Perform an operation on each config variable.
  ///
  /// The callback receives the normalized name and value of each variable
  /// in the config backend, and the data pointer passed to this function.
  /// If the callback returns a non-zero value, the function stops iterating
  /// and returns that value to the caller.
  ///
  /// The pointers passed to the callback are only valid as long as the
  /// iteration is ongoing.
  ///
  /// @param cfg where to get the variables from
  /// @param callback the function to call on each variable
  /// @param payload the data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_config_foreach(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_foreach(
      cfg,
      callback,
      payload,
    );
  }

  late final _git_config_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_foreach>>('git_config_foreach');
  late final _dart_git_config_foreach _git_config_foreach =
      _git_config_foreach_ptr.asFunction<_dart_git_config_foreach>();

  /// Iterate over all the config variables
  ///
  /// Use `git_config_next` to advance the iteration and
  /// `git_config_iterator_free` when done.
  ///
  /// @param out pointer to store the iterator
  /// @param cfg where to ge the variables from
  int git_config_iterator_new(
    ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
    ffi.Pointer<git_config> cfg,
  ) {
    return _git_config_iterator_new(
      out,
      cfg,
    );
  }

  late final _git_config_iterator_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_iterator_new>>(
          'git_config_iterator_new');
  late final _dart_git_config_iterator_new _git_config_iterator_new =
      _git_config_iterator_new_ptr.asFunction<_dart_git_config_iterator_new>();

  /// Iterate over all the config variables whose name matches a pattern
  ///
  /// Use `git_config_next` to advance the iteration and
  /// `git_config_iterator_free` when done.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param out pointer to store the iterator
  /// @param cfg where to ge the variables from
  /// @param regexp regular expression to match the names
  int git_config_iterator_glob_new(
    ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> regexp,
  ) {
    return _git_config_iterator_glob_new(
      out,
      cfg,
      regexp,
    );
  }

  late final _git_config_iterator_glob_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_iterator_glob_new>>(
          'git_config_iterator_glob_new');
  late final _dart_git_config_iterator_glob_new _git_config_iterator_glob_new =
      _git_config_iterator_glob_new_ptr
          .asFunction<_dart_git_config_iterator_glob_new>();

  /// Perform an operation on each config variable matching a regular expression.
  ///
  /// This behaves like `git_config_foreach` with an additional filter of a
  /// regular expression that filters which config keys are passed to the
  /// callback.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the case-insensitive parts are lower-case.
  ///
  /// @param cfg where to get the variables from
  /// @param regexp regular expression to match against config names
  /// @param callback the function to call on each variable
  /// @param payload the data to pass to the callback
  /// @return 0 or the return value of the callback which didn't return 0
  int git_config_foreach_match(
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> regexp,
    ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_foreach_match(
      cfg,
      regexp,
      callback,
      payload,
    );
  }

  late final _git_config_foreach_match_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_foreach_match>>(
          'git_config_foreach_match');
  late final _dart_git_config_foreach_match _git_config_foreach_match =
      _git_config_foreach_match_ptr
          .asFunction<_dart_git_config_foreach_match>();

  /// Query the value of a config variable and return it mapped to
  /// an integer constant.
  ///
  /// This is a helper method to easily map different possible values
  /// to a variable to integer constants that easily identify them.
  ///
  /// A mapping array looks as follows:
  ///
  /// git_configmap autocrlf_mapping[] = {
  /// {GIT_CVAR_FALSE, NULL, GIT_AUTO_CRLF_FALSE},
  /// {GIT_CVAR_TRUE, NULL, GIT_AUTO_CRLF_TRUE},
  /// {GIT_CVAR_STRING, "input", GIT_AUTO_CRLF_INPUT},
  /// {GIT_CVAR_STRING, "default", GIT_AUTO_CRLF_DEFAULT}};
  ///
  /// On any "false" value for the variable (e.g. "false", "FALSE", "no"), the
  /// mapping will store `GIT_AUTO_CRLF_FALSE` in the `out` parameter.
  ///
  /// The same thing applies for any "true" value such as "true", "yes" or "1", storing
  /// the `GIT_AUTO_CRLF_TRUE` variable.
  ///
  /// Otherwise, if the value matches the string "input" (with case insensitive comparison),
  /// the given constant will be stored in `out`, and likewise for "default".
  ///
  /// If not a single match can be made to store in `out`, an error code will be
  /// returned.
  ///
  /// @param out place to store the result of the mapping
  /// @param cfg config file to get the variables from
  /// @param name name of the config variable to lookup
  /// @param maps array of `git_configmap` objects specifying the possible mappings
  /// @param map_n number of mapping objects in `maps`
  /// @return 0 on success, error code otherwise
  int git_config_get_mapped(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<git_config> cfg,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<git_configmap> maps,
    int map_n,
  ) {
    return _git_config_get_mapped(
      out,
      cfg,
      name,
      maps,
      map_n,
    );
  }

  late final _git_config_get_mapped_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_get_mapped>>(
          'git_config_get_mapped');
  late final _dart_git_config_get_mapped _git_config_get_mapped =
      _git_config_get_mapped_ptr.asFunction<_dart_git_config_get_mapped>();

  /// Maps a string value to an integer constant
  ///
  /// @param out place to store the result of the parsing
  /// @param maps array of `git_configmap` objects specifying the possible mappings
  /// @param map_n number of mapping objects in `maps`
  /// @param value value to parse
  int git_config_lookup_map_value(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<git_configmap> maps,
    int map_n,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _git_config_lookup_map_value(
      out,
      maps,
      map_n,
      value,
    );
  }

  late final _git_config_lookup_map_value_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_lookup_map_value>>(
          'git_config_lookup_map_value');
  late final _dart_git_config_lookup_map_value _git_config_lookup_map_value =
      _git_config_lookup_map_value_ptr
          .asFunction<_dart_git_config_lookup_map_value>();

  /// Parse a string value as a bool.
  ///
  /// Valid values for true are: 'true', 'yes', 'on', 1 or any
  /// number different from 0
  /// Valid values for false are: 'false', 'no', 'off', 0
  ///
  /// @param out place to store the result of the parsing
  /// @param value value to parse
  int git_config_parse_bool(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _git_config_parse_bool(
      out,
      value,
    );
  }

  late final _git_config_parse_bool_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_parse_bool>>(
          'git_config_parse_bool');
  late final _dart_git_config_parse_bool _git_config_parse_bool =
      _git_config_parse_bool_ptr.asFunction<_dart_git_config_parse_bool>();

  /// Parse a string value as an int32.
  ///
  /// An optional value suffix of 'k', 'm', or 'g' will
  /// cause the value to be multiplied by 1024, 1048576,
  /// or 1073741824 prior to output.
  ///
  /// @param out place to store the result of the parsing
  /// @param value value to parse
  int git_config_parse_int32(
    ffi.Pointer<ffi.Int32> out,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _git_config_parse_int32(
      out,
      value,
    );
  }

  late final _git_config_parse_int32_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_parse_int32>>(
          'git_config_parse_int32');
  late final _dart_git_config_parse_int32 _git_config_parse_int32 =
      _git_config_parse_int32_ptr.asFunction<_dart_git_config_parse_int32>();

  /// Parse a string value as an int64.
  ///
  /// An optional value suffix of 'k', 'm', or 'g' will
  /// cause the value to be multiplied by 1024, 1048576,
  /// or 1073741824 prior to output.
  ///
  /// @param out place to store the result of the parsing
  /// @param value value to parse
  int git_config_parse_int64(
    ffi.Pointer<ffi.Int64> out,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _git_config_parse_int64(
      out,
      value,
    );
  }

  late final _git_config_parse_int64_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_parse_int64>>(
          'git_config_parse_int64');
  late final _dart_git_config_parse_int64 _git_config_parse_int64 =
      _git_config_parse_int64_ptr.asFunction<_dart_git_config_parse_int64>();

  /// Parse a string value as a path.
  ///
  /// A leading '~' will be expanded to the global search path (which
  /// defaults to the user's home directory but can be overridden via
  /// `git_libgit2_opts()`.
  ///
  /// If the value does not begin with a tilde, the input will be
  /// returned.
  ///
  /// @param out placae to store the result of parsing
  /// @param value the path to evaluate
  int git_config_parse_path(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<ffi.Int8> value,
  ) {
    return _git_config_parse_path(
      out,
      value,
    );
  }

  late final _git_config_parse_path_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_parse_path>>(
          'git_config_parse_path');
  late final _dart_git_config_parse_path _git_config_parse_path =
      _git_config_parse_path_ptr.asFunction<_dart_git_config_parse_path>();

  /// Perform an operation on each config variable in a given config backend,
  /// matching a regular expression.
  ///
  /// This behaves like `git_config_foreach_match` except that only config
  /// entries from the given backend entry are enumerated.
  ///
  /// The regular expression is applied case-sensitively on the normalized form of
  /// the variable name: the section and variable parts are lower-cased. The
  /// subsection is left unchanged.
  ///
  /// @param backend where to get the variables from
  /// @param regexp regular expression to match against config names (can be NULL)
  /// @param callback the function to call on each variable
  /// @param payload the data to pass to the callback
  int git_config_backend_foreach_match(
    ffi.Pointer<git_config_backend> backend,
    ffi.Pointer<ffi.Int8> regexp,
    ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_config_backend_foreach_match(
      backend,
      regexp,
      callback,
      payload,
    );
  }

  late final _git_config_backend_foreach_match_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_backend_foreach_match>>(
          'git_config_backend_foreach_match');
  late final _dart_git_config_backend_foreach_match
      _git_config_backend_foreach_match = _git_config_backend_foreach_match_ptr
          .asFunction<_dart_git_config_backend_foreach_match>();

  /// Lock the backend with the highest priority
  ///
  /// Locking disallows anybody else from writing to that backend. Any
  /// updates made after locking will not be visible to a reader until
  /// the file is unlocked.
  ///
  /// You can apply the changes by calling `git_transaction_commit()`
  /// before freeing the transaction. Either of these actions will unlock
  /// the config.
  ///
  /// @param tx the resulting transaction, use this to commit or undo the
  /// changes
  /// @param cfg the configuration in which to lock
  /// @return 0 or an error code
  int git_config_lock(
    ffi.Pointer<ffi.Pointer<git_transaction>> tx,
    ffi.Pointer<git_config> cfg,
  ) {
    return _git_config_lock(
      tx,
      cfg,
    );
  }

  late final _git_config_lock_ptr =
      _lookup<ffi.NativeFunction<_c_git_config_lock>>('git_config_lock');
  late final _dart_git_config_lock _git_config_lock =
      _git_config_lock_ptr.asFunction<_dart_git_config_lock>();

  /// Initialize git_describe_options structure
  ///
  /// Initializes a `git_describe_options` with default values. Equivalent to creating
  /// an instance with GIT_DESCRIBE_OPTIONS_INIT.
  ///
  /// @param opts The `git_describe_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DESCRIBE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_describe_options_init(
    ffi.Pointer<git_describe_options> opts,
    int version,
  ) {
    return _git_describe_options_init(
      opts,
      version,
    );
  }

  late final _git_describe_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_describe_options_init>>(
          'git_describe_options_init');
  late final _dart_git_describe_options_init _git_describe_options_init =
      _git_describe_options_init_ptr
          .asFunction<_dart_git_describe_options_init>();

  /// Initialize git_describe_format_options structure
  ///
  /// Initializes a `git_describe_format_options` with default values. Equivalent to creating
  /// an instance with GIT_DESCRIBE_FORMAT_OPTIONS_INIT.
  ///
  /// @param opts The `git_describe_format_options` struct to initialize.
  /// @param version The struct version; pass `GIT_DESCRIBE_FORMAT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_describe_format_options_init(
    ffi.Pointer<git_describe_format_options> opts,
    int version,
  ) {
    return _git_describe_format_options_init(
      opts,
      version,
    );
  }

  late final _git_describe_format_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_describe_format_options_init>>(
          'git_describe_format_options_init');
  late final _dart_git_describe_format_options_init
      _git_describe_format_options_init = _git_describe_format_options_init_ptr
          .asFunction<_dart_git_describe_format_options_init>();

  /// Describe a commit
  ///
  /// Perform the describe operation on the given committish object.
  ///
  /// @param result pointer to store the result. You must free this once
  /// you're done with it.
  /// @param committish a committish to describe
  /// @param opts the lookup options (or NULL for defaults)
  int git_describe_commit(
    ffi.Pointer<ffi.Pointer<git_describe_result>> result,
    ffi.Pointer<git_object> committish,
    ffi.Pointer<git_describe_options> opts,
  ) {
    return _git_describe_commit(
      result,
      committish,
      opts,
    );
  }

  late final _git_describe_commit_ptr =
      _lookup<ffi.NativeFunction<_c_git_describe_commit>>(
          'git_describe_commit');
  late final _dart_git_describe_commit _git_describe_commit =
      _git_describe_commit_ptr.asFunction<_dart_git_describe_commit>();

  /// Describe a commit
  ///
  /// Perform the describe operation on the current commit and the
  /// worktree. After peforming describe on HEAD, a status is run and the
  /// description is considered to be dirty if there are.
  ///
  /// @param out pointer to store the result. You must free this once
  /// you're done with it.
  /// @param repo the repository in which to perform the describe
  /// @param opts the lookup options (or NULL for defaults)
  int git_describe_workdir(
    ffi.Pointer<ffi.Pointer<git_describe_result>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_describe_options> opts,
  ) {
    return _git_describe_workdir(
      out,
      repo,
      opts,
    );
  }

  late final _git_describe_workdir_ptr =
      _lookup<ffi.NativeFunction<_c_git_describe_workdir>>(
          'git_describe_workdir');
  late final _dart_git_describe_workdir _git_describe_workdir =
      _git_describe_workdir_ptr.asFunction<_dart_git_describe_workdir>();

  /// Print the describe result to a buffer
  ///
  /// @param out The buffer to store the result
  /// @param result the result from `git_describe_commit()` or
  /// `git_describe_workdir()`.
  /// @param opts the formatting options (or NULL for defaults)
  int git_describe_format(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_describe_result> result,
    ffi.Pointer<git_describe_format_options> opts,
  ) {
    return _git_describe_format(
      out,
      result,
      opts,
    );
  }

  late final _git_describe_format_ptr =
      _lookup<ffi.NativeFunction<_c_git_describe_format>>(
          'git_describe_format');
  late final _dart_git_describe_format _git_describe_format =
      _git_describe_format_ptr.asFunction<_dart_git_describe_format>();

  /// Free the describe result.
  void git_describe_result_free(
    ffi.Pointer<git_describe_result> result,
  ) {
    return _git_describe_result_free(
      result,
    );
  }

  late final _git_describe_result_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_describe_result_free>>(
          'git_describe_result_free');
  late final _dart_git_describe_result_free _git_describe_result_free =
      _git_describe_result_free_ptr
          .asFunction<_dart_git_describe_result_free>();

  /// Return the last `git_error` object that was generated for the
  /// current thread.
  ///
  /// The default behaviour of this function is to return NULL if no previous error has occurred.
  /// However, libgit2's error strings are not cleared aggressively, so a prior
  /// (unrelated) error may be returned. This can be avoided by only calling
  /// this function if the prior call to a libgit2 API returned an error.
  ///
  /// @return A git_error object.
  ffi.Pointer<git_error> git_error_last() {
    return _git_error_last();
  }

  late final _git_error_last_ptr =
      _lookup<ffi.NativeFunction<_c_git_error_last>>('git_error_last');
  late final _dart_git_error_last _git_error_last =
      _git_error_last_ptr.asFunction<_dart_git_error_last>();

  /// Clear the last library error that occurred for this thread.
  void git_error_clear() {
    return _git_error_clear();
  }

  late final _git_error_clear_ptr =
      _lookup<ffi.NativeFunction<_c_git_error_clear>>('git_error_clear');
  late final _dart_git_error_clear _git_error_clear =
      _git_error_clear_ptr.asFunction<_dart_git_error_clear>();

  /// Set the error message string for this thread.
  ///
  /// This function is public so that custom ODB backends and the like can
  /// relay an error message through libgit2.  Most regular users of libgit2
  /// will never need to call this function -- actually, calling it in most
  /// circumstances (for example, calling from within a callback function)
  /// will just end up having the value overwritten by libgit2 internals.
  ///
  /// This error message is stored in thread-local storage and only applies
  /// to the particular thread that this libgit2 call is made from.
  ///
  /// @param error_class One of the `git_error_t` enum above describing the
  /// general subsystem that is responsible for the error.
  /// @param string The formatted error message to keep
  /// @return 0 on success or -1 on failure
  int git_error_set_str(
    int error_class,
    ffi.Pointer<ffi.Int8> string,
  ) {
    return _git_error_set_str(
      error_class,
      string,
    );
  }

  late final _git_error_set_str_ptr =
      _lookup<ffi.NativeFunction<_c_git_error_set_str>>('git_error_set_str');
  late final _dart_git_error_set_str _git_error_set_str =
      _git_error_set_str_ptr.asFunction<_dart_git_error_set_str>();

  /// Set the error message to a special value for memory allocation failure.
  ///
  /// The normal `git_error_set_str()` function attempts to `strdup()` the
  /// string that is passed in.  This is not a good idea when the error in
  /// question is a memory allocation failure.  That circumstance has a
  /// special setter function that sets the error string to a known and
  /// statically allocated internal value.
  void git_error_set_oom() {
    return _git_error_set_oom();
  }

  late final _git_error_set_oom_ptr =
      _lookup<ffi.NativeFunction<_c_git_error_set_oom>>('git_error_set_oom');
  late final _dart_git_error_set_oom _git_error_set_oom =
      _git_error_set_oom_ptr.asFunction<_dart_git_error_set_oom>();

  /// Initialize git_rebase_options structure
  ///
  /// Initializes a `git_rebase_options` with default values. Equivalent to
  /// creating an instance with `GIT_REBASE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_rebase_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REBASE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_rebase_options_init(
    ffi.Pointer<git_rebase_options> opts,
    int version,
  ) {
    return _git_rebase_options_init(
      opts,
      version,
    );
  }

  late final _git_rebase_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_options_init>>(
          'git_rebase_options_init');
  late final _dart_git_rebase_options_init _git_rebase_options_init =
      _git_rebase_options_init_ptr.asFunction<_dart_git_rebase_options_init>();

  /// Initializes a rebase operation to rebase the changes in `branch`
  /// relative to `upstream` onto another branch.  To begin the rebase
  /// process, call `git_rebase_next`.  When you have finished with this
  /// object, call `git_rebase_free`.
  ///
  /// @param out Pointer to store the rebase object
  /// @param repo The repository to perform the rebase
  /// @param branch The terminal commit to rebase, or NULL to rebase the
  /// current branch
  /// @param upstream The commit to begin rebasing from, or NULL to rebase all
  /// reachable commits
  /// @param onto The branch to rebase onto, or NULL to rebase onto the given
  /// upstream
  /// @param opts Options to specify how rebase is performed, or NULL
  /// @return Zero on success; -1 on failure.
  int git_rebase_init(
    ffi.Pointer<ffi.Pointer<git_rebase>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_annotated_commit> branch,
    ffi.Pointer<git_annotated_commit> upstream,
    ffi.Pointer<git_annotated_commit> onto,
    ffi.Pointer<git_rebase_options> opts,
  ) {
    return _git_rebase_init(
      out,
      repo,
      branch,
      upstream,
      onto,
      opts,
    );
  }

  late final _git_rebase_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_init>>('git_rebase_init');
  late final _dart_git_rebase_init _git_rebase_init =
      _git_rebase_init_ptr.asFunction<_dart_git_rebase_init>();

  /// Opens an existing rebase that was previously started by either an
  /// invocation of `git_rebase_init` or by another client.
  ///
  /// @param out Pointer to store the rebase object
  /// @param repo The repository that has a rebase in-progress
  /// @param opts Options to specify how rebase is performed
  /// @return Zero on success; -1 on failure.
  int git_rebase_open(
    ffi.Pointer<ffi.Pointer<git_rebase>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_rebase_options> opts,
  ) {
    return _git_rebase_open(
      out,
      repo,
      opts,
    );
  }

  late final _git_rebase_open_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_open>>('git_rebase_open');
  late final _dart_git_rebase_open _git_rebase_open =
      _git_rebase_open_ptr.asFunction<_dart_git_rebase_open>();

  /// Gets the original `HEAD` ref name for merge rebases.
  ///
  /// @return The original `HEAD` ref name
  ffi.Pointer<ffi.Int8> git_rebase_orig_head_name(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_orig_head_name(
      rebase,
    );
  }

  late final _git_rebase_orig_head_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_orig_head_name>>(
          'git_rebase_orig_head_name');
  late final _dart_git_rebase_orig_head_name _git_rebase_orig_head_name =
      _git_rebase_orig_head_name_ptr
          .asFunction<_dart_git_rebase_orig_head_name>();

  /// Gets the original `HEAD` id for merge rebases.
  ///
  /// @return The original `HEAD` id
  ffi.Pointer<git_oid> git_rebase_orig_head_id(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_orig_head_id(
      rebase,
    );
  }

  late final _git_rebase_orig_head_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_orig_head_id>>(
          'git_rebase_orig_head_id');
  late final _dart_git_rebase_orig_head_id _git_rebase_orig_head_id =
      _git_rebase_orig_head_id_ptr.asFunction<_dart_git_rebase_orig_head_id>();

  /// Gets the `onto` ref name for merge rebases.
  ///
  /// @return The `onto` ref name
  ffi.Pointer<ffi.Int8> git_rebase_onto_name(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_onto_name(
      rebase,
    );
  }

  late final _git_rebase_onto_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_onto_name>>(
          'git_rebase_onto_name');
  late final _dart_git_rebase_onto_name _git_rebase_onto_name =
      _git_rebase_onto_name_ptr.asFunction<_dart_git_rebase_onto_name>();

  /// Gets the `onto` id for merge rebases.
  ///
  /// @return The `onto` id
  ffi.Pointer<git_oid> git_rebase_onto_id(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_onto_id(
      rebase,
    );
  }

  late final _git_rebase_onto_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_onto_id>>('git_rebase_onto_id');
  late final _dart_git_rebase_onto_id _git_rebase_onto_id =
      _git_rebase_onto_id_ptr.asFunction<_dart_git_rebase_onto_id>();

  /// Gets the count of rebase operations that are to be applied.
  ///
  /// @param rebase The in-progress rebase
  /// @return The number of rebase operations in total
  int git_rebase_operation_entrycount(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_operation_entrycount(
      rebase,
    );
  }

  late final _git_rebase_operation_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_operation_entrycount>>(
          'git_rebase_operation_entrycount');
  late final _dart_git_rebase_operation_entrycount
      _git_rebase_operation_entrycount = _git_rebase_operation_entrycount_ptr
          .asFunction<_dart_git_rebase_operation_entrycount>();

  /// Gets the index of the rebase operation that is currently being applied.
  /// If the first operation has not yet been applied (because you have
  /// called `init` but not yet `next`) then this returns
  /// `GIT_REBASE_NO_OPERATION`.
  ///
  /// @param rebase The in-progress rebase
  /// @return The index of the rebase operation currently being applied.
  int git_rebase_operation_current(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_operation_current(
      rebase,
    );
  }

  late final _git_rebase_operation_current_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_operation_current>>(
          'git_rebase_operation_current');
  late final _dart_git_rebase_operation_current _git_rebase_operation_current =
      _git_rebase_operation_current_ptr
          .asFunction<_dart_git_rebase_operation_current>();

  /// Gets the rebase operation specified by the given index.
  ///
  /// @param rebase The in-progress rebase
  /// @param idx The index of the rebase operation to retrieve
  /// @return The rebase operation or NULL if `idx` was out of bounds
  ffi.Pointer<git_rebase_operation> git_rebase_operation_byindex(
    ffi.Pointer<git_rebase> rebase,
    int idx,
  ) {
    return _git_rebase_operation_byindex(
      rebase,
      idx,
    );
  }

  late final _git_rebase_operation_byindex_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_operation_byindex>>(
          'git_rebase_operation_byindex');
  late final _dart_git_rebase_operation_byindex _git_rebase_operation_byindex =
      _git_rebase_operation_byindex_ptr
          .asFunction<_dart_git_rebase_operation_byindex>();

  /// Performs the next rebase operation and returns the information about it.
  /// If the operation is one that applies a patch (which is any operation except
  /// GIT_REBASE_OPERATION_EXEC) then the patch will be applied and the index and
  /// working directory will be updated with the changes.  If there are conflicts,
  /// you will need to address those before committing the changes.
  ///
  /// @param operation Pointer to store the rebase operation that is to be performed next
  /// @param rebase The rebase in progress
  /// @return Zero on success; -1 on failure.
  int git_rebase_next(
    ffi.Pointer<ffi.Pointer<git_rebase_operation>> operation,
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_next(
      operation,
      rebase,
    );
  }

  late final _git_rebase_next_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_next>>('git_rebase_next');
  late final _dart_git_rebase_next _git_rebase_next =
      _git_rebase_next_ptr.asFunction<_dart_git_rebase_next>();

  /// Gets the index produced by the last operation, which is the result
  /// of `git_rebase_next` and which will be committed by the next
  /// invocation of `git_rebase_commit`.  This is useful for resolving
  /// conflicts in an in-memory rebase before committing them.  You must
  /// call `git_index_free` when you are finished with this.
  ///
  /// This is only applicable for in-memory rebases; for rebases within
  /// a working directory, the changes were applied to the repository's
  /// index.
  int git_rebase_inmemory_index(
    ffi.Pointer<ffi.Pointer<git_index>> index,
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_inmemory_index(
      index,
      rebase,
    );
  }

  late final _git_rebase_inmemory_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_inmemory_index>>(
          'git_rebase_inmemory_index');
  late final _dart_git_rebase_inmemory_index _git_rebase_inmemory_index =
      _git_rebase_inmemory_index_ptr
          .asFunction<_dart_git_rebase_inmemory_index>();

  /// Commits the current patch.  You must have resolved any conflicts that
  /// were introduced during the patch application from the `git_rebase_next`
  /// invocation.
  ///
  /// @param id Pointer in which to store the OID of the newly created commit
  /// @param rebase The rebase that is in-progress
  /// @param author The author of the updated commit, or NULL to keep the
  /// author from the original commit
  /// @param committer The committer of the rebase
  /// @param message_encoding The encoding for the message in the commit,
  /// represented with a standard encoding name.  If message is NULL,
  /// this should also be NULL, and the encoding from the original
  /// commit will be maintained.  If message is specified, this may be
  /// NULL to indicate that "UTF-8" is to be used.
  /// @param message The message for this commit, or NULL to use the message
  /// from the original commit.
  /// @return Zero on success, GIT_EUNMERGED if there are unmerged changes in
  /// the index, GIT_EAPPLIED if the current commit has already
  /// been applied to the upstream and there is nothing to commit,
  /// -1 on failure.
  int git_rebase_commit(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_rebase> rebase,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Int8> message_encoding,
    ffi.Pointer<ffi.Int8> message,
  ) {
    return _git_rebase_commit(
      id,
      rebase,
      author,
      committer,
      message_encoding,
      message,
    );
  }

  late final _git_rebase_commit_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_commit>>('git_rebase_commit');
  late final _dart_git_rebase_commit _git_rebase_commit =
      _git_rebase_commit_ptr.asFunction<_dart_git_rebase_commit>();

  /// Aborts a rebase that is currently in progress, resetting the repository
  /// and working directory to their state before rebase began.
  ///
  /// @param rebase The rebase that is in-progress
  /// @return Zero on success; GIT_ENOTFOUND if a rebase is not in progress,
  /// -1 on other errors.
  int git_rebase_abort(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_abort(
      rebase,
    );
  }

  late final _git_rebase_abort_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_abort>>('git_rebase_abort');
  late final _dart_git_rebase_abort _git_rebase_abort =
      _git_rebase_abort_ptr.asFunction<_dart_git_rebase_abort>();

  /// Finishes a rebase that is currently in progress once all patches have
  /// been applied.
  ///
  /// @param rebase The rebase that is in-progress
  /// @param signature The identity that is finishing the rebase (optional)
  /// @return Zero on success; -1 on error
  int git_rebase_finish(
    ffi.Pointer<git_rebase> rebase,
    ffi.Pointer<git_signature> signature,
  ) {
    return _git_rebase_finish(
      rebase,
      signature,
    );
  }

  late final _git_rebase_finish_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_finish>>('git_rebase_finish');
  late final _dart_git_rebase_finish _git_rebase_finish =
      _git_rebase_finish_ptr.asFunction<_dart_git_rebase_finish>();

  /// Frees the `git_rebase` object.
  ///
  /// @param rebase The rebase object
  void git_rebase_free(
    ffi.Pointer<git_rebase> rebase,
  ) {
    return _git_rebase_free(
      rebase,
    );
  }

  late final _git_rebase_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_free>>('git_rebase_free');
  late final _dart_git_rebase_free _git_rebase_free =
      _git_rebase_free_ptr.asFunction<_dart_git_rebase_free>();

  /// Sets the system tracing configuration to the specified level with the
  /// specified callback.  When system events occur at a level equal to, or
  /// lower than, the given level they will be reported to the given callback.
  ///
  /// @param level Level to set tracing to
  /// @param cb Function to call with trace data
  /// @return 0 or an error code
  int git_trace_set(
    int level,
    ffi.Pointer<ffi.NativeFunction<git_trace_cb>> cb,
  ) {
    return _git_trace_set(
      level,
      cb,
    );
  }

  late final _git_trace_set_ptr =
      _lookup<ffi.NativeFunction<_c_git_trace_set>>('git_trace_set');
  late final _dart_git_trace_set _git_trace_set =
      _git_trace_set_ptr.asFunction<_dart_git_trace_set>();

  /// Initialize git_revert_options structure
  ///
  /// Initializes a `git_revert_options` with default values. Equivalent to
  /// creating an instance with `GIT_REVERT_OPTIONS_INIT`.
  ///
  /// @param opts The `git_revert_options` struct to initialize.
  /// @param version The struct version; pass `GIT_REVERT_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_revert_options_init(
    ffi.Pointer<git_revert_options> opts,
    int version,
  ) {
    return _git_revert_options_init(
      opts,
      version,
    );
  }

  late final _git_revert_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_revert_options_init>>(
          'git_revert_options_init');
  late final _dart_git_revert_options_init _git_revert_options_init =
      _git_revert_options_init_ptr.asFunction<_dart_git_revert_options_init>();

  /// Reverts the given commit against the given "our" commit, producing an
  /// index that reflects the result of the revert.
  ///
  /// The returned index must be freed explicitly with `git_index_free`.
  ///
  /// @param out pointer to store the index result in
  /// @param repo the repository that contains the given commits
  /// @param revert_commit the commit to revert
  /// @param our_commit the commit to revert against (eg, HEAD)
  /// @param mainline the parent of the revert commit, if it is a merge
  /// @param merge_options the merge options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_revert_commit(
    ffi.Pointer<ffi.Pointer<git_index>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> revert_commit,
    ffi.Pointer<git_commit> our_commit,
    int mainline,
    ffi.Pointer<git_merge_options> merge_options,
  ) {
    return _git_revert_commit(
      out,
      repo,
      revert_commit,
      our_commit,
      mainline,
      merge_options,
    );
  }

  late final _git_revert_commit_ptr =
      _lookup<ffi.NativeFunction<_c_git_revert_commit>>('git_revert_commit');
  late final _dart_git_revert_commit _git_revert_commit =
      _git_revert_commit_ptr.asFunction<_dart_git_revert_commit>();

  /// Reverts the given commit, producing changes in the index and working directory.
  ///
  /// @param repo the repository to revert
  /// @param commit the commit to revert
  /// @param given_opts the revert options (or null for defaults)
  /// @return zero on success, -1 on failure.
  int git_revert(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> commit,
    ffi.Pointer<git_revert_options> given_opts,
  ) {
    return _git_revert(
      repo,
      commit,
      given_opts,
    );
  }

  late final _git_revert_ptr =
      _lookup<ffi.NativeFunction<_c_git_revert>>('git_revert');
  late final _dart_git_revert _git_revert =
      _git_revert_ptr.asFunction<_dart_git_revert>();

  /// Save the local modifications to a new stash.
  ///
  /// @param out Object id of the commit containing the stashed state.
  /// This commit is also the target of the direct reference refs/stash.
  ///
  /// @param repo The owning repository.
  ///
  /// @param stasher The identity of the person performing the stashing.
  ///
  /// @param message Optional description along with the stashed state.
  ///
  /// @param flags Flags to control the stashing process. (see GIT_STASH_* above)
  ///
  /// @return 0 on success, GIT_ENOTFOUND where there's nothing to stash,
  /// or error code.
  int git_stash_save(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_signature> stasher,
    ffi.Pointer<ffi.Int8> message,
    int flags,
  ) {
    return _git_stash_save(
      out,
      repo,
      stasher,
      message,
      flags,
    );
  }

  late final _git_stash_save_ptr =
      _lookup<ffi.NativeFunction<_c_git_stash_save>>('git_stash_save');
  late final _dart_git_stash_save _git_stash_save =
      _git_stash_save_ptr.asFunction<_dart_git_stash_save>();

  /// Initialize git_stash_apply_options structure
  ///
  /// Initializes a `git_stash_apply_options` with default values. Equivalent to
  /// creating an instance with `GIT_STASH_APPLY_OPTIONS_INIT`.
  ///
  /// @param opts The `git_stash_apply_options` struct to initialize.
  /// @param version The struct version; pass `GIT_STASH_APPLY_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_stash_apply_options_init(
    ffi.Pointer<git_stash_apply_options> opts,
    int version,
  ) {
    return _git_stash_apply_options_init(
      opts,
      version,
    );
  }

  late final _git_stash_apply_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_stash_apply_options_init>>(
          'git_stash_apply_options_init');
  late final _dart_git_stash_apply_options_init _git_stash_apply_options_init =
      _git_stash_apply_options_init_ptr
          .asFunction<_dart_git_stash_apply_options_init>();

  /// Apply a single stashed state from the stash list.
  ///
  /// If local changes in the working directory conflict with changes in the
  /// stash then GIT_EMERGECONFLICT will be returned.  In this case, the index
  /// will always remain unmodified and all files in the working directory will
  /// remain unmodified.  However, if you are restoring untracked files or
  /// ignored files and there is a conflict when applying the modified files,
  /// then those files will remain in the working directory.
  ///
  /// If passing the GIT_STASH_APPLY_REINSTATE_INDEX flag and there would be
  /// conflicts when reinstating the index, the function will return
  /// GIT_EMERGECONFLICT and both the working directory and index will be left
  /// unmodified.
  ///
  /// Note that a minimum checkout strategy of `GIT_CHECKOUT_SAFE` is implied.
  ///
  /// @param repo The owning repository.
  /// @param index The position within the stash list. 0 points to the
  /// most recent stashed state.
  /// @param options Optional options to control how stashes are applied.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the
  /// given index, GIT_EMERGECONFLICT if changes exist in the working
  /// directory, or an error code
  int git_stash_apply(
    ffi.Pointer<git_repository> repo,
    int index,
    ffi.Pointer<git_stash_apply_options> options,
  ) {
    return _git_stash_apply(
      repo,
      index,
      options,
    );
  }

  late final _git_stash_apply_ptr =
      _lookup<ffi.NativeFunction<_c_git_stash_apply>>('git_stash_apply');
  late final _dart_git_stash_apply _git_stash_apply =
      _git_stash_apply_ptr.asFunction<_dart_git_stash_apply>();

  /// Loop over all the stashed states and issue a callback for each one.
  ///
  /// If the callback returns a non-zero value, this will stop looping.
  ///
  /// @param repo Repository where to find the stash.
  ///
  /// @param callback Callback to invoke per found stashed state. The most
  /// recent stash state will be enumerated first.
  ///
  /// @param payload Extra parameter to callback function.
  ///
  /// @return 0 on success, non-zero callback return value, or error code.
  int git_stash_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.NativeFunction<git_stash_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_stash_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_stash_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_stash_foreach>>('git_stash_foreach');
  late final _dart_git_stash_foreach _git_stash_foreach =
      _git_stash_foreach_ptr.asFunction<_dart_git_stash_foreach>();

  /// Remove a single stashed state from the stash list.
  ///
  /// @param repo The owning repository.
  ///
  /// @param index The position within the stash list. 0 points to the
  /// most recent stashed state.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
  /// index, or error code.
  int git_stash_drop(
    ffi.Pointer<git_repository> repo,
    int index,
  ) {
    return _git_stash_drop(
      repo,
      index,
    );
  }

  late final _git_stash_drop_ptr =
      _lookup<ffi.NativeFunction<_c_git_stash_drop>>('git_stash_drop');
  late final _dart_git_stash_drop _git_stash_drop =
      _git_stash_drop_ptr.asFunction<_dart_git_stash_drop>();

  /// Apply a single stashed state from the stash list and remove it from the list
  /// if successful.
  ///
  /// @param repo The owning repository.
  /// @param index The position within the stash list. 0 points to the
  /// most recent stashed state.
  /// @param options Optional options to control how stashes are applied.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if there's no stashed state for the given
  /// index, or error code. (see git_stash_apply() above for details)
  int git_stash_pop(
    ffi.Pointer<git_repository> repo,
    int index,
    ffi.Pointer<git_stash_apply_options> options,
  ) {
    return _git_stash_pop(
      repo,
      index,
      options,
    );
  }

  late final _git_stash_pop_ptr =
      _lookup<ffi.NativeFunction<_c_git_stash_pop>>('git_stash_pop');
  late final _dart_git_stash_pop _git_stash_pop =
      _git_stash_pop_ptr.asFunction<_dart_git_stash_pop>();

  /// Initialize git_status_options structure
  ///
  /// Initializes a `git_status_options` with default values. Equivalent to
  /// creating an instance with `GIT_STATUS_OPTIONS_INIT`.
  ///
  /// @param opts The `git_status_options` struct to initialize.
  /// @param version The struct version; pass `GIT_STATUS_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_status_options_init(
    ffi.Pointer<git_status_options> opts,
    int version,
  ) {
    return _git_status_options_init(
      opts,
      version,
    );
  }

  late final _git_status_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_options_init>>(
          'git_status_options_init');
  late final _dart_git_status_options_init _git_status_options_init =
      _git_status_options_init_ptr.asFunction<_dart_git_status_options_init>();

  /// Gather file statuses and run a callback for each one.
  ///
  /// The callback is passed the path of the file, the status (a combination of
  /// the `git_status_t` values above) and the `payload` data pointer passed
  /// into this function.
  ///
  /// If the callback returns a non-zero value, this function will stop looping
  /// and return that value to caller.
  ///
  /// @param repo A repository object
  /// @param callback The function to call on each file
  /// @param payload Pointer to pass through to callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_status_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.NativeFunction<git_status_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_status_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_status_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_foreach>>('git_status_foreach');
  late final _dart_git_status_foreach _git_status_foreach =
      _git_status_foreach_ptr.asFunction<_dart_git_status_foreach>();

  /// Gather file status information and run callbacks as requested.
  ///
  /// This is an extended version of the `git_status_foreach()` API that
  /// allows for more granular control over which paths will be processed and
  /// in what order.  See the `git_status_options` structure for details
  /// about the additional controls that this makes available.
  ///
  /// Note that if a `pathspec` is given in the `git_status_options` to filter
  /// the status, then the results from rename detection (if you enable it) may
  /// not be accurate.  To do rename detection properly, this must be called
  /// with no `pathspec` so that all files can be considered.
  ///
  /// @param repo Repository object
  /// @param opts Status options structure
  /// @param callback The function to call on each file
  /// @param payload Pointer to pass through to callback function
  /// @return 0 on success, non-zero callback return value, or error code
  int git_status_foreach_ext(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_status_options> opts,
    ffi.Pointer<ffi.NativeFunction<git_status_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_status_foreach_ext(
      repo,
      opts,
      callback,
      payload,
    );
  }

  late final _git_status_foreach_ext_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_foreach_ext>>(
          'git_status_foreach_ext');
  late final _dart_git_status_foreach_ext _git_status_foreach_ext =
      _git_status_foreach_ext_ptr.asFunction<_dart_git_status_foreach_ext>();

  /// Get file status for a single file.
  ///
  /// This tries to get status for the filename that you give.  If no files
  /// match that name (in either the HEAD, index, or working directory), this
  /// returns GIT_ENOTFOUND.
  ///
  /// If the name matches multiple files (for example, if the `path` names a
  /// directory or if running on a case- insensitive filesystem and yet the
  /// HEAD has two entries that both match the path), then this returns
  /// GIT_EAMBIGUOUS because it cannot give correct results.
  ///
  /// This does not do any sort of rename detection.  Renames require a set of
  /// targets and because of the path filtering, there is not enough
  /// information to check renames correctly.  To check file status with rename
  /// detection, there is no choice but to do a full `git_status_list_new` and
  /// scan through looking for the path that you are interested in.
  ///
  /// @param status_flags Output combination of git_status_t values for file
  /// @param repo A repository object
  /// @param path The exact path to retrieve status for relative to the
  /// repository working directory
  /// @return 0 on success, GIT_ENOTFOUND if the file is not found in the HEAD,
  /// index, and work tree, GIT_EAMBIGUOUS if `path` matches multiple files
  /// or if it refers to a folder, and -1 on other errors.
  int git_status_file(
    ffi.Pointer<ffi.Uint32> status_flags,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_status_file(
      status_flags,
      repo,
      path,
    );
  }

  late final _git_status_file_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_file>>('git_status_file');
  late final _dart_git_status_file _git_status_file =
      _git_status_file_ptr.asFunction<_dart_git_status_file>();

  /// Gather file status information and populate the `git_status_list`.
  ///
  /// Note that if a `pathspec` is given in the `git_status_options` to filter
  /// the status, then the results from rename detection (if you enable it) may
  /// not be accurate.  To do rename detection properly, this must be called
  /// with no `pathspec` so that all files can be considered.
  ///
  /// @param out Pointer to store the status results in
  /// @param repo Repository object
  /// @param opts Status options structure
  /// @return 0 on success or error code
  int git_status_list_new(
    ffi.Pointer<ffi.Pointer<git_status_list>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_status_options> opts,
  ) {
    return _git_status_list_new(
      out,
      repo,
      opts,
    );
  }

  late final _git_status_list_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_list_new>>(
          'git_status_list_new');
  late final _dart_git_status_list_new _git_status_list_new =
      _git_status_list_new_ptr.asFunction<_dart_git_status_list_new>();

  /// Gets the count of status entries in this list.
  ///
  /// If there are no changes in status (at least according the options given
  /// when the status list was created), this can return 0.
  ///
  /// @param statuslist Existing status list object
  /// @return the number of status entries
  int git_status_list_entrycount(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _git_status_list_entrycount(
      statuslist,
    );
  }

  late final _git_status_list_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_list_entrycount>>(
          'git_status_list_entrycount');
  late final _dart_git_status_list_entrycount _git_status_list_entrycount =
      _git_status_list_entrycount_ptr
          .asFunction<_dart_git_status_list_entrycount>();

  /// Get a pointer to one of the entries in the status list.
  ///
  /// The entry is not modifiable and should not be freed.
  ///
  /// @param statuslist Existing status list object
  /// @param idx Position of the entry
  /// @return Pointer to the entry; NULL if out of bounds
  ffi.Pointer<git_status_entry> git_status_byindex(
    ffi.Pointer<git_status_list> statuslist,
    int idx,
  ) {
    return _git_status_byindex(
      statuslist,
      idx,
    );
  }

  late final _git_status_byindex_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_byindex>>('git_status_byindex');
  late final _dart_git_status_byindex _git_status_byindex =
      _git_status_byindex_ptr.asFunction<_dart_git_status_byindex>();

  /// Free an existing status list
  ///
  /// @param statuslist Existing status list object
  void git_status_list_free(
    ffi.Pointer<git_status_list> statuslist,
  ) {
    return _git_status_list_free(
      statuslist,
    );
  }

  late final _git_status_list_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_list_free>>(
          'git_status_list_free');
  late final _dart_git_status_list_free _git_status_list_free =
      _git_status_list_free_ptr.asFunction<_dart_git_status_list_free>();

  /// Test if the ignore rules apply to a given file.
  ///
  /// This function checks the ignore rules to see if they would apply to the
  /// given file.  This indicates if the file would be ignored regardless of
  /// whether the file is already in the index or committed to the repository.
  ///
  /// One way to think of this is if you were to do "git add ." on the
  /// directory containing the file, would it be added or not?
  ///
  /// @param ignored Boolean returning 0 if the file is not ignored, 1 if it is
  /// @param repo A repository object
  /// @param path The file to check ignores for, rooted at the repo's workdir.
  /// @return 0 if ignore rules could be processed for the file (regardless
  /// of whether it exists or not), or an error < 0 if they could not.
  int git_status_should_ignore(
    ffi.Pointer<ffi.Int32> ignored,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_status_should_ignore(
      ignored,
      repo,
      path,
    );
  }

  late final _git_status_should_ignore_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_should_ignore>>(
          'git_status_should_ignore');
  late final _dart_git_status_should_ignore _git_status_should_ignore =
      _git_status_should_ignore_ptr
          .asFunction<_dart_git_status_should_ignore>();

  /// Initialize git_submodule_update_options structure
  ///
  /// Initializes a `git_submodule_update_options` with default values. Equivalent to
  /// creating an instance with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_submodule_update_options` struct to initialize.
  /// @param version The struct version; pass `GIT_SUBMODULE_UPDATE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_submodule_update_options_init(
    ffi.Pointer<git_submodule_update_options> opts,
    int version,
  ) {
    return _git_submodule_update_options_init(
      opts,
      version,
    );
  }

  late final _git_submodule_update_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_update_options_init>>(
          'git_submodule_update_options_init');
  late final _dart_git_submodule_update_options_init
      _git_submodule_update_options_init =
      _git_submodule_update_options_init_ptr
          .asFunction<_dart_git_submodule_update_options_init>();

  /// Update a submodule. This will clone a missing submodule and
  /// checkout the subrepository to the commit specified in the index of
  /// the containing repository. If the submodule repository doesn't contain
  /// the target commit (e.g. because fetchRecurseSubmodules isn't set), then
  /// the submodule is fetched using the fetch options supplied in options.
  ///
  /// @param submodule Submodule object
  /// @param init If the submodule is not initialized, setting this flag to true
  /// will initialize the submodule before updating. Otherwise, this will
  /// return an error if attempting to update an uninitialzed repository.
  /// but setting this to true forces them to be updated.
  /// @param options configuration options for the update.  If NULL, the
  /// function works as though GIT_SUBMODULE_UPDATE_OPTIONS_INIT was passed.
  /// @return 0 on success, any non-zero return value from a callback
  /// function, or a negative value to indicate an error (use
  /// `git_error_last` for a detailed error message).
  int git_submodule_update(
    ffi.Pointer<git_submodule> submodule,
    int init,
    ffi.Pointer<git_submodule_update_options> options,
  ) {
    return _git_submodule_update(
      submodule,
      init,
      options,
    );
  }

  late final _git_submodule_update_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_update>>(
          'git_submodule_update');
  late final _dart_git_submodule_update _git_submodule_update =
      _git_submodule_update_ptr.asFunction<_dart_git_submodule_update>();

  /// Lookup submodule information by name or path.
  ///
  /// Given either the submodule name or path (they are usually the same), this
  /// returns a structure describing the submodule.
  ///
  /// There are two expected error scenarios:
  ///
  /// - The submodule is not mentioned in the HEAD, the index, and the config,
  /// but does "exist" in the working directory (i.e. there is a subdirectory
  /// that appears to be a Git repository).  In this case, this function
  /// returns GIT_EEXISTS to indicate a sub-repository exists but not in a
  /// state where a git_submodule can be instantiated.
  /// - The submodule is not mentioned in the HEAD, index, or config and the
  /// working directory doesn't contain a value git repo at that path.
  /// There may or may not be anything else at that path, but nothing that
  /// looks like a submodule.  In this case, this returns GIT_ENOTFOUND.
  ///
  /// You must call `git_submodule_free` when done with the submodule.
  ///
  /// @param out Output ptr to submodule; pass NULL to just get return code
  /// @param repo The parent repository
  /// @param name The name of or path to the submodule; trailing slashes okay
  /// @return 0 on success, GIT_ENOTFOUND if submodule does not exist,
  /// GIT_EEXISTS if a repository is found in working directory only,
  /// -1 on other errors.
  int git_submodule_lookup(
    ffi.Pointer<ffi.Pointer<git_submodule>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_submodule_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_submodule_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_lookup>>(
          'git_submodule_lookup');
  late final _dart_git_submodule_lookup _git_submodule_lookup =
      _git_submodule_lookup_ptr.asFunction<_dart_git_submodule_lookup>();

  /// Release a submodule
  ///
  /// @param submodule Submodule object
  void git_submodule_free(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_free(
      submodule,
    );
  }

  late final _git_submodule_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_free>>('git_submodule_free');
  late final _dart_git_submodule_free _git_submodule_free =
      _git_submodule_free_ptr.asFunction<_dart_git_submodule_free>();

  /// Iterate over all tracked submodules of a repository.
  ///
  /// See the note on `git_submodule` above.  This iterates over the tracked
  /// submodules as described therein.
  ///
  /// If you are concerned about items in the working directory that look like
  /// submodules but are not tracked, the diff API will generate a diff record
  /// for workdir items that look like submodules but are not tracked, showing
  /// them as added in the workdir.  Also, the status API will treat the entire
  /// subdirectory of a contained git repo as a single GIT_STATUS_WT_NEW item.
  ///
  /// @param repo The repository
  /// @param callback Function to be called with the name of each submodule.
  /// Return a non-zero value to terminate the iteration.
  /// @param payload Extra data to pass to callback
  /// @return 0 on success, -1 on error, or non-zero return value of callback
  int git_submodule_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.NativeFunction<git_submodule_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_submodule_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_submodule_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_foreach>>(
          'git_submodule_foreach');
  late final _dart_git_submodule_foreach _git_submodule_foreach =
      _git_submodule_foreach_ptr.asFunction<_dart_git_submodule_foreach>();

  /// Set up a new git submodule for checkout.
  ///
  /// This does "git submodule add" up to the fetch and checkout of the
  /// submodule contents.  It preps a new submodule, creates an entry in
  /// .gitmodules and creates an empty initialized repository either at the
  /// given path in the working directory or in .git/modules with a gitlink
  /// from the working directory to the new repo.
  ///
  /// To fully emulate "git submodule add" call this function, then open the
  /// submodule repo and perform the clone step as needed (if you don't need
  /// anything custom see `git_submodule_add_clone()`). Lastly, call
  /// `git_submodule_add_finalize()` to wrap up adding the new submodule and
  /// .gitmodules to the index to be ready to commit.
  ///
  /// You must call `git_submodule_free` on the submodule object when done.
  ///
  /// @param out The newly created submodule ready to open for clone
  /// @param repo The repository in which you want to create the submodule
  /// @param url URL for the submodule's remote
  /// @param path Path at which the submodule should be created
  /// @param use_gitlink Should workdir contain a gitlink to the repo in
  /// .git/modules vs. repo directly in workdir.
  /// @return 0 on success, GIT_EEXISTS if submodule already exists,
  /// -1 on other errors.
  int git_submodule_add_setup(
    ffi.Pointer<ffi.Pointer<git_submodule>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Int8> path,
    int use_gitlink,
  ) {
    return _git_submodule_add_setup(
      out,
      repo,
      url,
      path,
      use_gitlink,
    );
  }

  late final _git_submodule_add_setup_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_add_setup>>(
          'git_submodule_add_setup');
  late final _dart_git_submodule_add_setup _git_submodule_add_setup =
      _git_submodule_add_setup_ptr.asFunction<_dart_git_submodule_add_setup>();

  /// Perform the clone step for a newly created submodule.
  ///
  /// This performs the necessary `git_clone` to setup a newly-created submodule.
  ///
  /// @param out The newly created repository object. Optional.
  /// @param submodule The submodule currently waiting for its clone.
  /// @param opts The options to use.
  ///
  /// @return 0 on success, -1 on other errors (see git_clone).
  int git_submodule_clone(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_submodule> submodule,
    ffi.Pointer<git_submodule_update_options> opts,
  ) {
    return _git_submodule_clone(
      out,
      submodule,
      opts,
    );
  }

  late final _git_submodule_clone_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_clone>>(
          'git_submodule_clone');
  late final _dart_git_submodule_clone _git_submodule_clone =
      _git_submodule_clone_ptr.asFunction<_dart_git_submodule_clone>();

  /// Resolve the setup of a new git submodule.
  ///
  /// This should be called on a submodule once you have called add setup
  /// and done the clone of the submodule.  This adds the .gitmodules file
  /// and the newly cloned submodule to the index to be ready to be committed
  /// (but doesn't actually do the commit).
  ///
  /// @param submodule The submodule to finish adding.
  int git_submodule_add_finalize(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_add_finalize(
      submodule,
    );
  }

  late final _git_submodule_add_finalize_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_add_finalize>>(
          'git_submodule_add_finalize');
  late final _dart_git_submodule_add_finalize _git_submodule_add_finalize =
      _git_submodule_add_finalize_ptr
          .asFunction<_dart_git_submodule_add_finalize>();

  /// Add current submodule HEAD commit to index of superproject.
  ///
  /// @param submodule The submodule to add to the index
  /// @param write_index Boolean if this should immediately write the index
  /// file.  If you pass this as false, you will have to get the
  /// git_index and explicitly call `git_index_write()` on it to
  /// save the change.
  /// @return 0 on success, <0 on failure
  int git_submodule_add_to_index(
    ffi.Pointer<git_submodule> submodule,
    int write_index,
  ) {
    return _git_submodule_add_to_index(
      submodule,
      write_index,
    );
  }

  late final _git_submodule_add_to_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_add_to_index>>(
          'git_submodule_add_to_index');
  late final _dart_git_submodule_add_to_index _git_submodule_add_to_index =
      _git_submodule_add_to_index_ptr
          .asFunction<_dart_git_submodule_add_to_index>();

  /// Get the containing repository for a submodule.
  ///
  /// This returns a pointer to the repository that contains the submodule.
  /// This is a just a reference to the repository that was passed to the
  /// original `git_submodule_lookup()` call, so if that repository has been
  /// freed, then this may be a dangling reference.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to `git_repository`
  ffi.Pointer<git_repository> git_submodule_owner(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_owner(
      submodule,
    );
  }

  late final _git_submodule_owner_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_owner>>(
          'git_submodule_owner');
  late final _dart_git_submodule_owner _git_submodule_owner =
      _git_submodule_owner_ptr.asFunction<_dart_git_submodule_owner>();

  /// Get the name of submodule.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule name
  ffi.Pointer<ffi.Int8> git_submodule_name(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_name(
      submodule,
    );
  }

  late final _git_submodule_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_name>>('git_submodule_name');
  late final _dart_git_submodule_name _git_submodule_name =
      _git_submodule_name_ptr.asFunction<_dart_git_submodule_name>();

  /// Get the path to the submodule.
  ///
  /// The path is almost always the same as the submodule name, but the
  /// two are actually not required to match.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule path
  ffi.Pointer<ffi.Int8> git_submodule_path(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_path(
      submodule,
    );
  }

  late final _git_submodule_path_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_path>>('git_submodule_path');
  late final _dart_git_submodule_path _git_submodule_path =
      _git_submodule_path_ptr.asFunction<_dart_git_submodule_path>();

  /// Get the URL for the submodule.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule url
  ffi.Pointer<ffi.Int8> git_submodule_url(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_url(
      submodule,
    );
  }

  late final _git_submodule_url_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_url>>('git_submodule_url');
  late final _dart_git_submodule_url _git_submodule_url =
      _git_submodule_url_ptr.asFunction<_dart_git_submodule_url>();

  /// Resolve a submodule url relative to the given repository.
  ///
  /// @param out buffer to store the absolute submodule url in
  /// @param repo Pointer to repository object
  /// @param url Relative url
  /// @return 0 or an error code
  int git_submodule_resolve_url(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _git_submodule_resolve_url(
      out,
      repo,
      url,
    );
  }

  late final _git_submodule_resolve_url_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_resolve_url>>(
          'git_submodule_resolve_url');
  late final _dart_git_submodule_resolve_url _git_submodule_resolve_url =
      _git_submodule_resolve_url_ptr
          .asFunction<_dart_git_submodule_resolve_url>();

  /// Get the branch for the submodule.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to the submodule branch
  ffi.Pointer<ffi.Int8> git_submodule_branch(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_branch(
      submodule,
    );
  }

  late final _git_submodule_branch_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_branch>>(
          'git_submodule_branch');
  late final _dart_git_submodule_branch _git_submodule_branch =
      _git_submodule_branch_ptr.asFunction<_dart_git_submodule_branch>();

  /// Set the branch for the submodule in the configuration
  ///
  /// After calling this, you may wish to call `git_submodule_sync()` to
  /// write the changes to the checked out submodule repository.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submodule to configure
  /// @param branch Branch that should be used for the submodule
  /// @return 0 on success, <0 on failure
  int git_submodule_set_branch(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> branch,
  ) {
    return _git_submodule_set_branch(
      repo,
      name,
      branch,
    );
  }

  late final _git_submodule_set_branch_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_set_branch>>(
          'git_submodule_set_branch');
  late final _dart_git_submodule_set_branch _git_submodule_set_branch =
      _git_submodule_set_branch_ptr
          .asFunction<_dart_git_submodule_set_branch>();

  /// Set the URL for the submodule in the configuration
  ///
  ///
  /// After calling this, you may wish to call `git_submodule_sync()` to
  /// write the changes to the checked out submodule repository.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submodule to configure
  /// @param url URL that should be used for the submodule
  /// @return 0 on success, <0 on failure
  int git_submodule_set_url(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> url,
  ) {
    return _git_submodule_set_url(
      repo,
      name,
      url,
    );
  }

  late final _git_submodule_set_url_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_set_url>>(
          'git_submodule_set_url');
  late final _dart_git_submodule_set_url _git_submodule_set_url =
      _git_submodule_set_url_ptr.asFunction<_dart_git_submodule_set_url>();

  /// Get the OID for the submodule in the index.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to git_oid or NULL if submodule is not in index.
  ffi.Pointer<git_oid> git_submodule_index_id(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_index_id(
      submodule,
    );
  }

  late final _git_submodule_index_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_index_id>>(
          'git_submodule_index_id');
  late final _dart_git_submodule_index_id _git_submodule_index_id =
      _git_submodule_index_id_ptr.asFunction<_dart_git_submodule_index_id>();

  /// Get the OID for the submodule in the current HEAD tree.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to git_oid or NULL if submodule is not in the HEAD.
  ffi.Pointer<git_oid> git_submodule_head_id(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_head_id(
      submodule,
    );
  }

  late final _git_submodule_head_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_head_id>>(
          'git_submodule_head_id');
  late final _dart_git_submodule_head_id _git_submodule_head_id =
      _git_submodule_head_id_ptr.asFunction<_dart_git_submodule_head_id>();

  /// Get the OID for the submodule in the current working directory.
  ///
  /// This returns the OID that corresponds to looking up 'HEAD' in the checked
  /// out submodule.  If there are pending changes in the index or anything
  /// else, this won't notice that.  You should call `git_submodule_status()`
  /// for a more complete picture about the state of the working directory.
  ///
  /// @param submodule Pointer to submodule object
  /// @return Pointer to git_oid or NULL if submodule is not checked out.
  ffi.Pointer<git_oid> git_submodule_wd_id(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_wd_id(
      submodule,
    );
  }

  late final _git_submodule_wd_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_wd_id>>(
          'git_submodule_wd_id');
  late final _dart_git_submodule_wd_id _git_submodule_wd_id =
      _git_submodule_wd_id_ptr.asFunction<_dart_git_submodule_wd_id>();

  /// Get the ignore rule that will be used for the submodule.
  ///
  /// These values control the behavior of `git_submodule_status()` for this
  /// submodule.  There are four ignore values:
  ///
  /// - **GIT_SUBMODULE_IGNORE_NONE** will consider any change to the contents
  /// of the submodule from a clean checkout to be dirty, including the
  /// addition of untracked files.  This is the default if unspecified.
  /// - **GIT_SUBMODULE_IGNORE_UNTRACKED** examines the contents of the
  /// working tree (i.e. call `git_status_foreach()` on the submodule) but
  /// UNTRACKED files will not count as making the submodule dirty.
  /// - **GIT_SUBMODULE_IGNORE_DIRTY** means to only check if the HEAD of the
  /// submodule has moved for status.  This is fast since it does not need to
  /// scan the working tree of the submodule at all.
  /// - **GIT_SUBMODULE_IGNORE_ALL** means not to open the submodule repo.
  /// The working directory will be consider clean so long as there is a
  /// checked out version present.
  ///
  /// @param submodule The submodule to check
  /// @return The current git_submodule_ignore_t valyue what will be used for
  /// this submodule.
  int git_submodule_ignore(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_ignore(
      submodule,
    );
  }

  late final _git_submodule_ignore_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_ignore>>(
          'git_submodule_ignore');
  late final _dart_git_submodule_ignore _git_submodule_ignore =
      _git_submodule_ignore_ptr.asFunction<_dart_git_submodule_ignore>();

  /// Set the ignore rule for the submodule in the configuration
  ///
  /// This does not affect any currently-loaded instances.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submdule
  /// @param ignore The new value for the ignore rule
  /// @return 0 or an error code
  int git_submodule_set_ignore(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    int ignore,
  ) {
    return _git_submodule_set_ignore(
      repo,
      name,
      ignore,
    );
  }

  late final _git_submodule_set_ignore_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_set_ignore>>(
          'git_submodule_set_ignore');
  late final _dart_git_submodule_set_ignore _git_submodule_set_ignore =
      _git_submodule_set_ignore_ptr
          .asFunction<_dart_git_submodule_set_ignore>();

  /// Get the update rule that will be used for the submodule.
  ///
  /// This value controls the behavior of the `git submodule update` command.
  /// There are four useful values documented with `git_submodule_update_t`.
  ///
  /// @param submodule The submodule to check
  /// @return The current git_submodule_update_t value that will be used
  /// for this submodule.
  int git_submodule_update_strategy(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_update_strategy(
      submodule,
    );
  }

  late final _git_submodule_update_strategy_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_update_strategy>>(
          'git_submodule_update_strategy');
  late final _dart_git_submodule_update_strategy
      _git_submodule_update_strategy = _git_submodule_update_strategy_ptr
          .asFunction<_dart_git_submodule_update_strategy>();

  /// Set the update rule for the submodule in the configuration
  ///
  /// This setting won't affect any existing instances.
  ///
  /// @param repo the repository to affect
  /// @param name the name of the submodule to configure
  /// @param update The new value to use
  /// @return 0 or an error code
  int git_submodule_set_update(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    int update,
  ) {
    return _git_submodule_set_update(
      repo,
      name,
      update,
    );
  }

  late final _git_submodule_set_update_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_set_update>>(
          'git_submodule_set_update');
  late final _dart_git_submodule_set_update _git_submodule_set_update =
      _git_submodule_set_update_ptr
          .asFunction<_dart_git_submodule_set_update>();

  /// Read the fetchRecurseSubmodules rule for a submodule.
  ///
  /// This accesses the submodule.<name>.fetchRecurseSubmodules value for
  /// the submodule that controls fetching behavior for the submodule.
  ///
  /// Note that at this time, libgit2 does not honor this setting and the
  /// fetch functionality current ignores submodules.
  ///
  /// @return 0 if fetchRecurseSubmodules is false, 1 if true
  int git_submodule_fetch_recurse_submodules(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_fetch_recurse_submodules(
      submodule,
    );
  }

  late final _git_submodule_fetch_recurse_submodules_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_fetch_recurse_submodules>>(
          'git_submodule_fetch_recurse_submodules');
  late final _dart_git_submodule_fetch_recurse_submodules
      _git_submodule_fetch_recurse_submodules =
      _git_submodule_fetch_recurse_submodules_ptr
          .asFunction<_dart_git_submodule_fetch_recurse_submodules>();

  /// Set the fetchRecurseSubmodules rule for a submodule in the configuration
  ///
  /// This setting won't affect any existing instances.
  ///
  /// @param repo the repository to affect
  /// @param name the submodule to configure
  /// @param fetch_recurse_submodules Boolean value
  /// @return old value for fetchRecurseSubmodules
  int git_submodule_set_fetch_recurse_submodules(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    int fetch_recurse_submodules,
  ) {
    return _git_submodule_set_fetch_recurse_submodules(
      repo,
      name,
      fetch_recurse_submodules,
    );
  }

  late final _git_submodule_set_fetch_recurse_submodules_ptr = _lookup<
          ffi.NativeFunction<_c_git_submodule_set_fetch_recurse_submodules>>(
      'git_submodule_set_fetch_recurse_submodules');
  late final _dart_git_submodule_set_fetch_recurse_submodules
      _git_submodule_set_fetch_recurse_submodules =
      _git_submodule_set_fetch_recurse_submodules_ptr
          .asFunction<_dart_git_submodule_set_fetch_recurse_submodules>();

  /// Copy submodule info into ".git/config" file.
  ///
  /// Just like "git submodule init", this copies information about the
  /// submodule into ".git/config".  You can use the accessor functions
  /// above to alter the in-memory git_submodule object and control what
  /// is written to the config, overriding what is in .gitmodules.
  ///
  /// @param submodule The submodule to write into the superproject config
  /// @param overwrite By default, existing entries will not be overwritten,
  /// but setting this to true forces them to be updated.
  /// @return 0 on success, <0 on failure.
  int git_submodule_init(
    ffi.Pointer<git_submodule> submodule,
    int overwrite,
  ) {
    return _git_submodule_init(
      submodule,
      overwrite,
    );
  }

  late final _git_submodule_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_init>>('git_submodule_init');
  late final _dart_git_submodule_init _git_submodule_init =
      _git_submodule_init_ptr.asFunction<_dart_git_submodule_init>();

  /// Set up the subrepository for a submodule in preparation for clone.
  ///
  /// This function can be called to init and set up a submodule
  /// repository from a submodule in preparation to clone it from
  /// its remote.
  ///
  /// @param out Output pointer to the created git repository.
  /// @param sm The submodule to create a new subrepository from.
  /// @param use_gitlink Should the workdir contain a gitlink to
  /// the repo in .git/modules vs. repo directly in workdir.
  /// @return 0 on success, <0 on failure.
  int git_submodule_repo_init(
    ffi.Pointer<ffi.Pointer<git_repository>> out,
    ffi.Pointer<git_submodule> sm,
    int use_gitlink,
  ) {
    return _git_submodule_repo_init(
      out,
      sm,
      use_gitlink,
    );
  }

  late final _git_submodule_repo_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_repo_init>>(
          'git_submodule_repo_init');
  late final _dart_git_submodule_repo_init _git_submodule_repo_init =
      _git_submodule_repo_init_ptr.asFunction<_dart_git_submodule_repo_init>();

  /// Copy submodule remote info into submodule repo.
  ///
  /// This copies the information about the submodules URL into the checked out
  /// submodule config, acting like "git submodule sync".  This is useful if
  /// you have altered the URL for the submodule (or it has been altered by a
  /// fetch of upstream changes) and you need to update your local repo.
  int git_submodule_sync(
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_sync(
      submodule,
    );
  }

  late final _git_submodule_sync_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_sync>>('git_submodule_sync');
  late final _dart_git_submodule_sync _git_submodule_sync =
      _git_submodule_sync_ptr.asFunction<_dart_git_submodule_sync>();

  /// Open the repository for a submodule.
  ///
  /// This is a newly opened repository object.  The caller is responsible for
  /// calling `git_repository_free()` on it when done.  Multiple calls to this
  /// function will return distinct `git_repository` objects.  This will only
  /// work if the submodule is checked out into the working directory.
  ///
  /// @param repo Pointer to the submodule repo which was opened
  /// @param submodule Submodule to be opened
  /// @return 0 on success, <0 if submodule repo could not be opened.
  int git_submodule_open(
    ffi.Pointer<ffi.Pointer<git_repository>> repo,
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_open(
      repo,
      submodule,
    );
  }

  late final _git_submodule_open_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_open>>('git_submodule_open');
  late final _dart_git_submodule_open _git_submodule_open =
      _git_submodule_open_ptr.asFunction<_dart_git_submodule_open>();

  /// Reread submodule info from config, index, and HEAD.
  ///
  /// Call this to reread cached submodule information for this submodule if
  /// you have reason to believe that it has changed.
  ///
  /// @param submodule The submodule to reload
  /// @param force Force reload even if the data doesn't seem out of date
  /// @return 0 on success, <0 on error
  int git_submodule_reload(
    ffi.Pointer<git_submodule> submodule,
    int force,
  ) {
    return _git_submodule_reload(
      submodule,
      force,
    );
  }

  late final _git_submodule_reload_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_reload>>(
          'git_submodule_reload');
  late final _dart_git_submodule_reload _git_submodule_reload =
      _git_submodule_reload_ptr.asFunction<_dart_git_submodule_reload>();

  /// Get the status for a submodule.
  ///
  /// This looks at a submodule and tries to determine the status.  It
  /// will return a combination of the `GIT_SUBMODULE_STATUS` values above.
  /// How deeply it examines the working directory to do this will depend
  /// on the `git_submodule_ignore_t` value for the submodule.
  ///
  /// @param status Combination of `GIT_SUBMODULE_STATUS` flags
  /// @param repo the repository in which to look
  /// @param name name of the submodule
  /// @param ignore the ignore rules to follow
  /// @return 0 on success, <0 on error
  int git_submodule_status(
    ffi.Pointer<ffi.Uint32> status,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    int ignore,
  ) {
    return _git_submodule_status(
      status,
      repo,
      name,
      ignore,
    );
  }

  late final _git_submodule_status_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_status>>(
          'git_submodule_status');
  late final _dart_git_submodule_status _git_submodule_status =
      _git_submodule_status_ptr.asFunction<_dart_git_submodule_status>();

  /// Get the locations of submodule information.
  ///
  /// This is a bit like a very lightweight version of `git_submodule_status`.
  /// It just returns a made of the first four submodule status values (i.e.
  /// the ones like GIT_SUBMODULE_STATUS_IN_HEAD, etc) that tell you where the
  /// submodule data comes from (i.e. the HEAD commit, gitmodules file, etc.).
  /// This can be useful if you want to know if the submodule is present in the
  /// working directory at this point in time, etc.
  ///
  /// @param location_status Combination of first four `GIT_SUBMODULE_STATUS` flags
  /// @param submodule Submodule for which to get status
  /// @return 0 on success, <0 on error
  int git_submodule_location(
    ffi.Pointer<ffi.Uint32> location_status,
    ffi.Pointer<git_submodule> submodule,
  ) {
    return _git_submodule_location(
      location_status,
      submodule,
    );
  }

  late final _git_submodule_location_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_location>>(
          'git_submodule_location');
  late final _dart_git_submodule_location _git_submodule_location =
      _git_submodule_location_ptr.asFunction<_dart_git_submodule_location>();

  /// List names of linked working trees
  ///
  /// The returned list should be released with `git_strarray_free`
  /// when no longer needed.
  ///
  /// @param out pointer to the array of working tree names
  /// @param repo the repo to use when listing working trees
  /// @return 0 or an error code
  int git_worktree_list(
    ffi.Pointer<git_strarray> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_worktree_list(
      out,
      repo,
    );
  }

  late final _git_worktree_list_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_list>>('git_worktree_list');
  late final _dart_git_worktree_list _git_worktree_list =
      _git_worktree_list_ptr.asFunction<_dart_git_worktree_list>();

  /// Lookup a working tree by its name for a given repository
  ///
  /// @param out Output pointer to looked up worktree or `NULL`
  /// @param repo The repository containing worktrees
  /// @param name Name of the working tree to look up
  /// @return 0 or an error code
  int git_worktree_lookup(
    ffi.Pointer<ffi.Pointer<git_worktree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_worktree_lookup(
      out,
      repo,
      name,
    );
  }

  late final _git_worktree_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_lookup>>(
          'git_worktree_lookup');
  late final _dart_git_worktree_lookup _git_worktree_lookup =
      _git_worktree_lookup_ptr.asFunction<_dart_git_worktree_lookup>();

  /// Open a worktree of a given repository
  ///
  /// If a repository is not the main tree but a worktree, this
  /// function will look up the worktree inside the parent
  /// repository and create a new `git_worktree` structure.
  ///
  /// @param out Out-pointer for the newly allocated worktree
  /// @param repo Repository to look up worktree for
  int git_worktree_open_from_repository(
    ffi.Pointer<ffi.Pointer<git_worktree>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_worktree_open_from_repository(
      out,
      repo,
    );
  }

  late final _git_worktree_open_from_repository_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_open_from_repository>>(
          'git_worktree_open_from_repository');
  late final _dart_git_worktree_open_from_repository
      _git_worktree_open_from_repository =
      _git_worktree_open_from_repository_ptr
          .asFunction<_dart_git_worktree_open_from_repository>();

  /// Free a previously allocated worktree
  ///
  /// @param wt worktree handle to close. If NULL nothing occurs.
  void git_worktree_free(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_free(
      wt,
    );
  }

  late final _git_worktree_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_free>>('git_worktree_free');
  late final _dart_git_worktree_free _git_worktree_free =
      _git_worktree_free_ptr.asFunction<_dart_git_worktree_free>();

  /// Check if worktree is valid
  ///
  /// A valid worktree requires both the git data structures inside
  /// the linked parent repository and the linked working copy to be
  /// present.
  ///
  /// @param wt Worktree to check
  /// @return 0 when worktree is valid, error-code otherwise
  int git_worktree_validate(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_validate(
      wt,
    );
  }

  late final _git_worktree_validate_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_validate>>(
          'git_worktree_validate');
  late final _dart_git_worktree_validate _git_worktree_validate =
      _git_worktree_validate_ptr.asFunction<_dart_git_worktree_validate>();

  /// Initialize git_worktree_add_options structure
  ///
  /// Initializes a `git_worktree_add_options` with default values. Equivalent to
  /// creating an instance with `GIT_WORKTREE_ADD_OPTIONS_INIT`.
  ///
  /// @param opts The `git_worktree_add_options` struct to initialize.
  /// @param version The struct version; pass `GIT_WORKTREE_ADD_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_worktree_add_options_init(
    ffi.Pointer<git_worktree_add_options> opts,
    int version,
  ) {
    return _git_worktree_add_options_init(
      opts,
      version,
    );
  }

  late final _git_worktree_add_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_add_options_init>>(
          'git_worktree_add_options_init');
  late final _dart_git_worktree_add_options_init
      _git_worktree_add_options_init = _git_worktree_add_options_init_ptr
          .asFunction<_dart_git_worktree_add_options_init>();

  /// Add a new working tree
  ///
  /// Add a new working tree for the repository, that is create the
  /// required data structures inside the repository and check out
  /// the current HEAD at `path`
  ///
  /// @param out Output pointer containing new working tree
  /// @param repo Repository to create working tree for
  /// @param name Name of the working tree
  /// @param path Path to create working tree at
  /// @param opts Options to modify default behavior. May be NULL
  /// @return 0 or an error code
  int git_worktree_add(
    ffi.Pointer<ffi.Pointer<git_worktree>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<git_worktree_add_options> opts,
  ) {
    return _git_worktree_add(
      out,
      repo,
      name,
      path,
      opts,
    );
  }

  late final _git_worktree_add_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_add>>('git_worktree_add');
  late final _dart_git_worktree_add _git_worktree_add =
      _git_worktree_add_ptr.asFunction<_dart_git_worktree_add>();

  /// Lock worktree if not already locked
  ///
  /// Lock a worktree, optionally specifying a reason why the linked
  /// working tree is being locked.
  ///
  /// @param wt Worktree to lock
  /// @param reason Reason why the working tree is being locked
  /// @return 0 on success, non-zero otherwise
  int git_worktree_lock(
    ffi.Pointer<git_worktree> wt,
    ffi.Pointer<ffi.Int8> reason,
  ) {
    return _git_worktree_lock(
      wt,
      reason,
    );
  }

  late final _git_worktree_lock_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_lock>>('git_worktree_lock');
  late final _dart_git_worktree_lock _git_worktree_lock =
      _git_worktree_lock_ptr.asFunction<_dart_git_worktree_lock>();

  /// Unlock a locked worktree
  ///
  /// @param wt Worktree to unlock
  /// @return 0 on success, 1 if worktree was not locked, error-code
  /// otherwise
  int git_worktree_unlock(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_unlock(
      wt,
    );
  }

  late final _git_worktree_unlock_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_unlock>>(
          'git_worktree_unlock');
  late final _dart_git_worktree_unlock _git_worktree_unlock =
      _git_worktree_unlock_ptr.asFunction<_dart_git_worktree_unlock>();

  /// Check if worktree is locked
  ///
  /// A worktree may be locked if the linked working tree is stored
  /// on a portable device which is not available.
  ///
  /// @param reason Buffer to store reason in. If NULL no reason is stored.
  /// @param wt Worktree to check
  /// @return 0 when the working tree not locked, a value greater
  /// than zero if it is locked, less than zero if there was an
  /// error
  int git_worktree_is_locked(
    ffi.Pointer<git_buf> reason,
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_is_locked(
      reason,
      wt,
    );
  }

  late final _git_worktree_is_locked_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_is_locked>>(
          'git_worktree_is_locked');
  late final _dart_git_worktree_is_locked _git_worktree_is_locked =
      _git_worktree_is_locked_ptr.asFunction<_dart_git_worktree_is_locked>();

  /// Retrieve the name of the worktree
  ///
  /// @param wt Worktree to get the name for
  /// @return The worktree's name. The pointer returned is valid for the
  /// lifetime of the git_worktree
  ffi.Pointer<ffi.Int8> git_worktree_name(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_name(
      wt,
    );
  }

  late final _git_worktree_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_name>>('git_worktree_name');
  late final _dart_git_worktree_name _git_worktree_name =
      _git_worktree_name_ptr.asFunction<_dart_git_worktree_name>();

  /// Retrieve the filesystem path for the worktree
  ///
  /// @param wt Worktree to get the path for
  /// @return The worktree's filesystem path. The pointer returned
  /// is valid for the lifetime of the git_worktree.
  ffi.Pointer<ffi.Int8> git_worktree_path(
    ffi.Pointer<git_worktree> wt,
  ) {
    return _git_worktree_path(
      wt,
    );
  }

  late final _git_worktree_path_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_path>>('git_worktree_path');
  late final _dart_git_worktree_path _git_worktree_path =
      _git_worktree_path_ptr.asFunction<_dart_git_worktree_path>();

  /// Initialize git_worktree_prune_options structure
  ///
  /// Initializes a `git_worktree_prune_options` with default values. Equivalent to
  /// creating an instance with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`.
  ///
  /// @param opts The `git_worktree_prune_options` struct to initialize.
  /// @param version The struct version; pass `GIT_WORKTREE_PRUNE_OPTIONS_VERSION`.
  /// @return Zero on success; -1 on failure.
  int git_worktree_prune_options_init(
    ffi.Pointer<git_worktree_prune_options> opts,
    int version,
  ) {
    return _git_worktree_prune_options_init(
      opts,
      version,
    );
  }

  late final _git_worktree_prune_options_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_prune_options_init>>(
          'git_worktree_prune_options_init');
  late final _dart_git_worktree_prune_options_init
      _git_worktree_prune_options_init = _git_worktree_prune_options_init_ptr
          .asFunction<_dart_git_worktree_prune_options_init>();

  /// Is the worktree prunable with the given options?
  ///
  /// A worktree is not prunable in the following scenarios:
  ///
  /// - the worktree is linking to a valid on-disk worktree. The
  /// `valid` member will cause this check to be ignored.
  /// - the worktree is locked. The `locked` flag will cause this
  /// check to be ignored.
  ///
  /// If the worktree is not valid and not locked or if the above
  /// flags have been passed in, this function will return a
  /// positive value.
  int git_worktree_is_prunable(
    ffi.Pointer<git_worktree> wt,
    ffi.Pointer<git_worktree_prune_options> opts,
  ) {
    return _git_worktree_is_prunable(
      wt,
      opts,
    );
  }

  late final _git_worktree_is_prunable_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_is_prunable>>(
          'git_worktree_is_prunable');
  late final _dart_git_worktree_is_prunable _git_worktree_is_prunable =
      _git_worktree_is_prunable_ptr
          .asFunction<_dart_git_worktree_is_prunable>();

  /// Prune working tree
  ///
  /// Prune the working tree, that is remove the git data
  /// structures on disk. The repository will only be pruned of
  /// `git_worktree_is_prunable` succeeds.
  ///
  /// @param wt Worktree to prune
  /// @param opts Specifies which checks to override. See
  /// `git_worktree_is_prunable`. May be NULL
  /// @return 0 or an error code
  int git_worktree_prune(
    ffi.Pointer<git_worktree> wt,
    ffi.Pointer<git_worktree_prune_options> opts,
  ) {
    return _git_worktree_prune(
      wt,
      opts,
    );
  }

  late final _git_worktree_prune_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_prune>>('git_worktree_prune');
  late final _dart_git_worktree_prune _git_worktree_prune =
      _git_worktree_prune_ptr.asFunction<_dart_git_worktree_prune>();

  /// Stock callback usable as a git_credential_acquire_cb.  This calls
  /// git_cred_userpass_plaintext_new unless the protocol has not specified
  /// `GIT_CREDENTIAL_USERPASS_PLAINTEXT` as an allowed type.
  ///
  /// @param out The newly created credential object.
  /// @param url The resource for which we are demanding a credential.
  /// @param user_from_url The username that was embedded in a "user\@host"
  /// remote url, or NULL if not included.
  /// @param allowed_types A bitmask stating which credential types are OK to return.
  /// @param payload The payload provided when specifying this callback.  (This is
  /// interpreted as a `git_credential_userpass_payload*`.)
  int git_credential_userpass(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Int8> user_from_url,
    int allowed_types,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_credential_userpass(
      out,
      url,
      user_from_url,
      allowed_types,
      payload,
    );
  }

  late final _git_credential_userpass_ptr =
      _lookup<ffi.NativeFunction<_c_git_credential_userpass>>(
          'git_credential_userpass');
  late final _dart_git_credential_userpass _git_credential_userpass =
      _git_credential_userpass_ptr.asFunction<_dart_git_credential_userpass>();

  /// @name Deprecated Blob Functions
  ///
  /// These functions are retained for backward compatibility.  The newer
  /// versions of these functions should be preferred in all new code.
  ///
  /// There is no plan to remove these backward compatibility values at
  /// this time.
  /// /
  /// /**@{
  int git_blob_create_fromworkdir(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> relative_path,
  ) {
    return _git_blob_create_fromworkdir(
      id,
      repo,
      relative_path,
    );
  }

  late final _git_blob_create_fromworkdir_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_fromworkdir>>(
          'git_blob_create_fromworkdir');
  late final _dart_git_blob_create_fromworkdir _git_blob_create_fromworkdir =
      _git_blob_create_fromworkdir_ptr
          .asFunction<_dart_git_blob_create_fromworkdir>();

  int git_blob_create_fromdisk(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_blob_create_fromdisk(
      id,
      repo,
      path,
    );
  }

  late final _git_blob_create_fromdisk_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_fromdisk>>(
          'git_blob_create_fromdisk');
  late final _dart_git_blob_create_fromdisk _git_blob_create_fromdisk =
      _git_blob_create_fromdisk_ptr
          .asFunction<_dart_git_blob_create_fromdisk>();

  int git_blob_create_fromstream(
    ffi.Pointer<ffi.Pointer<git_writestream>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> hintpath,
  ) {
    return _git_blob_create_fromstream(
      out,
      repo,
      hintpath,
    );
  }

  late final _git_blob_create_fromstream_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_fromstream>>(
          'git_blob_create_fromstream');
  late final _dart_git_blob_create_fromstream _git_blob_create_fromstream =
      _git_blob_create_fromstream_ptr
          .asFunction<_dart_git_blob_create_fromstream>();

  int git_blob_create_fromstream_commit(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_writestream> stream,
  ) {
    return _git_blob_create_fromstream_commit(
      out,
      stream,
    );
  }

  late final _git_blob_create_fromstream_commit_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_fromstream_commit>>(
          'git_blob_create_fromstream_commit');
  late final _dart_git_blob_create_fromstream_commit
      _git_blob_create_fromstream_commit =
      _git_blob_create_fromstream_commit_ptr
          .asFunction<_dart_git_blob_create_fromstream_commit>();

  int git_blob_create_frombuffer(
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_blob_create_frombuffer(
      id,
      repo,
      buffer,
      len,
    );
  }

  late final _git_blob_create_frombuffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_create_frombuffer>>(
          'git_blob_create_frombuffer');
  late final _dart_git_blob_create_frombuffer _git_blob_create_frombuffer =
      _git_blob_create_frombuffer_ptr
          .asFunction<_dart_git_blob_create_frombuffer>();

  /// Deprecated in favor of `git_blob_filter`.
  ///
  /// @deprecated Use git_blob_filter
  /// @see git_blob_filter
  int git_blob_filtered_content(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Int8> as_path,
    int check_for_binary_data,
  ) {
    return _git_blob_filtered_content(
      out,
      blob,
      as_path,
      check_for_binary_data,
    );
  }

  late final _git_blob_filtered_content_ptr =
      _lookup<ffi.NativeFunction<_c_git_blob_filtered_content>>(
          'git_blob_filtered_content');
  late final _dart_git_blob_filtered_content _git_blob_filtered_content =
      _git_blob_filtered_content_ptr
          .asFunction<_dart_git_blob_filtered_content>();

  /// Free the memory referred to by the git_buf.  This is an alias of
  /// `git_buf_dispose` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_buf_dispose
  /// @see git_buf_dispose
  void git_buf_free(
    ffi.Pointer<git_buf> buffer,
  ) {
    return _git_buf_free(
      buffer,
    );
  }

  late final _git_buf_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_buf_free>>('git_buf_free');
  late final _dart_git_buf_free _git_buf_free =
      _git_buf_free_ptr.asFunction<_dart_git_buf_free>();

  /// Return the last `git_error` object that was generated for the
  /// current thread.  This is an alias of `git_error_last` and is
  /// preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_error_last
  /// @see git_error_last
  ffi.Pointer<git_error> giterr_last() {
    return _giterr_last();
  }

  late final _giterr_last_ptr =
      _lookup<ffi.NativeFunction<_c_giterr_last>>('giterr_last');
  late final _dart_giterr_last _giterr_last =
      _giterr_last_ptr.asFunction<_dart_giterr_last>();

  /// Clear the last error.  This is an alias of `git_error_last` and is
  /// preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_error_clear
  /// @see git_error_clear
  void giterr_clear() {
    return _giterr_clear();
  }

  late final _giterr_clear_ptr =
      _lookup<ffi.NativeFunction<_c_giterr_clear>>('giterr_clear');
  late final _dart_giterr_clear _giterr_clear =
      _giterr_clear_ptr.asFunction<_dart_giterr_clear>();

  /// Sets the error message to the given string.  This is an alias of
  /// `git_error_set_str` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_error_set_str
  /// @see git_error_set_str
  void giterr_set_str(
    int error_class,
    ffi.Pointer<ffi.Int8> string,
  ) {
    return _giterr_set_str(
      error_class,
      string,
    );
  }

  late final _giterr_set_str_ptr =
      _lookup<ffi.NativeFunction<_c_giterr_set_str>>('giterr_set_str');
  late final _dart_giterr_set_str _giterr_set_str =
      _giterr_set_str_ptr.asFunction<_dart_giterr_set_str>();

  /// Indicates that an out-of-memory situation occurred.  This is an alias
  /// of `git_error_set_oom` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_error_set_oom
  /// @see git_error_set_oom
  void giterr_set_oom() {
    return _giterr_set_oom();
  }

  late final _giterr_set_oom_ptr =
      _lookup<ffi.NativeFunction<_c_giterr_set_oom>>('giterr_set_oom');
  late final _dart_giterr_set_oom _giterr_set_oom =
      _giterr_set_oom_ptr.asFunction<_dart_giterr_set_oom>();

  int git_index_add_frombuffer(
    ffi.Pointer<git_index> index,
    ffi.Pointer<git_index_entry> entry,
    ffi.Pointer<ffi.Void> buffer,
    int len,
  ) {
    return _git_index_add_frombuffer(
      index,
      entry,
      buffer,
      len,
    );
  }

  late final _git_index_add_frombuffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_index_add_frombuffer>>(
          'git_index_add_frombuffer');
  late final _dart_git_index_add_frombuffer _git_index_add_frombuffer =
      _git_index_add_frombuffer_ptr
          .asFunction<_dart_git_index_add_frombuffer>();

  /// Get the size in bytes for the structure which
  /// acts as an in-memory representation of any given
  /// object type.
  ///
  /// For all the core types, this would the equivalent
  /// of calling `sizeof(git_commit)` if the core types
  /// were not opaque on the external API.
  ///
  /// @param type object type to get its size
  /// @return size in bytes of the object
  int git_object__size(
    int type,
  ) {
    return _git_object__size(
      type,
    );
  }

  late final _git_object__size_ptr =
      _lookup<ffi.NativeFunction<_c_git_object__size>>('git_object__size');
  late final _dart_git_object__size _git_object__size =
      _git_object__size_ptr.asFunction<_dart_git_object__size>();

  int git_tag_create_frombuffer(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> buffer,
    int force,
  ) {
    return _git_tag_create_frombuffer(
      oid,
      repo,
      buffer,
      force,
    );
  }

  late final _git_tag_create_frombuffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_create_frombuffer>>(
          'git_tag_create_frombuffer');
  late final _dart_git_tag_create_frombuffer _git_tag_create_frombuffer =
      _git_tag_create_frombuffer_ptr
          .asFunction<_dart_git_tag_create_frombuffer>();

  void git_cred_free(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_cred_free(
      cred,
    );
  }

  late final _git_cred_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_free>>('git_cred_free');
  late final _dart_git_cred_free _git_cred_free =
      _git_cred_free_ptr.asFunction<_dart_git_cred_free>();

  int git_cred_has_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_cred_has_username(
      cred,
    );
  }

  late final _git_cred_has_username_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_has_username>>(
          'git_cred_has_username');
  late final _dart_git_cred_has_username _git_cred_has_username =
      _git_cred_has_username_ptr.asFunction<_dart_git_cred_has_username>();

  ffi.Pointer<ffi.Int8> git_cred_get_username(
    ffi.Pointer<git_credential> cred,
  ) {
    return _git_cred_get_username(
      cred,
    );
  }

  late final _git_cred_get_username_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_get_username>>(
          'git_cred_get_username');
  late final _dart_git_cred_get_username _git_cred_get_username =
      _git_cred_get_username_ptr.asFunction<_dart_git_cred_get_username>();

  int git_cred_userpass_plaintext_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> password,
  ) {
    return _git_cred_userpass_plaintext_new(
      out,
      username,
      password,
    );
  }

  late final _git_cred_userpass_plaintext_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_userpass_plaintext_new>>(
          'git_cred_userpass_plaintext_new');
  late final _dart_git_cred_userpass_plaintext_new
      _git_cred_userpass_plaintext_new = _git_cred_userpass_plaintext_new_ptr
          .asFunction<_dart_git_cred_userpass_plaintext_new>();

  int git_cred_default_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
  ) {
    return _git_cred_default_new(
      out,
    );
  }

  late final _git_cred_default_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_default_new>>(
          'git_cred_default_new');
  late final _dart_git_cred_default_new _git_cred_default_new =
      _git_cred_default_new_ptr.asFunction<_dart_git_cred_default_new>();

  int git_cred_username_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
  ) {
    return _git_cred_username_new(
      out,
      username,
    );
  }

  late final _git_cred_username_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_username_new>>(
          'git_cred_username_new');
  late final _dart_git_cred_username_new _git_cred_username_new =
      _git_cred_username_new_ptr.asFunction<_dart_git_cred_username_new>();

  int git_cred_ssh_key_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> publickey,
    ffi.Pointer<ffi.Int8> privatekey,
    ffi.Pointer<ffi.Int8> passphrase,
  ) {
    return _git_cred_ssh_key_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_cred_ssh_key_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_ssh_key_new>>(
          'git_cred_ssh_key_new');
  late final _dart_git_cred_ssh_key_new _git_cred_ssh_key_new =
      _git_cred_ssh_key_new_ptr.asFunction<_dart_git_cred_ssh_key_new>();

  int git_cred_ssh_key_memory_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> publickey,
    ffi.Pointer<ffi.Int8> privatekey,
    ffi.Pointer<ffi.Int8> passphrase,
  ) {
    return _git_cred_ssh_key_memory_new(
      out,
      username,
      publickey,
      privatekey,
      passphrase,
    );
  }

  late final _git_cred_ssh_key_memory_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_ssh_key_memory_new>>(
          'git_cred_ssh_key_memory_new');
  late final _dart_git_cred_ssh_key_memory_new _git_cred_ssh_key_memory_new =
      _git_cred_ssh_key_memory_new_ptr
          .asFunction<_dart_git_cred_ssh_key_memory_new>();

  int git_cred_ssh_interactive_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.NativeFunction<git_credential_ssh_interactive_cb>>
        prompt_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_cred_ssh_interactive_new(
      out,
      username,
      prompt_callback,
      payload,
    );
  }

  late final _git_cred_ssh_interactive_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_ssh_interactive_new>>(
          'git_cred_ssh_interactive_new');
  late final _dart_git_cred_ssh_interactive_new _git_cred_ssh_interactive_new =
      _git_cred_ssh_interactive_new_ptr
          .asFunction<_dart_git_cred_ssh_interactive_new>();

  int git_cred_ssh_key_from_agent(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
  ) {
    return _git_cred_ssh_key_from_agent(
      out,
      username,
    );
  }

  late final _git_cred_ssh_key_from_agent_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_ssh_key_from_agent>>(
          'git_cred_ssh_key_from_agent');
  late final _dart_git_cred_ssh_key_from_agent _git_cred_ssh_key_from_agent =
      _git_cred_ssh_key_from_agent_ptr
          .asFunction<_dart_git_cred_ssh_key_from_agent>();

  int git_cred_ssh_custom_new(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> username,
    ffi.Pointer<ffi.Int8> publickey,
    int publickey_len,
    ffi.Pointer<ffi.NativeFunction<git_credential_sign_cb>> sign_callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_cred_ssh_custom_new(
      out,
      username,
      publickey,
      publickey_len,
      sign_callback,
      payload,
    );
  }

  late final _git_cred_ssh_custom_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_ssh_custom_new>>(
          'git_cred_ssh_custom_new');
  late final _dart_git_cred_ssh_custom_new _git_cred_ssh_custom_new =
      _git_cred_ssh_custom_new_ptr.asFunction<_dart_git_cred_ssh_custom_new>();

  int git_cred_userpass(
    ffi.Pointer<ffi.Pointer<git_credential>> out,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Int8> user_from_url,
    int allowed_types,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_cred_userpass(
      out,
      url,
      user_from_url,
      allowed_types,
      payload,
    );
  }

  late final _git_cred_userpass_ptr =
      _lookup<ffi.NativeFunction<_c_git_cred_userpass>>('git_cred_userpass');
  late final _dart_git_cred_userpass _git_cred_userpass =
      _git_cred_userpass_ptr.asFunction<_dart_git_cred_userpass>();

  /// @name Deprecated Object ID Types
  ///
  /// These types are retained for backward compatibility.  The newer
  /// versions of these values should be preferred in all new code.
  ///
  /// There is no plan to remove these backward compatibility values at
  /// this time.
  /// /
  /// /**@{
  int git_oid_iszero(
    ffi.Pointer<git_oid> id,
  ) {
    return _git_oid_iszero(
      id,
    );
  }

  late final _git_oid_iszero_ptr =
      _lookup<ffi.NativeFunction<_c_git_oid_iszero>>('git_oid_iszero');
  late final _dart_git_oid_iszero _git_oid_iszero =
      _git_oid_iszero_ptr.asFunction<_dart_git_oid_iszero>();

  /// Free the memory referred to by the git_strarray.  This is an alias of
  /// `git_strarray_dispose` and is preserved for backward compatibility.
  ///
  /// This function is deprecated, but there is no plan to remove this
  /// function at this time.
  ///
  /// @deprecated Use git_strarray_dispose
  /// @see git_strarray_dispose
  void git_strarray_free(
    ffi.Pointer<git_strarray> array,
  ) {
    return _git_strarray_free(
      array,
    );
  }

  late final _git_strarray_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_strarray_free>>('git_strarray_free');
  late final _dart_git_strarray_free _git_strarray_free =
      _git_strarray_free_ptr.asFunction<_dart_git_strarray_free>();

  /// @name Deprecated Options Initialization Functions
  ///
  /// These functions are retained for backward compatibility.  The newer
  /// versions of these functions should be preferred in all new code.
  ///
  /// There is no plan to remove these backward compatibility functions at
  /// this time.
  /// /
  /// /**@{
  int git_blame_init_options(
    ffi.Pointer<git_blame_options> opts,
    int version,
  ) {
    return _git_blame_init_options(
      opts,
      version,
    );
  }

  late final _git_blame_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_blame_init_options>>(
          'git_blame_init_options');
  late final _dart_git_blame_init_options _git_blame_init_options =
      _git_blame_init_options_ptr.asFunction<_dart_git_blame_init_options>();

  int git_checkout_init_options(
    ffi.Pointer<git_checkout_options> opts,
    int version,
  ) {
    return _git_checkout_init_options(
      opts,
      version,
    );
  }

  late final _git_checkout_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_checkout_init_options>>(
          'git_checkout_init_options');
  late final _dart_git_checkout_init_options _git_checkout_init_options =
      _git_checkout_init_options_ptr
          .asFunction<_dart_git_checkout_init_options>();

  int git_cherrypick_init_options(
    ffi.Pointer<git_cherrypick_options> opts,
    int version,
  ) {
    return _git_cherrypick_init_options(
      opts,
      version,
    );
  }

  late final _git_cherrypick_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_cherrypick_init_options>>(
          'git_cherrypick_init_options');
  late final _dart_git_cherrypick_init_options _git_cherrypick_init_options =
      _git_cherrypick_init_options_ptr
          .asFunction<_dart_git_cherrypick_init_options>();

  int git_clone_init_options(
    ffi.Pointer<git_clone_options> opts,
    int version,
  ) {
    return _git_clone_init_options(
      opts,
      version,
    );
  }

  late final _git_clone_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_clone_init_options>>(
          'git_clone_init_options');
  late final _dart_git_clone_init_options _git_clone_init_options =
      _git_clone_init_options_ptr.asFunction<_dart_git_clone_init_options>();

  int git_describe_init_options(
    ffi.Pointer<git_describe_options> opts,
    int version,
  ) {
    return _git_describe_init_options(
      opts,
      version,
    );
  }

  late final _git_describe_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_describe_init_options>>(
          'git_describe_init_options');
  late final _dart_git_describe_init_options _git_describe_init_options =
      _git_describe_init_options_ptr
          .asFunction<_dart_git_describe_init_options>();

  int git_describe_init_format_options(
    ffi.Pointer<git_describe_format_options> opts,
    int version,
  ) {
    return _git_describe_init_format_options(
      opts,
      version,
    );
  }

  late final _git_describe_init_format_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_describe_init_format_options>>(
          'git_describe_init_format_options');
  late final _dart_git_describe_init_format_options
      _git_describe_init_format_options = _git_describe_init_format_options_ptr
          .asFunction<_dart_git_describe_init_format_options>();

  int git_diff_init_options(
    ffi.Pointer<git_diff_options> opts,
    int version,
  ) {
    return _git_diff_init_options(
      opts,
      version,
    );
  }

  late final _git_diff_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_init_options>>(
          'git_diff_init_options');
  late final _dart_git_diff_init_options _git_diff_init_options =
      _git_diff_init_options_ptr.asFunction<_dart_git_diff_init_options>();

  int git_diff_find_init_options(
    ffi.Pointer<git_diff_find_options> opts,
    int version,
  ) {
    return _git_diff_find_init_options(
      opts,
      version,
    );
  }

  late final _git_diff_find_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_find_init_options>>(
          'git_diff_find_init_options');
  late final _dart_git_diff_find_init_options _git_diff_find_init_options =
      _git_diff_find_init_options_ptr
          .asFunction<_dart_git_diff_find_init_options>();

  int git_diff_format_email_init_options(
    ffi.Pointer<git_diff_format_email_options> opts,
    int version,
  ) {
    return _git_diff_format_email_init_options(
      opts,
      version,
    );
  }

  late final _git_diff_format_email_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_format_email_init_options>>(
          'git_diff_format_email_init_options');
  late final _dart_git_diff_format_email_init_options
      _git_diff_format_email_init_options =
      _git_diff_format_email_init_options_ptr
          .asFunction<_dart_git_diff_format_email_init_options>();

  int git_diff_patchid_init_options(
    ffi.Pointer<git_diff_patchid_options> opts,
    int version,
  ) {
    return _git_diff_patchid_init_options(
      opts,
      version,
    );
  }

  late final _git_diff_patchid_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_diff_patchid_init_options>>(
          'git_diff_patchid_init_options');
  late final _dart_git_diff_patchid_init_options
      _git_diff_patchid_init_options = _git_diff_patchid_init_options_ptr
          .asFunction<_dart_git_diff_patchid_init_options>();

  int git_fetch_init_options(
    ffi.Pointer<git_fetch_options> opts,
    int version,
  ) {
    return _git_fetch_init_options(
      opts,
      version,
    );
  }

  late final _git_fetch_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_fetch_init_options>>(
          'git_fetch_init_options');
  late final _dart_git_fetch_init_options _git_fetch_init_options =
      _git_fetch_init_options_ptr.asFunction<_dart_git_fetch_init_options>();

  int git_indexer_init_options(
    ffi.Pointer<git_indexer_options> opts,
    int version,
  ) {
    return _git_indexer_init_options(
      opts,
      version,
    );
  }

  late final _git_indexer_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_indexer_init_options>>(
          'git_indexer_init_options');
  late final _dart_git_indexer_init_options _git_indexer_init_options =
      _git_indexer_init_options_ptr
          .asFunction<_dart_git_indexer_init_options>();

  int git_merge_init_options(
    ffi.Pointer<git_merge_options> opts,
    int version,
  ) {
    return _git_merge_init_options(
      opts,
      version,
    );
  }

  late final _git_merge_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_init_options>>(
          'git_merge_init_options');
  late final _dart_git_merge_init_options _git_merge_init_options =
      _git_merge_init_options_ptr.asFunction<_dart_git_merge_init_options>();

  int git_merge_file_init_input(
    ffi.Pointer<git_merge_file_input> input,
    int version,
  ) {
    return _git_merge_file_init_input(
      input,
      version,
    );
  }

  late final _git_merge_file_init_input_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_file_init_input>>(
          'git_merge_file_init_input');
  late final _dart_git_merge_file_init_input _git_merge_file_init_input =
      _git_merge_file_init_input_ptr
          .asFunction<_dart_git_merge_file_init_input>();

  int git_merge_file_init_options(
    ffi.Pointer<git_merge_file_options> opts,
    int version,
  ) {
    return _git_merge_file_init_options(
      opts,
      version,
    );
  }

  late final _git_merge_file_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_merge_file_init_options>>(
          'git_merge_file_init_options');
  late final _dart_git_merge_file_init_options _git_merge_file_init_options =
      _git_merge_file_init_options_ptr
          .asFunction<_dart_git_merge_file_init_options>();

  int git_proxy_init_options(
    ffi.Pointer<git_proxy_options> opts,
    int version,
  ) {
    return _git_proxy_init_options(
      opts,
      version,
    );
  }

  late final _git_proxy_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_proxy_init_options>>(
          'git_proxy_init_options');
  late final _dart_git_proxy_init_options _git_proxy_init_options =
      _git_proxy_init_options_ptr.asFunction<_dart_git_proxy_init_options>();

  int git_push_init_options(
    ffi.Pointer<git_push_options> opts,
    int version,
  ) {
    return _git_push_init_options(
      opts,
      version,
    );
  }

  late final _git_push_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_push_init_options>>(
          'git_push_init_options');
  late final _dart_git_push_init_options _git_push_init_options =
      _git_push_init_options_ptr.asFunction<_dart_git_push_init_options>();

  int git_rebase_init_options(
    ffi.Pointer<git_rebase_options> opts,
    int version,
  ) {
    return _git_rebase_init_options(
      opts,
      version,
    );
  }

  late final _git_rebase_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_rebase_init_options>>(
          'git_rebase_init_options');
  late final _dart_git_rebase_init_options _git_rebase_init_options =
      _git_rebase_init_options_ptr.asFunction<_dart_git_rebase_init_options>();

  int git_remote_create_init_options(
    ffi.Pointer<git_remote_create_options> opts,
    int version,
  ) {
    return _git_remote_create_init_options(
      opts,
      version,
    );
  }

  late final _git_remote_create_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_remote_create_init_options>>(
          'git_remote_create_init_options');
  late final _dart_git_remote_create_init_options
      _git_remote_create_init_options = _git_remote_create_init_options_ptr
          .asFunction<_dart_git_remote_create_init_options>();

  int git_repository_init_init_options(
    ffi.Pointer<git_repository_init_options> opts,
    int version,
  ) {
    return _git_repository_init_init_options(
      opts,
      version,
    );
  }

  late final _git_repository_init_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_repository_init_init_options>>(
          'git_repository_init_init_options');
  late final _dart_git_repository_init_init_options
      _git_repository_init_init_options = _git_repository_init_init_options_ptr
          .asFunction<_dart_git_repository_init_init_options>();

  int git_revert_init_options(
    ffi.Pointer<git_revert_options> opts,
    int version,
  ) {
    return _git_revert_init_options(
      opts,
      version,
    );
  }

  late final _git_revert_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_revert_init_options>>(
          'git_revert_init_options');
  late final _dart_git_revert_init_options _git_revert_init_options =
      _git_revert_init_options_ptr.asFunction<_dart_git_revert_init_options>();

  int git_stash_apply_init_options(
    ffi.Pointer<git_stash_apply_options> opts,
    int version,
  ) {
    return _git_stash_apply_init_options(
      opts,
      version,
    );
  }

  late final _git_stash_apply_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_stash_apply_init_options>>(
          'git_stash_apply_init_options');
  late final _dart_git_stash_apply_init_options _git_stash_apply_init_options =
      _git_stash_apply_init_options_ptr
          .asFunction<_dart_git_stash_apply_init_options>();

  int git_status_init_options(
    ffi.Pointer<git_status_options> opts,
    int version,
  ) {
    return _git_status_init_options(
      opts,
      version,
    );
  }

  late final _git_status_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_status_init_options>>(
          'git_status_init_options');
  late final _dart_git_status_init_options _git_status_init_options =
      _git_status_init_options_ptr.asFunction<_dart_git_status_init_options>();

  int git_submodule_update_init_options(
    ffi.Pointer<git_submodule_update_options> opts,
    int version,
  ) {
    return _git_submodule_update_init_options(
      opts,
      version,
    );
  }

  late final _git_submodule_update_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_submodule_update_init_options>>(
          'git_submodule_update_init_options');
  late final _dart_git_submodule_update_init_options
      _git_submodule_update_init_options =
      _git_submodule_update_init_options_ptr
          .asFunction<_dart_git_submodule_update_init_options>();

  int git_worktree_add_init_options(
    ffi.Pointer<git_worktree_add_options> opts,
    int version,
  ) {
    return _git_worktree_add_init_options(
      opts,
      version,
    );
  }

  late final _git_worktree_add_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_add_init_options>>(
          'git_worktree_add_init_options');
  late final _dart_git_worktree_add_init_options
      _git_worktree_add_init_options = _git_worktree_add_init_options_ptr
          .asFunction<_dart_git_worktree_add_init_options>();

  int git_worktree_prune_init_options(
    ffi.Pointer<git_worktree_prune_options> opts,
    int version,
  ) {
    return _git_worktree_prune_init_options(
      opts,
      version,
    );
  }

  late final _git_worktree_prune_init_options_ptr =
      _lookup<ffi.NativeFunction<_c_git_worktree_prune_init_options>>(
          'git_worktree_prune_init_options');
  late final _dart_git_worktree_prune_init_options
      _git_worktree_prune_init_options = _git_worktree_prune_init_options_ptr
          .asFunction<_dart_git_worktree_prune_init_options>();

  /// Load the filter list for a given path.
  ///
  /// This will return 0 (success) but set the output git_filter_list to NULL
  /// if no filters are requested for the given file.
  ///
  /// @param filters Output newly created git_filter_list (or NULL)
  /// @param repo Repository object that contains `path`
  /// @param blob The blob to which the filter will be applied (if known)
  /// @param path Relative path of the file to be filtered
  /// @param mode Filtering direction (WT->ODB or ODB->WT)
  /// @param flags Combination of `git_filter_flag_t` flags
  /// @return 0 on success (which could still return NULL if no filters are
  /// needed for the requested file), <0 on error
  int git_filter_list_load(
    ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<ffi.Int8> path,
    int mode,
    int flags,
  ) {
    return _git_filter_list_load(
      filters,
      repo,
      blob,
      path,
      mode,
      flags,
    );
  }

  late final _git_filter_list_load_ptr =
      _lookup<ffi.NativeFunction<_c_git_filter_list_load>>(
          'git_filter_list_load');
  late final _dart_git_filter_list_load _git_filter_list_load =
      _git_filter_list_load_ptr.asFunction<_dart_git_filter_list_load>();

  /// Query the filter list to see if a given filter (by name) will run.
  /// The built-in filters "crlf" and "ident" can be queried, otherwise this
  /// is the name of the filter specified by the filter attribute.
  ///
  /// This will return 0 if the given filter is not in the list, or 1 if
  /// the filter will be applied.
  ///
  /// @param filters A loaded git_filter_list (or NULL)
  /// @param name The name of the filter to query
  /// @return 1 if the filter is in the list, 0 otherwise
  int git_filter_list_contains(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_filter_list_contains(
      filters,
      name,
    );
  }

  late final _git_filter_list_contains_ptr =
      _lookup<ffi.NativeFunction<_c_git_filter_list_contains>>(
          'git_filter_list_contains');
  late final _dart_git_filter_list_contains _git_filter_list_contains =
      _git_filter_list_contains_ptr
          .asFunction<_dart_git_filter_list_contains>();

  /// Apply filter list to a data buffer.
  ///
  /// See `git2/buffer.h` for background on `git_buf` objects.
  ///
  /// If the `in` buffer holds data allocated by libgit2 (i.e. `in->asize` is
  /// not zero), then it will be overwritten when applying the filters.  If
  /// not, then it will be left untouched.
  ///
  /// If there are no filters to apply (or `filters` is NULL), then the `out`
  /// buffer will reference the `in` buffer data (with `asize` set to zero)
  /// instead of allocating data.  This keeps allocations to a minimum, but
  /// it means you have to be careful about freeing the `in` data since `out`
  /// may be pointing to it!
  ///
  /// @param out Buffer to store the result of the filtering
  /// @param filters A loaded git_filter_list (or NULL)
  /// @param in Buffer containing the data to filter
  /// @return 0 on success, an error code otherwise
  int git_filter_list_apply_to_data(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_buf> in_1,
  ) {
    return _git_filter_list_apply_to_data(
      out,
      filters,
      in_1,
    );
  }

  late final _git_filter_list_apply_to_data_ptr =
      _lookup<ffi.NativeFunction<_c_git_filter_list_apply_to_data>>(
          'git_filter_list_apply_to_data');
  late final _dart_git_filter_list_apply_to_data
      _git_filter_list_apply_to_data = _git_filter_list_apply_to_data_ptr
          .asFunction<_dart_git_filter_list_apply_to_data>();

  /// Apply a filter list to the contents of a file on disk
  ///
  /// @param out buffer into which to store the filtered file
  /// @param filters the list of filters to apply
  /// @param repo the repository in which to perform the filtering
  /// @param path the path of the file to filter, a relative path will be
  /// taken as relative to the workdir
  int git_filter_list_apply_to_file(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_filter_list_apply_to_file(
      out,
      filters,
      repo,
      path,
    );
  }

  late final _git_filter_list_apply_to_file_ptr =
      _lookup<ffi.NativeFunction<_c_git_filter_list_apply_to_file>>(
          'git_filter_list_apply_to_file');
  late final _dart_git_filter_list_apply_to_file
      _git_filter_list_apply_to_file = _git_filter_list_apply_to_file_ptr
          .asFunction<_dart_git_filter_list_apply_to_file>();

  /// Apply a filter list to the contents of a blob
  ///
  /// @param out buffer into which to store the filtered file
  /// @param filters the list of filters to apply
  /// @param blob the blob to filter
  int git_filter_list_apply_to_blob(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_blob> blob,
  ) {
    return _git_filter_list_apply_to_blob(
      out,
      filters,
      blob,
    );
  }

  late final _git_filter_list_apply_to_blob_ptr =
      _lookup<ffi.NativeFunction<_c_git_filter_list_apply_to_blob>>(
          'git_filter_list_apply_to_blob');
  late final _dart_git_filter_list_apply_to_blob
      _git_filter_list_apply_to_blob = _git_filter_list_apply_to_blob_ptr
          .asFunction<_dart_git_filter_list_apply_to_blob>();

  /// Apply a filter list to an arbitrary buffer as a stream
  ///
  /// @param filters the list of filters to apply
  /// @param data the buffer to filter
  /// @param target the stream into which the data will be written
  int git_filter_list_stream_data(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_buf> data,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_data(
      filters,
      data,
      target,
    );
  }

  late final _git_filter_list_stream_data_ptr =
      _lookup<ffi.NativeFunction<_c_git_filter_list_stream_data>>(
          'git_filter_list_stream_data');
  late final _dart_git_filter_list_stream_data _git_filter_list_stream_data =
      _git_filter_list_stream_data_ptr
          .asFunction<_dart_git_filter_list_stream_data>();

  /// Apply a filter list to a file as a stream
  ///
  /// @param filters the list of filters to apply
  /// @param repo the repository in which to perform the filtering
  /// @param path the path of the file to filter, a relative path will be
  /// taken as relative to the workdir
  /// @param target the stream into which the data will be written
  int git_filter_list_stream_file(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_file(
      filters,
      repo,
      path,
      target,
    );
  }

  late final _git_filter_list_stream_file_ptr =
      _lookup<ffi.NativeFunction<_c_git_filter_list_stream_file>>(
          'git_filter_list_stream_file');
  late final _dart_git_filter_list_stream_file _git_filter_list_stream_file =
      _git_filter_list_stream_file_ptr
          .asFunction<_dart_git_filter_list_stream_file>();

  /// Apply a filter list to a blob as a stream
  ///
  /// @param filters the list of filters to apply
  /// @param blob the blob to filter
  /// @param target the stream into which the data will be written
  int git_filter_list_stream_blob(
    ffi.Pointer<git_filter_list> filters,
    ffi.Pointer<git_blob> blob,
    ffi.Pointer<git_writestream> target,
  ) {
    return _git_filter_list_stream_blob(
      filters,
      blob,
      target,
    );
  }

  late final _git_filter_list_stream_blob_ptr =
      _lookup<ffi.NativeFunction<_c_git_filter_list_stream_blob>>(
          'git_filter_list_stream_blob');
  late final _dart_git_filter_list_stream_blob _git_filter_list_stream_blob =
      _git_filter_list_stream_blob_ptr
          .asFunction<_dart_git_filter_list_stream_blob>();

  /// Free a git_filter_list
  ///
  /// @param filters A git_filter_list created by `git_filter_list_load`
  void git_filter_list_free(
    ffi.Pointer<git_filter_list> filters,
  ) {
    return _git_filter_list_free(
      filters,
    );
  }

  late final _git_filter_list_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_filter_list_free>>(
          'git_filter_list_free');
  late final _dart_git_filter_list_free _git_filter_list_free =
      _git_filter_list_free_ptr.asFunction<_dart_git_filter_list_free>();

  /// Init the global state
  ///
  /// This function must be called before any other libgit2 function in
  /// order to set up global state and threading.
  ///
  /// This function may be called multiple times - it will return the number
  /// of times the initialization has been called (including this one) that have
  /// not subsequently been shutdown.
  ///
  /// @return the number of initializations of the library, or an error code.
  int git_libgit2_init() {
    return _git_libgit2_init();
  }

  late final _git_libgit2_init_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_init>>('git_libgit2_init');
  late final _dart_git_libgit2_init _git_libgit2_init =
      _git_libgit2_init_ptr.asFunction<_dart_git_libgit2_init>();

  /// Shutdown the global state
  ///
  /// Clean up the global state and threading context after calling it as
  /// many times as `git_libgit2_init()` was called - it will return the
  /// number of remainining initializations that have not been shutdown
  /// (after this one).
  ///
  /// @return the number of remaining initializations of the library, or an
  /// error code.
  int git_libgit2_shutdown() {
    return _git_libgit2_shutdown();
  }

  late final _git_libgit2_shutdown_ptr =
      _lookup<ffi.NativeFunction<_c_git_libgit2_shutdown>>(
          'git_libgit2_shutdown');
  late final _dart_git_libgit2_shutdown _git_libgit2_shutdown =
      _git_libgit2_shutdown_ptr.asFunction<_dart_git_libgit2_shutdown>();

  /// Count the number of unique commits between two commit objects
  ///
  /// There is no need for branches containing the commits to have any
  /// upstream relationship, but it helps to think of one as a branch and
  /// the other as its upstream, the `ahead` and `behind` values will be
  /// what git would report for the branches.
  ///
  /// @param ahead number of unique from commits in `upstream`
  /// @param behind number of unique from commits in `local`
  /// @param repo the repository where the commits exist
  /// @param local the commit for local
  /// @param upstream the commit for upstream
  int git_graph_ahead_behind(
    ffi.Pointer<ffi.Int32> ahead,
    ffi.Pointer<ffi.Int32> behind,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> local,
    ffi.Pointer<git_oid> upstream,
  ) {
    return _git_graph_ahead_behind(
      ahead,
      behind,
      repo,
      local,
      upstream,
    );
  }

  late final _git_graph_ahead_behind_ptr =
      _lookup<ffi.NativeFunction<_c_git_graph_ahead_behind>>(
          'git_graph_ahead_behind');
  late final _dart_git_graph_ahead_behind _git_graph_ahead_behind =
      _git_graph_ahead_behind_ptr.asFunction<_dart_git_graph_ahead_behind>();

  /// Determine if a commit is the descendant of another commit.
  ///
  /// Note that a commit is not considered a descendant of itself, in contrast
  /// to `git merge-base --is-ancestor`.
  ///
  /// @param commit a previously loaded commit.
  /// @param ancestor a potential ancestor commit.
  /// @return 1 if the given commit is a descendant of the potential ancestor,
  /// 0 if not, error code otherwise.
  int git_graph_descendant_of(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> commit,
    ffi.Pointer<git_oid> ancestor,
  ) {
    return _git_graph_descendant_of(
      repo,
      commit,
      ancestor,
    );
  }

  late final _git_graph_descendant_of_ptr =
      _lookup<ffi.NativeFunction<_c_git_graph_descendant_of>>(
          'git_graph_descendant_of');
  late final _dart_git_graph_descendant_of _git_graph_descendant_of =
      _git_graph_descendant_of_ptr.asFunction<_dart_git_graph_descendant_of>();

  /// Add ignore rules for a repository.
  ///
  /// Excludesfile rules (i.e. .gitignore rules) are generally read from
  /// .gitignore files in the repository tree or from a shared system file
  /// only if a "core.excludesfile" config value is set.  The library also
  /// keeps a set of per-repository internal ignores that can be configured
  /// in-memory and will not persist.  This function allows you to add to
  /// that internal rules list.
  ///
  /// Example usage:
  ///
  /// error = git_ignore_add_rule(myrepo, "*.c\ndir/\nFile with space\n");
  ///
  /// This would add three rules to the ignores.
  ///
  /// @param repo The repository to add ignore rules to.
  /// @param rules Text of rules, a la the contents of a .gitignore file.
  /// It is okay to have multiple rules in the text; if so,
  /// each rule should be terminated with a newline.
  /// @return 0 on success
  int git_ignore_add_rule(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> rules,
  ) {
    return _git_ignore_add_rule(
      repo,
      rules,
    );
  }

  late final _git_ignore_add_rule_ptr =
      _lookup<ffi.NativeFunction<_c_git_ignore_add_rule>>(
          'git_ignore_add_rule');
  late final _dart_git_ignore_add_rule _git_ignore_add_rule =
      _git_ignore_add_rule_ptr.asFunction<_dart_git_ignore_add_rule>();

  /// Clear ignore rules that were explicitly added.
  ///
  /// Resets to the default internal ignore rules.  This will not turn off
  /// rules in .gitignore files that actually exist in the filesystem.
  ///
  /// The default internal ignores ignore ".", ".." and ".git" entries.
  ///
  /// @param repo The repository to remove ignore rules from.
  /// @return 0 on success
  int git_ignore_clear_internal_rules(
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_ignore_clear_internal_rules(
      repo,
    );
  }

  late final _git_ignore_clear_internal_rules_ptr =
      _lookup<ffi.NativeFunction<_c_git_ignore_clear_internal_rules>>(
          'git_ignore_clear_internal_rules');
  late final _dart_git_ignore_clear_internal_rules
      _git_ignore_clear_internal_rules = _git_ignore_clear_internal_rules_ptr
          .asFunction<_dart_git_ignore_clear_internal_rules>();

  /// Test if the ignore rules apply to a given path.
  ///
  /// This function checks the ignore rules to see if they would apply to the
  /// given file.  This indicates if the file would be ignored regardless of
  /// whether the file is already in the index or committed to the repository.
  ///
  /// One way to think of this is if you were to do "git check-ignore --no-index"
  /// on the given file, would it be shown or not?
  ///
  /// @param ignored boolean returning 0 if the file is not ignored, 1 if it is
  /// @param repo a repository object
  /// @param path the file to check ignores for, relative to the repo's workdir.
  /// @return 0 if ignore rules could be processed for the file (regardless
  /// of whether it exists or not), or an error < 0 if they could not.
  int git_ignore_path_is_ignored(
    ffi.Pointer<ffi.Int32> ignored,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_ignore_path_is_ignored(
      ignored,
      repo,
      path,
    );
  }

  late final _git_ignore_path_is_ignored_ptr =
      _lookup<ffi.NativeFunction<_c_git_ignore_path_is_ignored>>(
          'git_ignore_path_is_ignored');
  late final _dart_git_ignore_path_is_ignored _git_ignore_path_is_ignored =
      _git_ignore_path_is_ignored_ptr
          .asFunction<_dart_git_ignore_path_is_ignored>();

  /// Allocate a new mailmap object.
  ///
  /// This object is empty, so you'll have to add a mailmap file before you can do
  /// anything with it. The mailmap must be freed with 'git_mailmap_free'.
  ///
  /// @param out pointer to store the new mailmap
  /// @return 0 on success, or an error code
  int git_mailmap_new(
    ffi.Pointer<ffi.Pointer<git_mailmap>> out,
  ) {
    return _git_mailmap_new(
      out,
    );
  }

  late final _git_mailmap_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_mailmap_new>>('git_mailmap_new');
  late final _dart_git_mailmap_new _git_mailmap_new =
      _git_mailmap_new_ptr.asFunction<_dart_git_mailmap_new>();

  /// Free the mailmap and its associated memory.
  ///
  /// @param mm the mailmap to free
  void git_mailmap_free(
    ffi.Pointer<git_mailmap> mm,
  ) {
    return _git_mailmap_free(
      mm,
    );
  }

  late final _git_mailmap_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_mailmap_free>>('git_mailmap_free');
  late final _dart_git_mailmap_free _git_mailmap_free =
      _git_mailmap_free_ptr.asFunction<_dart_git_mailmap_free>();

  /// Add a single entry to the given mailmap object. If the entry already exists,
  /// it will be replaced with the new entry.
  ///
  /// @param mm mailmap to add the entry to
  /// @param real_name the real name to use, or NULL
  /// @param real_email the real email to use, or NULL
  /// @param replace_name the name to replace, or NULL
  /// @param replace_email the email to replace
  /// @return 0 on success, or an error code
  int git_mailmap_add_entry(
    ffi.Pointer<git_mailmap> mm,
    ffi.Pointer<ffi.Int8> real_name,
    ffi.Pointer<ffi.Int8> real_email,
    ffi.Pointer<ffi.Int8> replace_name,
    ffi.Pointer<ffi.Int8> replace_email,
  ) {
    return _git_mailmap_add_entry(
      mm,
      real_name,
      real_email,
      replace_name,
      replace_email,
    );
  }

  late final _git_mailmap_add_entry_ptr =
      _lookup<ffi.NativeFunction<_c_git_mailmap_add_entry>>(
          'git_mailmap_add_entry');
  late final _dart_git_mailmap_add_entry _git_mailmap_add_entry =
      _git_mailmap_add_entry_ptr.asFunction<_dart_git_mailmap_add_entry>();

  /// Create a new mailmap instance containing a single mailmap file
  ///
  /// @param out pointer to store the new mailmap
  /// @param buf buffer to parse the mailmap from
  /// @param len the length of the input buffer
  /// @return 0 on success, or an error code
  int git_mailmap_from_buffer(
    ffi.Pointer<ffi.Pointer<git_mailmap>> out,
    ffi.Pointer<ffi.Int8> buf,
    int len,
  ) {
    return _git_mailmap_from_buffer(
      out,
      buf,
      len,
    );
  }

  late final _git_mailmap_from_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_mailmap_from_buffer>>(
          'git_mailmap_from_buffer');
  late final _dart_git_mailmap_from_buffer _git_mailmap_from_buffer =
      _git_mailmap_from_buffer_ptr.asFunction<_dart_git_mailmap_from_buffer>();

  /// Create a new mailmap instance from a repository, loading mailmap files based
  /// on the repository's configuration.
  ///
  /// Mailmaps are loaded in the following order:
  /// 1. '.mailmap' in the root of the repository's working directory, if present.
  /// 2. The blob object identified by the 'mailmap.blob' config entry, if set.
  /// [NOTE: 'mailmap.blob' defaults to 'HEAD:.mailmap' in bare repositories]
  /// 3. The path in the 'mailmap.file' config entry, if set.
  ///
  /// @param out pointer to store the new mailmap
  /// @param repo repository to load mailmap information from
  /// @return 0 on success, or an error code
  int git_mailmap_from_repository(
    ffi.Pointer<ffi.Pointer<git_mailmap>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_mailmap_from_repository(
      out,
      repo,
    );
  }

  late final _git_mailmap_from_repository_ptr =
      _lookup<ffi.NativeFunction<_c_git_mailmap_from_repository>>(
          'git_mailmap_from_repository');
  late final _dart_git_mailmap_from_repository _git_mailmap_from_repository =
      _git_mailmap_from_repository_ptr
          .asFunction<_dart_git_mailmap_from_repository>();

  /// Resolve a name and email to the corresponding real name and email.
  ///
  /// The lifetime of the strings are tied to `mm`, `name`, and `email` parameters.
  ///
  /// @param real_name pointer to store the real name
  /// @param real_email pointer to store the real email
  /// @param mm the mailmap to perform a lookup with (may be NULL)
  /// @param name the name to look up
  /// @param email the email to look up
  /// @return 0 on success, or an error code
  int git_mailmap_resolve(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> real_name,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> real_email,
    ffi.Pointer<git_mailmap> mm,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> email,
  ) {
    return _git_mailmap_resolve(
      real_name,
      real_email,
      mm,
      name,
      email,
    );
  }

  late final _git_mailmap_resolve_ptr =
      _lookup<ffi.NativeFunction<_c_git_mailmap_resolve>>(
          'git_mailmap_resolve');
  late final _dart_git_mailmap_resolve _git_mailmap_resolve =
      _git_mailmap_resolve_ptr.asFunction<_dart_git_mailmap_resolve>();

  /// Resolve a signature to use real names and emails with a mailmap.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param out new signature
  /// @param mm mailmap to resolve with
  /// @param sig signature to resolve
  /// @return 0 or an error code
  int git_mailmap_resolve_signature(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_mailmap> mm,
    ffi.Pointer<git_signature> sig,
  ) {
    return _git_mailmap_resolve_signature(
      out,
      mm,
      sig,
    );
  }

  late final _git_mailmap_resolve_signature_ptr =
      _lookup<ffi.NativeFunction<_c_git_mailmap_resolve_signature>>(
          'git_mailmap_resolve_signature');
  late final _dart_git_mailmap_resolve_signature
      _git_mailmap_resolve_signature = _git_mailmap_resolve_signature_ptr
          .asFunction<_dart_git_mailmap_resolve_signature>();

  /// Clean up excess whitespace and make sure there is a trailing newline in the message.
  ///
  /// Optionally, it can remove lines which start with the comment character.
  ///
  /// @param out The user-allocated git_buf which will be filled with the
  /// cleaned up message.
  ///
  /// @param message The message to be prettified.
  ///
  /// @param strip_comments Non-zero to remove comment lines, 0 to leave them in.
  ///
  /// @param comment_char Comment character. Lines starting with this character
  /// are considered to be comments and removed if `strip_comments` is non-zero.
  ///
  /// @return 0 or an error code.
  int git_message_prettify(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<ffi.Int8> message,
    int strip_comments,
    int comment_char,
  ) {
    return _git_message_prettify(
      out,
      message,
      strip_comments,
      comment_char,
    );
  }

  late final _git_message_prettify_ptr =
      _lookup<ffi.NativeFunction<_c_git_message_prettify>>(
          'git_message_prettify');
  late final _dart_git_message_prettify _git_message_prettify =
      _git_message_prettify_ptr.asFunction<_dart_git_message_prettify>();

  /// Parse trailers out of a message, filling the array pointed to by +arr+.
  ///
  /// Trailers are key/value pairs in the last paragraph of a message, not
  /// including any patches or conflicts that may be present.
  ///
  /// @param arr A pre-allocated git_message_trailer_array struct to be filled in
  /// with any trailers found during parsing.
  /// @param message The message to be parsed
  /// @return 0 on success, or non-zero on error.
  int git_message_trailers(
    ffi.Pointer<git_message_trailer_array> arr,
    ffi.Pointer<ffi.Int8> message,
  ) {
    return _git_message_trailers(
      arr,
      message,
    );
  }

  late final _git_message_trailers_ptr =
      _lookup<ffi.NativeFunction<_c_git_message_trailers>>(
          'git_message_trailers');
  late final _dart_git_message_trailers _git_message_trailers =
      _git_message_trailers_ptr.asFunction<_dart_git_message_trailers>();

  /// Clean's up any allocated memory in the git_message_trailer_array filled by
  /// a call to git_message_trailers.
  void git_message_trailer_array_free(
    ffi.Pointer<git_message_trailer_array> arr,
  ) {
    return _git_message_trailer_array_free(
      arr,
    );
  }

  late final _git_message_trailer_array_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_message_trailer_array_free>>(
          'git_message_trailer_array_free');
  late final _dart_git_message_trailer_array_free
      _git_message_trailer_array_free = _git_message_trailer_array_free_ptr
          .asFunction<_dart_git_message_trailer_array_free>();

  /// Creates a new iterator for notes
  ///
  /// The iterator must be freed manually by the user.
  ///
  /// @param out pointer to the iterator
  /// @param repo repository where to look up the note
  /// @param notes_ref canonical name of the reference to use (optional); defaults to
  /// "refs/notes/commits"
  ///
  /// @return 0 or an error code
  int git_note_iterator_new(
    ffi.Pointer<ffi.Pointer<git_iterator>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> notes_ref,
  ) {
    return _git_note_iterator_new(
      out,
      repo,
      notes_ref,
    );
  }

  late final _git_note_iterator_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_iterator_new>>(
          'git_note_iterator_new');
  late final _dart_git_note_iterator_new _git_note_iterator_new =
      _git_note_iterator_new_ptr.asFunction<_dart_git_note_iterator_new>();

  /// Creates a new iterator for notes from a commit
  ///
  /// The iterator must be freed manually by the user.
  ///
  /// @param out pointer to the iterator
  /// @param notes_commit a pointer to the notes commit object
  ///
  /// @return 0 or an error code
  int git_note_commit_iterator_new(
    ffi.Pointer<ffi.Pointer<git_iterator>> out,
    ffi.Pointer<git_commit> notes_commit,
  ) {
    return _git_note_commit_iterator_new(
      out,
      notes_commit,
    );
  }

  late final _git_note_commit_iterator_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_commit_iterator_new>>(
          'git_note_commit_iterator_new');
  late final _dart_git_note_commit_iterator_new _git_note_commit_iterator_new =
      _git_note_commit_iterator_new_ptr
          .asFunction<_dart_git_note_commit_iterator_new>();

  /// Frees an git_note_iterator
  ///
  /// @param it pointer to the iterator
  void git_note_iterator_free(
    ffi.Pointer<git_iterator> it,
  ) {
    return _git_note_iterator_free(
      it,
    );
  }

  late final _git_note_iterator_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_iterator_free>>(
          'git_note_iterator_free');
  late final _dart_git_note_iterator_free _git_note_iterator_free =
      _git_note_iterator_free_ptr.asFunction<_dart_git_note_iterator_free>();

  /// Return the current item (note_id and annotated_id) and advance the iterator
  /// internally to the next value
  ///
  /// @param note_id id of blob containing the message
  /// @param annotated_id id of the git object being annotated
  /// @param it pointer to the iterator
  ///
  /// @return 0 (no error), GIT_ITEROVER (iteration is done) or an error code
  /// (negative value)
  int git_note_next(
    ffi.Pointer<git_oid> note_id,
    ffi.Pointer<git_oid> annotated_id,
    ffi.Pointer<git_iterator> it,
  ) {
    return _git_note_next(
      note_id,
      annotated_id,
      it,
    );
  }

  late final _git_note_next_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_next>>('git_note_next');
  late final _dart_git_note_next _git_note_next =
      _git_note_next_ptr.asFunction<_dart_git_note_next>();

  /// Read the note for an object
  ///
  /// The note must be freed manually by the user.
  ///
  /// @param out pointer to the read note; NULL in case of error
  /// @param repo repository where to look up the note
  /// @param notes_ref canonical name of the reference to use (optional); defaults to
  /// "refs/notes/commits"
  /// @param oid OID of the git object to read the note from
  ///
  /// @return 0 or an error code
  int git_note_read(
    ffi.Pointer<ffi.Pointer<git_note>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> notes_ref,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_read(
      out,
      repo,
      notes_ref,
      oid,
    );
  }

  late final _git_note_read_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_read>>('git_note_read');
  late final _dart_git_note_read _git_note_read =
      _git_note_read_ptr.asFunction<_dart_git_note_read>();

  /// Read the note for an object from a note commit
  ///
  /// The note must be freed manually by the user.
  ///
  /// @param out pointer to the read note; NULL in case of error
  /// @param repo repository where to look up the note
  /// @param notes_commit a pointer to the notes commit object
  /// @param oid OID of the git object to read the note from
  ///
  /// @return 0 or an error code
  int git_note_commit_read(
    ffi.Pointer<ffi.Pointer<git_note>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> notes_commit,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_commit_read(
      out,
      repo,
      notes_commit,
      oid,
    );
  }

  late final _git_note_commit_read_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_commit_read>>(
          'git_note_commit_read');
  late final _dart_git_note_commit_read _git_note_commit_read =
      _git_note_commit_read_ptr.asFunction<_dart_git_note_commit_read>();

  /// Get the note author
  ///
  /// @param note the note
  /// @return the author
  ffi.Pointer<git_signature> git_note_author(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_author(
      note,
    );
  }

  late final _git_note_author_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_author>>('git_note_author');
  late final _dart_git_note_author _git_note_author =
      _git_note_author_ptr.asFunction<_dart_git_note_author>();

  /// Get the note committer
  ///
  /// @param note the note
  /// @return the committer
  ffi.Pointer<git_signature> git_note_committer(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_committer(
      note,
    );
  }

  late final _git_note_committer_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_committer>>('git_note_committer');
  late final _dart_git_note_committer _git_note_committer =
      _git_note_committer_ptr.asFunction<_dart_git_note_committer>();

  /// Get the note message
  ///
  /// @param note the note
  /// @return the note message
  ffi.Pointer<ffi.Int8> git_note_message(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_message(
      note,
    );
  }

  late final _git_note_message_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_message>>('git_note_message');
  late final _dart_git_note_message _git_note_message =
      _git_note_message_ptr.asFunction<_dart_git_note_message>();

  /// Get the note object's id
  ///
  /// @param note the note
  /// @return the note object's id
  ffi.Pointer<git_oid> git_note_id(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_id(
      note,
    );
  }

  late final _git_note_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_id>>('git_note_id');
  late final _dart_git_note_id _git_note_id =
      _git_note_id_ptr.asFunction<_dart_git_note_id>();

  /// Add a note for an object
  ///
  /// @param out pointer to store the OID (optional); NULL in case of error
  /// @param repo repository where to store the note
  /// @param notes_ref canonical name of the reference to use (optional);
  /// defaults to "refs/notes/commits"
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to decorate
  /// @param note Content of the note to add for object oid
  /// @param force Overwrite existing note
  ///
  /// @return 0 or an error code
  int git_note_create(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> notes_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Int8> note,
    int force,
  ) {
    return _git_note_create(
      out,
      repo,
      notes_ref,
      author,
      committer,
      oid,
      note,
      force,
    );
  }

  late final _git_note_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_create>>('git_note_create');
  late final _dart_git_note_create _git_note_create =
      _git_note_create_ptr.asFunction<_dart_git_note_create>();

  /// Add a note for an object from a commit
  ///
  /// This function will create a notes commit for a given object,
  /// the commit is a dangling commit, no reference is created.
  ///
  /// @param notes_commit_out pointer to store the commit (optional);
  /// NULL in case of error
  /// @param notes_blob_out a point to the id of a note blob (optional)
  /// @param repo repository where the note will live
  /// @param parent Pointer to parent note
  /// or NULL if this shall start a new notes tree
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to decorate
  /// @param note Content of the note to add for object oid
  /// @param allow_note_overwrite Overwrite existing note
  ///
  /// @return 0 or an error code
  int git_note_commit_create(
    ffi.Pointer<git_oid> notes_commit_out,
    ffi.Pointer<git_oid> notes_blob_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> parent,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<ffi.Int8> note,
    int allow_note_overwrite,
  ) {
    return _git_note_commit_create(
      notes_commit_out,
      notes_blob_out,
      repo,
      parent,
      author,
      committer,
      oid,
      note,
      allow_note_overwrite,
    );
  }

  late final _git_note_commit_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_commit_create>>(
          'git_note_commit_create');
  late final _dart_git_note_commit_create _git_note_commit_create =
      _git_note_commit_create_ptr.asFunction<_dart_git_note_commit_create>();

  /// Remove the note for an object
  ///
  /// @param repo repository where the note lives
  /// @param notes_ref canonical name of the reference to use (optional);
  /// defaults to "refs/notes/commits"
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to remove the note from
  ///
  /// @return 0 or an error code
  int git_note_remove(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> notes_ref,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_remove(
      repo,
      notes_ref,
      author,
      committer,
      oid,
    );
  }

  late final _git_note_remove_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_remove>>('git_note_remove');
  late final _dart_git_note_remove _git_note_remove =
      _git_note_remove_ptr.asFunction<_dart_git_note_remove>();

  /// Remove the note for an object
  ///
  /// @param notes_commit_out pointer to store the new notes commit (optional);
  /// NULL in case of error.
  /// When removing a note a new tree containing all notes
  /// sans the note to be removed is created and a new commit
  /// pointing to that tree is also created.
  /// In the case where the resulting tree is an empty tree
  /// a new commit pointing to this empty tree will be returned.
  /// @param repo repository where the note lives
  /// @param notes_commit a pointer to the notes commit object
  /// @param author signature of the notes commit author
  /// @param committer signature of the notes commit committer
  /// @param oid OID of the git object to remove the note from
  ///
  /// @return 0 or an error code
  int git_note_commit_remove(
    ffi.Pointer<git_oid> notes_commit_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_commit> notes_commit,
    ffi.Pointer<git_signature> author,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_note_commit_remove(
      notes_commit_out,
      repo,
      notes_commit,
      author,
      committer,
      oid,
    );
  }

  late final _git_note_commit_remove_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_commit_remove>>(
          'git_note_commit_remove');
  late final _dart_git_note_commit_remove _git_note_commit_remove =
      _git_note_commit_remove_ptr.asFunction<_dart_git_note_commit_remove>();

  /// Free a git_note object
  ///
  /// @param note git_note object
  void git_note_free(
    ffi.Pointer<git_note> note,
  ) {
    return _git_note_free(
      note,
    );
  }

  late final _git_note_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_free>>('git_note_free');
  late final _dart_git_note_free _git_note_free =
      _git_note_free_ptr.asFunction<_dart_git_note_free>();

  /// Get the default notes reference for a repository
  ///
  /// @param out buffer in which to store the name of the default notes reference
  /// @param repo The Git repository
  ///
  /// @return 0 or an error code
  int git_note_default_ref(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_note_default_ref(
      out,
      repo,
    );
  }

  late final _git_note_default_ref_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_default_ref>>(
          'git_note_default_ref');
  late final _dart_git_note_default_ref _git_note_default_ref =
      _git_note_default_ref_ptr.asFunction<_dart_git_note_default_ref>();

  /// Loop over all the notes within a specified namespace
  /// and issue a callback for each one.
  ///
  /// @param repo Repository where to find the notes.
  ///
  /// @param notes_ref Reference to read from (optional); defaults to
  /// "refs/notes/commits".
  ///
  /// @param note_cb Callback to invoke per found annotation.  Return non-zero
  /// to stop looping.
  ///
  /// @param payload Extra parameter to callback function.
  ///
  /// @return 0 on success, non-zero callback return value, or error code
  int git_note_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> notes_ref,
    ffi.Pointer<ffi.NativeFunction<git_note_foreach_cb>> note_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_note_foreach(
      repo,
      notes_ref,
      note_cb,
      payload,
    );
  }

  late final _git_note_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_note_foreach>>('git_note_foreach');
  late final _dart_git_note_foreach _git_note_foreach =
      _git_note_foreach_ptr.asFunction<_dart_git_note_foreach>();

  /// Create a new object database with no backends.
  ///
  /// Before the ODB can be used for read/writing, a custom database
  /// backend must be manually added using `git_odb_add_backend()`
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @return 0 or an error code
  int git_odb_new(
    ffi.Pointer<ffi.Pointer<git_odb>> out,
  ) {
    return _git_odb_new(
      out,
    );
  }

  late final _git_odb_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_new>>('git_odb_new');
  late final _dart_git_odb_new _git_odb_new =
      _git_odb_new_ptr.asFunction<_dart_git_odb_new>();

  /// Create a new object database and automatically add
  /// the two default backends:
  ///
  /// - git_odb_backend_loose: read and write loose object files
  /// from disk, assuming `objects_dir` as the Objects folder
  ///
  /// - git_odb_backend_pack: read objects from packfiles,
  /// assuming `objects_dir` as the Objects folder which
  /// contains a 'pack/' folder with the corresponding data
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @param objects_dir path of the backends' "objects" directory.
  /// @return 0 or an error code
  int git_odb_open(
    ffi.Pointer<ffi.Pointer<git_odb>> out,
    ffi.Pointer<ffi.Int8> objects_dir,
  ) {
    return _git_odb_open(
      out,
      objects_dir,
    );
  }

  late final _git_odb_open_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_open>>('git_odb_open');
  late final _dart_git_odb_open _git_odb_open =
      _git_odb_open_ptr.asFunction<_dart_git_odb_open>();

  /// Add an on-disk alternate to an existing Object DB.
  ///
  /// Note that the added path must point to an `objects`, not
  /// to a full repository, to use it as an alternate store.
  ///
  /// Alternate backends are always checked for objects *after*
  /// all the main backends have been exhausted.
  ///
  /// Writing is disabled on alternate backends.
  ///
  /// @param odb database to add the backend to
  /// @param path path to the objects folder for the alternate
  /// @return 0 on success; error code otherwise
  int git_odb_add_disk_alternate(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_odb_add_disk_alternate(
      odb,
      path,
    );
  }

  late final _git_odb_add_disk_alternate_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_add_disk_alternate>>(
          'git_odb_add_disk_alternate');
  late final _dart_git_odb_add_disk_alternate _git_odb_add_disk_alternate =
      _git_odb_add_disk_alternate_ptr
          .asFunction<_dart_git_odb_add_disk_alternate>();

  /// Close an open object database.
  ///
  /// @param db database pointer to close. If NULL no action is taken.
  void git_odb_free(
    ffi.Pointer<git_odb> db,
  ) {
    return _git_odb_free(
      db,
    );
  }

  late final _git_odb_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_free>>('git_odb_free');
  late final _dart_git_odb_free _git_odb_free =
      _git_odb_free_ptr.asFunction<_dart_git_odb_free>();

  /// Read an object from the database.
  ///
  /// This method queries all available ODB backends
  /// trying to read the given OID.
  ///
  /// The returned object is reference counted and
  /// internally cached, so it should be closed
  /// by the user once it's no longer in use.
  ///
  /// @param out pointer where to store the read object
  /// @param db database to search for the object in.
  /// @param id identity of the object to read.
  /// @return
  /// - 0 if the object was read;
  /// - GIT_ENOTFOUND if the object is not in the database.
  int git_odb_read(
    ffi.Pointer<ffi.Pointer<git_odb_object>> out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_odb_read(
      out,
      db,
      id,
    );
  }

  late final _git_odb_read_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_read>>('git_odb_read');
  late final _dart_git_odb_read _git_odb_read =
      _git_odb_read_ptr.asFunction<_dart_git_odb_read>();

  /// Read an object from the database, given a prefix
  /// of its identifier.
  ///
  /// This method queries all available ODB backends
  /// trying to match the 'len' first hexadecimal
  /// characters of the 'short_id'.
  /// The remaining (GIT_OID_HEXSZ-len)*4 bits of
  /// 'short_id' must be 0s.
  /// 'len' must be at least GIT_OID_MINPREFIXLEN,
  /// and the prefix must be long enough to identify
  /// a unique object in all the backends; the
  /// method will fail otherwise.
  ///
  /// The returned object is reference counted and
  /// internally cached, so it should be closed
  /// by the user once it's no longer in use.
  ///
  /// @param out pointer where to store the read object
  /// @param db database to search for the object in.
  /// @param short_id a prefix of the id of the object to read.
  /// @param len the length of the prefix
  /// @return
  /// - 0 if the object was read;
  /// - GIT_ENOTFOUND if the object is not in the database.
  /// - GIT_EAMBIGUOUS if the prefix is ambiguous (several objects match the prefix)
  int git_odb_read_prefix(
    ffi.Pointer<ffi.Pointer<git_odb_object>> out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> short_id,
    int len,
  ) {
    return _git_odb_read_prefix(
      out,
      db,
      short_id,
      len,
    );
  }

  late final _git_odb_read_prefix_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_read_prefix>>(
          'git_odb_read_prefix');
  late final _dart_git_odb_read_prefix _git_odb_read_prefix =
      _git_odb_read_prefix_ptr.asFunction<_dart_git_odb_read_prefix>();

  /// Read the header of an object from the database, without
  /// reading its full contents.
  ///
  /// The header includes the length and the type of an object.
  ///
  /// Note that most backends do not support reading only the header
  /// of an object, so the whole object will be read and then the
  /// header will be returned.
  ///
  /// @param len_out pointer where to store the length
  /// @param type_out pointer where to store the type
  /// @param db database to search for the object in.
  /// @param id identity of the object to read.
  /// @return
  /// - 0 if the object was read;
  /// - GIT_ENOTFOUND if the object is not in the database.
  int git_odb_read_header(
    ffi.Pointer<ffi.Int32> len_out,
    ffi.Pointer<ffi.Int32> type_out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_odb_read_header(
      len_out,
      type_out,
      db,
      id,
    );
  }

  late final _git_odb_read_header_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_read_header>>(
          'git_odb_read_header');
  late final _dart_git_odb_read_header _git_odb_read_header =
      _git_odb_read_header_ptr.asFunction<_dart_git_odb_read_header>();

  /// Determine if the given object can be found in the object database.
  ///
  /// @param db database to be searched for the given object.
  /// @param id the object to search for.
  /// @return
  /// - 1, if the object was found
  /// - 0, otherwise
  int git_odb_exists(
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_odb_exists(
      db,
      id,
    );
  }

  late final _git_odb_exists_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_exists>>('git_odb_exists');
  late final _dart_git_odb_exists _git_odb_exists =
      _git_odb_exists_ptr.asFunction<_dart_git_odb_exists>();

  /// Determine if an object can be found in the object database by an
  /// abbreviated object ID.
  ///
  /// @param out The full OID of the found object if just one is found.
  /// @param db The database to be searched for the given object.
  /// @param short_id A prefix of the id of the object to read.
  /// @param len The length of the prefix.
  /// @return 0 if found, GIT_ENOTFOUND if not found, GIT_EAMBIGUOUS if multiple
  /// matches were found, other value < 0 if there was a read error.
  int git_odb_exists_prefix(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> short_id,
    int len,
  ) {
    return _git_odb_exists_prefix(
      out,
      db,
      short_id,
      len,
    );
  }

  late final _git_odb_exists_prefix_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_exists_prefix>>(
          'git_odb_exists_prefix');
  late final _dart_git_odb_exists_prefix _git_odb_exists_prefix =
      _git_odb_exists_prefix_ptr.asFunction<_dart_git_odb_exists_prefix>();

  /// Determine if one or more objects can be found in the object database
  /// by their abbreviated object ID and type.  The given array will be
  /// updated in place:  for each abbreviated ID that is unique in the
  /// database, and of the given type (if specified), the full object ID,
  /// object ID length (`GIT_OID_HEXSZ`) and type will be written back to
  /// the array.  For IDs that are not found (or are ambiguous), the
  /// array entry will be zeroed.
  ///
  /// Note that since this function operates on multiple objects, the
  /// underlying database will not be asked to be reloaded if an object is
  /// not found (which is unlike other object database operations.)
  ///
  /// @param db The database to be searched for the given objects.
  /// @param ids An array of short object IDs to search for
  /// @param count The length of the `ids` array
  /// @return 0 on success or an error code on failure
  int git_odb_expand_ids(
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_odb_expand_id> ids,
    int count,
  ) {
    return _git_odb_expand_ids(
      db,
      ids,
      count,
    );
  }

  late final _git_odb_expand_ids_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_expand_ids>>('git_odb_expand_ids');
  late final _dart_git_odb_expand_ids _git_odb_expand_ids =
      _git_odb_expand_ids_ptr.asFunction<_dart_git_odb_expand_ids>();

  /// Refresh the object database to load newly added files.
  ///
  /// If the object databases have changed on disk while the library
  /// is running, this function will force a reload of the underlying
  /// indexes.
  ///
  /// Use this function when you're confident that an external
  /// application has tampered with the ODB.
  ///
  /// NOTE that it is not necessary to call this function at all. The
  /// library will automatically attempt to refresh the ODB
  /// when a lookup fails, to see if the looked up object exists
  /// on disk but hasn't been loaded yet.
  ///
  /// @param db database to refresh
  /// @return 0 on success, error code otherwise
  int git_odb_refresh(
    ffi.Pointer<git_odb> db,
  ) {
    return _git_odb_refresh(
      db,
    );
  }

  late final _git_odb_refresh_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_refresh>>('git_odb_refresh');
  late final _dart_git_odb_refresh _git_odb_refresh =
      _git_odb_refresh_ptr.asFunction<_dart_git_odb_refresh>();

  /// List all objects available in the database
  ///
  /// The callback will be called for each object available in the
  /// database. Note that the objects are likely to be returned in the index
  /// order, which would make accessing the objects in that order inefficient.
  /// Return a non-zero value from the callback to stop looping.
  ///
  /// @param db database to use
  /// @param cb the callback to call for each object
  /// @param payload data to pass to the callback
  /// @return 0 on success, non-zero callback return value, or error code
  int git_odb_foreach(
    ffi.Pointer<git_odb> db,
    ffi.Pointer<ffi.NativeFunction<git_odb_foreach_cb>> cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_odb_foreach(
      db,
      cb,
      payload,
    );
  }

  late final _git_odb_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_foreach>>('git_odb_foreach');
  late final _dart_git_odb_foreach _git_odb_foreach =
      _git_odb_foreach_ptr.asFunction<_dart_git_odb_foreach>();

  /// Write an object directly into the ODB
  ///
  /// This method writes a full object straight into the ODB.
  /// For most cases, it is preferred to write objects through a write
  /// stream, which is both faster and less memory intensive, specially
  /// for big objects.
  ///
  /// This method is provided for compatibility with custom backends
  /// which are not able to support streaming writes
  ///
  /// @param out pointer to store the OID result of the write
  /// @param odb object database where to store the object
  /// @param data buffer with the data to store
  /// @param len size of the buffer
  /// @param type type of the data to store
  /// @return 0 or an error code
  int git_odb_write(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<ffi.Void> data,
    int len,
    int type,
  ) {
    return _git_odb_write(
      out,
      odb,
      data,
      len,
      type,
    );
  }

  late final _git_odb_write_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_write>>('git_odb_write');
  late final _dart_git_odb_write _git_odb_write =
      _git_odb_write_ptr.asFunction<_dart_git_odb_write>();

  /// Open a stream to write an object into the ODB
  ///
  /// The type and final length of the object must be specified
  /// when opening the stream.
  ///
  /// The returned stream will be of type `GIT_STREAM_WRONLY`, and it
  /// won't be effective until `git_odb_stream_finalize_write` is called
  /// and returns without an error
  ///
  /// The stream must always be freed when done with `git_odb_stream_free` or
  /// will leak memory.
  ///
  /// @see git_odb_stream
  ///
  /// @param out pointer where to store the stream
  /// @param db object database where the stream will write
  /// @param size final size of the object that will be written
  /// @param type type of the object that will be written
  /// @return 0 if the stream was created; error code otherwise
  int git_odb_open_wstream(
    ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
    ffi.Pointer<git_odb> db,
    int size,
    int type,
  ) {
    return _git_odb_open_wstream(
      out,
      db,
      size,
      type,
    );
  }

  late final _git_odb_open_wstream_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_open_wstream>>(
          'git_odb_open_wstream');
  late final _dart_git_odb_open_wstream _git_odb_open_wstream =
      _git_odb_open_wstream_ptr.asFunction<_dart_git_odb_open_wstream>();

  /// Write to an odb stream
  ///
  /// This method will fail if the total number of received bytes exceeds the
  /// size declared with `git_odb_open_wstream()`
  ///
  /// @param stream the stream
  /// @param buffer the data to write
  /// @param len the buffer's length
  /// @return 0 if the write succeeded; error code otherwise
  int git_odb_stream_write(
    ffi.Pointer<git_odb_stream> stream,
    ffi.Pointer<ffi.Int8> buffer,
    int len,
  ) {
    return _git_odb_stream_write(
      stream,
      buffer,
      len,
    );
  }

  late final _git_odb_stream_write_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_stream_write>>(
          'git_odb_stream_write');
  late final _dart_git_odb_stream_write _git_odb_stream_write =
      _git_odb_stream_write_ptr.asFunction<_dart_git_odb_stream_write>();

  /// Finish writing to an odb stream
  ///
  /// The object will take its final name and will be available to the
  /// odb.
  ///
  /// This method will fail if the total number of received bytes
  /// differs from the size declared with `git_odb_open_wstream()`
  ///
  /// @param out pointer to store the resulting object's id
  /// @param stream the stream
  /// @return 0 on success; an error code otherwise
  int git_odb_stream_finalize_write(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_odb_stream> stream,
  ) {
    return _git_odb_stream_finalize_write(
      out,
      stream,
    );
  }

  late final _git_odb_stream_finalize_write_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_stream_finalize_write>>(
          'git_odb_stream_finalize_write');
  late final _dart_git_odb_stream_finalize_write
      _git_odb_stream_finalize_write = _git_odb_stream_finalize_write_ptr
          .asFunction<_dart_git_odb_stream_finalize_write>();

  /// Read from an odb stream
  ///
  /// Most backends don't implement streaming reads
  int git_odb_stream_read(
    ffi.Pointer<git_odb_stream> stream,
    ffi.Pointer<ffi.Int8> buffer,
    int len,
  ) {
    return _git_odb_stream_read(
      stream,
      buffer,
      len,
    );
  }

  late final _git_odb_stream_read_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_stream_read>>(
          'git_odb_stream_read');
  late final _dart_git_odb_stream_read _git_odb_stream_read =
      _git_odb_stream_read_ptr.asFunction<_dart_git_odb_stream_read>();

  /// Free an odb stream
  ///
  /// @param stream the stream to free
  void git_odb_stream_free(
    ffi.Pointer<git_odb_stream> stream,
  ) {
    return _git_odb_stream_free(
      stream,
    );
  }

  late final _git_odb_stream_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_stream_free>>(
          'git_odb_stream_free');
  late final _dart_git_odb_stream_free _git_odb_stream_free =
      _git_odb_stream_free_ptr.asFunction<_dart_git_odb_stream_free>();

  /// Open a stream to read an object from the ODB
  ///
  /// Note that most backends do *not* support streaming reads
  /// because they store their objects as compressed/delta'ed blobs.
  ///
  /// It's recommended to use `git_odb_read` instead, which is
  /// assured to work on all backends.
  ///
  /// The returned stream will be of type `GIT_STREAM_RDONLY` and
  /// will have the following methods:
  ///
  /// - stream->read: read `n` bytes from the stream
  /// - stream->free: free the stream
  ///
  /// The stream must always be free'd or will leak memory.
  ///
  /// @see git_odb_stream
  ///
  /// @param out pointer where to store the stream
  /// @param len pointer where to store the length of the object
  /// @param type pointer where to store the type of the object
  /// @param db object database where the stream will read from
  /// @param oid oid of the object the stream will read from
  /// @return 0 if the stream was created; error code otherwise
  int git_odb_open_rstream(
    ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
    ffi.Pointer<ffi.Int32> len,
    ffi.Pointer<ffi.Int32> type,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<git_oid> oid,
  ) {
    return _git_odb_open_rstream(
      out,
      len,
      type,
      db,
      oid,
    );
  }

  late final _git_odb_open_rstream_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_open_rstream>>(
          'git_odb_open_rstream');
  late final _dart_git_odb_open_rstream _git_odb_open_rstream =
      _git_odb_open_rstream_ptr.asFunction<_dart_git_odb_open_rstream>();

  /// Open a stream for writing a pack file to the ODB.
  ///
  /// If the ODB layer understands pack files, then the given
  /// packfile will likely be streamed directly to disk (and a
  /// corresponding index created).  If the ODB layer does not
  /// understand pack files, the objects will be stored in whatever
  /// format the ODB layer uses.
  ///
  /// @see git_odb_writepack
  ///
  /// @param out pointer to the writepack functions
  /// @param db object database where the stream will read from
  /// @param progress_cb function to call with progress information.
  /// Be aware that this is called inline with network and indexing operations,
  /// so performance may be affected.
  /// @param progress_payload payload for the progress callback
  int git_odb_write_pack(
    ffi.Pointer<ffi.Pointer<git_odb_writepack>> out,
    ffi.Pointer<git_odb> db,
    ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>> progress_cb,
    ffi.Pointer<ffi.Void> progress_payload,
  ) {
    return _git_odb_write_pack(
      out,
      db,
      progress_cb,
      progress_payload,
    );
  }

  late final _git_odb_write_pack_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_write_pack>>('git_odb_write_pack');
  late final _dart_git_odb_write_pack _git_odb_write_pack =
      _git_odb_write_pack_ptr.asFunction<_dart_git_odb_write_pack>();

  /// Determine the object-ID (sha1 hash) of a data buffer
  ///
  /// The resulting SHA-1 OID will be the identifier for the data
  /// buffer as if the data buffer it were to written to the ODB.
  ///
  /// @param out the resulting object-ID.
  /// @param data data to hash
  /// @param len size of the data
  /// @param type of the data to hash
  /// @return 0 or an error code
  int git_odb_hash(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Void> data,
    int len,
    int type,
  ) {
    return _git_odb_hash(
      out,
      data,
      len,
      type,
    );
  }

  late final _git_odb_hash_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_hash>>('git_odb_hash');
  late final _dart_git_odb_hash _git_odb_hash =
      _git_odb_hash_ptr.asFunction<_dart_git_odb_hash>();

  /// Read a file from disk and fill a git_oid with the object id
  /// that the file would have if it were written to the Object
  /// Database as an object of the given type (w/o applying filters).
  /// Similar functionality to git.git's `git hash-object` without
  /// the `-w` flag, however, with the --no-filters flag.
  /// If you need filters, see git_repository_hashfile.
  ///
  /// @param out oid structure the result is written into.
  /// @param path file to read and determine object id for
  /// @param type the type of the object that will be hashed
  /// @return 0 or an error code
  int git_odb_hashfile(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<ffi.Int8> path,
    int type,
  ) {
    return _git_odb_hashfile(
      out,
      path,
      type,
    );
  }

  late final _git_odb_hashfile_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_hashfile>>('git_odb_hashfile');
  late final _dart_git_odb_hashfile _git_odb_hashfile =
      _git_odb_hashfile_ptr.asFunction<_dart_git_odb_hashfile>();

  /// Create a copy of an odb_object
  ///
  /// The returned copy must be manually freed with `git_odb_object_free`.
  /// Note that because of an implementation detail, the returned copy will be
  /// the same pointer as `source`: the object is internally refcounted, so the
  /// copy still needs to be freed twice.
  ///
  /// @param dest pointer where to store the copy
  /// @param source object to copy
  /// @return 0 or an error code
  int git_odb_object_dup(
    ffi.Pointer<ffi.Pointer<git_odb_object>> dest,
    ffi.Pointer<git_odb_object> source,
  ) {
    return _git_odb_object_dup(
      dest,
      source,
    );
  }

  late final _git_odb_object_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_object_dup>>('git_odb_object_dup');
  late final _dart_git_odb_object_dup _git_odb_object_dup =
      _git_odb_object_dup_ptr.asFunction<_dart_git_odb_object_dup>();

  /// Close an ODB object
  ///
  /// This method must always be called once a `git_odb_object` is no
  /// longer needed, otherwise memory will leak.
  ///
  /// @param object object to close
  void git_odb_object_free(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_free(
      object,
    );
  }

  late final _git_odb_object_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_object_free>>(
          'git_odb_object_free');
  late final _dart_git_odb_object_free _git_odb_object_free =
      _git_odb_object_free_ptr.asFunction<_dart_git_odb_object_free>();

  /// Return the OID of an ODB object
  ///
  /// This is the OID from which the object was read from
  ///
  /// @param object the object
  /// @return a pointer to the OID
  ffi.Pointer<git_oid> git_odb_object_id(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_id(
      object,
    );
  }

  late final _git_odb_object_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_object_id>>('git_odb_object_id');
  late final _dart_git_odb_object_id _git_odb_object_id =
      _git_odb_object_id_ptr.asFunction<_dart_git_odb_object_id>();

  /// Return the data of an ODB object
  ///
  /// This is the uncompressed, raw data as read from the ODB,
  /// without the leading header.
  ///
  /// This pointer is owned by the object and shall not be free'd.
  ///
  /// @param object the object
  /// @return a pointer to the data
  ffi.Pointer<ffi.Void> git_odb_object_data(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_data(
      object,
    );
  }

  late final _git_odb_object_data_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_object_data>>(
          'git_odb_object_data');
  late final _dart_git_odb_object_data _git_odb_object_data =
      _git_odb_object_data_ptr.asFunction<_dart_git_odb_object_data>();

  /// Return the size of an ODB object
  ///
  /// This is the real size of the `data` buffer, not the
  /// actual size of the object.
  ///
  /// @param object the object
  /// @return the size
  int git_odb_object_size(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_size(
      object,
    );
  }

  late final _git_odb_object_size_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_object_size>>(
          'git_odb_object_size');
  late final _dart_git_odb_object_size _git_odb_object_size =
      _git_odb_object_size_ptr.asFunction<_dart_git_odb_object_size>();

  /// Return the type of an ODB object
  ///
  /// @param object the object
  /// @return the type
  int git_odb_object_type(
    ffi.Pointer<git_odb_object> object,
  ) {
    return _git_odb_object_type(
      object,
    );
  }

  late final _git_odb_object_type_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_object_type>>(
          'git_odb_object_type');
  late final _dart_git_odb_object_type _git_odb_object_type =
      _git_odb_object_type_ptr.asFunction<_dart_git_odb_object_type>();

  /// Add a custom backend to an existing Object DB
  ///
  /// The backends are checked in relative ordering, based on the
  /// value of the `priority` parameter.
  ///
  /// Read <sys/odb_backend.h> for more information.
  ///
  /// @param odb database to add the backend to
  /// @param backend pointer to a git_odb_backend instance
  /// @param priority Value for ordering the backends queue
  /// @return 0 on success; error code otherwise
  int git_odb_add_backend(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_odb_backend> backend,
    int priority,
  ) {
    return _git_odb_add_backend(
      odb,
      backend,
      priority,
    );
  }

  late final _git_odb_add_backend_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_add_backend>>(
          'git_odb_add_backend');
  late final _dart_git_odb_add_backend _git_odb_add_backend =
      _git_odb_add_backend_ptr.asFunction<_dart_git_odb_add_backend>();

  /// Add a custom backend to an existing Object DB; this
  /// backend will work as an alternate.
  ///
  /// Alternate backends are always checked for objects *after*
  /// all the main backends have been exhausted.
  ///
  /// The backends are checked in relative ordering, based on the
  /// value of the `priority` parameter.
  ///
  /// Writing is disabled on alternate backends.
  ///
  /// Read <sys/odb_backend.h> for more information.
  ///
  /// @param odb database to add the backend to
  /// @param backend pointer to a git_odb_backend instance
  /// @param priority Value for ordering the backends queue
  /// @return 0 on success; error code otherwise
  int git_odb_add_alternate(
    ffi.Pointer<git_odb> odb,
    ffi.Pointer<git_odb_backend> backend,
    int priority,
  ) {
    return _git_odb_add_alternate(
      odb,
      backend,
      priority,
    );
  }

  late final _git_odb_add_alternate_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_add_alternate>>(
          'git_odb_add_alternate');
  late final _dart_git_odb_add_alternate _git_odb_add_alternate =
      _git_odb_add_alternate_ptr.asFunction<_dart_git_odb_add_alternate>();

  /// Get the number of ODB backend objects
  ///
  /// @param odb object database
  /// @return number of backends in the ODB
  int git_odb_num_backends(
    ffi.Pointer<git_odb> odb,
  ) {
    return _git_odb_num_backends(
      odb,
    );
  }

  late final _git_odb_num_backends_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_num_backends>>(
          'git_odb_num_backends');
  late final _dart_git_odb_num_backends _git_odb_num_backends =
      _git_odb_num_backends_ptr.asFunction<_dart_git_odb_num_backends>();

  /// Lookup an ODB backend object by index
  ///
  /// @param out output pointer to ODB backend at pos
  /// @param odb object database
  /// @param pos index into object database backend list
  /// @return 0 on success; GIT_ENOTFOUND if pos is invalid; other errors < 0
  int git_odb_get_backend(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<git_odb> odb,
    int pos,
  ) {
    return _git_odb_get_backend(
      out,
      odb,
      pos,
    );
  }

  late final _git_odb_get_backend_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_get_backend>>(
          'git_odb_get_backend');
  late final _dart_git_odb_get_backend _git_odb_get_backend =
      _git_odb_get_backend_ptr.asFunction<_dart_git_odb_get_backend>();

  /// Create a backend for the packfiles.
  ///
  /// @param out location to store the odb backend pointer
  /// @param objects_dir the Git repository's objects directory
  ///
  /// @return 0 or an error code
  int git_odb_backend_pack(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<ffi.Int8> objects_dir,
  ) {
    return _git_odb_backend_pack(
      out,
      objects_dir,
    );
  }

  late final _git_odb_backend_pack_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_backend_pack>>(
          'git_odb_backend_pack');
  late final _dart_git_odb_backend_pack _git_odb_backend_pack =
      _git_odb_backend_pack_ptr.asFunction<_dart_git_odb_backend_pack>();

  /// Create a backend for loose objects
  ///
  /// @param out location to store the odb backend pointer
  /// @param objects_dir the Git repository's objects directory
  /// @param compression_level zlib compression level to use
  /// @param do_fsync whether to do an fsync() after writing
  /// @param dir_mode permissions to use creating a directory or 0 for defaults
  /// @param file_mode permissions to use creating a file or 0 for defaults
  ///
  /// @return 0 or an error code
  int git_odb_backend_loose(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<ffi.Int8> objects_dir,
    int compression_level,
    int do_fsync,
    int dir_mode,
    int file_mode,
  ) {
    return _git_odb_backend_loose(
      out,
      objects_dir,
      compression_level,
      do_fsync,
      dir_mode,
      file_mode,
    );
  }

  late final _git_odb_backend_loose_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_backend_loose>>(
          'git_odb_backend_loose');
  late final _dart_git_odb_backend_loose _git_odb_backend_loose =
      _git_odb_backend_loose_ptr.asFunction<_dart_git_odb_backend_loose>();

  /// Create a backend out of a single packfile
  ///
  /// This can be useful for inspecting the contents of a single
  /// packfile.
  ///
  /// @param out location to store the odb backend pointer
  /// @param index_file path to the packfile's .idx file
  ///
  /// @return 0 or an error code
  int git_odb_backend_one_pack(
    ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
    ffi.Pointer<ffi.Int8> index_file,
  ) {
    return _git_odb_backend_one_pack(
      out,
      index_file,
    );
  }

  late final _git_odb_backend_one_pack_ptr =
      _lookup<ffi.NativeFunction<_c_git_odb_backend_one_pack>>(
          'git_odb_backend_one_pack');
  late final _dart_git_odb_backend_one_pack _git_odb_backend_one_pack =
      _git_odb_backend_one_pack_ptr
          .asFunction<_dart_git_odb_backend_one_pack>();

  /// Return a patch for an entry in the diff list.
  ///
  /// The `git_patch` is a newly created object contains the text diffs
  /// for the delta.  You have to call `git_patch_free()` when you are
  /// done with it.  You can use the patch object to loop over all the hunks
  /// and lines in the diff of the one delta.
  ///
  /// For an unchanged file or a binary file, no `git_patch` will be
  /// created, the output will be set to NULL, and the `binary` flag will be
  /// set true in the `git_diff_delta` structure.
  ///
  /// It is okay to pass NULL for either of the output parameters; if you pass
  /// NULL for the `git_patch`, then the text diff will not be calculated.
  ///
  /// @param out Output parameter for the delta patch object
  /// @param diff Diff list object
  /// @param idx Index into diff list
  /// @return 0 on success, other value < 0 on error
  int git_patch_from_diff(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<git_diff> diff,
    int idx,
  ) {
    return _git_patch_from_diff(
      out,
      diff,
      idx,
    );
  }

  late final _git_patch_from_diff_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_from_diff>>(
          'git_patch_from_diff');
  late final _dart_git_patch_from_diff _git_patch_from_diff =
      _git_patch_from_diff_ptr.asFunction<_dart_git_patch_from_diff>();

  /// Directly generate a patch from the difference between two blobs.
  ///
  /// This is just like `git_diff_blobs()` except it generates a patch object
  /// for the difference instead of directly making callbacks.  You can use the
  /// standard `git_patch` accessor functions to read the patch data, and
  /// you must call `git_patch_free()` on the patch when done.
  ///
  /// @param out The generated patch; NULL on error
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param new_blob Blob for new side of diff, or NULL for empty blob
  /// @param new_as_path Treat new blob as if it had this filename; can be NULL
  /// @param opts Options for diff, or NULL for default options
  /// @return 0 on success or error code < 0
  int git_patch_from_blobs(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Int8> old_as_path,
    ffi.Pointer<git_blob> new_blob,
    ffi.Pointer<ffi.Int8> new_as_path,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_patch_from_blobs(
      out,
      old_blob,
      old_as_path,
      new_blob,
      new_as_path,
      opts,
    );
  }

  late final _git_patch_from_blobs_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_from_blobs>>(
          'git_patch_from_blobs');
  late final _dart_git_patch_from_blobs _git_patch_from_blobs =
      _git_patch_from_blobs_ptr.asFunction<_dart_git_patch_from_blobs>();

  /// Directly generate a patch from the difference between a blob and a buffer.
  ///
  /// This is just like `git_diff_blob_to_buffer()` except it generates a patch
  /// object for the difference instead of directly making callbacks.  You can
  /// use the standard `git_patch` accessor functions to read the patch
  /// data, and you must call `git_patch_free()` on the patch when done.
  ///
  /// @param out The generated patch; NULL on error
  /// @param old_blob Blob for old side of diff, or NULL for empty blob
  /// @param old_as_path Treat old blob as if it had this filename; can be NULL
  /// @param buffer Raw data for new side of diff, or NULL for empty
  /// @param buffer_len Length of raw data for new side of diff
  /// @param buffer_as_path Treat buffer as if it had this filename; can be NULL
  /// @param opts Options for diff, or NULL for default options
  /// @return 0 on success or error code < 0
  int git_patch_from_blob_and_buffer(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<git_blob> old_blob,
    ffi.Pointer<ffi.Int8> old_as_path,
    ffi.Pointer<ffi.Void> buffer,
    int buffer_len,
    ffi.Pointer<ffi.Int8> buffer_as_path,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_patch_from_blob_and_buffer(
      out,
      old_blob,
      old_as_path,
      buffer,
      buffer_len,
      buffer_as_path,
      opts,
    );
  }

  late final _git_patch_from_blob_and_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_from_blob_and_buffer>>(
          'git_patch_from_blob_and_buffer');
  late final _dart_git_patch_from_blob_and_buffer
      _git_patch_from_blob_and_buffer = _git_patch_from_blob_and_buffer_ptr
          .asFunction<_dart_git_patch_from_blob_and_buffer>();

  /// Directly generate a patch from the difference between two buffers.
  ///
  /// This is just like `git_diff_buffers()` except it generates a patch
  /// object for the difference instead of directly making callbacks.  You can
  /// use the standard `git_patch` accessor functions to read the patch
  /// data, and you must call `git_patch_free()` on the patch when done.
  ///
  /// @param out The generated patch; NULL on error
  /// @param old_buffer Raw data for old side of diff, or NULL for empty
  /// @param old_len Length of the raw data for old side of the diff
  /// @param old_as_path Treat old buffer as if it had this filename; can be NULL
  /// @param new_buffer Raw data for new side of diff, or NULL for empty
  /// @param new_len Length of raw data for new side of diff
  /// @param new_as_path Treat buffer as if it had this filename; can be NULL
  /// @param opts Options for diff, or NULL for default options
  /// @return 0 on success or error code < 0
  int git_patch_from_buffers(
    ffi.Pointer<ffi.Pointer<git_patch>> out,
    ffi.Pointer<ffi.Void> old_buffer,
    int old_len,
    ffi.Pointer<ffi.Int8> old_as_path,
    ffi.Pointer<ffi.Void> new_buffer,
    int new_len,
    ffi.Pointer<ffi.Int8> new_as_path,
    ffi.Pointer<git_diff_options> opts,
  ) {
    return _git_patch_from_buffers(
      out,
      old_buffer,
      old_len,
      old_as_path,
      new_buffer,
      new_len,
      new_as_path,
      opts,
    );
  }

  late final _git_patch_from_buffers_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_from_buffers>>(
          'git_patch_from_buffers');
  late final _dart_git_patch_from_buffers _git_patch_from_buffers =
      _git_patch_from_buffers_ptr.asFunction<_dart_git_patch_from_buffers>();

  /// Free a git_patch object.
  void git_patch_free(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_free(
      patch,
    );
  }

  late final _git_patch_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_free>>('git_patch_free');
  late final _dart_git_patch_free _git_patch_free =
      _git_patch_free_ptr.asFunction<_dart_git_patch_free>();

  /// Get the delta associated with a patch.  This delta points to internal
  /// data and you do not have to release it when you are done with it.
  ffi.Pointer<git_diff_delta> git_patch_get_delta(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_get_delta(
      patch,
    );
  }

  late final _git_patch_get_delta_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_get_delta>>(
          'git_patch_get_delta');
  late final _dart_git_patch_get_delta _git_patch_get_delta =
      _git_patch_get_delta_ptr.asFunction<_dart_git_patch_get_delta>();

  /// Get the number of hunks in a patch
  int git_patch_num_hunks(
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_num_hunks(
      patch,
    );
  }

  late final _git_patch_num_hunks_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_num_hunks>>(
          'git_patch_num_hunks');
  late final _dart_git_patch_num_hunks _git_patch_num_hunks =
      _git_patch_num_hunks_ptr.asFunction<_dart_git_patch_num_hunks>();

  /// Get line counts of each type in a patch.
  ///
  /// This helps imitate a diff --numstat type of output.  For that purpose,
  /// you only need the `total_additions` and `total_deletions` values, but we
  /// include the `total_context` line count in case you want the total number
  /// of lines of diff output that will be generated.
  ///
  /// All outputs are optional. Pass NULL if you don't need a particular count.
  ///
  /// @param total_context Count of context lines in output, can be NULL.
  /// @param total_additions Count of addition lines in output, can be NULL.
  /// @param total_deletions Count of deletion lines in output, can be NULL.
  /// @param patch The git_patch object
  /// @return 0 on success, <0 on error
  int git_patch_line_stats(
    ffi.Pointer<ffi.Int32> total_context,
    ffi.Pointer<ffi.Int32> total_additions,
    ffi.Pointer<ffi.Int32> total_deletions,
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_line_stats(
      total_context,
      total_additions,
      total_deletions,
      patch,
    );
  }

  late final _git_patch_line_stats_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_line_stats>>(
          'git_patch_line_stats');
  late final _dart_git_patch_line_stats _git_patch_line_stats =
      _git_patch_line_stats_ptr.asFunction<_dart_git_patch_line_stats>();

  /// Get the information about a hunk in a patch
  ///
  /// Given a patch and a hunk index into the patch, this returns detailed
  /// information about that hunk.  Any of the output pointers can be passed
  /// as NULL if you don't care about that particular piece of information.
  ///
  /// @param out Output pointer to git_diff_hunk of hunk
  /// @param lines_in_hunk Output count of total lines in this hunk
  /// @param patch Input pointer to patch object
  /// @param hunk_idx Input index of hunk to get information about
  /// @return 0 on success, GIT_ENOTFOUND if hunk_idx out of range, <0 on error
  int git_patch_get_hunk(
    ffi.Pointer<ffi.Pointer<git_diff_hunk>> out,
    ffi.Pointer<ffi.Int32> lines_in_hunk,
    ffi.Pointer<git_patch> patch,
    int hunk_idx,
  ) {
    return _git_patch_get_hunk(
      out,
      lines_in_hunk,
      patch,
      hunk_idx,
    );
  }

  late final _git_patch_get_hunk_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_get_hunk>>('git_patch_get_hunk');
  late final _dart_git_patch_get_hunk _git_patch_get_hunk =
      _git_patch_get_hunk_ptr.asFunction<_dart_git_patch_get_hunk>();

  /// Get the number of lines in a hunk.
  ///
  /// @param patch The git_patch object
  /// @param hunk_idx Index of the hunk
  /// @return Number of lines in hunk or GIT_ENOTFOUND if invalid hunk index
  int git_patch_num_lines_in_hunk(
    ffi.Pointer<git_patch> patch,
    int hunk_idx,
  ) {
    return _git_patch_num_lines_in_hunk(
      patch,
      hunk_idx,
    );
  }

  late final _git_patch_num_lines_in_hunk_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_num_lines_in_hunk>>(
          'git_patch_num_lines_in_hunk');
  late final _dart_git_patch_num_lines_in_hunk _git_patch_num_lines_in_hunk =
      _git_patch_num_lines_in_hunk_ptr
          .asFunction<_dart_git_patch_num_lines_in_hunk>();

  /// Get data about a line in a hunk of a patch.
  ///
  /// Given a patch, a hunk index, and a line index in the hunk, this
  /// will return a lot of details about that line.  If you pass a hunk
  /// index larger than the number of hunks or a line index larger than
  /// the number of lines in the hunk, this will return -1.
  ///
  /// @param out The git_diff_line data for this line
  /// @param patch The patch to look in
  /// @param hunk_idx The index of the hunk
  /// @param line_of_hunk The index of the line in the hunk
  /// @return 0 on success, <0 on failure
  int git_patch_get_line_in_hunk(
    ffi.Pointer<ffi.Pointer<git_diff_line>> out,
    ffi.Pointer<git_patch> patch,
    int hunk_idx,
    int line_of_hunk,
  ) {
    return _git_patch_get_line_in_hunk(
      out,
      patch,
      hunk_idx,
      line_of_hunk,
    );
  }

  late final _git_patch_get_line_in_hunk_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_get_line_in_hunk>>(
          'git_patch_get_line_in_hunk');
  late final _dart_git_patch_get_line_in_hunk _git_patch_get_line_in_hunk =
      _git_patch_get_line_in_hunk_ptr
          .asFunction<_dart_git_patch_get_line_in_hunk>();

  /// Look up size of patch diff data in bytes
  ///
  /// This returns the raw size of the patch data.  This only includes the
  /// actual data from the lines of the diff, not the file or hunk headers.
  ///
  /// If you pass `include_context` as true (non-zero), this will be the size
  /// of all of the diff output; if you pass it as false (zero), this will
  /// only include the actual changed lines (as if `context_lines` was 0).
  ///
  /// @param patch A git_patch representing changes to one file
  /// @param include_context Include context lines in size if non-zero
  /// @param include_hunk_headers Include hunk header lines if non-zero
  /// @param include_file_headers Include file header lines if non-zero
  /// @return The number of bytes of data
  int git_patch_size(
    ffi.Pointer<git_patch> patch,
    int include_context,
    int include_hunk_headers,
    int include_file_headers,
  ) {
    return _git_patch_size(
      patch,
      include_context,
      include_hunk_headers,
      include_file_headers,
    );
  }

  late final _git_patch_size_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_size>>('git_patch_size');
  late final _dart_git_patch_size _git_patch_size =
      _git_patch_size_ptr.asFunction<_dart_git_patch_size>();

  /// Serialize the patch to text via callback.
  ///
  /// Returning a non-zero value from the callback will terminate the iteration
  /// and return that value to the caller.
  ///
  /// @param patch A git_patch representing changes to one file
  /// @param print_cb Callback function to output lines of the patch.  Will be
  /// called for file headers, hunk headers, and diff lines.
  /// @param payload Reference pointer that will be passed to your callbacks.
  /// @return 0 on success, non-zero callback return value, or error code
  int git_patch_print(
    ffi.Pointer<git_patch> patch,
    ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> print_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_patch_print(
      patch,
      print_cb,
      payload,
    );
  }

  late final _git_patch_print_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_print>>('git_patch_print');
  late final _dart_git_patch_print _git_patch_print =
      _git_patch_print_ptr.asFunction<_dart_git_patch_print>();

  /// Get the content of a patch as a single diff text.
  ///
  /// @param out The git_buf to be filled in
  /// @param patch A git_patch representing changes to one file
  /// @return 0 on success, <0 on failure.
  int git_patch_to_buf(
    ffi.Pointer<git_buf> out,
    ffi.Pointer<git_patch> patch,
  ) {
    return _git_patch_to_buf(
      out,
      patch,
    );
  }

  late final _git_patch_to_buf_ptr =
      _lookup<ffi.NativeFunction<_c_git_patch_to_buf>>('git_patch_to_buf');
  late final _dart_git_patch_to_buf _git_patch_to_buf =
      _git_patch_to_buf_ptr.asFunction<_dart_git_patch_to_buf>();

  /// Compile a pathspec
  ///
  /// @param out Output of the compiled pathspec
  /// @param pathspec A git_strarray of the paths to match
  /// @return 0 on success, <0 on failure
  int git_pathspec_new(
    ffi.Pointer<ffi.Pointer<git_pathspec>> out,
    ffi.Pointer<git_strarray> pathspec,
  ) {
    return _git_pathspec_new(
      out,
      pathspec,
    );
  }

  late final _git_pathspec_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_new>>('git_pathspec_new');
  late final _dart_git_pathspec_new _git_pathspec_new =
      _git_pathspec_new_ptr.asFunction<_dart_git_pathspec_new>();

  /// Free a pathspec
  ///
  /// @param ps The compiled pathspec
  void git_pathspec_free(
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_free(
      ps,
    );
  }

  late final _git_pathspec_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_free>>('git_pathspec_free');
  late final _dart_git_pathspec_free _git_pathspec_free =
      _git_pathspec_free_ptr.asFunction<_dart_git_pathspec_free>();

  /// Try to match a path against a pathspec
  ///
  /// Unlike most of the other pathspec matching functions, this will not
  /// fall back on the native case-sensitivity for your platform.  You must
  /// explicitly pass flags to control case sensitivity or else this will
  /// fall back on being case sensitive.
  ///
  /// @param ps The compiled pathspec
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param path The pathname to attempt to match
  /// @return 1 is path matches spec, 0 if it does not
  int git_pathspec_matches_path(
    ffi.Pointer<git_pathspec> ps,
    int flags,
    ffi.Pointer<ffi.Int8> path,
  ) {
    return _git_pathspec_matches_path(
      ps,
      flags,
      path,
    );
  }

  late final _git_pathspec_matches_path_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_matches_path>>(
          'git_pathspec_matches_path');
  late final _dart_git_pathspec_matches_path _git_pathspec_matches_path =
      _git_pathspec_matches_path_ptr
          .asFunction<_dart_git_pathspec_matches_path>();

  /// Match a pathspec against the working directory of a repository.
  ///
  /// This matches the pathspec against the current files in the working
  /// directory of the repository.  It is an error to invoke this on a bare
  /// repo.  This handles git ignores (i.e. ignored files will not be
  /// considered to match the `pathspec` unless the file is tracked in the
  /// index).
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param repo The repository in which to match; bare repo is an error
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag was given
  int git_pathspec_match_workdir(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_repository> repo,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_workdir(
      out,
      repo,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_workdir_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_workdir>>(
          'git_pathspec_match_workdir');
  late final _dart_git_pathspec_match_workdir _git_pathspec_match_workdir =
      _git_pathspec_match_workdir_ptr
          .asFunction<_dart_git_pathspec_match_workdir>();

  /// Match a pathspec against entries in an index.
  ///
  /// This matches the pathspec against the files in the repository index.
  ///
  /// NOTE: At the moment, the case sensitivity of this match is controlled
  /// by the current case-sensitivity of the index object itself and the
  /// USE_CASE and IGNORE_CASE flags will have no effect.  This behavior will
  /// be corrected in a future release.
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param index The index to match against
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
  int git_pathspec_match_index(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_index> index,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_index(
      out,
      index,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_index_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_index>>(
          'git_pathspec_match_index');
  late final _dart_git_pathspec_match_index _git_pathspec_match_index =
      _git_pathspec_match_index_ptr
          .asFunction<_dart_git_pathspec_match_index>();

  /// Match a pathspec against files in a tree.
  ///
  /// This matches the pathspec against the files in the given tree.
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param tree The root-level tree to match against
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
  int git_pathspec_match_tree(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_tree> tree,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_tree(
      out,
      tree,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_tree_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_tree>>(
          'git_pathspec_match_tree');
  late final _dart_git_pathspec_match_tree _git_pathspec_match_tree =
      _git_pathspec_match_tree_ptr.asFunction<_dart_git_pathspec_match_tree>();

  /// Match a pathspec against files in a diff list.
  ///
  /// This matches the pathspec against the files in the given diff list.
  ///
  /// If `out` is not NULL, this returns a `git_patchspec_match_list`.  That
  /// contains the list of all matched filenames (unless you pass the
  /// `GIT_PATHSPEC_FAILURES_ONLY` flag) and may also contain the list of
  /// pathspecs with no match (if you used the `GIT_PATHSPEC_FIND_FAILURES`
  /// flag).  You must call `git_pathspec_match_list_free()` on this object.
  ///
  /// @param out Output list of matches; pass NULL to just get return value
  /// @param diff A generated diff list
  /// @param flags Combination of git_pathspec_flag_t options to control match
  /// @param ps Pathspec to be matched
  /// @return 0 on success, -1 on error, GIT_ENOTFOUND if no matches and
  /// the GIT_PATHSPEC_NO_MATCH_ERROR flag is used
  int git_pathspec_match_diff(
    ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
    ffi.Pointer<git_diff> diff,
    int flags,
    ffi.Pointer<git_pathspec> ps,
  ) {
    return _git_pathspec_match_diff(
      out,
      diff,
      flags,
      ps,
    );
  }

  late final _git_pathspec_match_diff_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_diff>>(
          'git_pathspec_match_diff');
  late final _dart_git_pathspec_match_diff _git_pathspec_match_diff =
      _git_pathspec_match_diff_ptr.asFunction<_dart_git_pathspec_match_diff>();

  /// Free memory associates with a git_pathspec_match_list
  ///
  /// @param m The git_pathspec_match_list to be freed
  void git_pathspec_match_list_free(
    ffi.Pointer<git_pathspec_match_list> m,
  ) {
    return _git_pathspec_match_list_free(
      m,
    );
  }

  late final _git_pathspec_match_list_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_list_free>>(
          'git_pathspec_match_list_free');
  late final _dart_git_pathspec_match_list_free _git_pathspec_match_list_free =
      _git_pathspec_match_list_free_ptr
          .asFunction<_dart_git_pathspec_match_list_free>();

  /// Get the number of items in a match list.
  ///
  /// @param m The git_pathspec_match_list object
  /// @return Number of items in match list
  int git_pathspec_match_list_entrycount(
    ffi.Pointer<git_pathspec_match_list> m,
  ) {
    return _git_pathspec_match_list_entrycount(
      m,
    );
  }

  late final _git_pathspec_match_list_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_list_entrycount>>(
          'git_pathspec_match_list_entrycount');
  late final _dart_git_pathspec_match_list_entrycount
      _git_pathspec_match_list_entrycount =
      _git_pathspec_match_list_entrycount_ptr
          .asFunction<_dart_git_pathspec_match_list_entrycount>();

  /// Get a matching filename by position.
  ///
  /// This routine cannot be used if the match list was generated by
  /// `git_pathspec_match_diff`.  If so, it will always return NULL.
  ///
  /// @param m The git_pathspec_match_list object
  /// @param pos The index into the list
  /// @return The filename of the match
  ffi.Pointer<ffi.Int8> git_pathspec_match_list_entry(
    ffi.Pointer<git_pathspec_match_list> m,
    int pos,
  ) {
    return _git_pathspec_match_list_entry(
      m,
      pos,
    );
  }

  late final _git_pathspec_match_list_entry_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_list_entry>>(
          'git_pathspec_match_list_entry');
  late final _dart_git_pathspec_match_list_entry
      _git_pathspec_match_list_entry = _git_pathspec_match_list_entry_ptr
          .asFunction<_dart_git_pathspec_match_list_entry>();

  /// Get a matching diff delta by position.
  ///
  /// This routine can only be used if the match list was generated by
  /// `git_pathspec_match_diff`.  Otherwise it will always return NULL.
  ///
  /// @param m The git_pathspec_match_list object
  /// @param pos The index into the list
  /// @return The filename of the match
  ffi.Pointer<git_diff_delta> git_pathspec_match_list_diff_entry(
    ffi.Pointer<git_pathspec_match_list> m,
    int pos,
  ) {
    return _git_pathspec_match_list_diff_entry(
      m,
      pos,
    );
  }

  late final _git_pathspec_match_list_diff_entry_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_list_diff_entry>>(
          'git_pathspec_match_list_diff_entry');
  late final _dart_git_pathspec_match_list_diff_entry
      _git_pathspec_match_list_diff_entry =
      _git_pathspec_match_list_diff_entry_ptr
          .asFunction<_dart_git_pathspec_match_list_diff_entry>();

  /// Get the number of pathspec items that did not match.
  ///
  /// This will be zero unless you passed GIT_PATHSPEC_FIND_FAILURES when
  /// generating the git_pathspec_match_list.
  ///
  /// @param m The git_pathspec_match_list object
  /// @return Number of items in original pathspec that had no matches
  int git_pathspec_match_list_failed_entrycount(
    ffi.Pointer<git_pathspec_match_list> m,
  ) {
    return _git_pathspec_match_list_failed_entrycount(
      m,
    );
  }

  late final _git_pathspec_match_list_failed_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_list_failed_entrycount>>(
          'git_pathspec_match_list_failed_entrycount');
  late final _dart_git_pathspec_match_list_failed_entrycount
      _git_pathspec_match_list_failed_entrycount =
      _git_pathspec_match_list_failed_entrycount_ptr
          .asFunction<_dart_git_pathspec_match_list_failed_entrycount>();

  /// Get an original pathspec string that had no matches.
  ///
  /// This will be return NULL for positions out of range.
  ///
  /// @param m The git_pathspec_match_list object
  /// @param pos The index into the failed items
  /// @return The pathspec pattern that didn't match anything
  ffi.Pointer<ffi.Int8> git_pathspec_match_list_failed_entry(
    ffi.Pointer<git_pathspec_match_list> m,
    int pos,
  ) {
    return _git_pathspec_match_list_failed_entry(
      m,
      pos,
    );
  }

  late final _git_pathspec_match_list_failed_entry_ptr =
      _lookup<ffi.NativeFunction<_c_git_pathspec_match_list_failed_entry>>(
          'git_pathspec_match_list_failed_entry');
  late final _dart_git_pathspec_match_list_failed_entry
      _git_pathspec_match_list_failed_entry =
      _git_pathspec_match_list_failed_entry_ptr
          .asFunction<_dart_git_pathspec_match_list_failed_entry>();

  /// Create a new reference database with no backends.
  ///
  /// Before the Ref DB can be used for read/writing, a custom database
  /// backend must be manually set using `git_refdb_set_backend()`
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @param repo the repository
  /// @return 0 or an error code
  int git_refdb_new(
    ffi.Pointer<ffi.Pointer<git_refdb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_refdb_new(
      out,
      repo,
    );
  }

  late final _git_refdb_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_refdb_new>>('git_refdb_new');
  late final _dart_git_refdb_new _git_refdb_new =
      _git_refdb_new_ptr.asFunction<_dart_git_refdb_new>();

  /// Create a new reference database and automatically add
  /// the default backends:
  ///
  /// - git_refdb_dir: read and write loose and packed refs
  /// from disk, assuming the repository dir as the folder
  ///
  /// @param out location to store the database pointer, if opened.
  /// Set to NULL if the open failed.
  /// @param repo the repository
  /// @return 0 or an error code
  int git_refdb_open(
    ffi.Pointer<ffi.Pointer<git_refdb>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_refdb_open(
      out,
      repo,
    );
  }

  late final _git_refdb_open_ptr =
      _lookup<ffi.NativeFunction<_c_git_refdb_open>>('git_refdb_open');
  late final _dart_git_refdb_open _git_refdb_open =
      _git_refdb_open_ptr.asFunction<_dart_git_refdb_open>();

  /// Suggests that the given refdb compress or optimize its references.
  /// This mechanism is implementation specific.  For on-disk reference
  /// databases, for example, this may pack all loose references.
  int git_refdb_compress(
    ffi.Pointer<git_refdb> refdb,
  ) {
    return _git_refdb_compress(
      refdb,
    );
  }

  late final _git_refdb_compress_ptr =
      _lookup<ffi.NativeFunction<_c_git_refdb_compress>>('git_refdb_compress');
  late final _dart_git_refdb_compress _git_refdb_compress =
      _git_refdb_compress_ptr.asFunction<_dart_git_refdb_compress>();

  /// Close an open reference database.
  ///
  /// @param refdb reference database pointer or NULL
  void git_refdb_free(
    ffi.Pointer<git_refdb> refdb,
  ) {
    return _git_refdb_free(
      refdb,
    );
  }

  late final _git_refdb_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_refdb_free>>('git_refdb_free');
  late final _dart_git_refdb_free _git_refdb_free =
      _git_refdb_free_ptr.asFunction<_dart_git_refdb_free>();

  /// Read the reflog for the given reference
  ///
  /// If there is no reflog file for the given
  /// reference yet, an empty reflog object will
  /// be returned.
  ///
  /// The reflog must be freed manually by using
  /// git_reflog_free().
  ///
  /// @param out pointer to reflog
  /// @param repo the repostiory
  /// @param name reference to look up
  /// @return 0 or an error code
  int git_reflog_read(
    ffi.Pointer<ffi.Pointer<git_reflog>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_reflog_read(
      out,
      repo,
      name,
    );
  }

  late final _git_reflog_read_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_read>>('git_reflog_read');
  late final _dart_git_reflog_read _git_reflog_read =
      _git_reflog_read_ptr.asFunction<_dart_git_reflog_read>();

  /// Write an existing in-memory reflog object back to disk
  /// using an atomic file lock.
  ///
  /// @param reflog an existing reflog object
  /// @return 0 or an error code
  int git_reflog_write(
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_reflog_write(
      reflog,
    );
  }

  late final _git_reflog_write_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_write>>('git_reflog_write');
  late final _dart_git_reflog_write _git_reflog_write =
      _git_reflog_write_ptr.asFunction<_dart_git_reflog_write>();

  /// Add a new entry to the in-memory reflog.
  ///
  /// `msg` is optional and can be NULL.
  ///
  /// @param reflog an existing reflog object
  /// @param id the OID the reference is now pointing to
  /// @param committer the signature of the committer
  /// @param msg the reflog message
  /// @return 0 or an error code
  int git_reflog_append(
    ffi.Pointer<git_reflog> reflog,
    ffi.Pointer<git_oid> id,
    ffi.Pointer<git_signature> committer,
    ffi.Pointer<ffi.Int8> msg,
  ) {
    return _git_reflog_append(
      reflog,
      id,
      committer,
      msg,
    );
  }

  late final _git_reflog_append_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_append>>('git_reflog_append');
  late final _dart_git_reflog_append _git_reflog_append =
      _git_reflog_append_ptr.asFunction<_dart_git_reflog_append>();

  /// Rename a reflog
  ///
  /// The reflog to be renamed is expected to already exist
  ///
  /// The new name will be checked for validity.
  /// See `git_reference_create_symbolic()` for rules about valid names.
  ///
  /// @param repo the repository
  /// @param old_name the old name of the reference
  /// @param name the new name of the reference
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  int git_reflog_rename(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> old_name,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_reflog_rename(
      repo,
      old_name,
      name,
    );
  }

  late final _git_reflog_rename_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_rename>>('git_reflog_rename');
  late final _dart_git_reflog_rename _git_reflog_rename =
      _git_reflog_rename_ptr.asFunction<_dart_git_reflog_rename>();

  /// Delete the reflog for the given reference
  ///
  /// @param repo the repository
  /// @param name the reflog to delete
  /// @return 0 or an error code
  int git_reflog_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> name,
  ) {
    return _git_reflog_delete(
      repo,
      name,
    );
  }

  late final _git_reflog_delete_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_delete>>('git_reflog_delete');
  late final _dart_git_reflog_delete _git_reflog_delete =
      _git_reflog_delete_ptr.asFunction<_dart_git_reflog_delete>();

  /// Get the number of log entries in a reflog
  ///
  /// @param reflog the previously loaded reflog
  /// @return the number of log entries
  int git_reflog_entrycount(
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_reflog_entrycount(
      reflog,
    );
  }

  late final _git_reflog_entrycount_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_entrycount>>(
          'git_reflog_entrycount');
  late final _dart_git_reflog_entrycount _git_reflog_entrycount =
      _git_reflog_entrycount_ptr.asFunction<_dart_git_reflog_entrycount>();

  /// Lookup an entry by its index
  ///
  /// Requesting the reflog entry with an index of 0 (zero) will
  /// return the most recently created entry.
  ///
  /// @param reflog a previously loaded reflog
  /// @param idx the position of the entry to lookup. Should be greater than or
  /// equal to 0 (zero) and less than `git_reflog_entrycount()`.
  /// @return the entry; NULL if not found
  ffi.Pointer<git_reflog_entry> git_reflog_entry_byindex(
    ffi.Pointer<git_reflog> reflog,
    int idx,
  ) {
    return _git_reflog_entry_byindex(
      reflog,
      idx,
    );
  }

  late final _git_reflog_entry_byindex_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_entry_byindex>>(
          'git_reflog_entry_byindex');
  late final _dart_git_reflog_entry_byindex _git_reflog_entry_byindex =
      _git_reflog_entry_byindex_ptr
          .asFunction<_dart_git_reflog_entry_byindex>();

  /// Remove an entry from the reflog by its index
  ///
  /// To ensure there's no gap in the log history, set `rewrite_previous_entry`
  /// param value to 1. When deleting entry `n`, member old_oid of entry `n-1`
  /// (if any) will be updated with the value of member new_oid of entry `n+1`.
  ///
  /// @param reflog a previously loaded reflog.
  ///
  /// @param idx the position of the entry to remove. Should be greater than or
  /// equal to 0 (zero) and less than `git_reflog_entrycount()`.
  ///
  /// @param rewrite_previous_entry 1 to rewrite the history; 0 otherwise.
  ///
  /// @return 0 on success, GIT_ENOTFOUND if the entry doesn't exist
  /// or an error code.
  int git_reflog_drop(
    ffi.Pointer<git_reflog> reflog,
    int idx,
    int rewrite_previous_entry,
  ) {
    return _git_reflog_drop(
      reflog,
      idx,
      rewrite_previous_entry,
    );
  }

  late final _git_reflog_drop_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_drop>>('git_reflog_drop');
  late final _dart_git_reflog_drop _git_reflog_drop =
      _git_reflog_drop_ptr.asFunction<_dart_git_reflog_drop>();

  /// Get the old oid
  ///
  /// @param entry a reflog entry
  /// @return the old oid
  ffi.Pointer<git_oid> git_reflog_entry_id_old(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_id_old(
      entry,
    );
  }

  late final _git_reflog_entry_id_old_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_entry_id_old>>(
          'git_reflog_entry_id_old');
  late final _dart_git_reflog_entry_id_old _git_reflog_entry_id_old =
      _git_reflog_entry_id_old_ptr.asFunction<_dart_git_reflog_entry_id_old>();

  /// Get the new oid
  ///
  /// @param entry a reflog entry
  /// @return the new oid at this time
  ffi.Pointer<git_oid> git_reflog_entry_id_new(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_id_new(
      entry,
    );
  }

  late final _git_reflog_entry_id_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_entry_id_new>>(
          'git_reflog_entry_id_new');
  late final _dart_git_reflog_entry_id_new _git_reflog_entry_id_new =
      _git_reflog_entry_id_new_ptr.asFunction<_dart_git_reflog_entry_id_new>();

  /// Get the committer of this entry
  ///
  /// @param entry a reflog entry
  /// @return the committer
  ffi.Pointer<git_signature> git_reflog_entry_committer(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_committer(
      entry,
    );
  }

  late final _git_reflog_entry_committer_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_entry_committer>>(
          'git_reflog_entry_committer');
  late final _dart_git_reflog_entry_committer _git_reflog_entry_committer =
      _git_reflog_entry_committer_ptr
          .asFunction<_dart_git_reflog_entry_committer>();

  /// Get the log message
  ///
  /// @param entry a reflog entry
  /// @return the log msg
  ffi.Pointer<ffi.Int8> git_reflog_entry_message(
    ffi.Pointer<git_reflog_entry> entry,
  ) {
    return _git_reflog_entry_message(
      entry,
    );
  }

  late final _git_reflog_entry_message_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_entry_message>>(
          'git_reflog_entry_message');
  late final _dart_git_reflog_entry_message _git_reflog_entry_message =
      _git_reflog_entry_message_ptr
          .asFunction<_dart_git_reflog_entry_message>();

  /// Free the reflog
  ///
  /// @param reflog reflog to free
  void git_reflog_free(
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_reflog_free(
      reflog,
    );
  }

  late final _git_reflog_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_reflog_free>>('git_reflog_free');
  late final _dart_git_reflog_free _git_reflog_free =
      _git_reflog_free_ptr.asFunction<_dart_git_reflog_free>();

  /// Sets the current head to the specified commit oid and optionally
  /// resets the index and working tree to match.
  ///
  /// SOFT reset means the Head will be moved to the commit.
  ///
  /// MIXED reset will trigger a SOFT reset, plus the index will be replaced
  /// with the content of the commit tree.
  ///
  /// HARD reset will trigger a MIXED reset and the working directory will be
  /// replaced with the content of the index.  (Untracked and ignored files
  /// will be left alone, however.)
  ///
  /// TODO: Implement remaining kinds of resets.
  ///
  /// @param repo Repository where to perform the reset operation.
  ///
  /// @param target Committish to which the Head should be moved to. This object
  /// must belong to the given `repo` and can either be a git_commit or a
  /// git_tag. When a git_tag is being passed, it should be dereferencable
  /// to a git_commit which oid will be used as the target of the branch.
  ///
  /// @param reset_type Kind of reset operation to perform.
  ///
  /// @param checkout_opts Optional checkout options to be used for a HARD reset.
  /// The checkout_strategy field will be overridden (based on reset_type).
  /// This parameter can be used to propagate notify and progress callbacks.
  ///
  /// @return 0 on success or an error code
  int git_reset(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> target,
    int reset_type,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _git_reset(
      repo,
      target,
      reset_type,
      checkout_opts,
    );
  }

  late final _git_reset_ptr =
      _lookup<ffi.NativeFunction<_c_git_reset>>('git_reset');
  late final _dart_git_reset _git_reset =
      _git_reset_ptr.asFunction<_dart_git_reset>();

  /// Sets the current head to the specified commit oid and optionally
  /// resets the index and working tree to match.
  ///
  /// This behaves like `git_reset()` but takes an annotated commit,
  /// which lets you specify which extended sha syntax string was
  /// specified by a user, allowing for more exact reflog messages.
  ///
  /// See the documentation for `git_reset()`.
  ///
  /// @see git_reset
  int git_reset_from_annotated(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_annotated_commit> commit,
    int reset_type,
    ffi.Pointer<git_checkout_options> checkout_opts,
  ) {
    return _git_reset_from_annotated(
      repo,
      commit,
      reset_type,
      checkout_opts,
    );
  }

  late final _git_reset_from_annotated_ptr =
      _lookup<ffi.NativeFunction<_c_git_reset_from_annotated>>(
          'git_reset_from_annotated');
  late final _dart_git_reset_from_annotated _git_reset_from_annotated =
      _git_reset_from_annotated_ptr
          .asFunction<_dart_git_reset_from_annotated>();

  /// Updates some entries in the index from the target commit tree.
  ///
  /// The scope of the updated entries is determined by the paths
  /// being passed in the `pathspec` parameters.
  ///
  /// Passing a NULL `target` will result in removing
  /// entries in the index matching the provided pathspecs.
  ///
  /// @param repo Repository where to perform the reset operation.
  ///
  /// @param target The committish which content will be used to reset the content
  /// of the index.
  ///
  /// @param pathspecs List of pathspecs to operate on.
  ///
  /// @return 0 on success or an error code < 0
  int git_reset_default(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_strarray> pathspecs,
  ) {
    return _git_reset_default(
      repo,
      target,
      pathspecs,
    );
  }

  late final _git_reset_default_ptr =
      _lookup<ffi.NativeFunction<_c_git_reset_default>>('git_reset_default');
  late final _dart_git_reset_default _git_reset_default =
      _git_reset_default_ptr.asFunction<_dart_git_reset_default>();

  /// Find a single object, as specified by a revision string.
  ///
  /// See `man gitrevisions`, or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// The returned object should be released with `git_object_free` when no
  /// longer needed.
  ///
  /// @param out pointer to output object
  /// @param repo the repository to search in
  /// @param spec the textual specification for an object
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EAMBIGUOUS, GIT_EINVALIDSPEC or an error code
  int git_revparse_single(
    ffi.Pointer<ffi.Pointer<git_object>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> spec,
  ) {
    return _git_revparse_single(
      out,
      repo,
      spec,
    );
  }

  late final _git_revparse_single_ptr =
      _lookup<ffi.NativeFunction<_c_git_revparse_single>>(
          'git_revparse_single');
  late final _dart_git_revparse_single _git_revparse_single =
      _git_revparse_single_ptr.asFunction<_dart_git_revparse_single>();

  /// Find a single object and intermediate reference by a revision string.
  ///
  /// See `man gitrevisions`, or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// In some cases (`@{<-n>}` or `<branchname>@{upstream}`), the expression may
  /// point to an intermediate reference. When such expressions are being passed
  /// in, `reference_out` will be valued as well.
  ///
  /// The returned object should be released with `git_object_free` and the
  /// returned reference with `git_reference_free` when no longer needed.
  ///
  /// @param object_out pointer to output object
  /// @param reference_out pointer to output reference or NULL
  /// @param repo the repository to search in
  /// @param spec the textual specification for an object
  /// @return 0 on success, GIT_ENOTFOUND, GIT_EAMBIGUOUS, GIT_EINVALIDSPEC
  /// or an error code
  int git_revparse_ext(
    ffi.Pointer<ffi.Pointer<git_object>> object_out,
    ffi.Pointer<ffi.Pointer<git_reference>> reference_out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> spec,
  ) {
    return _git_revparse_ext(
      object_out,
      reference_out,
      repo,
      spec,
    );
  }

  late final _git_revparse_ext_ptr =
      _lookup<ffi.NativeFunction<_c_git_revparse_ext>>('git_revparse_ext');
  late final _dart_git_revparse_ext _git_revparse_ext =
      _git_revparse_ext_ptr.asFunction<_dart_git_revparse_ext>();

  /// Parse a revision string for `from`, `to`, and intent.
  ///
  /// See `man gitrevisions` or
  /// http://git-scm.com/docs/git-rev-parse.html#_specifying_revisions for
  /// information on the syntax accepted.
  ///
  /// @param revspec Pointer to an user-allocated git_revspec struct where
  /// the result of the rev-parse will be stored
  /// @param repo the repository to search in
  /// @param spec the rev-parse spec to parse
  /// @return 0 on success, GIT_INVALIDSPEC, GIT_ENOTFOUND, GIT_EAMBIGUOUS or an error code
  int git_revparse(
    ffi.Pointer<git_revspec> revspec,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> spec,
  ) {
    return _git_revparse(
      revspec,
      repo,
      spec,
    );
  }

  late final _git_revparse_ptr =
      _lookup<ffi.NativeFunction<_c_git_revparse>>('git_revparse');
  late final _dart_git_revparse _git_revparse =
      _git_revparse_ptr.asFunction<_dart_git_revparse>();

  /// Allocate a new revision walker to iterate through a repo.
  ///
  /// This revision walker uses a custom memory pool and an internal
  /// commit cache, so it is relatively expensive to allocate.
  ///
  /// For maximum performance, this revision walker should be
  /// reused for different walks.
  ///
  /// This revision walker is *not* thread safe: it may only be
  /// used to walk a repository on a single thread; however,
  /// it is possible to have several revision walkers in
  /// several different threads walking the same repository.
  ///
  /// @param out pointer to the new revision walker
  /// @param repo the repo to walk through
  /// @return 0 or an error code
  int git_revwalk_new(
    ffi.Pointer<ffi.Pointer<git_revwalk>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_revwalk_new(
      out,
      repo,
    );
  }

  late final _git_revwalk_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_new>>('git_revwalk_new');
  late final _dart_git_revwalk_new _git_revwalk_new =
      _git_revwalk_new_ptr.asFunction<_dart_git_revwalk_new>();

  /// Reset the revision walker for reuse.
  ///
  /// This will clear all the pushed and hidden commits, and
  /// leave the walker in a blank state (just like at
  /// creation) ready to receive new commit pushes and
  /// start a new walk.
  ///
  /// The revision walk is automatically reset when a walk
  /// is over.
  ///
  /// @param walker handle to reset.
  /// @return 0 or an error code
  int git_revwalk_reset(
    ffi.Pointer<git_revwalk> walker,
  ) {
    return _git_revwalk_reset(
      walker,
    );
  }

  late final _git_revwalk_reset_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_reset>>('git_revwalk_reset');
  late final _dart_git_revwalk_reset _git_revwalk_reset =
      _git_revwalk_reset_ptr.asFunction<_dart_git_revwalk_reset>();

  /// Add a new root for the traversal
  ///
  /// The pushed commit will be marked as one of the roots from which to
  /// start the walk. This commit may not be walked if it or a child is
  /// hidden.
  ///
  /// At least one commit must be pushed onto the walker before a walk
  /// can be started.
  ///
  /// The given id must belong to a committish on the walked
  /// repository.
  ///
  /// @param walk the walker being used for the traversal.
  /// @param id the oid of the commit to start from.
  /// @return 0 or an error code
  int git_revwalk_push(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_revwalk_push(
      walk,
      id,
    );
  }

  late final _git_revwalk_push_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_push>>('git_revwalk_push');
  late final _dart_git_revwalk_push _git_revwalk_push =
      _git_revwalk_push_ptr.asFunction<_dart_git_revwalk_push>();

  /// Push matching references
  ///
  /// The OIDs pointed to by the references that match the given glob
  /// pattern will be pushed to the revision walker.
  ///
  /// A leading 'refs/' is implied if not present as well as a trailing
  /// '/\*' if the glob lacks '?', '\*' or '['.
  ///
  /// Any references matching this glob which do not point to a
  /// committish will be ignored.
  ///
  /// @param walk the walker being used for the traversal
  /// @param glob the glob pattern references should match
  /// @return 0 or an error code
  int git_revwalk_push_glob(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Int8> glob,
  ) {
    return _git_revwalk_push_glob(
      walk,
      glob,
    );
  }

  late final _git_revwalk_push_glob_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_push_glob>>(
          'git_revwalk_push_glob');
  late final _dart_git_revwalk_push_glob _git_revwalk_push_glob =
      _git_revwalk_push_glob_ptr.asFunction<_dart_git_revwalk_push_glob>();

  /// Push the repository's HEAD
  ///
  /// @param walk the walker being used for the traversal
  /// @return 0 or an error code
  int git_revwalk_push_head(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_push_head(
      walk,
    );
  }

  late final _git_revwalk_push_head_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_push_head>>(
          'git_revwalk_push_head');
  late final _dart_git_revwalk_push_head _git_revwalk_push_head =
      _git_revwalk_push_head_ptr.asFunction<_dart_git_revwalk_push_head>();

  /// Mark a commit (and its ancestors) uninteresting for the output.
  ///
  /// The given id must belong to a committish on the walked
  /// repository.
  ///
  /// The resolved commit and all its parents will be hidden from the
  /// output on the revision walk.
  ///
  /// @param walk the walker being used for the traversal.
  /// @param commit_id the oid of commit that will be ignored during the traversal
  /// @return 0 or an error code
  int git_revwalk_hide(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<git_oid> commit_id,
  ) {
    return _git_revwalk_hide(
      walk,
      commit_id,
    );
  }

  late final _git_revwalk_hide_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_hide>>('git_revwalk_hide');
  late final _dart_git_revwalk_hide _git_revwalk_hide =
      _git_revwalk_hide_ptr.asFunction<_dart_git_revwalk_hide>();

  /// Hide matching references.
  ///
  /// The OIDs pointed to by the references that match the given glob
  /// pattern and their ancestors will be hidden from the output on the
  /// revision walk.
  ///
  /// A leading 'refs/' is implied if not present as well as a trailing
  /// '/\*' if the glob lacks '?', '\*' or '['.
  ///
  /// Any references matching this glob which do not point to a
  /// committish will be ignored.
  ///
  /// @param walk the walker being used for the traversal
  /// @param glob the glob pattern references should match
  /// @return 0 or an error code
  int git_revwalk_hide_glob(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Int8> glob,
  ) {
    return _git_revwalk_hide_glob(
      walk,
      glob,
    );
  }

  late final _git_revwalk_hide_glob_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_hide_glob>>(
          'git_revwalk_hide_glob');
  late final _dart_git_revwalk_hide_glob _git_revwalk_hide_glob =
      _git_revwalk_hide_glob_ptr.asFunction<_dart_git_revwalk_hide_glob>();

  /// Hide the repository's HEAD
  ///
  /// @param walk the walker being used for the traversal
  /// @return 0 or an error code
  int git_revwalk_hide_head(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_hide_head(
      walk,
    );
  }

  late final _git_revwalk_hide_head_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_hide_head>>(
          'git_revwalk_hide_head');
  late final _dart_git_revwalk_hide_head _git_revwalk_hide_head =
      _git_revwalk_hide_head_ptr.asFunction<_dart_git_revwalk_hide_head>();

  /// Push the OID pointed to by a reference
  ///
  /// The reference must point to a committish.
  ///
  /// @param walk the walker being used for the traversal
  /// @param refname the reference to push
  /// @return 0 or an error code
  int git_revwalk_push_ref(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_revwalk_push_ref(
      walk,
      refname,
    );
  }

  late final _git_revwalk_push_ref_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_push_ref>>(
          'git_revwalk_push_ref');
  late final _dart_git_revwalk_push_ref _git_revwalk_push_ref =
      _git_revwalk_push_ref_ptr.asFunction<_dart_git_revwalk_push_ref>();

  /// Hide the OID pointed to by a reference
  ///
  /// The reference must point to a committish.
  ///
  /// @param walk the walker being used for the traversal
  /// @param refname the reference to hide
  /// @return 0 or an error code
  int git_revwalk_hide_ref(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_revwalk_hide_ref(
      walk,
      refname,
    );
  }

  late final _git_revwalk_hide_ref_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_hide_ref>>(
          'git_revwalk_hide_ref');
  late final _dart_git_revwalk_hide_ref _git_revwalk_hide_ref =
      _git_revwalk_hide_ref_ptr.asFunction<_dart_git_revwalk_hide_ref>();

  /// Get the next commit from the revision walk.
  ///
  /// The initial call to this method is *not* blocking when
  /// iterating through a repo with a time-sorting mode.
  ///
  /// Iterating with Topological or inverted modes makes the initial
  /// call blocking to preprocess the commit list, but this block should be
  /// mostly unnoticeable on most repositories (topological preprocessing
  /// times at 0.3s on the git.git repo).
  ///
  /// The revision walker is reset when the walk is over.
  ///
  /// @param out Pointer where to store the oid of the next commit
  /// @param walk the walker to pop the commit from.
  /// @return 0 if the next commit was found;
  /// GIT_ITEROVER if there are no commits left to iterate
  int git_revwalk_next(
    ffi.Pointer<git_oid> out,
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_next(
      out,
      walk,
    );
  }

  late final _git_revwalk_next_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_next>>('git_revwalk_next');
  late final _dart_git_revwalk_next _git_revwalk_next =
      _git_revwalk_next_ptr.asFunction<_dart_git_revwalk_next>();

  /// Change the sorting mode when iterating through the
  /// repository's contents.
  ///
  /// Changing the sorting mode resets the walker.
  ///
  /// @param walk the walker being used for the traversal.
  /// @param sort_mode combination of GIT_SORT_XXX flags
  /// @return 0 or an error code
  int git_revwalk_sorting(
    ffi.Pointer<git_revwalk> walk,
    int sort_mode,
  ) {
    return _git_revwalk_sorting(
      walk,
      sort_mode,
    );
  }

  late final _git_revwalk_sorting_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_sorting>>(
          'git_revwalk_sorting');
  late final _dart_git_revwalk_sorting _git_revwalk_sorting =
      _git_revwalk_sorting_ptr.asFunction<_dart_git_revwalk_sorting>();

  /// Push and hide the respective endpoints of the given range.
  ///
  /// The range should be of the form
  /// <commit>..<commit>
  /// where each <commit> is in the form accepted by 'git_revparse_single'.
  /// The left-hand commit will be hidden and the right-hand commit pushed.
  ///
  /// @param walk the walker being used for the traversal
  /// @param range the range
  /// @return 0 or an error code
  int git_revwalk_push_range(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.Int8> range,
  ) {
    return _git_revwalk_push_range(
      walk,
      range,
    );
  }

  late final _git_revwalk_push_range_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_push_range>>(
          'git_revwalk_push_range');
  late final _dart_git_revwalk_push_range _git_revwalk_push_range =
      _git_revwalk_push_range_ptr.asFunction<_dart_git_revwalk_push_range>();

  /// Simplify the history by first-parent
  ///
  /// No parents other than the first for each commit will be enqueued.
  ///
  /// @return 0 or an error code
  int git_revwalk_simplify_first_parent(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_simplify_first_parent(
      walk,
    );
  }

  late final _git_revwalk_simplify_first_parent_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_simplify_first_parent>>(
          'git_revwalk_simplify_first_parent');
  late final _dart_git_revwalk_simplify_first_parent
      _git_revwalk_simplify_first_parent =
      _git_revwalk_simplify_first_parent_ptr
          .asFunction<_dart_git_revwalk_simplify_first_parent>();

  /// Free a revision walker previously allocated.
  ///
  /// @param walk traversal handle to close. If NULL nothing occurs.
  void git_revwalk_free(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_free(
      walk,
    );
  }

  late final _git_revwalk_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_free>>('git_revwalk_free');
  late final _dart_git_revwalk_free _git_revwalk_free =
      _git_revwalk_free_ptr.asFunction<_dart_git_revwalk_free>();

  /// Return the repository on which this walker
  /// is operating.
  ///
  /// @param walk the revision walker
  /// @return the repository being walked
  ffi.Pointer<git_repository> git_revwalk_repository(
    ffi.Pointer<git_revwalk> walk,
  ) {
    return _git_revwalk_repository(
      walk,
    );
  }

  late final _git_revwalk_repository_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_repository>>(
          'git_revwalk_repository');
  late final _dart_git_revwalk_repository _git_revwalk_repository =
      _git_revwalk_repository_ptr.asFunction<_dart_git_revwalk_repository>();

  /// Adds, changes or removes a callback function to hide a commit and its parents
  ///
  /// @param walk the revision walker
  /// @param hide_cb  callback function to hide a commit and its parents
  /// @param payload  data payload to be passed to callback function
  int git_revwalk_add_hide_cb(
    ffi.Pointer<git_revwalk> walk,
    ffi.Pointer<ffi.NativeFunction<git_revwalk_hide_cb>> hide_cb,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_revwalk_add_hide_cb(
      walk,
      hide_cb,
      payload,
    );
  }

  late final _git_revwalk_add_hide_cb_ptr =
      _lookup<ffi.NativeFunction<_c_git_revwalk_add_hide_cb>>(
          'git_revwalk_add_hide_cb');
  late final _dart_git_revwalk_add_hide_cb _git_revwalk_add_hide_cb =
      _git_revwalk_add_hide_cb_ptr.asFunction<_dart_git_revwalk_add_hide_cb>();

  /// Create a new action signature.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// Note: angle brackets ('<' and '>') characters are not allowed
  /// to be used in either the `name` or the `email` parameter.
  ///
  /// @param out new signature, in case of error NULL
  /// @param name name of the person
  /// @param email email of the person
  /// @param time time (in seconds from epoch) when the action happened
  /// @param offset timezone offset (in minutes) for the time
  /// @return 0 or an error code
  int git_signature_new(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> email,
    int time,
    int offset,
  ) {
    return _git_signature_new(
      out,
      name,
      email,
      time,
      offset,
    );
  }

  late final _git_signature_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_signature_new>>('git_signature_new');
  late final _dart_git_signature_new _git_signature_new =
      _git_signature_new_ptr.asFunction<_dart_git_signature_new>();

  /// Create a new action signature with a timestamp of 'now'.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param out new signature, in case of error NULL
  /// @param name name of the person
  /// @param email email of the person
  /// @return 0 or an error code
  int git_signature_now(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> email,
  ) {
    return _git_signature_now(
      out,
      name,
      email,
    );
  }

  late final _git_signature_now_ptr =
      _lookup<ffi.NativeFunction<_c_git_signature_now>>('git_signature_now');
  late final _dart_git_signature_now _git_signature_now =
      _git_signature_now_ptr.asFunction<_dart_git_signature_now>();

  /// Create a new action signature with default user and now timestamp.
  ///
  /// This looks up the user.name and user.email from the configuration and
  /// uses the current time as the timestamp, and creates a new signature
  /// based on that information.  It will return GIT_ENOTFOUND if either the
  /// user.name or user.email are not set.
  ///
  /// @param out new signature
  /// @param repo repository pointer
  /// @return 0 on success, GIT_ENOTFOUND if config is missing, or error code
  int git_signature_default(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_signature_default(
      out,
      repo,
    );
  }

  late final _git_signature_default_ptr =
      _lookup<ffi.NativeFunction<_c_git_signature_default>>(
          'git_signature_default');
  late final _dart_git_signature_default _git_signature_default =
      _git_signature_default_ptr.asFunction<_dart_git_signature_default>();

  /// Create a new signature by parsing the given buffer, which is
  /// expected to be in the format "Real Name <email> timestamp tzoffset",
  /// where `timestamp` is the number of seconds since the Unix epoch and
  /// `tzoffset` is the timezone offset in `hhmm` format (note the lack
  /// of a colon separator).
  ///
  /// @param out new signature
  /// @param buf signature string
  /// @return 0 on success, or an error code
  int git_signature_from_buffer(
    ffi.Pointer<ffi.Pointer<git_signature>> out,
    ffi.Pointer<ffi.Int8> buf,
  ) {
    return _git_signature_from_buffer(
      out,
      buf,
    );
  }

  late final _git_signature_from_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_signature_from_buffer>>(
          'git_signature_from_buffer');
  late final _dart_git_signature_from_buffer _git_signature_from_buffer =
      _git_signature_from_buffer_ptr
          .asFunction<_dart_git_signature_from_buffer>();

  /// Create a copy of an existing signature.  All internal strings are also
  /// duplicated.
  ///
  /// Call `git_signature_free()` to free the data.
  ///
  /// @param dest pointer where to store the copy
  /// @param sig signature to duplicate
  /// @return 0 or an error code
  int git_signature_dup(
    ffi.Pointer<ffi.Pointer<git_signature>> dest,
    ffi.Pointer<git_signature> sig,
  ) {
    return _git_signature_dup(
      dest,
      sig,
    );
  }

  late final _git_signature_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_signature_dup>>('git_signature_dup');
  late final _dart_git_signature_dup _git_signature_dup =
      _git_signature_dup_ptr.asFunction<_dart_git_signature_dup>();

  /// Free an existing signature.
  ///
  /// Because the signature is not an opaque structure, it is legal to free it
  /// manually, but be sure to free the "name" and "email" strings in addition
  /// to the structure itself.
  ///
  /// @param sig signature to free
  void git_signature_free(
    ffi.Pointer<git_signature> sig,
  ) {
    return _git_signature_free(
      sig,
    );
  }

  late final _git_signature_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_signature_free>>('git_signature_free');
  late final _dart_git_signature_free _git_signature_free =
      _git_signature_free_ptr.asFunction<_dart_git_signature_free>();

  /// Lookup a tag object from the repository.
  ///
  /// @param out pointer to the looked up tag
  /// @param repo the repo to use when locating the tag.
  /// @param id identity of the tag to locate.
  /// @return 0 or an error code
  int git_tag_lookup(
    ffi.Pointer<ffi.Pointer<git_tag>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
  ) {
    return _git_tag_lookup(
      out,
      repo,
      id,
    );
  }

  late final _git_tag_lookup_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_lookup>>('git_tag_lookup');
  late final _dart_git_tag_lookup _git_tag_lookup =
      _git_tag_lookup_ptr.asFunction<_dart_git_tag_lookup>();

  /// Lookup a tag object from the repository,
  /// given a prefix of its identifier (short id).
  ///
  /// @see git_object_lookup_prefix
  ///
  /// @param out pointer to the looked up tag
  /// @param repo the repo to use when locating the tag.
  /// @param id identity of the tag to locate.
  /// @param len the length of the short identifier
  /// @return 0 or an error code
  int git_tag_lookup_prefix(
    ffi.Pointer<ffi.Pointer<git_tag>> out,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<git_oid> id,
    int len,
  ) {
    return _git_tag_lookup_prefix(
      out,
      repo,
      id,
      len,
    );
  }

  late final _git_tag_lookup_prefix_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_lookup_prefix>>(
          'git_tag_lookup_prefix');
  late final _dart_git_tag_lookup_prefix _git_tag_lookup_prefix =
      _git_tag_lookup_prefix_ptr.asFunction<_dart_git_tag_lookup_prefix>();

  /// Close an open tag
  ///
  /// You can no longer use the git_tag pointer after this call.
  ///
  /// IMPORTANT: You MUST call this method when you are through with a tag to
  /// release memory. Failure to do so will cause a memory leak.
  ///
  /// @param tag the tag to close
  void git_tag_free(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_free(
      tag,
    );
  }

  late final _git_tag_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_free>>('git_tag_free');
  late final _dart_git_tag_free _git_tag_free =
      _git_tag_free_ptr.asFunction<_dart_git_tag_free>();

  /// Get the id of a tag.
  ///
  /// @param tag a previously loaded tag.
  /// @return object identity for the tag.
  ffi.Pointer<git_oid> git_tag_id(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_id(
      tag,
    );
  }

  late final _git_tag_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_id>>('git_tag_id');
  late final _dart_git_tag_id _git_tag_id =
      _git_tag_id_ptr.asFunction<_dart_git_tag_id>();

  /// Get the repository that contains the tag.
  ///
  /// @param tag A previously loaded tag.
  /// @return Repository that contains this tag.
  ffi.Pointer<git_repository> git_tag_owner(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_owner(
      tag,
    );
  }

  late final _git_tag_owner_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_owner>>('git_tag_owner');
  late final _dart_git_tag_owner _git_tag_owner =
      _git_tag_owner_ptr.asFunction<_dart_git_tag_owner>();

  /// Get the tagged object of a tag
  ///
  /// This method performs a repository lookup for the
  /// given object and returns it
  ///
  /// @param target_out pointer where to store the target
  /// @param tag a previously loaded tag.
  /// @return 0 or an error code
  int git_tag_target(
    ffi.Pointer<ffi.Pointer<git_object>> target_out,
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_target(
      target_out,
      tag,
    );
  }

  late final _git_tag_target_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_target>>('git_tag_target');
  late final _dart_git_tag_target _git_tag_target =
      _git_tag_target_ptr.asFunction<_dart_git_tag_target>();

  /// Get the OID of the tagged object of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return pointer to the OID
  ffi.Pointer<git_oid> git_tag_target_id(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_target_id(
      tag,
    );
  }

  late final _git_tag_target_id_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_target_id>>('git_tag_target_id');
  late final _dart_git_tag_target_id _git_tag_target_id =
      _git_tag_target_id_ptr.asFunction<_dart_git_tag_target_id>();

  /// Get the type of a tag's tagged object
  ///
  /// @param tag a previously loaded tag.
  /// @return type of the tagged object
  int git_tag_target_type(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_target_type(
      tag,
    );
  }

  late final _git_tag_target_type_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_target_type>>(
          'git_tag_target_type');
  late final _dart_git_tag_target_type _git_tag_target_type =
      _git_tag_target_type_ptr.asFunction<_dart_git_tag_target_type>();

  /// Get the name of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return name of the tag
  ffi.Pointer<ffi.Int8> git_tag_name(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_name(
      tag,
    );
  }

  late final _git_tag_name_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_name>>('git_tag_name');
  late final _dart_git_tag_name _git_tag_name =
      _git_tag_name_ptr.asFunction<_dart_git_tag_name>();

  /// Get the tagger (author) of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return reference to the tag's author or NULL when unspecified
  ffi.Pointer<git_signature> git_tag_tagger(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_tagger(
      tag,
    );
  }

  late final _git_tag_tagger_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_tagger>>('git_tag_tagger');
  late final _dart_git_tag_tagger _git_tag_tagger =
      _git_tag_tagger_ptr.asFunction<_dart_git_tag_tagger>();

  /// Get the message of a tag
  ///
  /// @param tag a previously loaded tag.
  /// @return message of the tag or NULL when unspecified
  ffi.Pointer<ffi.Int8> git_tag_message(
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_message(
      tag,
    );
  }

  late final _git_tag_message_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_message>>('git_tag_message');
  late final _dart_git_tag_message _git_tag_message =
      _git_tag_message_ptr.asFunction<_dart_git_tag_message>();

  /// Create a new tag in the repository from an object
  ///
  /// A new reference will also be created pointing to
  /// this tag object. If `force` is true and a reference
  /// already exists with the given name, it'll be replaced.
  ///
  /// The message will not be cleaned up. This can be achieved
  /// through `git_message_prettify()`.
  ///
  /// The tag name will be checked for validity. You must avoid
  /// the characters '~', '^', ':', '\\', '?', '[', and '*', and the
  /// sequences ".." and "@{" which have special meaning to revparse.
  ///
  /// @param oid Pointer where to store the OID of the
  /// newly created tag. If the tag already exists, this parameter
  /// will be the oid of the existing tag, and the function will
  /// return a GIT_EEXISTS error code.
  ///
  /// @param repo Repository where to store the tag
  ///
  /// @param tag_name Name for the tag; this name is validated
  /// for consistency. It should also not conflict with an
  /// already existing tag name
  ///
  /// @param target Object to which this tag points. This object
  /// must belong to the given `repo`.
  ///
  /// @param tagger Signature of the tagger for this tag, and
  /// of the tagging time
  ///
  /// @param message Full message for this tag
  ///
  /// @param force Overwrite existing references
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  /// A tag object is written to the ODB, and a proper reference
  /// is written in the /refs/tags folder, pointing to it
  int git_tag_create(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> tag_name,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_signature> tagger,
    ffi.Pointer<ffi.Int8> message,
    int force,
  ) {
    return _git_tag_create(
      oid,
      repo,
      tag_name,
      target,
      tagger,
      message,
      force,
    );
  }

  late final _git_tag_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_create>>('git_tag_create');
  late final _dart_git_tag_create _git_tag_create =
      _git_tag_create_ptr.asFunction<_dart_git_tag_create>();

  /// Create a new tag in the object database pointing to a git_object
  ///
  /// The message will not be cleaned up. This can be achieved
  /// through `git_message_prettify()`.
  ///
  /// @param oid Pointer where to store the OID of the
  /// newly created tag
  ///
  /// @param repo Repository where to store the tag
  ///
  /// @param tag_name Name for the tag
  ///
  /// @param target Object to which this tag points. This object
  /// must belong to the given `repo`.
  ///
  /// @param tagger Signature of the tagger for this tag, and
  /// of the tagging time
  ///
  /// @param message Full message for this tag
  ///
  /// @return 0 on success or an error code
  int git_tag_annotation_create(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> tag_name,
    ffi.Pointer<git_object> target,
    ffi.Pointer<git_signature> tagger,
    ffi.Pointer<ffi.Int8> message,
  ) {
    return _git_tag_annotation_create(
      oid,
      repo,
      tag_name,
      target,
      tagger,
      message,
    );
  }

  late final _git_tag_annotation_create_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_annotation_create>>(
          'git_tag_annotation_create');
  late final _dart_git_tag_annotation_create _git_tag_annotation_create =
      _git_tag_annotation_create_ptr
          .asFunction<_dart_git_tag_annotation_create>();

  /// Create a new tag in the repository from a buffer
  ///
  /// @param oid Pointer where to store the OID of the newly created tag
  /// @param repo Repository where to store the tag
  /// @param buffer Raw tag data
  /// @param force Overwrite existing tags
  /// @return 0 on success; error code otherwise
  int git_tag_create_from_buffer(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> buffer,
    int force,
  ) {
    return _git_tag_create_from_buffer(
      oid,
      repo,
      buffer,
      force,
    );
  }

  late final _git_tag_create_from_buffer_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_create_from_buffer>>(
          'git_tag_create_from_buffer');
  late final _dart_git_tag_create_from_buffer _git_tag_create_from_buffer =
      _git_tag_create_from_buffer_ptr
          .asFunction<_dart_git_tag_create_from_buffer>();

  /// Create a new lightweight tag pointing at a target object
  ///
  /// A new direct reference will be created pointing to
  /// this target object. If `force` is true and a reference
  /// already exists with the given name, it'll be replaced.
  ///
  /// The tag name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param oid Pointer where to store the OID of the provided
  /// target object. If the tag already exists, this parameter
  /// will be filled with the oid of the existing pointed object
  /// and the function will return a GIT_EEXISTS error code.
  ///
  /// @param repo Repository where to store the lightweight tag
  ///
  /// @param tag_name Name for the tag; this name is validated
  /// for consistency. It should also not conflict with an
  /// already existing tag name
  ///
  /// @param target Object to which this tag points. This object
  /// must belong to the given `repo`.
  ///
  /// @param force Overwrite existing references
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  /// A proper reference is written in the /refs/tags folder,
  /// pointing to the provided target object
  int git_tag_create_lightweight(
    ffi.Pointer<git_oid> oid,
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> tag_name,
    ffi.Pointer<git_object> target,
    int force,
  ) {
    return _git_tag_create_lightweight(
      oid,
      repo,
      tag_name,
      target,
      force,
    );
  }

  late final _git_tag_create_lightweight_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_create_lightweight>>(
          'git_tag_create_lightweight');
  late final _dart_git_tag_create_lightweight _git_tag_create_lightweight =
      _git_tag_create_lightweight_ptr
          .asFunction<_dart_git_tag_create_lightweight>();

  /// Delete an existing tag reference.
  ///
  /// The tag name will be checked for validity.
  /// See `git_tag_create()` for rules about valid names.
  ///
  /// @param repo Repository where lives the tag
  ///
  /// @param tag_name Name of the tag to be deleted;
  /// this name is validated for consistency.
  ///
  /// @return 0 on success, GIT_EINVALIDSPEC or an error code
  int git_tag_delete(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.Int8> tag_name,
  ) {
    return _git_tag_delete(
      repo,
      tag_name,
    );
  }

  late final _git_tag_delete_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_delete>>('git_tag_delete');
  late final _dart_git_tag_delete _git_tag_delete =
      _git_tag_delete_ptr.asFunction<_dart_git_tag_delete>();

  /// Fill a list with all the tags in the Repository
  ///
  /// The string array will be filled with the names of the
  /// matching tags; these values are owned by the user and
  /// should be free'd manually when no longer needed, using
  /// `git_strarray_free`.
  ///
  /// @param tag_names Pointer to a git_strarray structure where
  /// the tag names will be stored
  /// @param repo Repository where to find the tags
  /// @return 0 or an error code
  int git_tag_list(
    ffi.Pointer<git_strarray> tag_names,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_tag_list(
      tag_names,
      repo,
    );
  }

  late final _git_tag_list_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_list>>('git_tag_list');
  late final _dart_git_tag_list _git_tag_list =
      _git_tag_list_ptr.asFunction<_dart_git_tag_list>();

  /// Fill a list with all the tags in the Repository
  /// which name match a defined pattern
  ///
  /// If an empty pattern is provided, all the tags
  /// will be returned.
  ///
  /// The string array will be filled with the names of the
  /// matching tags; these values are owned by the user and
  /// should be free'd manually when no longer needed, using
  /// `git_strarray_free`.
  ///
  /// @param tag_names Pointer to a git_strarray structure where
  /// the tag names will be stored
  /// @param pattern Standard fnmatch pattern
  /// @param repo Repository where to find the tags
  /// @return 0 or an error code
  int git_tag_list_match(
    ffi.Pointer<git_strarray> tag_names,
    ffi.Pointer<ffi.Int8> pattern,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_tag_list_match(
      tag_names,
      pattern,
      repo,
    );
  }

  late final _git_tag_list_match_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_list_match>>('git_tag_list_match');
  late final _dart_git_tag_list_match _git_tag_list_match =
      _git_tag_list_match_ptr.asFunction<_dart_git_tag_list_match>();

  /// Call callback `cb' for each tag in the repository
  ///
  /// @param repo Repository
  /// @param callback Callback function
  /// @param payload Pointer to callback data (optional)
  int git_tag_foreach(
    ffi.Pointer<git_repository> repo,
    ffi.Pointer<ffi.NativeFunction<git_tag_foreach_cb>> callback,
    ffi.Pointer<ffi.Void> payload,
  ) {
    return _git_tag_foreach(
      repo,
      callback,
      payload,
    );
  }

  late final _git_tag_foreach_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_foreach>>('git_tag_foreach');
  late final _dart_git_tag_foreach _git_tag_foreach =
      _git_tag_foreach_ptr.asFunction<_dart_git_tag_foreach>();

  /// Recursively peel a tag until a non tag git_object is found
  ///
  /// The retrieved `tag_target` object is owned by the repository
  /// and should be closed with the `git_object_free` method.
  ///
  /// @param tag_target_out Pointer to the peeled git_object
  /// @param tag The tag to be processed
  /// @return 0 or an error code
  int git_tag_peel(
    ffi.Pointer<ffi.Pointer<git_object>> tag_target_out,
    ffi.Pointer<git_tag> tag,
  ) {
    return _git_tag_peel(
      tag_target_out,
      tag,
    );
  }

  late final _git_tag_peel_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_peel>>('git_tag_peel');
  late final _dart_git_tag_peel _git_tag_peel =
      _git_tag_peel_ptr.asFunction<_dart_git_tag_peel>();

  /// Create an in-memory copy of a tag. The copy must be explicitly
  /// free'd or it will leak.
  ///
  /// @param out Pointer to store the copy of the tag
  /// @param source Original tag to copy
  int git_tag_dup(
    ffi.Pointer<ffi.Pointer<git_tag>> out,
    ffi.Pointer<git_tag> source,
  ) {
    return _git_tag_dup(
      out,
      source,
    );
  }

  late final _git_tag_dup_ptr =
      _lookup<ffi.NativeFunction<_c_git_tag_dup>>('git_tag_dup');
  late final _dart_git_tag_dup _git_tag_dup =
      _git_tag_dup_ptr.asFunction<_dart_git_tag_dup>();

  /// Create a new transaction object
  ///
  /// This does not lock anything, but sets up the transaction object to
  /// know from which repository to lock.
  ///
  /// @param out the resulting transaction
  /// @param repo the repository in which to lock
  /// @return 0 or an error code
  int git_transaction_new(
    ffi.Pointer<ffi.Pointer<git_transaction>> out,
    ffi.Pointer<git_repository> repo,
  ) {
    return _git_transaction_new(
      out,
      repo,
    );
  }

  late final _git_transaction_new_ptr =
      _lookup<ffi.NativeFunction<_c_git_transaction_new>>(
          'git_transaction_new');
  late final _dart_git_transaction_new _git_transaction_new =
      _git_transaction_new_ptr.asFunction<_dart_git_transaction_new>();

  /// Lock a reference
  ///
  /// Lock the specified reference. This is the first step to updating a
  /// reference.
  ///
  /// @param tx the transaction
  /// @param refname the reference to lock
  /// @return 0 or an error message
  int git_transaction_lock_ref(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_transaction_lock_ref(
      tx,
      refname,
    );
  }

  late final _git_transaction_lock_ref_ptr =
      _lookup<ffi.NativeFunction<_c_git_transaction_lock_ref>>(
          'git_transaction_lock_ref');
  late final _dart_git_transaction_lock_ref _git_transaction_lock_ref =
      _git_transaction_lock_ref_ptr
          .asFunction<_dart_git_transaction_lock_ref>();

  /// Set the target of a reference
  ///
  /// Set the target of the specified reference. This reference must be
  /// locked.
  ///
  /// @param tx the transaction
  /// @param refname reference to update
  /// @param target target to set the reference to
  /// @param sig signature to use in the reflog; pass NULL to read the identity from the config
  /// @param msg message to use in the reflog
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_set_target(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Int8> refname,
    ffi.Pointer<git_oid> target,
    ffi.Pointer<git_signature> sig,
    ffi.Pointer<ffi.Int8> msg,
  ) {
    return _git_transaction_set_target(
      tx,
      refname,
      target,
      sig,
      msg,
    );
  }

  late final _git_transaction_set_target_ptr =
      _lookup<ffi.NativeFunction<_c_git_transaction_set_target>>(
          'git_transaction_set_target');
  late final _dart_git_transaction_set_target _git_transaction_set_target =
      _git_transaction_set_target_ptr
          .asFunction<_dart_git_transaction_set_target>();

  /// Set the target of a reference
  ///
  /// Set the target of the specified reference. This reference must be
  /// locked.
  ///
  /// @param tx the transaction
  /// @param refname reference to update
  /// @param target target to set the reference to
  /// @param sig signature to use in the reflog; pass NULL to read the identity from the config
  /// @param msg message to use in the reflog
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_set_symbolic_target(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Int8> refname,
    ffi.Pointer<ffi.Int8> target,
    ffi.Pointer<git_signature> sig,
    ffi.Pointer<ffi.Int8> msg,
  ) {
    return _git_transaction_set_symbolic_target(
      tx,
      refname,
      target,
      sig,
      msg,
    );
  }

  late final _git_transaction_set_symbolic_target_ptr =
      _lookup<ffi.NativeFunction<_c_git_transaction_set_symbolic_target>>(
          'git_transaction_set_symbolic_target');
  late final _dart_git_transaction_set_symbolic_target
      _git_transaction_set_symbolic_target =
      _git_transaction_set_symbolic_target_ptr
          .asFunction<_dart_git_transaction_set_symbolic_target>();

  /// Set the reflog of a reference
  ///
  /// Set the specified reference's reflog. If this is combined with
  /// setting the target, that update won't be written to the reflog.
  ///
  /// @param tx the transaction
  /// @param refname the reference whose reflog to set
  /// @param reflog the reflog as it should be written out
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_set_reflog(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Int8> refname,
    ffi.Pointer<git_reflog> reflog,
  ) {
    return _git_transaction_set_reflog(
      tx,
      refname,
      reflog,
    );
  }

  late final _git_transaction_set_reflog_ptr =
      _lookup<ffi.NativeFunction<_c_git_transaction_set_reflog>>(
          'git_transaction_set_reflog');
  late final _dart_git_transaction_set_reflog _git_transaction_set_reflog =
      _git_transaction_set_reflog_ptr
          .asFunction<_dart_git_transaction_set_reflog>();

  /// Remove a reference
  ///
  /// @param tx the transaction
  /// @param refname the reference to remove
  /// @return 0, GIT_ENOTFOUND if the reference is not among the locked ones, or an error code
  int git_transaction_remove(
    ffi.Pointer<git_transaction> tx,
    ffi.Pointer<ffi.Int8> refname,
  ) {
    return _git_transaction_remove(
      tx,
      refname,
    );
  }

  late final _git_transaction_remove_ptr =
      _lookup<ffi.NativeFunction<_c_git_transaction_remove>>(
          'git_transaction_remove');
  late final _dart_git_transaction_remove _git_transaction_remove =
      _git_transaction_remove_ptr.asFunction<_dart_git_transaction_remove>();

  /// Commit the changes from the transaction
  ///
  /// Perform the changes that have been queued. The updates will be made
  /// one by one, and the first failure will stop the processing.
  ///
  /// @param tx the transaction
  /// @return 0 or an error code
  int git_transaction_commit(
    ffi.Pointer<git_transaction> tx,
  ) {
    return _git_transaction_commit(
      tx,
    );
  }

  late final _git_transaction_commit_ptr =
      _lookup<ffi.NativeFunction<_c_git_transaction_commit>>(
          'git_transaction_commit');
  late final _dart_git_transaction_commit _git_transaction_commit =
      _git_transaction_commit_ptr.asFunction<_dart_git_transaction_commit>();

  /// Free the resources allocated by this transaction
  ///
  /// If any references remain locked, they will be unlocked without any
  /// changes made to them.
  ///
  /// @param tx the transaction
  void git_transaction_free(
    ffi.Pointer<git_transaction> tx,
  ) {
    return _git_transaction_free(
      tx,
    );
  }

  late final _git_transaction_free_ptr =
      _lookup<ffi.NativeFunction<_c_git_transaction_free>>(
          'git_transaction_free');
  late final _dart_git_transaction_free _git_transaction_free =
      _git_transaction_free_ptr.asFunction<_dart_git_transaction_free>();
}

class __fsid_t extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Int32> __val;
}

class tm extends ffi.Struct {
  @ffi.Int32()
  external int tm_sec;

  @ffi.Int32()
  external int tm_min;

  @ffi.Int32()
  external int tm_hour;

  @ffi.Int32()
  external int tm_mday;

  @ffi.Int32()
  external int tm_mon;

  @ffi.Int32()
  external int tm_year;

  @ffi.Int32()
  external int tm_wday;

  @ffi.Int32()
  external int tm_yday;

  @ffi.Int32()
  external int tm_isdst;

  @ffi.Int64()
  external int tm_gmtoff;

  external ffi.Pointer<ffi.Int8> tm_zone;
}

class timespec extends ffi.Struct {
  @ffi.Int64()
  external int tv_sec;

  @ffi.Int64()
  external int tv_nsec;
}

class itimerspec extends ffi.Struct {
  external timespec it_interval;

  external timespec it_value;
}

class sigevent extends ffi.Opaque {}

class __locale_data extends ffi.Opaque {}

class __locale_struct extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<__locale_data>> __locales;

  external ffi.Pointer<ffi.Uint16> __ctype_b;

  external ffi.Pointer<ffi.Int32> __ctype_tolower;

  external ffi.Pointer<ffi.Int32> __ctype_toupper;

  @ffi.Array.multi([13])
  external ffi.Array<ffi.Pointer<ffi.Int8>> __names;
}

class div_t extends ffi.Struct {
  @ffi.Int32()
  external int quot;

  @ffi.Int32()
  external int rem;
}

class ldiv_t extends ffi.Struct {
  @ffi.Int64()
  external int quot;

  @ffi.Int64()
  external int rem;
}

class lldiv_t extends ffi.Struct {
  @ffi.Int64()
  external int quot;

  @ffi.Int64()
  external int rem;
}

class __sigset_t extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint64> __val;
}

class timeval extends ffi.Struct {
  @ffi.Int64()
  external int tv_sec;

  @ffi.Int64()
  external int tv_usec;
}

class fd_set extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Int64> __fds_bits;
}

class __pthread_list_t extends ffi.Struct {
  external ffi.Pointer<__pthread_list_t> __prev;

  external ffi.Pointer<__pthread_list_t> __next;
}

class __pthread_slist_t extends ffi.Struct {
  external ffi.Pointer<__pthread_slist_t> __next;
}

class __pthread_mutex_s extends ffi.Struct {
  @ffi.Int32()
  external int __lock;

  @ffi.Uint32()
  external int __count;

  @ffi.Int32()
  external int __owner;

  @ffi.Uint32()
  external int __nusers;

  @ffi.Int32()
  external int __kind;

  @ffi.Int16()
  external int __spins;

  @ffi.Int16()
  external int __elision;

  external __pthread_list_t __list;
}

class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.Uint32()
  external int __readers;

  @ffi.Uint32()
  external int __writers;

  @ffi.Uint32()
  external int __wrphase_futex;

  @ffi.Uint32()
  external int __writers_futex;

  @ffi.Uint32()
  external int __pad3;

  @ffi.Uint32()
  external int __pad4;

  @ffi.Int32()
  external int __cur_writer;

  @ffi.Int32()
  external int __shared;

  @ffi.Int8()
  external int __rwelision;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.Uint8> __pad1;

  @ffi.Uint64()
  external int __pad2;

  @ffi.Uint32()
  external int __flags;
}

class __pthread_cond_s extends ffi.Struct {
  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> __g_refs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> __g_size;

  @ffi.Uint32()
  external int __g1_orig_size;

  @ffi.Uint32()
  external int __wrefs;

  @ffi.Array.multi([2])
  external ffi.Array<ffi.Uint32> __g_signals;
}

class __once_flag extends ffi.Struct {
  @ffi.Int32()
  external int __data;
}

class pthread_mutexattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int8> __size;

  @ffi.Int32()
  external int __align;
}

class pthread_condattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int8> __size;

  @ffi.Int32()
  external int __align;
}

class pthread_attr_t extends ffi.Union {
  @ffi.Array.multi([56])
  external ffi.Array<ffi.Int8> __size;

  @ffi.Int64()
  external int __align;
}

class pthread_mutex_t extends ffi.Union {
  external __pthread_mutex_s __data;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Int8> __size;

  @ffi.Int64()
  external int __align;
}

class pthread_cond_t extends ffi.Union {
  external __pthread_cond_s __data;

  @ffi.Array.multi([48])
  external ffi.Array<ffi.Int8> __size;

  @ffi.Int64()
  external int __align;
}

class pthread_rwlock_t extends ffi.Union {
  external __pthread_rwlock_arch_t __data;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Int8> __size;

  @ffi.Int64()
  external int __align;
}

class pthread_rwlockattr_t extends ffi.Union {
  @ffi.Array.multi([8])
  external ffi.Array<ffi.Int8> __size;

  @ffi.Int64()
  external int __align;
}

class pthread_barrier_t extends ffi.Union {
  @ffi.Array.multi([32])
  external ffi.Array<ffi.Int8> __size;

  @ffi.Int64()
  external int __align;
}

class pthread_barrierattr_t extends ffi.Union {
  @ffi.Array.multi([4])
  external ffi.Array<ffi.Int8> __size;

  @ffi.Int32()
  external int __align;
}

class random_data extends ffi.Struct {
  external ffi.Pointer<ffi.Int32> fptr;

  external ffi.Pointer<ffi.Int32> rptr;

  external ffi.Pointer<ffi.Int32> state;

  @ffi.Int32()
  external int rand_type;

  @ffi.Int32()
  external int rand_deg;

  @ffi.Int32()
  external int rand_sep;

  external ffi.Pointer<ffi.Int32> end_ptr;
}

class drand48_data extends ffi.Struct {
  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint16> __x;

  @ffi.Array.multi([3])
  external ffi.Array<ffi.Uint16> __old_x;

  @ffi.Uint16()
  external int __c;

  @ffi.Uint16()
  external int __init;

  @ffi.Uint64()
  external int __a;
}

class imaxdiv_t extends ffi.Struct {
  @ffi.Int64()
  external int quot;

  @ffi.Int64()
  external int rem;
}

/// Combinations of these values describe the features with which libgit2
/// was compiled
abstract class git_feature_t {
  /// If set, libgit2 was built thread-aware and can be safely used from multiple
  /// threads.
  static const int GIT_FEATURE_THREADS = 1;

  /// If set, libgit2 was built with and linked against a TLS implementation.
  /// Custom TLS streams may still be added by the user to support HTTPS
  /// regardless of this.
  static const int GIT_FEATURE_HTTPS = 2;

  /// If set, libgit2 was built with and linked against libssh2. A custom
  /// transport may still be added by the user to support libssh2 regardless of
  /// this.
  static const int GIT_FEATURE_SSH = 4;

  /// If set, libgit2 was built with support for sub-second resolution in file
  /// modification times.
  static const int GIT_FEATURE_NSEC = 8;
}

/// Global library options
///
/// These are used to select which global option to set or get and are
/// used in `git_libgit2_opts()`.
abstract class git_libgit2_opt_t {
  static const int GIT_OPT_GET_MWINDOW_SIZE = 0;
  static const int GIT_OPT_SET_MWINDOW_SIZE = 1;
  static const int GIT_OPT_GET_MWINDOW_MAPPED_LIMIT = 2;
  static const int GIT_OPT_SET_MWINDOW_MAPPED_LIMIT = 3;
  static const int GIT_OPT_GET_SEARCH_PATH = 4;
  static const int GIT_OPT_SET_SEARCH_PATH = 5;
  static const int GIT_OPT_SET_CACHE_OBJECT_LIMIT = 6;
  static const int GIT_OPT_SET_CACHE_MAX_SIZE = 7;
  static const int GIT_OPT_ENABLE_CACHING = 8;
  static const int GIT_OPT_GET_CACHED_MEMORY = 9;
  static const int GIT_OPT_GET_TEMPLATE_PATH = 10;
  static const int GIT_OPT_SET_TEMPLATE_PATH = 11;
  static const int GIT_OPT_SET_SSL_CERT_LOCATIONS = 12;
  static const int GIT_OPT_SET_USER_AGENT = 13;
  static const int GIT_OPT_ENABLE_STRICT_OBJECT_CREATION = 14;
  static const int GIT_OPT_ENABLE_STRICT_SYMBOLIC_REF_CREATION = 15;
  static const int GIT_OPT_SET_SSL_CIPHERS = 16;
  static const int GIT_OPT_GET_USER_AGENT = 17;
  static const int GIT_OPT_ENABLE_OFS_DELTA = 18;
  static const int GIT_OPT_ENABLE_FSYNC_GITDIR = 19;
  static const int GIT_OPT_GET_WINDOWS_SHAREMODE = 20;
  static const int GIT_OPT_SET_WINDOWS_SHAREMODE = 21;
  static const int GIT_OPT_ENABLE_STRICT_HASH_VERIFICATION = 22;
  static const int GIT_OPT_SET_ALLOCATOR = 23;
  static const int GIT_OPT_ENABLE_UNSAVED_INDEX_SAFETY = 24;
  static const int GIT_OPT_GET_PACK_MAX_OBJECTS = 25;
  static const int GIT_OPT_SET_PACK_MAX_OBJECTS = 26;
  static const int GIT_OPT_DISABLE_PACK_KEEP_FILE_CHECKS = 27;
  static const int GIT_OPT_ENABLE_HTTP_EXPECT_CONTINUE = 28;
  static const int GIT_OPT_GET_MWINDOW_FILE_LIMIT = 29;
  static const int GIT_OPT_SET_MWINDOW_FILE_LIMIT = 30;
}

/// A data buffer for exporting data from libgit2
///
/// Sometimes libgit2 wants to return an allocated data buffer to the
/// caller and have the caller take responsibility for freeing that memory.
/// This can be awkward if the caller does not have easy access to the same
/// allocation functions that libgit2 is using.  In those cases, libgit2
/// will fill in a `git_buf` and the caller can use `git_buf_dispose()` to
/// release it when they are done.
///
/// A `git_buf` may also be used for the caller to pass in a reference to
/// a block of memory they hold.  In this case, libgit2 will not resize or
/// free the memory, but will read from it as needed.
///
/// Some APIs may occasionally do something slightly unusual with a buffer,
/// such as setting `ptr` to a value that was passed in by the user.  In
/// those cases, the behavior will be clearly documented by the API.
class git_buf extends ffi.Struct {
  /// The buffer contents.
  ///
  /// `ptr` points to the start of the allocated memory.  If it is NULL,
  /// then the `git_buf` is considered empty and libgit2 will feel free
  /// to overwrite it with new data.
  external ffi.Pointer<ffi.Int8> ptr;

  /// `asize` holds the known total amount of allocated memory if the `ptr`
  /// was allocated by libgit2.  It may be larger than `size`.  If `ptr`
  /// was not allocated by libgit2 and should not be resized and/or freed,
  /// then `asize` will be set to zero.
  @ffi.Int32()
  external int asize;

  /// `size` holds the size (in bytes) of the data that is actually used.
  @ffi.Int32()
  external int size;
}

/// Unique identity of any object (commit, tree, blob, tag).
class git_oid extends ffi.Struct {
  @ffi.Array.multi([20])
  external ffi.Array<ffi.Uint8> id;
}

class git_oid_shorten extends ffi.Opaque {}

/// Basic type (loose or packed) of any Git object.
abstract class git_object_t {
  /// < Object can be any of the following
  static const int GIT_OBJECT_ANY = -2;

  /// < Object is invalid.
  static const int GIT_OBJECT_INVALID = -1;

  /// < A commit object.
  static const int GIT_OBJECT_COMMIT = 1;

  /// < A tree (directory listing) object.
  static const int GIT_OBJECT_TREE = 2;

  /// < A file revision object.
  static const int GIT_OBJECT_BLOB = 3;

  /// < An annotated tag object.
  static const int GIT_OBJECT_TAG = 4;

  /// < A delta, base is given by an offset.
  static const int GIT_OBJECT_OFS_DELTA = 6;

  /// < A delta, base is given by object id.
  static const int GIT_OBJECT_REF_DELTA = 7;
}

class git_odb extends ffi.Opaque {}

class git_odb_backend extends ffi.Opaque {}

class git_odb_object extends ffi.Opaque {}

/// A stream to read/write from a backend.
///
/// This represents a stream of data being written to or read from a
/// backend. When writing, the frontend functions take care of
/// calculating the object's id and all `finalize_write` needs to do is
/// store the object with the id it is passed.
class git_odb_stream extends ffi.Struct {
  external ffi.Pointer<git_odb_backend> backend;

  @ffi.Uint32()
  external int mode;

  external ffi.Pointer<ffi.Void> hash_ctx;

  @ffi.Uint64()
  external int declared_size;

  @ffi.Uint64()
  external int received_bytes;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_4>> read;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_5>> write;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_6>> finalize_write;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_7>> free;
}

/// This structure is used to provide callers information about the
/// progress of indexing a packfile, either directly or part of a
/// fetch or clone that downloads a packfile.
class git_indexer_progress extends ffi.Struct {
  /// number of objects in the packfile being indexed
  @ffi.Uint32()
  external int total_objects;

  /// received objects that have been hashed
  @ffi.Uint32()
  external int indexed_objects;

  /// received_objects: objects which have been downloaded
  @ffi.Uint32()
  external int received_objects;

  /// locally-available objects that have been injected in order
  /// to fix a thin pack
  @ffi.Uint32()
  external int local_objects;

  /// number of deltas in the packfile being indexed
  @ffi.Uint32()
  external int total_deltas;

  /// received deltas that have been indexed
  @ffi.Uint32()
  external int indexed_deltas;

  /// size of the packfile received up to now
  @ffi.Int32()
  external int received_bytes;
}

/// A stream to write a pack file to the ODB
class git_odb_writepack extends ffi.Struct {
  external ffi.Pointer<git_odb_backend> backend;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_8>> append;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_9>> commit;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_10>> free;
}

class git_refdb extends ffi.Opaque {}

class git_refdb_backend extends ffi.Opaque {}

class git_repository extends ffi.Opaque {}

class git_worktree extends ffi.Opaque {}

class git_object extends ffi.Opaque {}

class git_revwalk extends ffi.Opaque {}

class git_tag extends ffi.Opaque {}

class git_blob extends ffi.Opaque {}

class git_commit extends ffi.Opaque {}

class git_tree_entry extends ffi.Opaque {}

class git_tree extends ffi.Opaque {}

class git_treebuilder extends ffi.Opaque {}

class git_index extends ffi.Opaque {}

class git_index_iterator extends ffi.Opaque {}

class git_index_conflict_iterator extends ffi.Opaque {}

class git_config extends ffi.Opaque {}

class git_config_backend extends ffi.Opaque {}

class git_reflog_entry extends ffi.Opaque {}

class git_reflog extends ffi.Opaque {}

class git_note extends ffi.Opaque {}

class git_packbuilder extends ffi.Opaque {}

/// Time in a signature
class git_time extends ffi.Struct {
  /// < time in seconds from epoch
  @ffi.Int64()
  external int time;

  /// < timezone offset, in minutes
  @ffi.Int32()
  external int offset;

  /// < indicator for questionable '-0000' offsets in signature
  @ffi.Int8()
  external int sign;
}

/// An action signature (e.g. for committers, taggers, etc)
class git_signature extends ffi.Struct {
  /// < full name of the author
  external ffi.Pointer<ffi.Int8> name;

  /// < email of the author
  external ffi.Pointer<ffi.Int8> email;

  /// < time when the action happened
  external git_time when;
}

class git_reference extends ffi.Opaque {}

class git_reference_iterator extends ffi.Opaque {}

class git_transaction extends ffi.Opaque {}

class git_annotated_commit extends ffi.Opaque {}

class git_status_list extends ffi.Opaque {}

class git_rebase extends ffi.Opaque {}

/// Basic type of any Git reference.
abstract class git_reference_t {
  /// < Invalid reference
  static const int GIT_REFERENCE_INVALID = 0;

  /// < A reference that points at an object id
  static const int GIT_REFERENCE_DIRECT = 1;

  /// < A reference that points at another reference
  static const int GIT_REFERENCE_SYMBOLIC = 2;
  static const int GIT_REFERENCE_ALL = 3;
}

/// Basic type of any Git branch.
abstract class git_branch_t {
  static const int GIT_BRANCH_LOCAL = 1;
  static const int GIT_BRANCH_REMOTE = 2;
  static const int GIT_BRANCH_ALL = 3;
}

/// Valid modes for index and tree entries.
abstract class git_filemode_t {
  static const int GIT_FILEMODE_UNREADABLE = 0;
  static const int GIT_FILEMODE_TREE = 16384;
  static const int GIT_FILEMODE_BLOB = 33188;
  static const int GIT_FILEMODE_BLOB_EXECUTABLE = 33261;
  static const int GIT_FILEMODE_LINK = 40960;
  static const int GIT_FILEMODE_COMMIT = 57344;
}

class git_refspec extends ffi.Opaque {}

class git_remote extends ffi.Opaque {}

class git_transport extends ffi.Opaque {}

class git_push extends ffi.Opaque {}

/// Description of a reference advertised by a remote server, given out
/// on `ls` calls.
class git_remote_head extends ffi.Struct {
  /// available locally
  @ffi.Int32()
  external int local;

  external git_oid oid;

  external git_oid loid;

  external ffi.Pointer<ffi.Int8> name;

  /// If the server send a symref mapping for this ref, this will
  /// point to the target.
  external ffi.Pointer<ffi.Int8> symref_target;
}

/// The base structure for all credential types
class git_credential extends ffi.Struct {
  /// < A type of credential
  @ffi.Int32()
  external int credtype;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_12>> free;
}

/// Parent type for `git_cert_hostkey` and `git_cert_x509`.
class git_cert extends ffi.Struct {
  /// Type of certificate. A `GIT_CERT_` value.
  @ffi.Int32()
  external int cert_type;
}

/// Represents an update which will be performed on the remote during push
class git_push_update extends ffi.Struct {
  /// The source name of the reference
  external ffi.Pointer<ffi.Int8> src_refname;

  /// The name of the reference to update on the server
  external ffi.Pointer<ffi.Int8> dst_refname;

  /// The current target of the reference
  external git_oid src;

  /// The new target for the reference
  external git_oid dst;
}

/// The callback settings structure
///
/// Set the callbacks to be called by the remote when informing the user
/// about the progress of the network operations.
class git_remote_callbacks extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// Textual progress from the remote. Text send over the
  /// progress side-band will be passed to this function (this is
  /// the 'counting objects' output).
  external ffi.Pointer<ffi.NativeFunction<git_transport_message_cb>>
      sideband_progress;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_11>> completion;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<ffi.NativeFunction<git_credential_acquire_cb>>
      credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<ffi.NativeFunction<git_transport_certificate_check_cb>>
      certificate_check;

  /// During the download of new data, this will be regularly
  /// called with the current count of progress done by the
  /// indexer.
  external ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>>
      transfer_progress;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_13>> update_tips;

  /// Function to call with progress information during pack
  /// building. Be aware that this is called inline with pack
  /// building operations, so performance may be affected.
  external ffi.Pointer<ffi.NativeFunction<git_packbuilder_progress>>
      pack_progress;

  /// Function to call with progress information during the
  /// upload portion of a push. Be aware that this is called
  /// inline with pack building operations, so performance may be
  /// affected.
  external ffi.Pointer<ffi.NativeFunction<git_push_transfer_progress_cb>>
      push_transfer_progress;

  /// See documentation of git_push_update_reference_cb
  external ffi.Pointer<ffi.NativeFunction<git_push_update_reference_cb>>
      push_update_reference;

  /// Called once between the negotiation step and the upload. It
  /// provides information about what updates will be performed.
  external ffi.Pointer<ffi.NativeFunction<git_push_negotiation>>
      push_negotiation;

  /// Create the transport to use for this operation. Leave NULL
  /// to auto-detect.
  external ffi.Pointer<ffi.NativeFunction<git_transport_cb>> transport;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;

  /// Resolve URL before connecting to remote.
  /// The returned URL will be used to connect to the remote instead.
  external ffi.Pointer<ffi.NativeFunction<git_url_resolve_cb>> resolve_url;
}

class git_submodule extends ffi.Opaque {}

/// Submodule update values
///
/// These values represent settings for the `submodule.$name.update`
/// configuration value which says how to handle `git submodule update` for
/// this submodule.  The value is usually set in the ".gitmodules" file and
/// copied to ".git/config" when the submodule is initialized.
///
/// You can override this setting on a per-submodule basis with
/// `git_submodule_set_update()` and write the changed value to disk using
/// `git_submodule_save()`.  If you have overwritten the value, you can
/// revert it by passing `GIT_SUBMODULE_UPDATE_RESET` to the set function.
///
/// The values are:
///
/// - GIT_SUBMODULE_UPDATE_CHECKOUT: the default; when a submodule is
/// updated, checkout the new detached HEAD to the submodule directory.
/// - GIT_SUBMODULE_UPDATE_REBASE: update by rebasing the current checked
/// out branch onto the commit from the superproject.
/// - GIT_SUBMODULE_UPDATE_MERGE: update by merging the commit in the
/// superproject into the current checkout out branch of the submodule.
/// - GIT_SUBMODULE_UPDATE_NONE: do not update this submodule even when
/// the commit in the superproject is updated.
/// - GIT_SUBMODULE_UPDATE_DEFAULT: not used except as static initializer
/// when we don't want any particular update rule to be specified.
abstract class git_submodule_update_t {
  static const int GIT_SUBMODULE_UPDATE_CHECKOUT = 1;
  static const int GIT_SUBMODULE_UPDATE_REBASE = 2;
  static const int GIT_SUBMODULE_UPDATE_MERGE = 3;
  static const int GIT_SUBMODULE_UPDATE_NONE = 4;
  static const int GIT_SUBMODULE_UPDATE_DEFAULT = 0;
}

/// Submodule ignore values
///
/// These values represent settings for the `submodule.$name.ignore`
/// configuration value which says how deeply to look at the working
/// directory when getting submodule status.
///
/// You can override this value in memory on a per-submodule basis with
/// `git_submodule_set_ignore()` and can write the changed value to disk
/// with `git_submodule_save()`.  If you have overwritten the value, you
/// can revert to the on disk value by using `GIT_SUBMODULE_IGNORE_RESET`.
///
/// The values are:
///
/// - GIT_SUBMODULE_IGNORE_UNSPECIFIED: use the submodule's configuration
/// - GIT_SUBMODULE_IGNORE_NONE: don't ignore any change - i.e. even an
/// untracked file, will mark the submodule as dirty.  Ignored files are
/// still ignored, of course.
/// - GIT_SUBMODULE_IGNORE_UNTRACKED: ignore untracked files; only changes
/// to tracked files, or the index or the HEAD commit will matter.
/// - GIT_SUBMODULE_IGNORE_DIRTY: ignore changes in the working directory,
/// only considering changes if the HEAD of submodule has moved from the
/// value in the superproject.
/// - GIT_SUBMODULE_IGNORE_ALL: never check if the submodule is dirty
/// - GIT_SUBMODULE_IGNORE_DEFAULT: not used except as static initializer
/// when we don't want any particular ignore rule to be specified.
abstract class git_submodule_ignore_t {
  /// < use the submodule's configuration
  static const int GIT_SUBMODULE_IGNORE_UNSPECIFIED = -1;

  /// < any change or untracked == dirty
  static const int GIT_SUBMODULE_IGNORE_NONE = 1;

  /// < dirty if tracked files change
  static const int GIT_SUBMODULE_IGNORE_UNTRACKED = 2;

  /// < only dirty if HEAD moved
  static const int GIT_SUBMODULE_IGNORE_DIRTY = 3;

  /// < never dirty
  static const int GIT_SUBMODULE_IGNORE_ALL = 4;
}

/// Options for submodule recurse.
///
/// Represent the value of `submodule.$name.fetchRecurseSubmodules`
///
/// * GIT_SUBMODULE_RECURSE_NO    - do no recurse into submodules
/// * GIT_SUBMODULE_RECURSE_YES   - recurse into submodules
/// * GIT_SUBMODULE_RECURSE_ONDEMAND - recurse into submodules only when
/// commit not already in local clone
abstract class git_submodule_recurse_t {
  static const int GIT_SUBMODULE_RECURSE_NO = 0;
  static const int GIT_SUBMODULE_RECURSE_YES = 1;
  static const int GIT_SUBMODULE_RECURSE_ONDEMAND = 2;
}

/// A type to write in a streaming fashion, for example, for filters.
class git_writestream extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<_typedefC_14>> write;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_15>> close;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_16>> free;
}

class git_mailmap extends ffi.Opaque {}

/// Option flags for `git_repository_open_ext`.
abstract class git_repository_open_flag_t {
  /// Only open the repository if it can be immediately found in the
  /// start_path. Do not walk up from the start_path looking at parent
  /// directories.
  static const int GIT_REPOSITORY_OPEN_NO_SEARCH = 1;

  /// Unless this flag is set, open will not continue searching across
  /// filesystem boundaries (i.e. when `st_dev` changes from the `stat`
  /// system call).  For example, searching in a user's home directory at
  /// "/home/user/source/" will not return "/.git/" as the found repo if
  /// "/" is a different filesystem than "/home".
  static const int GIT_REPOSITORY_OPEN_CROSS_FS = 2;

  /// Open repository as a bare repo regardless of core.bare config, and
  /// defer loading config file for faster setup.
  /// Unlike `git_repository_open_bare`, this can follow gitlinks.
  static const int GIT_REPOSITORY_OPEN_BARE = 4;

  /// Do not check for a repository by appending /.git to the start_path;
  /// only open the repository if start_path itself points to the git
  /// directory.
  static const int GIT_REPOSITORY_OPEN_NO_DOTGIT = 8;

  /// Find and open a git repository, respecting the environment variables
  /// used by the git command-line tools.
  /// If set, `git_repository_open_ext` will ignore the other flags and
  /// the `ceiling_dirs` argument, and will allow a NULL `path` to use
  /// `GIT_DIR` or search from the current directory.
  /// The search for a repository will respect $GIT_CEILING_DIRECTORIES and
  /// $GIT_DISCOVERY_ACROSS_FILESYSTEM.  The opened repository will
  /// respect $GIT_INDEX_FILE, $GIT_NAMESPACE, $GIT_OBJECT_DIRECTORY, and
  /// $GIT_ALTERNATE_OBJECT_DIRECTORIES.
  /// In the future, this flag will also cause `git_repository_open_ext`
  /// to respect $GIT_WORK_TREE and $GIT_COMMON_DIR; currently,
  /// `git_repository_open_ext` with this flag will error out if either
  /// $GIT_WORK_TREE or $GIT_COMMON_DIR is set.
  static const int GIT_REPOSITORY_OPEN_FROM_ENV = 16;
}

/// Option flags for `git_repository_init_ext`.
///
/// These flags configure extra behaviors to `git_repository_init_ext`.
/// In every case, the default behavior is the zero value (i.e. flag is
/// not set).  Just OR the flag values together for the `flags` parameter
/// when initializing a new repo.  Details of individual values are:
///
/// * BARE   - Create a bare repository with no working directory.
/// * NO_REINIT - Return an GIT_EEXISTS error if the repo_path appears to
/// already be an git repository.
/// * NO_DOTGIT_DIR - Normally a "/.git/" will be appended to the repo
/// path for non-bare repos (if it is not already there), but
/// passing this flag prevents that behavior.
/// * MKDIR  - Make the repo_path (and workdir_path) as needed.  Init is
/// always willing to create the ".git" directory even without this
/// flag.  This flag tells init to create the trailing component of
/// the repo and workdir paths as needed.
/// * MKPATH - Recursively make all components of the repo and workdir
/// paths as necessary.
/// * EXTERNAL_TEMPLATE - libgit2 normally uses internal templates to
/// initialize a new repo.  This flags enables external templates,
/// looking the "template_path" from the options if set, or the
/// `init.templatedir` global config if not, or falling back on
/// "/usr/share/git-core/templates" if it exists.
/// * GIT_REPOSITORY_INIT_RELATIVE_GITLINK - If an alternate workdir is
/// specified, use relative paths for the gitdir and core.worktree.
abstract class git_repository_init_flag_t {
  static const int GIT_REPOSITORY_INIT_BARE = 1;
  static const int GIT_REPOSITORY_INIT_NO_REINIT = 2;
  static const int GIT_REPOSITORY_INIT_NO_DOTGIT_DIR = 4;
  static const int GIT_REPOSITORY_INIT_MKDIR = 8;
  static const int GIT_REPOSITORY_INIT_MKPATH = 16;
  static const int GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE = 32;
  static const int GIT_REPOSITORY_INIT_RELATIVE_GITLINK = 64;
}

/// Mode options for `git_repository_init_ext`.
///
/// Set the mode field of the `git_repository_init_options` structure
/// either to the custom mode that you would like, or to one of the
/// following modes:
///
/// * SHARED_UMASK - Use permissions configured by umask - the default.
/// * SHARED_GROUP - Use "--shared=group" behavior, chmod'ing the new repo
/// to be group writable and "g+sx" for sticky group assignment.
/// * SHARED_ALL - Use "--shared=all" behavior, adding world readability.
/// * Anything else - Set to custom value.
abstract class git_repository_init_mode_t {
  static const int GIT_REPOSITORY_INIT_SHARED_UMASK = 0;
  static const int GIT_REPOSITORY_INIT_SHARED_GROUP = 1533;
  static const int GIT_REPOSITORY_INIT_SHARED_ALL = 1535;
}

/// Extended options structure for `git_repository_init_ext`.
///
/// This contains extra options for `git_repository_init_ext` that enable
/// additional initialization features.  The fields are:
///
/// * flags - Combination of GIT_REPOSITORY_INIT flags above.
/// * mode  - Set to one of the standard GIT_REPOSITORY_INIT_SHARED_...
/// constants above, or to a custom value that you would like.
/// * workdir_path - The path to the working dir or NULL for default (i.e.
/// repo_path parent on non-bare repos).  IF THIS IS RELATIVE PATH,
/// IT WILL BE EVALUATED RELATIVE TO THE REPO_PATH.  If this is not
/// the "natural" working directory, a .git gitlink file will be
/// created here linking to the repo_path.
/// * description - If set, this will be used to initialize the "description"
/// file in the repository, instead of using the template content.
/// * template_path - When GIT_REPOSITORY_INIT_EXTERNAL_TEMPLATE is set,
/// this contains the path to use for the template directory.  If
/// this is NULL, the config or default directory options will be
/// used instead.
/// * initial_head - The name of the head to point HEAD at.  If NULL, then
/// this will be treated as "master" and the HEAD ref will be set
/// to "refs/heads/master".  If this begins with "refs/" it will be
/// used verbatim; otherwise "refs/heads/" will be prefixed.
/// * origin_url - If this is non-NULL, then after the rest of the
/// repository initialization is completed, an "origin" remote
/// will be added pointing to this URL.
class git_repository_init_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  @ffi.Uint32()
  external int flags;

  @ffi.Uint32()
  external int mode;

  external ffi.Pointer<ffi.Int8> workdir_path;

  external ffi.Pointer<ffi.Int8> description;

  external ffi.Pointer<ffi.Int8> template_path;

  external ffi.Pointer<ffi.Int8> initial_head;

  external ffi.Pointer<ffi.Int8> origin_url;
}

/// List of items which belong to the git repository layout
abstract class git_repository_item_t {
  static const int GIT_REPOSITORY_ITEM_GITDIR = 0;
  static const int GIT_REPOSITORY_ITEM_WORKDIR = 1;
  static const int GIT_REPOSITORY_ITEM_COMMONDIR = 2;
  static const int GIT_REPOSITORY_ITEM_INDEX = 3;
  static const int GIT_REPOSITORY_ITEM_OBJECTS = 4;
  static const int GIT_REPOSITORY_ITEM_REFS = 5;
  static const int GIT_REPOSITORY_ITEM_PACKED_REFS = 6;
  static const int GIT_REPOSITORY_ITEM_REMOTES = 7;
  static const int GIT_REPOSITORY_ITEM_CONFIG = 8;
  static const int GIT_REPOSITORY_ITEM_INFO = 9;
  static const int GIT_REPOSITORY_ITEM_HOOKS = 10;
  static const int GIT_REPOSITORY_ITEM_LOGS = 11;
  static const int GIT_REPOSITORY_ITEM_MODULES = 12;
  static const int GIT_REPOSITORY_ITEM_WORKTREES = 13;
  static const int GIT_REPOSITORY_ITEM__LAST = 14;
}

/// Repository state
///
/// These values represent possible states for the repository to be in,
/// based on the current operation which is ongoing.
abstract class git_repository_state_t {
  static const int GIT_REPOSITORY_STATE_NONE = 0;
  static const int GIT_REPOSITORY_STATE_MERGE = 1;
  static const int GIT_REPOSITORY_STATE_REVERT = 2;
  static const int GIT_REPOSITORY_STATE_REVERT_SEQUENCE = 3;
  static const int GIT_REPOSITORY_STATE_CHERRYPICK = 4;
  static const int GIT_REPOSITORY_STATE_CHERRYPICK_SEQUENCE = 5;
  static const int GIT_REPOSITORY_STATE_BISECT = 6;
  static const int GIT_REPOSITORY_STATE_REBASE = 7;
  static const int GIT_REPOSITORY_STATE_REBASE_INTERACTIVE = 8;
  static const int GIT_REPOSITORY_STATE_REBASE_MERGE = 9;
  static const int GIT_REPOSITORY_STATE_APPLY_MAILBOX = 10;
  static const int GIT_REPOSITORY_STATE_APPLY_MAILBOX_OR_REBASE = 11;
}

/// Tree traversal modes
abstract class git_treewalk_mode {
  /// Pre-order
  static const int GIT_TREEWALK_PRE = 0;

  /// Post-order
  static const int GIT_TREEWALK_POST = 1;
}

/// The kind of update to perform
abstract class git_tree_update_t {
  /// Update or insert an entry at the specified path
  static const int GIT_TREE_UPDATE_UPSERT = 0;

  /// Remove an entry from the specified path
  static const int GIT_TREE_UPDATE_REMOVE = 1;
}

/// An action to perform during the update of a tree
class git_tree_update extends ffi.Struct {
  /// Update action. If it's an removal, only the path is looked at
  @ffi.Int32()
  external int action;

  /// The entry's id
  external git_oid id;

  /// The filemode/kind of object
  @ffi.Int32()
  external int filemode;

  /// The full path from the root tree
  external ffi.Pointer<ffi.Int8> path;
}

/// Array of strings
class git_strarray extends ffi.Struct {
  external ffi.Pointer<ffi.Pointer<ffi.Int8>> strings;

  @ffi.Int32()
  external int count;
}

/// Normalization options for reference lookup
abstract class git_reference_format_t {
  /// No particular normalization.
  static const int GIT_REFERENCE_FORMAT_NORMAL = 0;

  /// Control whether one-level refnames are accepted
  /// (i.e., refnames that do not contain multiple /-separated
  /// components). Those are expected to be written only using
  /// uppercase letters and underscore (FETCH_HEAD, ...)
  static const int GIT_REFERENCE_FORMAT_ALLOW_ONELEVEL = 1;

  /// Interpret the provided name as a reference pattern for a
  /// refspec (as used with remote repositories). If this option
  /// is enabled, the name is allowed to contain a single * (<star>)
  /// in place of a one full pathname component
  /// (e.g., foo/<star>/bar but not foo/bar<star>).
  static const int GIT_REFERENCE_FORMAT_REFSPEC_PATTERN = 2;

  /// Interpret the name as part of a refspec in shorthand form
  /// so the `ONELEVEL` naming rules aren't enforced and 'master'
  /// becomes a valid name.
  static const int GIT_REFERENCE_FORMAT_REFSPEC_SHORTHAND = 4;
}

/// Flags for diff options.  A combination of these flags can be passed
/// in via the `flags` value in the `git_diff_options`.
abstract class git_diff_option_t {
  /// Normal diff, the default
  static const int GIT_DIFF_NORMAL = 0;

  /// Reverse the sides of the diff
  static const int GIT_DIFF_REVERSE = 1;

  /// Include ignored files in the diff
  static const int GIT_DIFF_INCLUDE_IGNORED = 2;

  /// Even with GIT_DIFF_INCLUDE_IGNORED, an entire ignored directory
  /// will be marked with only a single entry in the diff; this flag
  /// adds all files under the directory as IGNORED entries, too.
  static const int GIT_DIFF_RECURSE_IGNORED_DIRS = 4;

  /// Include untracked files in the diff
  static const int GIT_DIFF_INCLUDE_UNTRACKED = 8;

  /// Even with GIT_DIFF_INCLUDE_UNTRACKED, an entire untracked
  /// directory will be marked with only a single entry in the diff
  /// (a la what core Git does in `git status`); this flag adds *all*
  /// files under untracked directories as UNTRACKED entries, too.
  static const int GIT_DIFF_RECURSE_UNTRACKED_DIRS = 16;

  /// Include unmodified files in the diff
  static const int GIT_DIFF_INCLUDE_UNMODIFIED = 32;

  /// Normally, a type change between files will be converted into a
  /// DELETED record for the old and an ADDED record for the new; this
  /// options enabled the generation of TYPECHANGE delta records.
  static const int GIT_DIFF_INCLUDE_TYPECHANGE = 64;

  /// Even with GIT_DIFF_INCLUDE_TYPECHANGE, blob->tree changes still
  /// generally show as a DELETED blob.  This flag tries to correctly
  /// label blob->tree transitions as TYPECHANGE records with new_file's
  /// mode set to tree.  Note: the tree SHA will not be available.
  static const int GIT_DIFF_INCLUDE_TYPECHANGE_TREES = 128;

  /// Ignore file mode changes
  static const int GIT_DIFF_IGNORE_FILEMODE = 256;

  /// Treat all submodules as unmodified
  static const int GIT_DIFF_IGNORE_SUBMODULES = 512;

  /// Use case insensitive filename comparisons
  static const int GIT_DIFF_IGNORE_CASE = 1024;

  /// May be combined with `GIT_DIFF_IGNORE_CASE` to specify that a file
  /// that has changed case will be returned as an add/delete pair.
  static const int GIT_DIFF_INCLUDE_CASECHANGE = 2048;

  /// If the pathspec is set in the diff options, this flags indicates
  /// that the paths will be treated as literal paths instead of
  /// fnmatch patterns.  Each path in the list must either be a full
  /// path to a file or a directory.  (A trailing slash indicates that
  /// the path will _only_ match a directory).  If a directory is
  /// specified, all children will be included.
  static const int GIT_DIFF_DISABLE_PATHSPEC_MATCH = 4096;

  /// Disable updating of the `binary` flag in delta records.  This is
  /// useful when iterating over a diff if you don't need hunk and data
  /// callbacks and want to avoid having to load file completely.
  static const int GIT_DIFF_SKIP_BINARY_CHECK = 8192;

  /// When diff finds an untracked directory, to match the behavior of
  /// core Git, it scans the contents for IGNORED and UNTRACKED files.
  /// If *all* contents are IGNORED, then the directory is IGNORED; if
  /// any contents are not IGNORED, then the directory is UNTRACKED.
  /// This is extra work that may not matter in many cases.  This flag
  /// turns off that scan and immediately labels an untracked directory
  /// as UNTRACKED (changing the behavior to not match core Git).
  static const int GIT_DIFF_ENABLE_FAST_UNTRACKED_DIRS = 16384;

  /// When diff finds a file in the working directory with stat
  /// information different from the index, but the OID ends up being the
  /// same, write the correct stat information into the index.  Note:
  /// without this flag, diff will always leave the index untouched.
  static const int GIT_DIFF_UPDATE_INDEX = 32768;

  /// Include unreadable files in the diff
  static const int GIT_DIFF_INCLUDE_UNREADABLE = 65536;

  /// Include unreadable files in the diff
  static const int GIT_DIFF_INCLUDE_UNREADABLE_AS_UNTRACKED = 131072;

  /// Use a heuristic that takes indentation and whitespace into account
  /// which generally can produce better diffs when dealing with ambiguous
  /// diff hunks.
  static const int GIT_DIFF_INDENT_HEURISTIC = 262144;

  /// Treat all files as text, disabling binary attributes & detection
  static const int GIT_DIFF_FORCE_TEXT = 1048576;

  /// Treat all files as binary, disabling text diffs
  static const int GIT_DIFF_FORCE_BINARY = 2097152;

  /// Ignore all whitespace
  static const int GIT_DIFF_IGNORE_WHITESPACE = 4194304;

  /// Ignore changes in amount of whitespace
  static const int GIT_DIFF_IGNORE_WHITESPACE_CHANGE = 8388608;

  /// Ignore whitespace at end of line
  static const int GIT_DIFF_IGNORE_WHITESPACE_EOL = 16777216;

  /// When generating patch text, include the content of untracked
  /// files.  This automatically turns on GIT_DIFF_INCLUDE_UNTRACKED but
  /// it does not turn on GIT_DIFF_RECURSE_UNTRACKED_DIRS.  Add that
  /// flag if you want the content of every single UNTRACKED file.
  static const int GIT_DIFF_SHOW_UNTRACKED_CONTENT = 33554432;

  /// When generating output, include the names of unmodified files if
  /// they are included in the git_diff.  Normally these are skipped in
  /// the formats that list files (e.g. name-only, name-status, raw).
  /// Even with this, these will not be included in patch format.
  static const int GIT_DIFF_SHOW_UNMODIFIED = 67108864;

  /// Use the "patience diff" algorithm
  static const int GIT_DIFF_PATIENCE = 268435456;

  /// Take extra time to find minimal diff
  static const int GIT_DIFF_MINIMAL = 536870912;

  /// Include the necessary deflate / delta information so that `git-apply`
  /// can apply given diff information to binary files.
  static const int GIT_DIFF_SHOW_BINARY = 1073741824;
}

class git_diff extends ffi.Opaque {}

/// Flags for the delta object and the file objects on each side.
///
/// These flags are used for both the `flags` value of the `git_diff_delta`
/// and the flags for the `git_diff_file` objects representing the old and
/// new sides of the delta.  Values outside of this public range should be
/// considered reserved for internal or future use.
abstract class git_diff_flag_t {
  /// < file(s) treated as binary data
  static const int GIT_DIFF_FLAG_BINARY = 1;

  /// < file(s) treated as text data
  static const int GIT_DIFF_FLAG_NOT_BINARY = 2;

  /// < `id` value is known correct
  static const int GIT_DIFF_FLAG_VALID_ID = 4;

  /// < file exists at this side of the delta
  static const int GIT_DIFF_FLAG_EXISTS = 8;
}

/// What type of change is described by a git_diff_delta?
///
/// `GIT_DELTA_RENAMED` and `GIT_DELTA_COPIED` will only show up if you run
/// `git_diff_find_similar()` on the diff object.
///
/// `GIT_DELTA_TYPECHANGE` only shows up given `GIT_DIFF_INCLUDE_TYPECHANGE`
/// in the option flags (otherwise type changes will be split into ADDED /
/// DELETED pairs).
abstract class git_delta_t {
  /// < no changes
  static const int GIT_DELTA_UNMODIFIED = 0;

  /// < entry does not exist in old version
  static const int GIT_DELTA_ADDED = 1;

  /// < entry does not exist in new version
  static const int GIT_DELTA_DELETED = 2;

  /// < entry content changed between old and new
  static const int GIT_DELTA_MODIFIED = 3;

  /// < entry was renamed between old and new
  static const int GIT_DELTA_RENAMED = 4;

  /// < entry was copied from another old entry
  static const int GIT_DELTA_COPIED = 5;

  /// < entry is ignored item in workdir
  static const int GIT_DELTA_IGNORED = 6;

  /// < entry is untracked item in workdir
  static const int GIT_DELTA_UNTRACKED = 7;

  /// < type of entry changed between old and new
  static const int GIT_DELTA_TYPECHANGE = 8;

  /// < entry is unreadable
  static const int GIT_DELTA_UNREADABLE = 9;

  /// < entry in the index is conflicted
  static const int GIT_DELTA_CONFLICTED = 10;
}

/// Description of one side of a delta.
///
/// Although this is called a "file", it could represent a file, a symbolic
/// link, a submodule commit id, or even a tree (although that only if you
/// are tracking type changes or ignored/untracked directories).
///
/// The `id` is the `git_oid` of the item.  If the entry represents an
/// absent side of a diff (e.g. the `old_file` of a `GIT_DELTA_ADDED` delta),
/// then the oid will be zeroes.
///
/// `path` is the NUL-terminated path to the entry relative to the working
/// directory of the repository.
///
/// `size` is the size of the entry in bytes.
///
/// `flags` is a combination of the `git_diff_flag_t` types
///
/// `mode` is, roughly, the stat() `st_mode` value for the item.  This will
/// be restricted to one of the `git_filemode_t` values.
///
/// The `id_abbrev` represents the known length of the `id` field, when
/// converted to a hex string.  It is generally `GIT_OID_HEXSZ`, unless this
/// delta was created from reading a patch file, in which case it may be
/// abbreviated to something reasonable, like 7 characters.
class git_diff_file extends ffi.Struct {
  external git_oid id;

  external ffi.Pointer<ffi.Int8> path;

  @ffi.Uint64()
  external int size;

  @ffi.Uint32()
  external int flags;

  @ffi.Uint16()
  external int mode;

  @ffi.Uint16()
  external int id_abbrev;
}

/// Description of changes to one entry.
///
/// A `delta` is a file pair with an old and new revision.  The old version
/// may be absent if the file was just created and the new version may be
/// absent if the file was deleted.  A diff is mostly just a list of deltas.
///
/// When iterating over a diff, this will be passed to most callbacks and
/// you can use the contents to understand exactly what has changed.
///
/// The `old_file` represents the "from" side of the diff and the `new_file`
/// represents to "to" side of the diff.  What those means depend on the
/// function that was used to generate the diff and will be documented below.
/// You can also use the `GIT_DIFF_REVERSE` flag to flip it around.
///
/// Although the two sides of the delta are named "old_file" and "new_file",
/// they actually may correspond to entries that represent a file, a symbolic
/// link, a submodule commit id, or even a tree (if you are tracking type
/// changes or ignored/untracked directories).
///
/// Under some circumstances, in the name of efficiency, not all fields will
/// be filled in, but we generally try to fill in as much as possible.  One
/// example is that the "flags" field may not have either the `BINARY` or the
/// `NOT_BINARY` flag set to avoid examining file contents if you do not pass
/// in hunk and/or line callbacks to the diff foreach iteration function.  It
/// will just use the git attributes for those files.
///
/// The similarity score is zero unless you call `git_diff_find_similar()`
/// which does a similarity analysis of files in the diff.  Use that
/// function to do rename and copy detection, and to split heavily modified
/// files in add/delete pairs.  After that call, deltas with a status of
/// GIT_DELTA_RENAMED or GIT_DELTA_COPIED will have a similarity score
/// between 0 and 100 indicating how similar the old and new sides are.
///
/// If you ask `git_diff_find_similar` to find heavily modified files to
/// break, but to not *actually* break the records, then GIT_DELTA_MODIFIED
/// records may have a non-zero similarity score if the self-similarity is
/// below the split threshold.  To display this value like core Git, invert
/// the score (a la `printf("M%03d", 100 - delta->similarity)`).
class git_diff_delta extends ffi.Struct {
  @ffi.Int32()
  external int status;

  /// < git_diff_flag_t values
  @ffi.Uint32()
  external int flags;

  /// < for RENAMED and COPIED, value 0-100
  @ffi.Uint16()
  external int similarity;

  /// < number of files in this delta
  @ffi.Uint16()
  external int nfiles;

  external git_diff_file old_file;

  external git_diff_file new_file;
}

/// Structure describing options about how the diff should be executed.
///
/// Setting all values of the structure to zero will yield the default
/// values.  Similarly, passing NULL for the options structure will
/// give the defaults.  The default values are marked below.
class git_diff_options extends ffi.Struct {
  /// < version for the struct
  @ffi.Uint32()
  external int version;

  /// A combination of `git_diff_option_t` values above.
  /// Defaults to GIT_DIFF_NORMAL
  @ffi.Uint32()
  external int flags;

  /// Overrides the submodule ignore setting for all submodules in the diff.
  @ffi.Int32()
  external int ignore_submodules;

  /// An array of paths / fnmatch patterns to constrain diff.
  /// All paths are included by default.
  external git_strarray pathspec;

  /// An optional callback function, notifying the consumer of changes to
  /// the diff as new deltas are added.
  external ffi.Pointer<ffi.NativeFunction<git_diff_notify_cb>> notify_cb;

  /// An optional callback function, notifying the consumer of which files
  /// are being examined as the diff is generated.
  external ffi.Pointer<ffi.NativeFunction<git_diff_progress_cb>> progress_cb;

  /// The payload to pass to the callback functions.
  external ffi.Pointer<ffi.Void> payload;

  /// The number of unchanged lines that define the boundary of a hunk
  /// (and to display before and after). Defaults to 3.
  @ffi.Uint32()
  external int context_lines;

  /// The maximum number of unchanged lines between hunk boundaries before
  /// the hunks will be merged into one. Defaults to 0.
  @ffi.Uint32()
  external int interhunk_lines;

  /// The abbreviation length to use when formatting object ids.
  /// Defaults to the value of 'core.abbrev' from the config, or 7 if unset.
  @ffi.Uint16()
  external int id_abbrev;

  /// A size (in bytes) above which a blob will be marked as binary
  /// automatically; pass a negative value to disable.
  /// Defaults to 512MB.
  @ffi.Int64()
  external int max_size;

  /// The virtual "directory" prefix for old file names in hunk headers.
  /// Default is "a".
  external ffi.Pointer<ffi.Int8> old_prefix;

  /// The virtual "directory" prefix for new file names in hunk headers.
  /// Defaults to "b".
  external ffi.Pointer<ffi.Int8> new_prefix;
}

/// When producing a binary diff, the binary data returned will be
/// either the deflated full ("literal") contents of the file, or
/// the deflated binary delta between the two sides (whichever is
/// smaller).
abstract class git_diff_binary_t {
  /// There is no binary delta.
  static const int GIT_DIFF_BINARY_NONE = 0;

  /// The binary data is the literal contents of the file.
  static const int GIT_DIFF_BINARY_LITERAL = 1;

  /// The binary data is the delta from one side to the other.
  static const int GIT_DIFF_BINARY_DELTA = 2;
}

/// The contents of one of the files in a binary diff.
class git_diff_binary_file extends ffi.Struct {
  /// The type of binary data for this file.
  @ffi.Int32()
  external int type;

  /// The binary data, deflated.
  external ffi.Pointer<ffi.Int8> data;

  /// The length of the binary data.
  @ffi.Int32()
  external int datalen;

  /// The length of the binary data after inflation.
  @ffi.Int32()
  external int inflatedlen;
}

/// Structure describing the binary contents of a diff.
///
/// A `binary` file / delta is a file (or pair) for which no text diffs
/// should be generated. A diff can contain delta entries that are
/// binary, but no diff content will be output for those files. There is
/// a base heuristic for binary detection and you can further tune the
/// behavior with git attributes or diff flags and option settings.
class git_diff_binary extends ffi.Struct {
  /// Whether there is data in this binary structure or not.
  ///
  /// If this is `1`, then this was produced and included binary content.
  /// If this is `0` then this was generated knowing only that a binary
  /// file changed but without providing the data, probably from a patch
  /// that said `Binary files a/file.txt and b/file.txt differ`.
  @ffi.Uint32()
  external int contains_data;

  /// < The contents of the old file.
  external git_diff_binary_file old_file;

  /// < The contents of the new file.
  external git_diff_binary_file new_file;
}

/// Structure describing a hunk of a diff.
///
/// A `hunk` is a span of modified lines in a delta along with some stable
/// surrounding context. You can configure the amount of context and other
/// properties of how hunks are generated. Each hunk also comes with a
/// header that described where it starts and ends in both the old and new
/// versions in the delta.
class git_diff_hunk extends ffi.Struct {
  /// < Starting line number in old_file
  @ffi.Int32()
  external int old_start;

  /// < Number of lines in old_file
  @ffi.Int32()
  external int old_lines;

  /// < Starting line number in new_file
  @ffi.Int32()
  external int new_start;

  /// < Number of lines in new_file
  @ffi.Int32()
  external int new_lines;

  /// < Number of bytes in header text
  @ffi.Int32()
  external int header_len;

  @ffi.Array.multi([128])
  external ffi.Array<ffi.Int8> header;
}

/// Line origin constants.
///
/// These values describe where a line came from and will be passed to
/// the git_diff_line_cb when iterating over a diff.  There are some
/// special origin constants at the end that are used for the text
/// output callbacks to demarcate lines that are actually part of
/// the file or hunk headers.
abstract class git_diff_line_t {
  /// These values will be sent to `git_diff_line_cb` along with the line
  static const int GIT_DIFF_LINE_CONTEXT = 32;
  static const int GIT_DIFF_LINE_ADDITION = 43;
  static const int GIT_DIFF_LINE_DELETION = 45;

  /// < Both files have no LF at end
  static const int GIT_DIFF_LINE_CONTEXT_EOFNL = 61;

  /// < Old has no LF at end, new does
  static const int GIT_DIFF_LINE_ADD_EOFNL = 62;

  /// < Old has LF at end, new does not
  static const int GIT_DIFF_LINE_DEL_EOFNL = 60;

  /// The following values will only be sent to a `git_diff_line_cb` when
  /// the content of a diff is being formatted through `git_diff_print`.
  static const int GIT_DIFF_LINE_FILE_HDR = 70;
  static const int GIT_DIFF_LINE_HUNK_HDR = 72;

  /// < For "Binary files x and y differ"
  static const int GIT_DIFF_LINE_BINARY = 66;
}

/// Structure describing a line (or data span) of a diff.
///
/// A `line` is a range of characters inside a hunk.  It could be a context
/// line (i.e. in both old and new versions), an added line (i.e. only in
/// the new version), or a removed line (i.e. only in the old version).
/// Unfortunately, we don't know anything about the encoding of data in the
/// file being diffed, so we cannot tell you much about the line content.
/// Line data will not be NUL-byte terminated, however, because it will be
/// just a span of bytes inside the larger file.
class git_diff_line extends ffi.Struct {
  /// < A git_diff_line_t value
  @ffi.Int8()
  external int origin;

  /// < Line number in old file or -1 for added line
  @ffi.Int32()
  external int old_lineno;

  /// < Line number in new file or -1 for deleted line
  @ffi.Int32()
  external int new_lineno;

  /// < Number of newline characters in content
  @ffi.Int32()
  external int num_lines;

  /// < Number of bytes of data
  @ffi.Int32()
  external int content_len;

  /// < Offset in the original file to the content
  @ffi.Int64()
  external int content_offset;

  /// < Pointer to diff text, not NUL-byte terminated
  external ffi.Pointer<ffi.Int8> content;
}

/// Flags to control the behavior of diff rename/copy detection.
abstract class git_diff_find_t {
  /// Obey `diff.renames`. Overridden by any other GIT_DIFF_FIND_... flag.
  static const int GIT_DIFF_FIND_BY_CONFIG = 0;

  /// Look for renames? (`--find-renames`)
  static const int GIT_DIFF_FIND_RENAMES = 1;

  /// Consider old side of MODIFIED for renames? (`--break-rewrites=N`)
  static const int GIT_DIFF_FIND_RENAMES_FROM_REWRITES = 2;

  /// Look for copies? (a la `--find-copies`).
  static const int GIT_DIFF_FIND_COPIES = 4;

  /// Consider UNMODIFIED as copy sources? (`--find-copies-harder`).
  ///
  /// For this to work correctly, use GIT_DIFF_INCLUDE_UNMODIFIED when
  /// the initial `git_diff` is being generated.
  static const int GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED = 8;

  /// Mark significant rewrites for split (`--break-rewrites=/M`)
  static const int GIT_DIFF_FIND_REWRITES = 16;

  /// Actually split large rewrites into delete/add pairs
  static const int GIT_DIFF_BREAK_REWRITES = 32;

  /// Mark rewrites for split and break into delete/add pairs
  static const int GIT_DIFF_FIND_AND_BREAK_REWRITES = 48;

  /// Find renames/copies for UNTRACKED items in working directory.
  ///
  /// For this to work correctly, use GIT_DIFF_INCLUDE_UNTRACKED when the
  /// initial `git_diff` is being generated (and obviously the diff must
  /// be against the working directory for this to make sense).
  static const int GIT_DIFF_FIND_FOR_UNTRACKED = 64;

  /// Turn on all finding features.
  static const int GIT_DIFF_FIND_ALL = 255;

  /// Measure similarity ignoring leading whitespace (default)
  static const int GIT_DIFF_FIND_IGNORE_LEADING_WHITESPACE = 0;

  /// Measure similarity ignoring all whitespace
  static const int GIT_DIFF_FIND_IGNORE_WHITESPACE = 4096;

  /// Measure similarity including all data
  static const int GIT_DIFF_FIND_DONT_IGNORE_WHITESPACE = 8192;

  /// Measure similarity only by comparing SHAs (fast and cheap)
  static const int GIT_DIFF_FIND_EXACT_MATCH_ONLY = 16384;

  /// Do not break rewrites unless they contribute to a rename.
  ///
  /// Normally, GIT_DIFF_FIND_AND_BREAK_REWRITES will measure the self-
  /// similarity of modified files and split the ones that have changed a
  /// lot into a DELETE / ADD pair.  Then the sides of that pair will be
  /// considered candidates for rename and copy detection.
  ///
  /// If you add this flag in and the split pair is *not* used for an
  /// actual rename or copy, then the modified record will be restored to
  /// a regular MODIFIED record instead of being split.
  static const int GIT_DIFF_BREAK_REWRITES_FOR_RENAMES_ONLY = 32768;

  /// Remove any UNMODIFIED deltas after find_similar is done.
  ///
  /// Using GIT_DIFF_FIND_COPIES_FROM_UNMODIFIED to emulate the
  /// --find-copies-harder behavior requires building a diff with the
  /// GIT_DIFF_INCLUDE_UNMODIFIED flag.  If you do not want UNMODIFIED
  /// records in the final result, pass this flag to have them removed.
  static const int GIT_DIFF_FIND_REMOVE_UNMODIFIED = 65536;
}

/// Pluggable similarity metric
class git_diff_similarity_metric extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<_typedefC_17>> file_signature;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_18>> buffer_signature;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_19>> free_signature;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_20>> similarity;

  external ffi.Pointer<ffi.Void> payload;
}

/// Control behavior of rename and copy detection
///
/// These options mostly mimic parameters that can be passed to git-diff.
class git_diff_find_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Combination of git_diff_find_t values (default GIT_DIFF_FIND_BY_CONFIG).
  /// NOTE: if you don't explicitly set this, `diff.renames` could be set
  /// to false, resulting in `git_diff_find_similar` doing nothing.
  @ffi.Uint32()
  external int flags;

  /// Threshold above which similar files will be considered renames.
  /// This is equivalent to the -M option. Defaults to 50.
  @ffi.Uint16()
  external int rename_threshold;

  /// Threshold below which similar files will be eligible to be a rename source.
  /// This is equivalent to the first part of the -B option. Defaults to 50.
  @ffi.Uint16()
  external int rename_from_rewrite_threshold;

  /// Threshold above which similar files will be considered copies.
  /// This is equivalent to the -C option. Defaults to 50.
  @ffi.Uint16()
  external int copy_threshold;

  /// Treshold below which similar files will be split into a delete/add pair.
  /// This is equivalent to the last part of the -B option. Defaults to 60.
  @ffi.Uint16()
  external int break_rewrite_threshold;

  /// Maximum number of matches to consider for a particular file.
  ///
  /// This is a little different from the `-l` option from Git because we
  /// will still process up to this many matches before abandoning the search.
  /// Defaults to 200.
  @ffi.Int32()
  external int rename_limit;

  /// The `metric` option allows you to plug in a custom similarity metric.
  ///
  /// Set it to NULL to use the default internal metric.
  ///
  /// The default metric is based on sampling hashes of ranges of data in
  /// the file, which is a pretty good similarity approximation that should
  /// work fairly well for both text and binary data while still being
  /// pretty fast with a fixed memory overhead.
  external ffi.Pointer<git_diff_similarity_metric> metric;
}

/// Possible output formats for diff data
abstract class git_diff_format_t {
  /// < full git diff
  static const int GIT_DIFF_FORMAT_PATCH = 1;

  /// < just the file headers of patch
  static const int GIT_DIFF_FORMAT_PATCH_HEADER = 2;

  /// < like git diff --raw
  static const int GIT_DIFF_FORMAT_RAW = 3;

  /// < like git diff --name-only
  static const int GIT_DIFF_FORMAT_NAME_ONLY = 4;

  /// < like git diff --name-status
  static const int GIT_DIFF_FORMAT_NAME_STATUS = 5;

  /// < git diff as used by git patch-id
  static const int GIT_DIFF_FORMAT_PATCH_ID = 6;
}

class git_diff_stats extends ffi.Opaque {}

/// Formatting options for diff stats
abstract class git_diff_stats_format_t {
  /// No stats
  static const int GIT_DIFF_STATS_NONE = 0;

  /// Full statistics, equivalent of `--stat`
  static const int GIT_DIFF_STATS_FULL = 1;

  /// Short statistics, equivalent of `--shortstat`
  static const int GIT_DIFF_STATS_SHORT = 2;

  /// Number statistics, equivalent of `--numstat`
  static const int GIT_DIFF_STATS_NUMBER = 4;

  /// Extended header information such as creations, renames and mode changes, equivalent of `--summary`
  static const int GIT_DIFF_STATS_INCLUDE_SUMMARY = 8;
}

/// Formatting options for diff e-mail generation
abstract class git_diff_format_email_flags_t {
  /// Normal patch, the default
  static const int GIT_DIFF_FORMAT_EMAIL_NONE = 0;

  /// Don't insert "[PATCH]" in the subject header
  static const int GIT_DIFF_FORMAT_EMAIL_EXCLUDE_SUBJECT_PATCH_MARKER = 1;
}

/// Options for controlling the formatting of the generated e-mail.
class git_diff_format_email_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// see `git_diff_format_email_flags_t` above
  @ffi.Uint32()
  external int flags;

  /// This patch number
  @ffi.Int32()
  external int patch_no;

  /// Total number of patches in this series
  @ffi.Int32()
  external int total_patches;

  /// id to use for the commit
  external ffi.Pointer<git_oid> id;

  /// Summary of the change
  external ffi.Pointer<ffi.Int8> summary;

  /// Commit message's body
  external ffi.Pointer<ffi.Int8> body;

  /// Author of the change
  external ffi.Pointer<git_signature> author;
}

/// Patch ID options structure
///
/// Initialize with `GIT_PATCHID_OPTIONS_INIT`. Alternatively, you can
/// use `git_diff_patchid_options_init`.
class git_diff_patchid_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;
}

/// Flags controlling the behavior of git_apply
abstract class git_apply_flags_t {
  /// Don't actually make changes, just test that the patch applies.
  /// This is the equivalent of `git apply --check`.
  static const int GIT_APPLY_CHECK = 1;
}

/// Apply options structure
///
/// Initialize with `GIT_APPLY_OPTIONS_INIT`. Alternatively, you can
/// use `git_apply_options_init`.
///
/// @see git_apply_to_tree, git_apply
class git_apply_options extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// When applying a patch, callback that will be made per delta (file).
  external ffi.Pointer<ffi.NativeFunction<git_apply_delta_cb>> delta_cb;

  /// When applying a patch, callback that will be made per hunk.
  external ffi.Pointer<ffi.NativeFunction<git_apply_hunk_cb>> hunk_cb;

  /// Payload passed to both delta_cb & hunk_cb.
  external ffi.Pointer<ffi.Void> payload;

  /// Bitmask of git_apply_flags_t
  @ffi.Uint32()
  external int flags;
}

/// Possible application locations for git_apply
abstract class git_apply_location_t {
  /// Apply the patch to the workdir, leaving the index untouched.
  /// This is the equivalent of `git apply` with no location argument.
  static const int GIT_APPLY_LOCATION_WORKDIR = 0;

  /// Apply the patch to the index, leaving the working directory
  /// untouched.  This is the equivalent of `git apply --cached`.
  static const int GIT_APPLY_LOCATION_INDEX = 1;

  /// Apply the patch to both the working directory and the index.
  /// This is the equivalent of `git apply --index`.
  static const int GIT_APPLY_LOCATION_BOTH = 2;
}

/// Possible states for an attribute
abstract class git_attr_value_t {
  /// < The attribute has been left unspecified
  static const int GIT_ATTR_VALUE_UNSPECIFIED = 0;

  /// < The attribute has been set
  static const int GIT_ATTR_VALUE_TRUE = 1;

  /// < The attribute has been unset
  static const int GIT_ATTR_VALUE_FALSE = 2;

  /// < This attribute has a value
  static const int GIT_ATTR_VALUE_STRING = 3;
}

/// Flags to control the functionality of `git_blob_filter`.
abstract class git_blob_filter_flag_t {
  /// When set, filters will not be applied to binary files.
  static const int GIT_BLOB_FILTER_CHECK_FOR_BINARY = 1;

  /// When set, filters will not load configuration from the
  /// system-wide `gitattributes` in `/etc` (or system equivalent).
  static const int GIT_BLOB_FILTER_NO_SYSTEM_ATTRIBUTES = 2;

  /// When set, filters will be loaded from a `.gitattributes` file
  /// in the HEAD commit.
  static const int GIT_BLOB_FILTER_ATTTRIBUTES_FROM_HEAD = 4;
}

/// The options used when applying filter options to a file.
class git_blob_filter_options extends ffi.Struct {
  @ffi.Int32()
  external int version;

  /// Flags to control the filtering process, see `git_blob_filter_flag_t` above
  @ffi.Uint32()
  external int flags;
}

/// Flags for indicating option behavior for git_blame APIs.
abstract class git_blame_flag_t {
  /// Normal blame, the default
  static const int GIT_BLAME_NORMAL = 0;

  /// Track lines that have moved within a file (like `git blame -M`).
  /// NOT IMPLEMENTED.
  static const int GIT_BLAME_TRACK_COPIES_SAME_FILE = 1;

  /// Track lines that have moved across files in the same commit (like `git blame -C`).
  /// NOT IMPLEMENTED.
  static const int GIT_BLAME_TRACK_COPIES_SAME_COMMIT_MOVES = 2;

  /// Track lines that have been copied from another file that exists in the
  /// same commit (like `git blame -CC`). Implies SAME_FILE.
  /// NOT IMPLEMENTED.
  static const int GIT_BLAME_TRACK_COPIES_SAME_COMMIT_COPIES = 4;

  /// Track lines that have been copied from another file that exists in *any*
  /// commit (like `git blame -CCC`). Implies SAME_COMMIT_COPIES.
  /// NOT IMPLEMENTED.
  static const int GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES = 8;

  /// Restrict the search of commits to those reachable following only the
  /// first parents.
  static const int GIT_BLAME_FIRST_PARENT = 16;

  /// Use mailmap file to map author and committer names and email addresses
  /// to canonical real names and email addresses. The mailmap will be read
  /// from the working directory, or HEAD in a bare repository.
  static const int GIT_BLAME_USE_MAILMAP = 32;

  /// Ignore whitespace differences
  static const int GIT_BLAME_IGNORE_WHITESPACE = 64;
}

/// Blame options structure
///
/// Initialize with `GIT_BLAME_OPTIONS_INIT`. Alternatively, you can
/// use `git_blame_options_init`.
class git_blame_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// A combination of `git_blame_flag_t`
  @ffi.Uint32()
  external int flags;

  /// The lower bound on the number of alphanumeric
  /// characters that must be detected as moving/copying within a file for it to
  /// associate those lines with the parent commit. The default value is 20.
  /// This value only takes effect if any of the `GIT_BLAME_TRACK_COPIES_*`
  /// flags are specified.
  @ffi.Uint16()
  external int min_match_characters;

  /// The id of the newest commit to consider. The default is HEAD.
  external git_oid newest_commit;

  /// The id of the oldest commit to consider.
  /// The default is the first commit encountered with a NULL parent.
  external git_oid oldest_commit;

  /// The first line in the file to blame.
  /// The default is 1 (line numbers start with 1).
  @ffi.Int32()
  external int min_line;

  /// The last line in the file to blame.
  /// The default is the last line of the file.
  @ffi.Int32()
  external int max_line;
}

/// Structure that represents a blame hunk.
///
/// - `lines_in_hunk` is the number of lines in this hunk
/// - `final_commit_id` is the OID of the commit where this line was last
/// changed.
/// - `final_start_line_number` is the 1-based line number where this hunk
/// begins, in the final version of the file
/// - `final_signature` is the author of `final_commit_id`. If
/// `GIT_BLAME_USE_MAILMAP` has been specified, it will contain the canonical
/// real name and email address.
/// - `orig_commit_id` is the OID of the commit where this hunk was found.  This
/// will usually be the same as `final_commit_id`, except when
/// `GIT_BLAME_TRACK_COPIES_ANY_COMMIT_COPIES` has been specified.
/// - `orig_path` is the path to the file where this hunk originated, as of the
/// commit specified by `orig_commit_id`.
/// - `orig_start_line_number` is the 1-based line number where this hunk begins
/// in the file named by `orig_path` in the commit specified by
/// `orig_commit_id`.
/// - `orig_signature` is the author of `orig_commit_id`. If
/// `GIT_BLAME_USE_MAILMAP` has been specified, it will contain the canonical
/// real name and email address.
/// - `boundary` is 1 iff the hunk has been tracked to a boundary commit (the
/// root, or the commit specified in git_blame_options.oldest_commit)
class git_blame_hunk extends ffi.Struct {
  @ffi.Int32()
  external int lines_in_hunk;

  external git_oid final_commit_id;

  @ffi.Int32()
  external int final_start_line_number;

  external ffi.Pointer<git_signature> final_signature;

  external git_oid orig_commit_id;

  external ffi.Pointer<ffi.Int8> orig_path;

  @ffi.Int32()
  external int orig_start_line_number;

  external ffi.Pointer<git_signature> orig_signature;

  @ffi.Int8()
  external int boundary;
}

class git_blame extends ffi.Opaque {}

class git_branch_iterator extends ffi.Opaque {}

/// Type of host certificate structure that is passed to the check callback
abstract class git_cert_t {
  /// No information about the certificate is available. This may
  /// happen when using curl.
  static const int GIT_CERT_NONE = 0;

  /// The `data` argument to the callback will be a pointer to
  /// the DER-encoded data.
  static const int GIT_CERT_X509 = 1;

  /// The `data` argument to the callback will be a pointer to a
  /// `git_cert_hostkey` structure.
  static const int GIT_CERT_HOSTKEY_LIBSSH2 = 2;

  /// The `data` argument to the callback will be a pointer to a
  /// `git_strarray` with `name:content` strings containing
  /// information about the certificate. This is used when using
  /// curl.
  static const int GIT_CERT_STRARRAY = 3;
}

/// Type of SSH host fingerprint
abstract class git_cert_ssh_t {
  /// MD5 is available
  static const int GIT_CERT_SSH_MD5 = 1;

  /// SHA-1 is available
  static const int GIT_CERT_SSH_SHA1 = 2;

  /// SHA-256 is available
  static const int GIT_CERT_SSH_SHA256 = 4;
}

/// Hostkey information taken from libssh2
class git_cert_hostkey extends ffi.Struct {
  /// < The parent cert
  external git_cert parent;

  /// A hostkey type from libssh2, either
  /// `GIT_CERT_SSH_MD5` or `GIT_CERT_SSH_SHA1`
  @ffi.Int32()
  external int type;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> hash_md5;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Uint8> hash_sha1;

  @ffi.Array.multi([32])
  external ffi.Array<ffi.Uint8> hash_sha256;
}

/// X.509 certificate information
class git_cert_x509 extends ffi.Struct {
  /// < The parent cert
  external git_cert parent;

  /// Pointer to the X.509 certificate data
  external ffi.Pointer<ffi.Void> data;

  /// Length of the memory block pointed to by `data`.
  @ffi.Int32()
  external int len;
}

/// Checkout behavior flags
///
/// In libgit2, checkout is used to update the working directory and index
/// to match a target tree.  Unlike git checkout, it does not move the HEAD
/// commit for you - use `git_repository_set_head` or the like to do that.
///
/// Checkout looks at (up to) four things: the "target" tree you want to
/// check out, the "baseline" tree of what was checked out previously, the
/// working directory for actual files, and the index for staged changes.
///
/// You give checkout one of three strategies for update:
///
/// - `GIT_CHECKOUT_NONE` is a dry-run strategy that checks for conflicts,
/// etc., but doesn't make any actual changes.
///
/// - `GIT_CHECKOUT_FORCE` is at the opposite extreme, taking any action to
/// make the working directory match the target (including potentially
/// discarding modified files).
///
/// - `GIT_CHECKOUT_SAFE` is between these two options, it will only make
/// modifications that will not lose changes.
///
/// |  target == baseline   |  target != baseline  |
/// ---------------------|-----------------------|----------------------|
/// workdir == baseline |       no action       |  create, update, or  |
/// |                       |     delete file      |
/// ---------------------|-----------------------|----------------------|
/// workdir exists and  |       no action       |   conflict (notify   |
/// is != baseline    | notify dirty MODIFIED | and cancel checkout) |
/// ---------------------|-----------------------|----------------------|
/// workdir missing,   | notify dirty DELETED  |     create file      |
/// baseline present   |                       |                      |
/// ---------------------|-----------------------|----------------------|
///
/// To emulate `git checkout`, use `GIT_CHECKOUT_SAFE` with a checkout
/// notification callback (see below) that displays information about dirty
/// files.  The default behavior will cancel checkout on conflicts.
///
/// To emulate `git checkout-index`, use `GIT_CHECKOUT_SAFE` with a
/// notification callback that cancels the operation if a dirty-but-existing
/// file is found in the working directory.  This core git command isn't
/// quite "force" but is sensitive about some types of changes.
///
/// To emulate `git checkout -f`, use `GIT_CHECKOUT_FORCE`.
///
///
/// There are some additional flags to modify the behavior of checkout:
///
/// - GIT_CHECKOUT_ALLOW_CONFLICTS makes SAFE mode apply safe file updates
/// even if there are conflicts (instead of cancelling the checkout).
///
/// - GIT_CHECKOUT_REMOVE_UNTRACKED means remove untracked files (i.e. not
/// in target, baseline, or index, and not ignored) from the working dir.
///
/// - GIT_CHECKOUT_REMOVE_IGNORED means remove ignored files (that are also
/// untracked) from the working directory as well.
///
/// - GIT_CHECKOUT_UPDATE_ONLY means to only update the content of files that
/// already exist.  Files will not be created nor deleted.  This just skips
/// applying adds, deletes, and typechanges.
///
/// - GIT_CHECKOUT_DONT_UPDATE_INDEX prevents checkout from writing the
/// updated files' information to the index.
///
/// - Normally, checkout will reload the index and git attributes from disk
/// before any operations.  GIT_CHECKOUT_NO_REFRESH prevents this reload.
///
/// - Unmerged index entries are conflicts.  GIT_CHECKOUT_SKIP_UNMERGED skips
/// files with unmerged index entries instead.  GIT_CHECKOUT_USE_OURS and
/// GIT_CHECKOUT_USE_THEIRS to proceed with the checkout using either the
/// stage 2 ("ours") or stage 3 ("theirs") version of files in the index.
///
/// - GIT_CHECKOUT_DONT_OVERWRITE_IGNORED prevents ignored files from being
/// overwritten.  Normally, files that are ignored in the working directory
/// are not considered "precious" and may be overwritten if the checkout
/// target contains that file.
///
/// - GIT_CHECKOUT_DONT_REMOVE_EXISTING prevents checkout from removing
/// files or folders that fold to the same name on case insensitive
/// filesystems.  This can cause files to retain their existing names
/// and write through existing symbolic links.
abstract class git_checkout_strategy_t {
  /// < default is a dry run, no actual updates
  static const int GIT_CHECKOUT_NONE = 0;

  /// Allow safe updates that cannot overwrite uncommitted data.
  /// If the uncommitted changes don't conflict with the checked out files,
  /// the checkout will still proceed, leaving the changes intact.
  ///
  /// Mutually exclusive with GIT_CHECKOUT_FORCE.
  /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
  static const int GIT_CHECKOUT_SAFE = 1;

  /// Allow all updates to force working directory to look like index.
  ///
  /// Mutually exclusive with GIT_CHECKOUT_SAFE.
  /// GIT_CHECKOUT_FORCE takes precedence over GIT_CHECKOUT_SAFE.
  static const int GIT_CHECKOUT_FORCE = 2;

  /// Allow checkout to recreate missing files
  static const int GIT_CHECKOUT_RECREATE_MISSING = 4;

  /// Allow checkout to make safe updates even if conflicts are found
  static const int GIT_CHECKOUT_ALLOW_CONFLICTS = 16;

  /// Remove untracked files not in index (that are not ignored)
  static const int GIT_CHECKOUT_REMOVE_UNTRACKED = 32;

  /// Remove ignored files not in index
  static const int GIT_CHECKOUT_REMOVE_IGNORED = 64;

  /// Only update existing files, don't create new ones
  static const int GIT_CHECKOUT_UPDATE_ONLY = 128;

  /// Normally checkout updates index entries as it goes; this stops that.
  /// Implies `GIT_CHECKOUT_DONT_WRITE_INDEX`.
  static const int GIT_CHECKOUT_DONT_UPDATE_INDEX = 256;

  /// Don't refresh index/config/etc before doing checkout
  static const int GIT_CHECKOUT_NO_REFRESH = 512;

  /// Allow checkout to skip unmerged files
  static const int GIT_CHECKOUT_SKIP_UNMERGED = 1024;

  /// For unmerged files, checkout stage 2 from index
  static const int GIT_CHECKOUT_USE_OURS = 2048;

  /// For unmerged files, checkout stage 3 from index
  static const int GIT_CHECKOUT_USE_THEIRS = 4096;

  /// Treat pathspec as simple list of exact match file paths
  static const int GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH = 8192;

  /// Ignore directories in use, they will be left empty
  static const int GIT_CHECKOUT_SKIP_LOCKED_DIRECTORIES = 262144;

  /// Don't overwrite ignored files that exist in the checkout target
  static const int GIT_CHECKOUT_DONT_OVERWRITE_IGNORED = 524288;

  /// Write normal merge files for conflicts
  static const int GIT_CHECKOUT_CONFLICT_STYLE_MERGE = 1048576;

  /// Include common ancestor data in diff3 format files for conflicts
  static const int GIT_CHECKOUT_CONFLICT_STYLE_DIFF3 = 2097152;

  /// Don't overwrite existing files or folders
  static const int GIT_CHECKOUT_DONT_REMOVE_EXISTING = 4194304;

  /// Normally checkout writes the index upon completion; this prevents that.
  static const int GIT_CHECKOUT_DONT_WRITE_INDEX = 8388608;

  /// Recursively checkout submodules with same options (NOT IMPLEMENTED)
  static const int GIT_CHECKOUT_UPDATE_SUBMODULES = 65536;

  /// Recursively checkout submodules if HEAD moved in super repo (NOT IMPLEMENTED)
  static const int GIT_CHECKOUT_UPDATE_SUBMODULES_IF_CHANGED = 131072;
}

/// Checkout notification flags
///
/// Checkout will invoke an options notification callback (`notify_cb`) for
/// certain cases - you pick which ones via `notify_flags`:
///
/// - GIT_CHECKOUT_NOTIFY_CONFLICT invokes checkout on conflicting paths.
///
/// - GIT_CHECKOUT_NOTIFY_DIRTY notifies about "dirty" files, i.e. those that
/// do not need an update but no longer match the baseline.  Core git
/// displays these files when checkout runs, but won't stop the checkout.
///
/// - GIT_CHECKOUT_NOTIFY_UPDATED sends notification for any file changed.
///
/// - GIT_CHECKOUT_NOTIFY_UNTRACKED notifies about untracked files.
///
/// - GIT_CHECKOUT_NOTIFY_IGNORED notifies about ignored files.
///
/// Returning a non-zero value from this callback will cancel the checkout.
/// The non-zero return value will be propagated back and returned by the
/// git_checkout_... call.
///
/// Notification callbacks are made prior to modifying any files on disk,
/// so canceling on any notification will still happen prior to any files
/// being modified.
abstract class git_checkout_notify_t {
  static const int GIT_CHECKOUT_NOTIFY_NONE = 0;
  static const int GIT_CHECKOUT_NOTIFY_CONFLICT = 1;
  static const int GIT_CHECKOUT_NOTIFY_DIRTY = 2;
  static const int GIT_CHECKOUT_NOTIFY_UPDATED = 4;
  static const int GIT_CHECKOUT_NOTIFY_UNTRACKED = 8;
  static const int GIT_CHECKOUT_NOTIFY_IGNORED = 16;
  static const int GIT_CHECKOUT_NOTIFY_ALL = 65535;
}

/// Checkout performance-reporting structure
class git_checkout_perfdata extends ffi.Struct {
  @ffi.Int32()
  external int mkdir_calls;

  @ffi.Int32()
  external int stat_calls;

  @ffi.Int32()
  external int chmod_calls;
}

/// Checkout options structure
///
/// Initialize with `GIT_CHECKOUT_OPTIONS_INIT`. Alternatively, you can
/// use `git_checkout_options_init`.
class git_checkout_options extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// < default will be a safe checkout
  @ffi.Uint32()
  external int checkout_strategy;

  /// < don't apply filters like CRLF conversion
  @ffi.Int32()
  external int disable_filters;

  /// < default is 0755
  @ffi.Uint32()
  external int dir_mode;

  /// < default is 0644 or 0755 as dictated by blob
  @ffi.Uint32()
  external int file_mode;

  /// < default is O_CREAT | O_TRUNC | O_WRONLY
  @ffi.Int32()
  external int file_open_flags;

  /// < see `git_checkout_notify_t` above
  @ffi.Uint32()
  external int notify_flags;

  /// Optional callback to get notifications on specific file states.
  /// @see git_checkout_notify_t
  external ffi.Pointer<ffi.NativeFunction<git_checkout_notify_cb>> notify_cb;

  /// Payload passed to notify_cb
  external ffi.Pointer<ffi.Void> notify_payload;

  /// Optional callback to notify the consumer of checkout progress.
  external ffi.Pointer<ffi.NativeFunction<git_checkout_progress_cb>>
      progress_cb;

  /// Payload passed to progress_cb
  external ffi.Pointer<ffi.Void> progress_payload;

  /// A list of wildmatch patterns or paths.
  ///
  /// By default, all paths are processed. If you pass an array of wildmatch
  /// patterns, those will be used to filter which paths should be taken into
  /// account.
  ///
  /// Use GIT_CHECKOUT_DISABLE_PATHSPEC_MATCH to treat as a simple list.
  external git_strarray paths;

  /// The expected content of the working directory; defaults to HEAD.
  ///
  /// If the working directory does not match this baseline information,
  /// that will produce a checkout conflict.
  external ffi.Pointer<git_tree> baseline;

  /// Like `baseline` above, though expressed as an index.  This
  /// option overrides `baseline`.
  external ffi.Pointer<git_index> baseline_index;

  /// < alternative checkout path to workdir
  external ffi.Pointer<ffi.Int8> target_directory;

  /// < the name of the common ancestor side of conflicts
  external ffi.Pointer<ffi.Int8> ancestor_label;

  /// < the name of the "our" side of conflicts
  external ffi.Pointer<ffi.Int8> our_label;

  /// < the name of the "their" side of conflicts
  external ffi.Pointer<ffi.Int8> their_label;

  /// Optional callback to notify the consumer of performance data.
  external ffi.Pointer<ffi.NativeFunction<git_checkout_perfdata_cb>>
      perfdata_cb;

  /// Payload passed to perfdata_cb
  external ffi.Pointer<ffi.Void> perfdata_payload;
}

/// Array of object ids
class git_oidarray extends ffi.Struct {
  external ffi.Pointer<git_oid> ids;

  @ffi.Int32()
  external int count;
}

class git_indexer extends ffi.Opaque {}

/// Options for indexer configuration
class git_indexer_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// progress_cb function to call with progress information
  external ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>> progress_cb;

  /// progress_cb_payload payload for the progress callback
  external ffi.Pointer<ffi.Void> progress_cb_payload;

  /// Do connectivity checks for the received pack
  @ffi.Uint8()
  external int verify;
}

/// Time structure used in a git index entry
class git_index_time extends ffi.Struct {
  @ffi.Int32()
  external int seconds;

  /// nsec should not be stored as time_t compatible
  @ffi.Uint32()
  external int nanoseconds;
}

/// In-memory representation of a file entry in the index.
///
/// This is a public structure that represents a file entry in the index.
/// The meaning of the fields corresponds to core Git's documentation (in
/// "Documentation/technical/index-format.txt").
///
/// The `flags` field consists of a number of bit fields which can be
/// accessed via the first set of `GIT_INDEX_ENTRY_...` bitmasks below.
/// These flags are all read from and persisted to disk.
///
/// The `flags_extended` field also has a number of bit fields which can be
/// accessed via the later `GIT_INDEX_ENTRY_...` bitmasks below.  Some of
/// these flags are read from and written to disk, but some are set aside
/// for in-memory only reference.
///
/// Note that the time and size fields are truncated to 32 bits. This
/// is enough to detect changes, which is enough for the index to
/// function as a cache, but it should not be taken as an authoritative
/// source for that data.
class git_index_entry extends ffi.Struct {
  external git_index_time ctime;

  external git_index_time mtime;

  @ffi.Uint32()
  external int dev;

  @ffi.Uint32()
  external int ino;

  @ffi.Uint32()
  external int mode;

  @ffi.Uint32()
  external int uid;

  @ffi.Uint32()
  external int gid;

  @ffi.Uint32()
  external int file_size;

  external git_oid id;

  @ffi.Uint16()
  external int flags;

  @ffi.Uint16()
  external int flags_extended;

  external ffi.Pointer<ffi.Int8> path;
}

/// Flags for index entries
abstract class git_index_entry_flag_t {
  static const int GIT_INDEX_ENTRY_EXTENDED = 16384;
  static const int GIT_INDEX_ENTRY_VALID = 32768;
}

/// Bitmasks for on-disk fields of `git_index_entry`'s `flags_extended`
///
/// In memory, the `flags_extended` fields are divided into two parts: the
/// fields that are read from and written to disk, and other fields that
/// in-memory only and used by libgit2.  Only the flags in
/// `GIT_INDEX_ENTRY_EXTENDED_FLAGS` will get saved on-disk.
///
/// Thee first three bitmasks match the three fields in the
/// `git_index_entry` `flags_extended` value that belong on disk.  You
/// can use them to interpret the data in the `flags_extended`.
///
/// The rest of the bitmasks match the other fields in the `git_index_entry`
/// `flags_extended` value that are only used in-memory by libgit2.
/// You can use them to interpret the data in the `flags_extended`.
abstract class git_index_entry_extended_flag_t {
  static const int GIT_INDEX_ENTRY_INTENT_TO_ADD = 8192;
  static const int GIT_INDEX_ENTRY_SKIP_WORKTREE = 16384;
  static const int GIT_INDEX_ENTRY_EXTENDED_FLAGS = 24576;
  static const int GIT_INDEX_ENTRY_UPTODATE = 4;
}

/// Capabilities of system that affect index actions.
abstract class git_index_capability_t {
  static const int GIT_INDEX_CAPABILITY_IGNORE_CASE = 1;
  static const int GIT_INDEX_CAPABILITY_NO_FILEMODE = 2;
  static const int GIT_INDEX_CAPABILITY_NO_SYMLINKS = 4;
  static const int GIT_INDEX_CAPABILITY_FROM_OWNER = -1;
}

/// Flags for APIs that add files matching pathspec
abstract class git_index_add_option_t {
  static const int GIT_INDEX_ADD_DEFAULT = 0;
  static const int GIT_INDEX_ADD_FORCE = 1;
  static const int GIT_INDEX_ADD_DISABLE_PATHSPEC_MATCH = 2;
  static const int GIT_INDEX_ADD_CHECK_PATHSPEC = 4;
}

/// Git index stage states
abstract class git_index_stage_t {
  /// Match any index stage.
  ///
  /// Some index APIs take a stage to match; pass this value to match
  /// any entry matching the path regardless of stage.
  static const int GIT_INDEX_STAGE_ANY = -1;

  /// A normal staged file in the index.
  static const int GIT_INDEX_STAGE_NORMAL = 0;

  /// The ancestor side of a conflict.
  static const int GIT_INDEX_STAGE_ANCESTOR = 1;

  /// The "ours" side of a conflict.
  static const int GIT_INDEX_STAGE_OURS = 2;

  /// The "theirs" side of a conflict.
  static const int GIT_INDEX_STAGE_THEIRS = 3;
}

/// The file inputs to `git_merge_file`.  Callers should populate the
/// `git_merge_file_input` structure with descriptions of the files in
/// each side of the conflict for use in producing the merge file.
class git_merge_file_input extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Pointer to the contents of the file.
  external ffi.Pointer<ffi.Int8> ptr;

  /// Size of the contents pointed to in `ptr`.
  @ffi.Int32()
  external int size;

  /// File name of the conflicted file, or `NULL` to not merge the path.
  external ffi.Pointer<ffi.Int8> path;

  /// File mode of the conflicted file, or `0` to not merge the mode.
  @ffi.Uint32()
  external int mode;
}

/// Flags for `git_merge` options.  A combination of these flags can be
/// passed in via the `flags` value in the `git_merge_options`.
abstract class git_merge_flag_t {
  /// Detect renames that occur between the common ancestor and the "ours"
  /// side or the common ancestor and the "theirs" side.  This will enable
  /// the ability to merge between a modified and renamed file.
  static const int GIT_MERGE_FIND_RENAMES = 1;

  /// If a conflict occurs, exit immediately instead of attempting to
  /// continue resolving conflicts.  The merge operation will fail with
  /// GIT_EMERGECONFLICT and no index will be returned.
  static const int GIT_MERGE_FAIL_ON_CONFLICT = 2;

  /// Do not write the REUC extension on the generated index
  static const int GIT_MERGE_SKIP_REUC = 4;

  /// If the commits being merged have multiple merge bases, do not build
  /// a recursive merge base (by merging the multiple merge bases),
  /// instead simply use the first base.  This flag provides a similar
  /// merge base to `git-merge-resolve`.
  static const int GIT_MERGE_NO_RECURSIVE = 8;
}

/// Merge file favor options for `git_merge_options` instruct the file-level
/// merging functionality how to deal with conflicting regions of the files.
abstract class git_merge_file_favor_t {
  /// When a region of a file is changed in both branches, a conflict
  /// will be recorded in the index so that `git_checkout` can produce
  /// a merge file with conflict markers in the working directory.
  /// This is the default.
  static const int GIT_MERGE_FILE_FAVOR_NORMAL = 0;

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "ours" side of any conflicting
  /// region.  The index will not record a conflict.
  static const int GIT_MERGE_FILE_FAVOR_OURS = 1;

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain the "theirs" side of any conflicting
  /// region.  The index will not record a conflict.
  static const int GIT_MERGE_FILE_FAVOR_THEIRS = 2;

  /// When a region of a file is changed in both branches, the file
  /// created in the index will contain each unique line from each side,
  /// which has the result of combining both files.  The index will not
  /// record a conflict.
  static const int GIT_MERGE_FILE_FAVOR_UNION = 3;
}

/// File merging flags
abstract class git_merge_file_flag_t {
  /// Defaults
  static const int GIT_MERGE_FILE_DEFAULT = 0;

  /// Create standard conflicted merge files
  static const int GIT_MERGE_FILE_STYLE_MERGE = 1;

  /// Create diff3-style files
  static const int GIT_MERGE_FILE_STYLE_DIFF3 = 2;

  /// Condense non-alphanumeric regions for simplified diff file
  static const int GIT_MERGE_FILE_SIMPLIFY_ALNUM = 4;

  /// Ignore all whitespace
  static const int GIT_MERGE_FILE_IGNORE_WHITESPACE = 8;

  /// Ignore changes in amount of whitespace
  static const int GIT_MERGE_FILE_IGNORE_WHITESPACE_CHANGE = 16;

  /// Ignore whitespace at end of line
  static const int GIT_MERGE_FILE_IGNORE_WHITESPACE_EOL = 32;

  /// Use the "patience diff" algorithm
  static const int GIT_MERGE_FILE_DIFF_PATIENCE = 64;

  /// Take extra time to find minimal diff
  static const int GIT_MERGE_FILE_DIFF_MINIMAL = 128;
}

/// Options for merging a file
class git_merge_file_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Label for the ancestor file side of the conflict which will be prepended
  /// to labels in diff3-format merge files.
  external ffi.Pointer<ffi.Int8> ancestor_label;

  /// Label for our file side of the conflict which will be prepended
  /// to labels in merge files.
  external ffi.Pointer<ffi.Int8> our_label;

  /// Label for their file side of the conflict which will be prepended
  /// to labels in merge files.
  external ffi.Pointer<ffi.Int8> their_label;

  /// The file to favor in region conflicts.
  @ffi.Int32()
  external int favor;

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// The size of conflict markers (eg, "<<<<<<<").  Default is
  /// GIT_MERGE_CONFLICT_MARKER_SIZE.
  @ffi.Uint16()
  external int marker_size;
}

/// Information about file-level merging
class git_merge_file_result extends ffi.Struct {
  /// True if the output was automerged, false if the output contains
  /// conflict markers.
  @ffi.Uint32()
  external int automergeable;

  /// The path that the resultant merge file should use, or NULL if a
  /// filename conflict would occur.
  external ffi.Pointer<ffi.Int8> path;

  /// The mode that the resultant merge file should use.
  @ffi.Uint32()
  external int mode;

  /// The contents of the merge.
  external ffi.Pointer<ffi.Int8> ptr;

  /// The length of the merge contents.
  @ffi.Int32()
  external int len;
}

/// Merging options
class git_merge_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// See `git_merge_flag_t` above
  @ffi.Uint32()
  external int flags;

  /// Similarity to consider a file renamed (default 50).  If
  /// `GIT_MERGE_FIND_RENAMES` is enabled, added files will be compared
  /// with deleted files to determine their similarity.  Files that are
  /// more similar than the rename threshold (percentage-wise) will be
  /// treated as a rename.
  @ffi.Uint32()
  external int rename_threshold;

  /// Maximum similarity sources to examine for renames (default 200).
  /// If the number of rename candidates (add / delete pairs) is greater
  /// than this value, inexact rename detection is aborted.
  ///
  /// This setting overrides the `merge.renameLimit` configuration value.
  @ffi.Uint32()
  external int target_limit;

  /// Pluggable similarity metric; pass NULL to use internal metric
  external ffi.Pointer<git_diff_similarity_metric> metric;

  /// Maximum number of times to merge common ancestors to build a
  /// virtual merge base when faced with criss-cross merges.  When this
  /// limit is reached, the next ancestor will simply be used instead of
  /// attempting to merge it.  The default is unlimited.
  @ffi.Uint32()
  external int recursion_limit;

  /// Default merge driver to be used when both sides of a merge have
  /// changed.  The default is the `text` driver.
  external ffi.Pointer<ffi.Int8> default_driver;

  /// Flags for handling conflicting content, to be used with the standard
  /// (`text`) merge driver.
  @ffi.Int32()
  external int file_favor;

  /// see `git_merge_file_flag_t` above
  @ffi.Uint32()
  external int file_flags;
}

/// The results of `git_merge_analysis` indicate the merge opportunities.
abstract class git_merge_analysis_t {
  /// No merge is possible.  (Unused.)
  static const int GIT_MERGE_ANALYSIS_NONE = 0;

  /// A "normal" merge; both HEAD and the given merge input have diverged
  /// from their common ancestor.  The divergent commits must be merged.
  static const int GIT_MERGE_ANALYSIS_NORMAL = 1;

  /// All given merge inputs are reachable from HEAD, meaning the
  /// repository is up-to-date and no merge needs to be performed.
  static const int GIT_MERGE_ANALYSIS_UP_TO_DATE = 2;

  /// The given merge input is a fast-forward from HEAD and no merge
  /// needs to be performed.  Instead, the client can check out the
  /// given merge input.
  static const int GIT_MERGE_ANALYSIS_FASTFORWARD = 4;

  /// The HEAD of the current repository is "unborn" and does not point to
  /// a valid commit.  No merge can be performed, but the caller may wish
  /// to simply set HEAD to the target commit(s).
  static const int GIT_MERGE_ANALYSIS_UNBORN = 8;
}

/// The user's stated preference for merges.
abstract class git_merge_preference_t {
  /// No configuration was found that suggests a preferred behavior for
  /// merge.
  static const int GIT_MERGE_PREFERENCE_NONE = 0;

  /// There is a `merge.ff=false` configuration setting, suggesting that
  /// the user does not want to allow a fast-forward merge.
  static const int GIT_MERGE_PREFERENCE_NO_FASTFORWARD = 1;

  /// There is a `merge.ff=only` configuration setting, suggesting that
  /// the user only wants fast-forward merges.
  static const int GIT_MERGE_PREFERENCE_FASTFORWARD_ONLY = 2;
}

/// Cherry-pick options
class git_cherrypick_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// For merge commits, the "mainline" is treated as the parent.
  @ffi.Uint32()
  external int mainline;

  /// < Options for the merging
  external git_merge_options merge_opts;

  /// < Options for the checkout
  external git_checkout_options checkout_opts;
}

/// Direction of the connection.
///
/// We need this because we need to know whether we should call
/// git-upload-pack or git-receive-pack on the remote end when get_refs
/// gets called.
abstract class git_direction {
  static const int GIT_DIRECTION_FETCH = 0;
  static const int GIT_DIRECTION_PUSH = 1;
}

/// Supported credential types
///
/// This represents the various types of authentication methods supported by
/// the library.
abstract class git_credential_t {
  /// A vanilla user/password request
  /// @see git_credential_userpass_plaintext_new
  static const int GIT_CREDENTIAL_USERPASS_PLAINTEXT = 1;

  /// An SSH key-based authentication request
  /// @see git_credential_ssh_key_new
  static const int GIT_CREDENTIAL_SSH_KEY = 2;

  /// An SSH key-based authentication request, with a custom signature
  /// @see git_credential_ssh_custom_new
  static const int GIT_CREDENTIAL_SSH_CUSTOM = 4;

  /// An NTLM/Negotiate-based authentication request.
  /// @see git_credential_default
  static const int GIT_CREDENTIAL_DEFAULT = 8;

  /// An SSH interactive authentication request
  /// @see git_credential_ssh_interactive_new
  static const int GIT_CREDENTIAL_SSH_INTERACTIVE = 16;

  /// Username-only authentication request
  ///
  /// Used as a pre-authentication step if the underlying transport
  /// (eg. SSH, with no username in its URL) does not know which username
  /// to use.
  ///
  /// @see git_credential_username_new
  static const int GIT_CREDENTIAL_USERNAME = 32;

  /// An SSH key-based authentication request
  ///
  /// Allows credentials to be read from memory instead of files.
  /// Note that because of differences in crypto backend support, it might
  /// not be functional.
  ///
  /// @see git_credential_ssh_key_memory_new
  static const int GIT_CREDENTIAL_SSH_MEMORY = 64;
}

/// A plaintext username and password
class git_credential_userpass_plaintext extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Int8> username;

  /// < The password to use
  external ffi.Pointer<ffi.Int8> password;
}

/// Username-only credential information
class git_credential_username extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Int8> username;
}

/// A ssh key from disk
class git_credential_ssh_key extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Int8> username;

  /// < The path to a public key
  external ffi.Pointer<ffi.Int8> publickey;

  /// < The path to a private key
  external ffi.Pointer<ffi.Int8> privatekey;

  /// < Passphrase to decrypt the private key
  external ffi.Pointer<ffi.Int8> passphrase;
}

class _LIBSSH2_USERAUTH_KBDINT_PROMPT extends ffi.Opaque {}

class _LIBSSH2_USERAUTH_KBDINT_RESPONSE extends ffi.Opaque {}

/// Keyboard-interactive based ssh authentication
class git_credential_ssh_interactive extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Int8> username;

  /// Callback used for authentication.
  external ffi.Pointer<ffi.NativeFunction<git_credential_ssh_interactive_cb>>
      prompt_callback;

  /// < Payload passed to prompt_callback
  external ffi.Pointer<ffi.Void> payload;
}

class _LIBSSH2_SESSION extends ffi.Opaque {}

/// A key with a custom signature function
class git_credential_ssh_custom extends ffi.Struct {
  /// < The parent credential
  external git_credential parent;

  /// < The username to authenticate as
  external ffi.Pointer<ffi.Int8> username;

  /// < The public key data
  external ffi.Pointer<ffi.Int8> publickey;

  /// < Length of the public key
  @ffi.Int32()
  external int publickey_len;

  /// Callback used to sign the data.
  external ffi.Pointer<ffi.NativeFunction<git_credential_sign_cb>>
      sign_callback;

  /// < Payload passed to prompt_callback
  external ffi.Pointer<ffi.Void> payload;
}

/// Stages that are reported by the packbuilder progress callback.
abstract class git_packbuilder_stage_t {
  static const int GIT_PACKBUILDER_ADDING_OBJECTS = 0;
  static const int GIT_PACKBUILDER_DELTAFICATION = 1;
}

/// The type of proxy to use.
abstract class git_proxy_t {
  /// Do not attempt to connect through a proxy
  ///
  /// If built against libcurl, it itself may attempt to connect
  /// to a proxy if the environment variables specify it.
  static const int GIT_PROXY_NONE = 0;

  /// Try to auto-detect the proxy from the git configuration.
  static const int GIT_PROXY_AUTO = 1;

  /// Connect via the URL given in the options
  static const int GIT_PROXY_SPECIFIED = 2;
}

/// Options for connecting through a proxy
///
/// Note that not all types may be supported, depending on the platform
/// and compilation options.
class git_proxy_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The type of proxy to use, by URL, auto-detect.
  @ffi.Int32()
  external int type;

  /// The URL of the proxy.
  external ffi.Pointer<ffi.Int8> url;

  /// This will be called if the remote host requires
  /// authentication in order to connect to it.
  ///
  /// Returning GIT_PASSTHROUGH will make libgit2 behave as
  /// though this field isn't set.
  external ffi.Pointer<ffi.NativeFunction<git_credential_acquire_cb>>
      credentials;

  /// If cert verification fails, this will be called to let the
  /// user make the final decision of whether to allow the
  /// connection to proceed. Returns 0 to allow the connection
  /// or a negative value to indicate an error.
  external ffi.Pointer<ffi.NativeFunction<git_transport_certificate_check_cb>>
      certificate_check;

  /// Payload to be provided to the credentials and certificate
  /// check callbacks.
  external ffi.Pointer<ffi.Void> payload;
}

/// Remote creation options flags
abstract class git_remote_create_flags {
  /// Ignore the repository apply.insteadOf configuration
  static const int GIT_REMOTE_CREATE_SKIP_INSTEADOF = 1;

  /// Don't build a fetchspec from the name if none is set
  static const int GIT_REMOTE_CREATE_SKIP_DEFAULT_FETCHSPEC = 2;
}

/// Remote creation options structure
///
/// Initialize with `GIT_REMOTE_CREATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_remote_create_options_init`.
class git_remote_create_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// The repository that should own the remote.
  /// Setting this to NULL results in a detached remote.
  external ffi.Pointer<git_repository> repository;

  /// The remote's name.
  /// Setting this to NULL results in an in-memory/anonymous remote.
  external ffi.Pointer<ffi.Int8> name;

  /// The fetchspec the remote should use.
  external ffi.Pointer<ffi.Int8> fetchspec;

  /// Additional flags for the remote. See git_remote_create_flags.
  @ffi.Uint32()
  external int flags;
}

/// Argument to the completion callback which tells it which operation
/// finished.
abstract class git_remote_completion_t {
  static const int GIT_REMOTE_COMPLETION_DOWNLOAD = 0;
  static const int GIT_REMOTE_COMPLETION_INDEXING = 1;
  static const int GIT_REMOTE_COMPLETION_ERROR = 2;
}

/// Acceptable prune settings when fetching
abstract class git_fetch_prune_t {
  /// Use the setting from the configuration
  static const int GIT_FETCH_PRUNE_UNSPECIFIED = 0;

  /// Force pruning on
  static const int GIT_FETCH_PRUNE = 1;

  /// Force pruning off
  static const int GIT_FETCH_NO_PRUNE = 2;
}

/// Automatic tag following option
///
/// Lets us select the --tags option to use.
abstract class git_remote_autotag_option_t {
  /// Use the setting from the configuration.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_UNSPECIFIED = 0;

  /// Ask the server for tags pointing to objects we're already
  /// downloading.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_AUTO = 1;

  /// Don't ask for any tags beyond the refspecs.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_NONE = 2;

  /// Ask for the all the tags.
  static const int GIT_REMOTE_DOWNLOAD_TAGS_ALL = 3;
}

/// Fetch options structure.
///
/// Zero out for defaults.  Initialize with `GIT_FETCH_OPTIONS_INIT` macro to
/// correctly set the `version` field.  E.g.
///
/// git_fetch_options opts = GIT_FETCH_OPTIONS_INIT;
class git_fetch_options extends ffi.Struct {
  @ffi.Int32()
  external int version;

  /// Callbacks to use for this fetch operation
  external git_remote_callbacks callbacks;

  /// Whether to perform a prune after the fetch
  @ffi.Int32()
  external int prune;

  /// Whether to write the results to FETCH_HEAD. Defaults to
  /// on. Leave this default in order to behave like git.
  @ffi.Int32()
  external int update_fetchhead;

  /// Determines how to behave regarding tags on the remote, such
  /// as auto-downloading tags for objects we're downloading or
  /// downloading all of them.
  ///
  /// The default is to auto-follow tags.
  @ffi.Int32()
  external int download_tags;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Extra headers for this fetch operation
  external git_strarray custom_headers;
}

/// Controls the behavior of a git_push object.
class git_push_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// If the transport being used to push to the remote requires the creation
  /// of a pack file, this controls the number of worker threads used by
  /// the packbuilder when creating that pack file to be sent to the remote.
  ///
  /// If set to 0, the packbuilder will auto-detect the number of threads
  /// to create. The default value is 1.
  @ffi.Uint32()
  external int pb_parallelism;

  /// Callbacks to use for this push operation
  external git_remote_callbacks callbacks;

  /// Proxy options to use, by default no proxy is used.
  external git_proxy_options proxy_opts;

  /// Extra headers for this push operation
  external git_strarray custom_headers;
}

/// Options for bypassing the git-aware transport on clone. Bypassing
/// it means that instead of a fetch, libgit2 will copy the object
/// database directory instead of figuring out what it needs, which is
/// faster. If possible, it will hardlink the files to save space.
abstract class git_clone_local_t {
  /// Auto-detect (default), libgit2 will bypass the git-aware
  /// transport for local paths, but use a normal fetch for
  /// `file://` urls.
  static const int GIT_CLONE_LOCAL_AUTO = 0;

  /// Bypass the git-aware transport even for a `file://` url.
  static const int GIT_CLONE_LOCAL = 1;

  /// Do no bypass the git-aware transport
  static const int GIT_CLONE_NO_LOCAL = 2;

  /// Bypass the git-aware transport, but do not try to use
  /// hardlinks.
  static const int GIT_CLONE_LOCAL_NO_LINKS = 3;
}

/// Clone options structure
///
/// Initialize with `GIT_CLONE_OPTIONS_INIT`. Alternatively, you can
/// use `git_clone_options_init`.
class git_clone_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to
  /// `GIT_CHECKOUT_NONE`.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  ///
  /// The callbacks are used for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Set to zero (false) to create a standard repo, or non-zero
  /// for a bare repo
  @ffi.Int32()
  external int bare;

  /// Whether to use a fetch or copy the object database.
  @ffi.Int32()
  external int local;

  /// The name of the branch to checkout. NULL means use the
  /// remote's default branch.
  external ffi.Pointer<ffi.Int8> checkout_branch;

  /// A callback used to create the new repository into which to
  /// clone. If NULL, the 'bare' field will be used to determine
  /// whether to create a bare repository.
  external ffi.Pointer<ffi.NativeFunction<git_repository_create_cb>>
      repository_cb;

  /// An opaque payload to pass to the git_repository creation callback.
  /// This parameter is ignored unless repository_cb is non-NULL.
  external ffi.Pointer<ffi.Void> repository_cb_payload;

  /// A callback used to create the git_remote, prior to its being
  /// used to perform the clone operation. See the documentation for
  /// git_remote_create_cb for details. This parameter may be NULL,
  /// indicating that git_clone should provide default behavior.
  external ffi.Pointer<ffi.NativeFunction<git_remote_create_cb>> remote_cb;

  /// An opaque payload to pass to the git_remote creation callback.
  /// This parameter is ignored unless remote_cb is non-NULL.
  external ffi.Pointer<ffi.Void> remote_cb_payload;
}

/// Priority level of a config file.
/// These priority levels correspond to the natural escalation logic
/// (from higher to lower) when searching for config entries in git.git.
///
/// git_config_open_default() and git_repository_config() honor those
/// priority levels as well.
abstract class git_config_level_t {
  /// System-wide on Windows, for compatibility with portable git
  static const int GIT_CONFIG_LEVEL_PROGRAMDATA = 1;

  /// System-wide configuration file; /etc/gitconfig on Linux systems
  static const int GIT_CONFIG_LEVEL_SYSTEM = 2;

  /// XDG compatible configuration file; typically ~/.config/git/config
  static const int GIT_CONFIG_LEVEL_XDG = 3;

  /// User-specific configuration file (also called Global configuration
  /// file); typically ~/.gitconfig
  static const int GIT_CONFIG_LEVEL_GLOBAL = 4;

  /// Repository specific configuration file; $WORK_DIR/.git/config on
  /// non-bare repos
  static const int GIT_CONFIG_LEVEL_LOCAL = 5;

  /// Application specific configuration file; freely defined by applications
  static const int GIT_CONFIG_LEVEL_APP = 6;

  /// Represents the highest level available config file (i.e. the most
  /// specific config file available that actually is loaded)
  static const int GIT_CONFIG_HIGHEST_LEVEL = -1;
}

/// An entry in a configuration file
class git_config_entry extends ffi.Struct {
  /// < Name of the entry (normalised)
  external ffi.Pointer<ffi.Int8> name;

  /// < String value of the entry
  external ffi.Pointer<ffi.Int8> value;

  /// < Depth of includes where this variable was found
  @ffi.Uint32()
  external int include_depth;

  /// < Which config file this was found in
  @ffi.Int32()
  external int level;

  external ffi.Pointer<ffi.NativeFunction<_typedefC_21>> free;

  /// < Opaque value for the free function. Do not read or write
  external ffi.Pointer<ffi.Void> payload;
}

class git_config_iterator extends ffi.Opaque {}

/// Config var type
abstract class git_configmap_t {
  static const int GIT_CONFIGMAP_FALSE = 0;
  static const int GIT_CONFIGMAP_TRUE = 1;
  static const int GIT_CONFIGMAP_INT32 = 2;
  static const int GIT_CONFIGMAP_STRING = 3;
}

/// Mapping from config variables to values.
class git_configmap extends ffi.Struct {
  @ffi.Int32()
  external int type;

  external ffi.Pointer<ffi.Int8> str_match;

  @ffi.Int32()
  external int map_value;
}

/// Reference lookup strategy
///
/// These behave like the --tags and --all options to git-describe,
/// namely they say to look for any reference in either refs/tags/ or
/// refs/ respectively.
abstract class git_describe_strategy_t {
  static const int GIT_DESCRIBE_DEFAULT = 0;
  static const int GIT_DESCRIBE_TAGS = 1;
  static const int GIT_DESCRIBE_ALL = 2;
}

/// Describe options structure
///
/// Initialize with `GIT_DESCRIBE_OPTIONS_INIT`. Alternatively, you can
/// use `git_describe_options_init`.
class git_describe_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// < default: 10
  @ffi.Uint32()
  external int max_candidates_tags;

  /// < default: GIT_DESCRIBE_DEFAULT
  @ffi.Uint32()
  external int describe_strategy;

  external ffi.Pointer<ffi.Int8> pattern;

  /// When calculating the distance from the matching tag or
  /// reference, only walk down the first-parent ancestry.
  @ffi.Int32()
  external int only_follow_first_parent;

  /// If no matching tag or reference is found, the describe
  /// operation would normally fail. If this option is set, it
  /// will instead fall back to showing the full id of the
  /// commit.
  @ffi.Int32()
  external int show_commit_oid_as_fallback;
}

/// Describe format options structure
///
/// Initialize with `GIT_DESCRIBE_FORMAT_OPTIONS_INIT`. Alternatively, you can
/// use `git_describe_format_options_init`.
class git_describe_format_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Size of the abbreviated commit id to use. This value is the
  /// lower bound for the length of the abbreviated string. The
  /// default is 7.
  @ffi.Uint32()
  external int abbreviated_size;

  /// Set to use the long format even when a shorter name could be used.
  @ffi.Int32()
  external int always_use_long_format;

  /// If the workdir is dirty and this is set, this string will
  /// be appended to the description string.
  external ffi.Pointer<ffi.Int8> dirty_suffix;
}

class git_describe_result extends ffi.Opaque {}

/// Generic return codes
abstract class git_error_code {
  /// < No error
  static const int GIT_OK = 0;

  /// < Generic error
  static const int GIT_ERROR = -1;

  /// < Requested object could not be found
  static const int GIT_ENOTFOUND = -3;

  /// < Object exists preventing operation
  static const int GIT_EEXISTS = -4;

  /// < More than one object matches
  static const int GIT_EAMBIGUOUS = -5;

  /// < Output buffer too short to hold data
  static const int GIT_EBUFS = -6;

  /// GIT_EUSER is a special error that is never generated by libgit2
  /// code.  You can return it from a callback (e.g to stop an iteration)
  /// to know that it was generated by the callback and not by libgit2.
  static const int GIT_EUSER = -7;

  /// < Operation not allowed on bare repository
  static const int GIT_EBAREREPO = -8;

  /// < HEAD refers to branch with no commits
  static const int GIT_EUNBORNBRANCH = -9;

  /// < Merge in progress prevented operation
  static const int GIT_EUNMERGED = -10;

  /// < Reference was not fast-forwardable
  static const int GIT_ENONFASTFORWARD = -11;

  /// < Name/ref spec was not in a valid format
  static const int GIT_EINVALIDSPEC = -12;

  /// < Checkout conflicts prevented operation
  static const int GIT_ECONFLICT = -13;

  /// < Lock file prevented operation
  static const int GIT_ELOCKED = -14;

  /// < Reference value does not match expected
  static const int GIT_EMODIFIED = -15;

  /// < Authentication error
  static const int GIT_EAUTH = -16;

  /// < Server certificate is invalid
  static const int GIT_ECERTIFICATE = -17;

  /// < Patch/merge has already been applied
  static const int GIT_EAPPLIED = -18;

  /// < The requested peel operation is not possible
  static const int GIT_EPEEL = -19;

  /// < Unexpected EOF
  static const int GIT_EEOF = -20;

  /// < Invalid operation or input
  static const int GIT_EINVALID = -21;

  /// < Uncommitted changes in index prevented operation
  static const int GIT_EUNCOMMITTED = -22;

  /// < The operation is not valid for a directory
  static const int GIT_EDIRECTORY = -23;

  /// < A merge conflict exists and cannot continue
  static const int GIT_EMERGECONFLICT = -24;

  /// < A user-configured callback refused to act
  static const int GIT_PASSTHROUGH = -30;

  /// < Signals end of iteration with iterator
  static const int GIT_ITEROVER = -31;

  /// < Internal only
  static const int GIT_RETRY = -32;

  /// < Hashsum mismatch in object
  static const int GIT_EMISMATCH = -33;

  /// < Unsaved changes in the index would be overwritten
  static const int GIT_EINDEXDIRTY = -34;

  /// < Patch application failed
  static const int GIT_EAPPLYFAIL = -35;
}

/// Structure to store extra details of the last error that occurred.
///
/// This is kept on a per-thread basis if GIT_THREADS was defined when the
/// library was build, otherwise one is kept globally for the library
class git_error extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> message;

  @ffi.Int32()
  external int klass;
}

/// Error classes
abstract class git_error_t {
  static const int GIT_ERROR_NONE = 0;
  static const int GIT_ERROR_NOMEMORY = 1;
  static const int GIT_ERROR_OS = 2;
  static const int GIT_ERROR_INVALID = 3;
  static const int GIT_ERROR_REFERENCE = 4;
  static const int GIT_ERROR_ZLIB = 5;
  static const int GIT_ERROR_REPOSITORY = 6;
  static const int GIT_ERROR_CONFIG = 7;
  static const int GIT_ERROR_REGEX = 8;
  static const int GIT_ERROR_ODB = 9;
  static const int GIT_ERROR_INDEX = 10;
  static const int GIT_ERROR_OBJECT = 11;
  static const int GIT_ERROR_NET = 12;
  static const int GIT_ERROR_TAG = 13;
  static const int GIT_ERROR_TREE = 14;
  static const int GIT_ERROR_INDEXER = 15;
  static const int GIT_ERROR_SSL = 16;
  static const int GIT_ERROR_SUBMODULE = 17;
  static const int GIT_ERROR_THREAD = 18;
  static const int GIT_ERROR_STASH = 19;
  static const int GIT_ERROR_CHECKOUT = 20;
  static const int GIT_ERROR_FETCHHEAD = 21;
  static const int GIT_ERROR_MERGE = 22;
  static const int GIT_ERROR_SSH = 23;
  static const int GIT_ERROR_FILTER = 24;
  static const int GIT_ERROR_REVERT = 25;
  static const int GIT_ERROR_CALLBACK = 26;
  static const int GIT_ERROR_CHERRYPICK = 27;
  static const int GIT_ERROR_DESCRIBE = 28;
  static const int GIT_ERROR_REBASE = 29;
  static const int GIT_ERROR_FILESYSTEM = 30;
  static const int GIT_ERROR_PATCH = 31;
  static const int GIT_ERROR_WORKTREE = 32;
  static const int GIT_ERROR_SHA1 = 33;
  static const int GIT_ERROR_HTTP = 34;
  static const int GIT_ERROR_INTERNAL = 35;
}

/// Rebase options
///
/// Use to tell the rebase machinery how to operate.
class git_rebase_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// Used by `git_rebase_init`, this will instruct other clients working
  /// on this rebase that you want a quiet rebase experience, which they
  /// may choose to provide in an application-specific manner.  This has no
  /// effect upon libgit2 directly, but is provided for interoperability
  /// between Git tools.
  @ffi.Int32()
  external int quiet;

  /// Used by `git_rebase_init`, this will begin an in-memory rebase,
  /// which will allow callers to step through the rebase operations and
  /// commit the rebased changes, but will not rewind HEAD or update the
  /// repository to be in a rebasing state.  This will not interfere with
  /// the working directory (if there is one).
  @ffi.Int32()
  external int inmemory;

  /// Used by `git_rebase_finish`, this is the name of the notes reference
  /// used to rewrite notes for rebased commits when finishing the rebase;
  /// if NULL, the contents of the configuration option `notes.rewriteRef`
  /// is examined, unless the configuration option `notes.rewrite.rebase`
  /// is set to false.  If `notes.rewriteRef` is also NULL, notes will
  /// not be rewritten.
  external ffi.Pointer<ffi.Int8> rewrite_notes_ref;

  /// Options to control how trees are merged during `git_rebase_next`.
  external git_merge_options merge_options;

  /// Options to control how files are written during `git_rebase_init`,
  /// `git_rebase_next` and `git_rebase_abort`.  Note that a minimum
  /// strategy of `GIT_CHECKOUT_SAFE` is defaulted in `init` and `next`,
  /// and a minimum strategy of `GIT_CHECKOUT_FORCE` is defaulted in
  /// `abort` to match git semantics.
  external git_checkout_options checkout_options;

  /// If provided, this will be called with the commit content, allowing
  /// a signature to be added to the rebase commit. Can be skipped with
  /// GIT_PASSTHROUGH. If GIT_PASSTHROUGH is returned, a commit will be made
  /// without a signature.
  /// This field is only used when performing git_rebase_commit.
  external ffi.Pointer<ffi.NativeFunction<git_commit_signing_cb>> signing_cb;

  /// This will be passed to each of the callbacks in this struct
  /// as the last parameter.
  external ffi.Pointer<ffi.Void> payload;
}

/// Type of rebase operation in-progress after calling `git_rebase_next`.
abstract class git_rebase_operation_t {
  /// The given commit is to be cherry-picked.  The client should commit
  /// the changes and continue if there are no conflicts.
  static const int GIT_REBASE_OPERATION_PICK = 0;

  /// The given commit is to be cherry-picked, but the client should prompt
  /// the user to provide an updated commit message.
  static const int GIT_REBASE_OPERATION_REWORD = 1;

  /// The given commit is to be cherry-picked, but the client should stop
  /// to allow the user to edit the changes before committing them.
  static const int GIT_REBASE_OPERATION_EDIT = 2;

  /// The given commit is to be squashed into the previous commit.  The
  /// commit message will be merged with the previous message.
  static const int GIT_REBASE_OPERATION_SQUASH = 3;

  /// The given commit is to be squashed into the previous commit.  The
  /// commit message from this commit will be discarded.
  static const int GIT_REBASE_OPERATION_FIXUP = 4;

  /// No commit will be cherry-picked.  The client should run the given
  /// command and (if successful) continue.
  static const int GIT_REBASE_OPERATION_EXEC = 5;
}

/// A rebase operation
///
/// Describes a single instruction/operation to be performed during the
/// rebase.
class git_rebase_operation extends ffi.Struct {
  /// The type of rebase operation.
  @ffi.Int32()
  external int type;

  /// The commit ID being cherry-picked.  This will be populated for
  /// all operations except those of type `GIT_REBASE_OPERATION_EXEC`.
  external git_oid id;

  /// The executable the user has requested be run.  This will only
  /// be populated for operations of type `GIT_REBASE_OPERATION_EXEC`.
  external ffi.Pointer<ffi.Int8> exec;
}

/// Available tracing levels.  When tracing is set to a particular level,
/// callers will be provided tracing at the given level and all lower levels.
abstract class git_trace_level_t {
  /// No tracing will be performed.
  static const int GIT_TRACE_NONE = 0;

  /// Severe errors that may impact the program's execution
  static const int GIT_TRACE_FATAL = 1;

  /// Errors that do not impact the program's execution
  static const int GIT_TRACE_ERROR = 2;

  /// Warnings that suggest abnormal data
  static const int GIT_TRACE_WARN = 3;

  /// Informational messages about program execution
  static const int GIT_TRACE_INFO = 4;

  /// Detailed data that allows for debugging
  static const int GIT_TRACE_DEBUG = 5;

  /// Exceptionally detailed debugging data
  static const int GIT_TRACE_TRACE = 6;
}

/// Options for revert
class git_revert_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// For merge commits, the "mainline" is treated as the parent.
  @ffi.Uint32()
  external int mainline;

  /// < Options for the merging
  external git_merge_options merge_opts;

  /// < Options for the checkout
  external git_checkout_options checkout_opts;
}

/// Stash flags
abstract class git_stash_flags {
  /// No option, default
  static const int GIT_STASH_DEFAULT = 0;

  /// All changes already added to the index are left intact in
  /// the working directory
  static const int GIT_STASH_KEEP_INDEX = 1;

  /// All untracked files are also stashed and then cleaned up
  /// from the working directory
  static const int GIT_STASH_INCLUDE_UNTRACKED = 2;

  /// All ignored files are also stashed and then cleaned up from
  /// the working directory
  static const int GIT_STASH_INCLUDE_IGNORED = 4;
}

/// Stash application flags.
abstract class git_stash_apply_flags {
  static const int GIT_STASH_APPLY_DEFAULT = 0;

  /// Try to reinstate not only the working tree's changes,
  /// but also the index's changes.
  static const int GIT_STASH_APPLY_REINSTATE_INDEX = 1;
}

/// Stash apply progression states
abstract class git_stash_apply_progress_t {
  static const int GIT_STASH_APPLY_PROGRESS_NONE = 0;

  /// Loading the stashed data from the object database.
  static const int GIT_STASH_APPLY_PROGRESS_LOADING_STASH = 1;

  /// The stored index is being analyzed.
  static const int GIT_STASH_APPLY_PROGRESS_ANALYZE_INDEX = 2;

  /// The modified files are being analyzed.
  static const int GIT_STASH_APPLY_PROGRESS_ANALYZE_MODIFIED = 3;

  /// The untracked and ignored files are being analyzed.
  static const int GIT_STASH_APPLY_PROGRESS_ANALYZE_UNTRACKED = 4;

  /// The untracked files are being written to disk.
  static const int GIT_STASH_APPLY_PROGRESS_CHECKOUT_UNTRACKED = 5;

  /// The modified files are being written to disk.
  static const int GIT_STASH_APPLY_PROGRESS_CHECKOUT_MODIFIED = 6;

  /// The stash was applied successfully.
  static const int GIT_STASH_APPLY_PROGRESS_DONE = 7;
}

/// Stash application options structure
///
/// Initialize with `GIT_STASH_APPLY_OPTIONS_INIT`. Alternatively, you can
/// use `git_stash_apply_options_init`.
class git_stash_apply_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// See `git_stash_apply_flags`, above.
  @ffi.Uint32()
  external int flags;

  /// Options to use when writing files to the working directory.
  external git_checkout_options checkout_options;

  /// Optional callback to notify the consumer of application progress.
  external ffi.Pointer<ffi.NativeFunction<git_stash_apply_progress_cb>>
      progress_cb;

  external ffi.Pointer<ffi.Void> progress_payload;
}

/// Status flags for a single file.
///
/// A combination of these values will be returned to indicate the status of
/// a file.  Status compares the working directory, the index, and the
/// current HEAD of the repository.  The `GIT_STATUS_INDEX` set of flags
/// represents the status of file in the index relative to the HEAD, and the
/// `GIT_STATUS_WT` set of flags represent the status of the file in the
/// working directory relative to the index.
abstract class git_status_t {
  static const int GIT_STATUS_CURRENT = 0;
  static const int GIT_STATUS_INDEX_NEW = 1;
  static const int GIT_STATUS_INDEX_MODIFIED = 2;
  static const int GIT_STATUS_INDEX_DELETED = 4;
  static const int GIT_STATUS_INDEX_RENAMED = 8;
  static const int GIT_STATUS_INDEX_TYPECHANGE = 16;
  static const int GIT_STATUS_WT_NEW = 128;
  static const int GIT_STATUS_WT_MODIFIED = 256;
  static const int GIT_STATUS_WT_DELETED = 512;
  static const int GIT_STATUS_WT_TYPECHANGE = 1024;
  static const int GIT_STATUS_WT_RENAMED = 2048;
  static const int GIT_STATUS_WT_UNREADABLE = 4096;
  static const int GIT_STATUS_IGNORED = 16384;
  static const int GIT_STATUS_CONFLICTED = 32768;
}

/// Select the files on which to report status.
///
/// With `git_status_foreach_ext`, this will control which changes get
/// callbacks.  With `git_status_list_new`, these will control which
/// changes are included in the list.
///
/// - GIT_STATUS_SHOW_INDEX_AND_WORKDIR is the default.  This roughly
/// matches `git status --porcelain` regarding which files are
/// included and in what order.
/// - GIT_STATUS_SHOW_INDEX_ONLY only gives status based on HEAD to index
/// comparison, not looking at working directory changes.
/// - GIT_STATUS_SHOW_WORKDIR_ONLY only gives status based on index to
/// working directory comparison, not comparing the index to the HEAD.
abstract class git_status_show_t {
  static const int GIT_STATUS_SHOW_INDEX_AND_WORKDIR = 0;
  static const int GIT_STATUS_SHOW_INDEX_ONLY = 1;
  static const int GIT_STATUS_SHOW_WORKDIR_ONLY = 2;
}

/// Flags to control status callbacks
///
/// - GIT_STATUS_OPT_INCLUDE_UNTRACKED says that callbacks should be made
/// on untracked files.  These will only be made if the workdir files are
/// included in the status "show" option.
/// - GIT_STATUS_OPT_INCLUDE_IGNORED says that ignored files get callbacks.
/// Again, these callbacks will only be made if the workdir files are
/// included in the status "show" option.
/// - GIT_STATUS_OPT_INCLUDE_UNMODIFIED indicates that callback should be
/// made even on unmodified files.
/// - GIT_STATUS_OPT_EXCLUDE_SUBMODULES indicates that submodules should be
/// skipped.  This only applies if there are no pending typechanges to
/// the submodule (either from or to another type).
/// - GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS indicates that all files in
/// untracked directories should be included.  Normally if an entire
/// directory is new, then just the top-level directory is included (with
/// a trailing slash on the entry name).  This flag says to include all
/// of the individual files in the directory instead.
/// - GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH indicates that the given path
/// should be treated as a literal path, and not as a pathspec pattern.
/// - GIT_STATUS_OPT_RECURSE_IGNORED_DIRS indicates that the contents of
/// ignored directories should be included in the status.  This is like
/// doing `git ls-files -o -i --exclude-standard` with core git.
/// - GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX indicates that rename detection
/// should be processed between the head and the index and enables
/// the GIT_STATUS_INDEX_RENAMED as a possible status flag.
/// - GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR indicates that rename
/// detection should be run between the index and the working directory
/// and enabled GIT_STATUS_WT_RENAMED as a possible status flag.
/// - GIT_STATUS_OPT_SORT_CASE_SENSITIVELY overrides the native case
/// sensitivity for the file system and forces the output to be in
/// case-sensitive order
/// - GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY overrides the native case
/// sensitivity for the file system and forces the output to be in
/// case-insensitive order
/// - GIT_STATUS_OPT_RENAMES_FROM_REWRITES indicates that rename detection
/// should include rewritten files
/// - GIT_STATUS_OPT_NO_REFRESH bypasses the default status behavior of
/// doing a "soft" index reload (i.e. reloading the index data if the
/// file on disk has been modified outside libgit2).
/// - GIT_STATUS_OPT_UPDATE_INDEX tells libgit2 to refresh the stat cache
/// in the index for files that are unchanged but have out of date stat
/// information in the index.  It will result in less work being done on
/// subsequent calls to get status.  This is mutually exclusive with the
/// NO_REFRESH option.
///
/// Calling `git_status_foreach()` is like calling the extended version
/// with: GIT_STATUS_OPT_INCLUDE_IGNORED, GIT_STATUS_OPT_INCLUDE_UNTRACKED,
/// and GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS.  Those options are bundled
/// together as `GIT_STATUS_OPT_DEFAULTS` if you want them as a baseline.
abstract class git_status_opt_t {
  static const int GIT_STATUS_OPT_INCLUDE_UNTRACKED = 1;
  static const int GIT_STATUS_OPT_INCLUDE_IGNORED = 2;
  static const int GIT_STATUS_OPT_INCLUDE_UNMODIFIED = 4;
  static const int GIT_STATUS_OPT_EXCLUDE_SUBMODULES = 8;
  static const int GIT_STATUS_OPT_RECURSE_UNTRACKED_DIRS = 16;
  static const int GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH = 32;
  static const int GIT_STATUS_OPT_RECURSE_IGNORED_DIRS = 64;
  static const int GIT_STATUS_OPT_RENAMES_HEAD_TO_INDEX = 128;
  static const int GIT_STATUS_OPT_RENAMES_INDEX_TO_WORKDIR = 256;
  static const int GIT_STATUS_OPT_SORT_CASE_SENSITIVELY = 512;
  static const int GIT_STATUS_OPT_SORT_CASE_INSENSITIVELY = 1024;
  static const int GIT_STATUS_OPT_RENAMES_FROM_REWRITES = 2048;
  static const int GIT_STATUS_OPT_NO_REFRESH = 4096;
  static const int GIT_STATUS_OPT_UPDATE_INDEX = 8192;
  static const int GIT_STATUS_OPT_INCLUDE_UNREADABLE = 16384;
  static const int GIT_STATUS_OPT_INCLUDE_UNREADABLE_AS_UNTRACKED = 32768;
}

/// Options to control how `git_status_foreach_ext()` will issue callbacks.
///
/// Initialize with `GIT_STATUS_OPTIONS_INIT`. Alternatively, you can
/// use `git_status_options_init`.
class git_status_options extends ffi.Struct {
  /// < The version
  @ffi.Uint32()
  external int version;

  /// The `show` value is one of the `git_status_show_t` constants that
  /// control which files to scan and in what order.
  @ffi.Int32()
  external int show_1;

  /// The `flags` value is an OR'ed combination of the `git_status_opt_t`
  /// values above.
  @ffi.Uint32()
  external int flags;

  /// The `pathspec` is an array of path patterns to match (using
  /// fnmatch-style matching), or just an array of paths to match exactly if
  /// `GIT_STATUS_OPT_DISABLE_PATHSPEC_MATCH` is specified in the flags.
  external git_strarray pathspec;

  /// The `baseline` is the tree to be used for comparison to the working directory
  /// and index; defaults to HEAD.
  external ffi.Pointer<git_tree> baseline;
}

/// A status entry, providing the differences between the file as it exists
/// in HEAD and the index, and providing the differences between the index
/// and the working directory.
///
/// The `status` value provides the status flags for this file.
///
/// The `head_to_index` value provides detailed information about the
/// differences between the file in HEAD and the file in the index.
///
/// The `index_to_workdir` value provides detailed information about the
/// differences between the file in the index and the file in the
/// working directory.
class git_status_entry extends ffi.Struct {
  @ffi.Int32()
  external int status;

  external ffi.Pointer<git_diff_delta> head_to_index;

  external ffi.Pointer<git_diff_delta> index_to_workdir;
}

/// Return codes for submodule status.
///
/// A combination of these flags will be returned to describe the status of a
/// submodule.  Depending on the "ignore" property of the submodule, some of
/// the flags may never be returned because they indicate changes that are
/// supposed to be ignored.
///
/// Submodule info is contained in 4 places: the HEAD tree, the index, config
/// files (both .git/config and .gitmodules), and the working directory.  Any
/// or all of those places might be missing information about the submodule
/// depending on what state the repo is in.  We consider all four places to
/// build the combination of status flags.
///
/// There are four values that are not really status, but give basic info
/// about what sources of submodule data are available.  These will be
/// returned even if ignore is set to "ALL".
///
/// * IN_HEAD   - superproject head contains submodule
/// * IN_INDEX  - superproject index contains submodule
/// * IN_CONFIG - superproject gitmodules has submodule
/// * IN_WD     - superproject workdir has submodule
///
/// The following values will be returned so long as ignore is not "ALL".
///
/// * INDEX_ADDED       - in index, not in head
/// * INDEX_DELETED     - in head, not in index
/// * INDEX_MODIFIED    - index and head don't match
/// * WD_UNINITIALIZED  - workdir contains empty directory
/// * WD_ADDED          - in workdir, not index
/// * WD_DELETED        - in index, not workdir
/// * WD_MODIFIED       - index and workdir head don't match
///
/// The following can only be returned if ignore is "NONE" or "UNTRACKED".
///
/// * WD_INDEX_MODIFIED - submodule workdir index is dirty
/// * WD_WD_MODIFIED    - submodule workdir has modified files
///
/// Lastly, the following will only be returned for ignore "NONE".
///
/// * WD_UNTRACKED      - wd contains untracked files
abstract class git_submodule_status_t {
  static const int GIT_SUBMODULE_STATUS_IN_HEAD = 1;
  static const int GIT_SUBMODULE_STATUS_IN_INDEX = 2;
  static const int GIT_SUBMODULE_STATUS_IN_CONFIG = 4;
  static const int GIT_SUBMODULE_STATUS_IN_WD = 8;
  static const int GIT_SUBMODULE_STATUS_INDEX_ADDED = 16;
  static const int GIT_SUBMODULE_STATUS_INDEX_DELETED = 32;
  static const int GIT_SUBMODULE_STATUS_INDEX_MODIFIED = 64;
  static const int GIT_SUBMODULE_STATUS_WD_UNINITIALIZED = 128;
  static const int GIT_SUBMODULE_STATUS_WD_ADDED = 256;
  static const int GIT_SUBMODULE_STATUS_WD_DELETED = 512;
  static const int GIT_SUBMODULE_STATUS_WD_MODIFIED = 1024;
  static const int GIT_SUBMODULE_STATUS_WD_INDEX_MODIFIED = 2048;
  static const int GIT_SUBMODULE_STATUS_WD_WD_MODIFIED = 4096;
  static const int GIT_SUBMODULE_STATUS_WD_UNTRACKED = 8192;
}

/// Submodule update options structure
///
/// Initialize with `GIT_SUBMODULE_UPDATE_OPTIONS_INIT`. Alternatively, you can
/// use `git_submodule_update_options_init`.
class git_submodule_update_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// These options are passed to the checkout step. To disable
  /// checkout, set the `checkout_strategy` to
  /// `GIT_CHECKOUT_NONE`. Generally you will want the use
  /// GIT_CHECKOUT_SAFE to update files in the working
  /// directory.
  external git_checkout_options checkout_opts;

  /// Options which control the fetch, including callbacks.
  ///
  /// The callbacks to use for reporting fetch progress, and for acquiring
  /// credentials in the event they are needed.
  external git_fetch_options fetch_opts;

  /// Allow fetching from the submodule's default remote if the target
  /// commit isn't found. Enabled by default.
  @ffi.Int32()
  external int allow_fetch;
}

/// Worktree add options structure
///
/// Initialize with `GIT_WORKTREE_ADD_OPTIONS_INIT`. Alternatively, you can
/// use `git_worktree_add_options_init`.
class git_worktree_add_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  /// < lock newly created worktree
  @ffi.Int32()
  external int lock;

  /// < reference to use for the new worktree HEAD
  external ffi.Pointer<git_reference> ref;
}

/// Flags which can be passed to git_worktree_prune to alter its
/// behavior.
abstract class git_worktree_prune_t {
  /// Prune working tree even if working tree is valid
  static const int GIT_WORKTREE_PRUNE_VALID = 1;

  /// Prune working tree even if it is locked
  static const int GIT_WORKTREE_PRUNE_LOCKED = 2;

  /// Prune checked out working tree
  static const int GIT_WORKTREE_PRUNE_WORKING_TREE = 4;
}

/// Worktree prune options structure
///
/// Initialize with `GIT_WORKTREE_PRUNE_OPTIONS_INIT`. Alternatively, you can
/// use `git_worktree_prune_options_init`.
class git_worktree_prune_options extends ffi.Struct {
  @ffi.Uint32()
  external int version;

  @ffi.Uint32()
  external int flags;
}

/// Payload for git_credential_userpass_plaintext.
class git_credential_userpass_payload extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> username;

  external ffi.Pointer<ffi.Int8> password;
}

/// Filters are applied in one of two directions: smudging - which is
/// exporting a file from the Git object database to the working directory,
/// and cleaning - which is importing a file from the working directory to
/// the Git object database.  These values control which direction of
/// change is being applied.
abstract class git_filter_mode_t {
  static const int GIT_FILTER_TO_WORKTREE = 0;
  static const int GIT_FILTER_SMUDGE = 0;
  static const int GIT_FILTER_TO_ODB = 1;
  static const int GIT_FILTER_CLEAN = 1;
}

/// Filter option flags.
abstract class git_filter_flag_t {
  static const int GIT_FILTER_DEFAULT = 0;

  /// Don't error for `safecrlf` violations, allow them to continue.
  static const int GIT_FILTER_ALLOW_UNSAFE = 1;

  /// Don't load `/etc/gitattributes` (or the system equivalent)
  static const int GIT_FILTER_NO_SYSTEM_ATTRIBUTES = 2;

  /// Load attributes from `.gitattributes` in the root of HEAD
  static const int GIT_FILTER_ATTRIBUTES_FROM_HEAD = 4;
}

class git_filter extends ffi.Opaque {}

class git_filter_list extends ffi.Opaque {}

/// Represents a single git message trailer.
class git_message_trailer extends ffi.Struct {
  external ffi.Pointer<ffi.Int8> key;

  external ffi.Pointer<ffi.Int8> value;
}

/// Represents an array of git message trailers.
///
/// Struct members under the private comment are private, subject to change
/// and should not be used by callers.
class git_message_trailer_array extends ffi.Struct {
  external ffi.Pointer<git_message_trailer> trailers;

  @ffi.Int32()
  external int count;

  /// private
  external ffi.Pointer<ffi.Int8> _trailer_block;
}

class git_iterator extends ffi.Opaque {}

/// The information about object IDs to query in `git_odb_expand_ids`,
/// which will be populated upon return.
class git_odb_expand_id extends ffi.Struct {
  /// The object ID to expand
  external git_oid id;

  /// The length of the object ID (in nibbles, or packets of 4 bits; the
  /// number of hex characters)
  @ffi.Uint16()
  external int length;

  /// The (optional) type of the object to search for; leave as `0` or set
  /// to `GIT_OBJECT_ANY` to query for any object matching the ID.
  @ffi.Int32()
  external int type;
}

/// Streaming mode
abstract class git_odb_stream_t {
  static const int GIT_STREAM_RDONLY = 2;
  static const int GIT_STREAM_WRONLY = 4;
  static const int GIT_STREAM_RW = 6;
}

class git_patch extends ffi.Opaque {}

class git_pathspec extends ffi.Opaque {}

class git_pathspec_match_list extends ffi.Opaque {}

/// Options controlling how pathspec match should be executed
abstract class git_pathspec_flag_t {
  static const int GIT_PATHSPEC_DEFAULT = 0;

  /// GIT_PATHSPEC_IGNORE_CASE forces match to ignore case; otherwise
  /// match will use native case sensitivity of platform filesystem
  static const int GIT_PATHSPEC_IGNORE_CASE = 1;

  /// GIT_PATHSPEC_USE_CASE forces case sensitive match; otherwise
  /// match will use native case sensitivity of platform filesystem
  static const int GIT_PATHSPEC_USE_CASE = 2;

  /// GIT_PATHSPEC_NO_GLOB disables glob patterns and just uses simple
  /// string comparison for matching
  static const int GIT_PATHSPEC_NO_GLOB = 4;

  /// GIT_PATHSPEC_NO_MATCH_ERROR means the match functions return error
  /// code GIT_ENOTFOUND if no matches are found; otherwise no matches is
  /// still success (return 0) but `git_pathspec_match_list_entrycount`
  /// will indicate 0 matches.
  static const int GIT_PATHSPEC_NO_MATCH_ERROR = 8;

  /// GIT_PATHSPEC_FIND_FAILURES means that the `git_pathspec_match_list`
  /// should track which patterns matched which files so that at the end of
  /// the match we can identify patterns that did not match any files.
  static const int GIT_PATHSPEC_FIND_FAILURES = 16;

  /// GIT_PATHSPEC_FAILURES_ONLY means that the `git_pathspec_match_list`
  /// does not need to keep the actual matching filenames.  Use this to
  /// just test if there were any matches at all or in combination with
  /// GIT_PATHSPEC_FIND_FAILURES to validate a pathspec.
  static const int GIT_PATHSPEC_FAILURES_ONLY = 32;
}

/// Kinds of reset operation
abstract class git_reset_t {
  /// < Move the head to the given commit
  static const int GIT_RESET_SOFT = 1;

  /// < SOFT plus reset index to the commit
  static const int GIT_RESET_MIXED = 2;

  /// < MIXED plus changes in working tree discarded
  static const int GIT_RESET_HARD = 3;
}

/// Revparse flags.  These indicate the intended behavior of the spec passed to
/// git_revparse.
abstract class git_revparse_mode_t {
  /// The spec targeted a single object.
  static const int GIT_REVPARSE_SINGLE = 1;

  /// The spec targeted a range of commits.
  static const int GIT_REVPARSE_RANGE = 2;

  /// The spec used the '...' operator, which invokes special semantics.
  static const int GIT_REVPARSE_MERGE_BASE = 4;
}

/// Git Revision Spec: output of a `git_revparse` operation
class git_revspec extends ffi.Struct {
  /// The left element of the revspec; must be freed by the user
  external ffi.Pointer<git_object> from;

  /// The right element of the revspec; must be freed by the user
  external ffi.Pointer<git_object> to;

  /// The intent of the revspec (i.e. `git_revparse_mode_t` flags)
  @ffi.Uint32()
  external int flags;
}

/// Flags to specify the sorting which a revwalk should perform.
abstract class git_sort_t {
  /// Sort the output with the same default method from `git`: reverse
  /// chronological order. This is the default sorting for new walkers.
  static const int GIT_SORT_NONE = 0;

  /// Sort the repository contents in topological order (no parents before
  /// all of its children are shown); this sorting mode can be combined
  /// with time sorting to produce `git`'s `--date-order``.
  static const int GIT_SORT_TOPOLOGICAL = 1;

  /// Sort the repository contents by commit time;
  /// this sorting mode can be combined with
  /// topological sorting.
  static const int GIT_SORT_TIME = 2;

  /// Iterate through the repository contents in reverse
  /// order; this sorting mode can be combined with
  /// any of the above.
  static const int GIT_SORT_REVERSE = 4;
}

const int _TIME_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 33;

const int _SYS_CDEFS_H = 1;

const int __THROW = 1;

const int __THROWNL = 1;

const int __glibc_c99_flexarr_available = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int _BITS_TIME_H = 1;

const int _BITS_TYPES_H = 1;

const int __TIMESIZE = 64;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int CLOCKS_PER_SEC = 1000000;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 1;

const int CLOCK_PROCESS_CPUTIME_ID = 2;

const int CLOCK_THREAD_CPUTIME_ID = 3;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_REALTIME_COARSE = 5;

const int CLOCK_MONOTONIC_COARSE = 6;

const int CLOCK_BOOTTIME = 7;

const int CLOCK_REALTIME_ALARM = 8;

const int CLOCK_BOOTTIME_ALARM = 9;

const int CLOCK_TAI = 11;

const int TIMER_ABSTIME = 1;

const int __clock_t_defined = 1;

const int __time_t_defined = 1;

const int __struct_tm_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int __clockid_t_defined = 1;

const int __timer_t_defined = 1;

const int __itimerspec_defined = 1;

const int _BITS_TYPES_LOCALE_T_H = 1;

const int _BITS_TYPES___LOCALE_T_H = 1;

const int TIME_UTC = 1;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _SYS_TYPES_H = 1;

const int _BITS_STDINT_INTN_H = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int _ALLOCA_H = 1;

const int _INTTYPES_H = 1;

const int _STDINT_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_UINTN_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int ____gwchar_t_defined = 1;

const String __PRI64_PREFIX = 'l';

const String __PRIPTR_PREFIX = 'l';

const String PRId8 = 'd';

const String PRId16 = 'd';

const String PRId32 = 'd';

const String PRId64 = 'ld';

const String PRIdLEAST8 = 'd';

const String PRIdLEAST16 = 'd';

const String PRIdLEAST32 = 'd';

const String PRIdLEAST64 = 'ld';

const String PRIdFAST8 = 'd';

const String PRIdFAST16 = 'ld';

const String PRIdFAST32 = 'ld';

const String PRIdFAST64 = 'ld';

const String PRIi8 = 'i';

const String PRIi16 = 'i';

const String PRIi32 = 'i';

const String PRIi64 = 'li';

const String PRIiLEAST8 = 'i';

const String PRIiLEAST16 = 'i';

const String PRIiLEAST32 = 'i';

const String PRIiLEAST64 = 'li';

const String PRIiFAST8 = 'i';

const String PRIiFAST16 = 'li';

const String PRIiFAST32 = 'li';

const String PRIiFAST64 = 'li';

const String PRIo8 = 'o';

const String PRIo16 = 'o';

const String PRIo32 = 'o';

const String PRIo64 = 'lo';

const String PRIoLEAST8 = 'o';

const String PRIoLEAST16 = 'o';

const String PRIoLEAST32 = 'o';

const String PRIoLEAST64 = 'lo';

const String PRIoFAST8 = 'o';

const String PRIoFAST16 = 'lo';

const String PRIoFAST32 = 'lo';

const String PRIoFAST64 = 'lo';

const String PRIu8 = 'u';

const String PRIu16 = 'u';

const String PRIu32 = 'u';

const String PRIu64 = 'lu';

const String PRIuLEAST8 = 'u';

const String PRIuLEAST16 = 'u';

const String PRIuLEAST32 = 'u';

const String PRIuLEAST64 = 'lu';

const String PRIuFAST8 = 'u';

const String PRIuFAST16 = 'lu';

const String PRIuFAST32 = 'lu';

const String PRIuFAST64 = 'lu';

const String PRIx8 = 'x';

const String PRIx16 = 'x';

const String PRIx32 = 'x';

const String PRIx64 = 'lx';

const String PRIxLEAST8 = 'x';

const String PRIxLEAST16 = 'x';

const String PRIxLEAST32 = 'x';

const String PRIxLEAST64 = 'lx';

const String PRIxFAST8 = 'x';

const String PRIxFAST16 = 'lx';

const String PRIxFAST32 = 'lx';

const String PRIxFAST64 = 'lx';

const String PRIX8 = 'X';

const String PRIX16 = 'X';

const String PRIX32 = 'X';

const String PRIX64 = 'lX';

const String PRIXLEAST8 = 'X';

const String PRIXLEAST16 = 'X';

const String PRIXLEAST32 = 'X';

const String PRIXLEAST64 = 'lX';

const String PRIXFAST8 = 'X';

const String PRIXFAST16 = 'lX';

const String PRIXFAST32 = 'lX';

const String PRIXFAST64 = 'lX';

const String PRIdMAX = 'ld';

const String PRIiMAX = 'li';

const String PRIoMAX = 'lo';

const String PRIuMAX = 'lu';

const String PRIxMAX = 'lx';

const String PRIXMAX = 'lX';

const String PRIdPTR = 'ld';

const String PRIiPTR = 'li';

const String PRIoPTR = 'lo';

const String PRIuPTR = 'lu';

const String PRIxPTR = 'lx';

const String PRIXPTR = 'lX';

const String SCNd8 = 'hhd';

const String SCNd16 = 'hd';

const String SCNd32 = 'd';

const String SCNd64 = 'ld';

const String SCNdLEAST8 = 'hhd';

const String SCNdLEAST16 = 'hd';

const String SCNdLEAST32 = 'd';

const String SCNdLEAST64 = 'ld';

const String SCNdFAST8 = 'hhd';

const String SCNdFAST16 = 'ld';

const String SCNdFAST32 = 'ld';

const String SCNdFAST64 = 'ld';

const String SCNi8 = 'hhi';

const String SCNi16 = 'hi';

const String SCNi32 = 'i';

const String SCNi64 = 'li';

const String SCNiLEAST8 = 'hhi';

const String SCNiLEAST16 = 'hi';

const String SCNiLEAST32 = 'i';

const String SCNiLEAST64 = 'li';

const String SCNiFAST8 = 'hhi';

const String SCNiFAST16 = 'li';

const String SCNiFAST32 = 'li';

const String SCNiFAST64 = 'li';

const String SCNu8 = 'hhu';

const String SCNu16 = 'hu';

const String SCNu32 = 'u';

const String SCNu64 = 'lu';

const String SCNuLEAST8 = 'hhu';

const String SCNuLEAST16 = 'hu';

const String SCNuLEAST32 = 'u';

const String SCNuLEAST64 = 'lu';

const String SCNuFAST8 = 'hhu';

const String SCNuFAST16 = 'lu';

const String SCNuFAST32 = 'lu';

const String SCNuFAST64 = 'lu';

const String SCNo8 = 'hho';

const String SCNo16 = 'ho';

const String SCNo32 = 'o';

const String SCNo64 = 'lo';

const String SCNoLEAST8 = 'hho';

const String SCNoLEAST16 = 'ho';

const String SCNoLEAST32 = 'o';

const String SCNoLEAST64 = 'lo';

const String SCNoFAST8 = 'hho';

const String SCNoFAST16 = 'lo';

const String SCNoFAST32 = 'lo';

const String SCNoFAST64 = 'lo';

const String SCNx8 = 'hhx';

const String SCNx16 = 'hx';

const String SCNx32 = 'x';

const String SCNx64 = 'lx';

const String SCNxLEAST8 = 'hhx';

const String SCNxLEAST16 = 'hx';

const String SCNxLEAST32 = 'x';

const String SCNxLEAST64 = 'lx';

const String SCNxFAST8 = 'hhx';

const String SCNxFAST16 = 'lx';

const String SCNxFAST32 = 'lx';

const String SCNxFAST64 = 'lx';

const String SCNdMAX = 'ld';

const String SCNiMAX = 'li';

const String SCNoMAX = 'lo';

const String SCNuMAX = 'lu';

const String SCNxMAX = 'lx';

const String SCNdPTR = 'ld';

const String SCNiPTR = 'li';

const String SCNoPTR = 'lo';

const String SCNuPTR = 'lu';

const String SCNxPTR = 'lx';

const int GIT_PATH_LIST_SEPARATOR = 58;

const int GIT_PATH_MAX = 4096;

const String GIT_OID_HEX_ZERO = '0000000000000000000000000000000000000000';

const int GIT_OID_RAWSZ = 20;

const int GIT_OID_HEXSZ = 40;

const int GIT_OID_MINPREFIXLEN = 4;

const int GIT_REPOSITORY_INIT_OPTIONS_VERSION = 1;

const int GIT_OBJECT_SIZE_MAX = -1;

const int GIT_DIFF_OPTIONS_VERSION = 1;

const int GIT_DIFF_HUNK_HEADER_SIZE = 128;

const int GIT_DIFF_FIND_OPTIONS_VERSION = 1;

const int GIT_DIFF_FORMAT_EMAIL_OPTIONS_VERSION = 1;

const int GIT_DIFF_PATCHID_OPTIONS_VERSION = 1;

const int GIT_APPLY_OPTIONS_VERSION = 1;

const int GIT_ATTR_CHECK_FILE_THEN_INDEX = 0;

const int GIT_ATTR_CHECK_INDEX_THEN_FILE = 1;

const int GIT_ATTR_CHECK_INDEX_ONLY = 2;

const int GIT_ATTR_CHECK_NO_SYSTEM = 4;

const int GIT_ATTR_CHECK_INCLUDE_HEAD = 8;

const int GIT_BLOB_FILTER_OPTIONS_VERSION = 1;

const int GIT_BLAME_OPTIONS_VERSION = 1;

const int GIT_CHECKOUT_OPTIONS_VERSION = 1;

const int GIT_INDEXER_OPTIONS_VERSION = 1;

const int GIT_INDEX_ENTRY_NAMEMASK = 4095;

const int GIT_INDEX_ENTRY_STAGEMASK = 12288;

const int GIT_INDEX_ENTRY_STAGESHIFT = 12;

const int GIT_MERGE_FILE_INPUT_VERSION = 1;

const int GIT_MERGE_CONFLICT_MARKER_SIZE = 7;

const int GIT_MERGE_FILE_OPTIONS_VERSION = 1;

const int GIT_MERGE_OPTIONS_VERSION = 1;

const int GIT_CHERRYPICK_OPTIONS_VERSION = 1;

const String GIT_DEFAULT_PORT = '9418';

const int GIT_PROXY_OPTIONS_VERSION = 1;

const int GIT_REMOTE_CREATE_OPTIONS_VERSION = 1;

const int GIT_REMOTE_CALLBACKS_VERSION = 1;

const int GIT_FETCH_OPTIONS_VERSION = 1;

const int GIT_PUSH_OPTIONS_VERSION = 1;

const int GIT_CLONE_OPTIONS_VERSION = 1;

const int GIT_DESCRIBE_DEFAULT_MAX_CANDIDATES_TAGS = 10;

const int GIT_DESCRIBE_DEFAULT_ABBREVIATED_SIZE = 7;

const int GIT_DESCRIBE_OPTIONS_VERSION = 1;

const int GIT_DESCRIBE_FORMAT_OPTIONS_VERSION = 1;

const int GIT_REBASE_OPTIONS_VERSION = 1;

const int GIT_REBASE_NO_OPERATION = -1;

const int GIT_REVERT_OPTIONS_VERSION = 1;

const int GIT_STASH_APPLY_OPTIONS_VERSION = 1;

const int GIT_STATUS_OPT_DEFAULTS = 19;

const int GIT_STATUS_OPTIONS_VERSION = 1;

const int GIT_SUBMODULE_STATUS__IN_FLAGS = 15;

const int GIT_SUBMODULE_STATUS__INDEX_FLAGS = 112;

const int GIT_SUBMODULE_STATUS__WD_FLAGS = 16256;

const int GIT_SUBMODULE_UPDATE_OPTIONS_VERSION = 1;

const int GIT_WORKTREE_ADD_OPTIONS_VERSION = 1;

const int GIT_WORKTREE_PRUNE_OPTIONS_VERSION = 1;

const int GIT_ATTR_UNSPECIFIED_T = 0;

const int GIT_ATTR_TRUE_T = 1;

const int GIT_ATTR_FALSE_T = 2;

const int GIT_ATTR_VALUE_T = 3;

const int GIT_CVAR_FALSE = 0;

const int GIT_CVAR_TRUE = 1;

const int GIT_CVAR_INT32 = 2;

const int GIT_CVAR_STRING = 3;

const int GITERR_NONE = 0;

const int GITERR_NOMEMORY = 1;

const int GITERR_OS = 2;

const int GITERR_INVALID = 3;

const int GITERR_REFERENCE = 4;

const int GITERR_ZLIB = 5;

const int GITERR_REPOSITORY = 6;

const int GITERR_CONFIG = 7;

const int GITERR_REGEX = 8;

const int GITERR_ODB = 9;

const int GITERR_INDEX = 10;

const int GITERR_OBJECT = 11;

const int GITERR_NET = 12;

const int GITERR_TAG = 13;

const int GITERR_TREE = 14;

const int GITERR_INDEXER = 15;

const int GITERR_SSL = 16;

const int GITERR_SUBMODULE = 17;

const int GITERR_THREAD = 18;

const int GITERR_STASH = 19;

const int GITERR_CHECKOUT = 20;

const int GITERR_FETCHHEAD = 21;

const int GITERR_MERGE = 22;

const int GITERR_SSH = 23;

const int GITERR_FILTER = 24;

const int GITERR_REVERT = 25;

const int GITERR_CALLBACK = 26;

const int GITERR_CHERRYPICK = 27;

const int GITERR_DESCRIBE = 28;

const int GITERR_REBASE = 29;

const int GITERR_FILESYSTEM = 30;

const int GITERR_PATCH = 31;

const int GITERR_WORKTREE = 32;

const int GITERR_SHA1 = 33;

const int GIT_IDXENTRY_NAMEMASK = 4095;

const int GIT_IDXENTRY_STAGEMASK = 12288;

const int GIT_IDXENTRY_STAGESHIFT = 12;

const int GIT_IDXENTRY_EXTENDED = 16384;

const int GIT_IDXENTRY_VALID = 32768;

const int GIT_IDXENTRY_INTENT_TO_ADD = 8192;

const int GIT_IDXENTRY_SKIP_WORKTREE = 16384;

const int GIT_IDXENTRY_EXTENDED_FLAGS = 24576;

const int GIT_IDXENTRY_EXTENDED2 = 32768;

const int GIT_IDXENTRY_UPDATE = 1;

const int GIT_IDXENTRY_REMOVE = 2;

const int GIT_IDXENTRY_UPTODATE = 4;

const int GIT_IDXENTRY_ADDED = 8;

const int GIT_IDXENTRY_HASHED = 16;

const int GIT_IDXENTRY_UNHASHED = 32;

const int GIT_IDXENTRY_WT_REMOVE = 64;

const int GIT_IDXENTRY_CONFLICTED = 128;

const int GIT_IDXENTRY_UNPACKED = 256;

const int GIT_IDXENTRY_NEW_SKIP_WORKTREE = 512;

const int GIT_INDEXCAP_IGNORE_CASE = 1;

const int GIT_INDEXCAP_NO_FILEMODE = 2;

const int GIT_INDEXCAP_NO_SYMLINKS = 4;

const int GIT_INDEXCAP_FROM_OWNER = -1;

const int GIT_OBJ_ANY = -2;

const int GIT_OBJ_BAD = -1;

const int GIT_OBJ__EXT1 = 0;

const int GIT_OBJ_COMMIT = 1;

const int GIT_OBJ_TREE = 2;

const int GIT_OBJ_BLOB = 3;

const int GIT_OBJ_TAG = 4;

const int GIT_OBJ__EXT2 = 5;

const int GIT_OBJ_OFS_DELTA = 6;

const int GIT_OBJ_REF_DELTA = 7;

const int GIT_REF_INVALID = 0;

const int GIT_REF_OID = 1;

const int GIT_REF_SYMBOLIC = 2;

const int GIT_REF_LISTALL = 3;

const int GIT_REF_FORMAT_NORMAL = 0;

const int GIT_REF_FORMAT_ALLOW_ONELEVEL = 1;

const int GIT_REF_FORMAT_REFSPEC_PATTERN = 2;

const int GIT_REF_FORMAT_REFSPEC_SHORTHAND = 4;

const int GIT_CREDTYPE_USERPASS_PLAINTEXT = 1;

const int GIT_CREDTYPE_SSH_KEY = 2;

const int GIT_CREDTYPE_SSH_CUSTOM = 4;

const int GIT_CREDTYPE_DEFAULT = 8;

const int GIT_CREDTYPE_SSH_INTERACTIVE = 16;

const int GIT_CREDTYPE_USERNAME = 32;

const int GIT_CREDTYPE_SSH_MEMORY = 64;

const String LIBGIT2_VERSION = '1.1.0';

const int LIBGIT2_VER_MAJOR = 1;

const int LIBGIT2_VER_MINOR = 1;

const int LIBGIT2_VER_REVISION = 0;

const int LIBGIT2_VER_PATCH = 0;

const String LIBGIT2_SOVERSION = '1.1';

typedef _c_clock = ffi.Int64 Function();

typedef _dart_clock = int Function();

typedef _c_time = ffi.Int64 Function(
  ffi.Pointer<ffi.Int64> __timer,
);

typedef _dart_time = int Function(
  ffi.Pointer<ffi.Int64> __timer,
);

typedef _c_difftime = ffi.Double Function(
  ffi.Int64 __time1,
  ffi.Int64 __time0,
);

typedef _dart_difftime = double Function(
  int __time1,
  int __time0,
);

typedef _c_mktime = ffi.Int64 Function(
  ffi.Pointer<tm> __tp,
);

typedef _dart_mktime = int Function(
  ffi.Pointer<tm> __tp,
);

typedef _c_strftime = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Int32 __maxsize,
  ffi.Pointer<ffi.Int8> __format,
  ffi.Pointer<tm> __tp,
);

typedef _dart_strftime = int Function(
  ffi.Pointer<ffi.Int8> __s,
  int __maxsize,
  ffi.Pointer<ffi.Int8> __format,
  ffi.Pointer<tm> __tp,
);

typedef _c_strftime_l = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Int32 __maxsize,
  ffi.Pointer<ffi.Int8> __format,
  ffi.Pointer<tm> __tp,
  ffi.Pointer<__locale_struct> __loc,
);

typedef _dart_strftime_l = int Function(
  ffi.Pointer<ffi.Int8> __s,
  int __maxsize,
  ffi.Pointer<ffi.Int8> __format,
  ffi.Pointer<tm> __tp,
  ffi.Pointer<__locale_struct> __loc,
);

typedef _c_gmtime = ffi.Pointer<tm> Function(
  ffi.Pointer<ffi.Int64> __timer,
);

typedef _dart_gmtime = ffi.Pointer<tm> Function(
  ffi.Pointer<ffi.Int64> __timer,
);

typedef _c_localtime = ffi.Pointer<tm> Function(
  ffi.Pointer<ffi.Int64> __timer,
);

typedef _dart_localtime = ffi.Pointer<tm> Function(
  ffi.Pointer<ffi.Int64> __timer,
);

typedef _c_gmtime_r = ffi.Pointer<tm> Function(
  ffi.Pointer<ffi.Int64> __timer,
  ffi.Pointer<tm> __tp,
);

typedef _dart_gmtime_r = ffi.Pointer<tm> Function(
  ffi.Pointer<ffi.Int64> __timer,
  ffi.Pointer<tm> __tp,
);

typedef _c_localtime_r = ffi.Pointer<tm> Function(
  ffi.Pointer<ffi.Int64> __timer,
  ffi.Pointer<tm> __tp,
);

typedef _dart_localtime_r = ffi.Pointer<tm> Function(
  ffi.Pointer<ffi.Int64> __timer,
  ffi.Pointer<tm> __tp,
);

typedef _c_asctime = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<tm> __tp,
);

typedef _dart_asctime = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<tm> __tp,
);

typedef _c_ctime = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int64> __timer,
);

typedef _dart_ctime = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int64> __timer,
);

typedef _c_asctime_r = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<tm> __tp,
  ffi.Pointer<ffi.Int8> __buf,
);

typedef _dart_asctime_r = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<tm> __tp,
  ffi.Pointer<ffi.Int8> __buf,
);

typedef _c_ctime_r = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int64> __timer,
  ffi.Pointer<ffi.Int8> __buf,
);

typedef _dart_ctime_r = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int64> __timer,
  ffi.Pointer<ffi.Int8> __buf,
);

typedef _c_tzset = ffi.Void Function();

typedef _dart_tzset = void Function();

typedef _c_timegm = ffi.Int64 Function(
  ffi.Pointer<tm> __tp,
);

typedef _dart_timegm = int Function(
  ffi.Pointer<tm> __tp,
);

typedef _c_timelocal = ffi.Int64 Function(
  ffi.Pointer<tm> __tp,
);

typedef _dart_timelocal = int Function(
  ffi.Pointer<tm> __tp,
);

typedef _c_dysize = ffi.Int32 Function(
  ffi.Int32 __year,
);

typedef _dart_dysize = int Function(
  int __year,
);

typedef _c_nanosleep = ffi.Int32 Function(
  ffi.Pointer<timespec> __requested_time,
  ffi.Pointer<timespec> __remaining,
);

typedef _dart_nanosleep = int Function(
  ffi.Pointer<timespec> __requested_time,
  ffi.Pointer<timespec> __remaining,
);

typedef _c_clock_getres = ffi.Int32 Function(
  ffi.Int32 __clock_id,
  ffi.Pointer<timespec> __res,
);

typedef _dart_clock_getres = int Function(
  int __clock_id,
  ffi.Pointer<timespec> __res,
);

typedef _c_clock_gettime = ffi.Int32 Function(
  ffi.Int32 __clock_id,
  ffi.Pointer<timespec> __tp,
);

typedef _dart_clock_gettime = int Function(
  int __clock_id,
  ffi.Pointer<timespec> __tp,
);

typedef _c_clock_settime = ffi.Int32 Function(
  ffi.Int32 __clock_id,
  ffi.Pointer<timespec> __tp,
);

typedef _dart_clock_settime = int Function(
  int __clock_id,
  ffi.Pointer<timespec> __tp,
);

typedef _c_clock_nanosleep = ffi.Int32 Function(
  ffi.Int32 __clock_id,
  ffi.Int32 __flags,
  ffi.Pointer<timespec> __req,
  ffi.Pointer<timespec> __rem,
);

typedef _dart_clock_nanosleep = int Function(
  int __clock_id,
  int __flags,
  ffi.Pointer<timespec> __req,
  ffi.Pointer<timespec> __rem,
);

typedef _c_clock_getcpuclockid = ffi.Int32 Function(
  ffi.Int32 __pid,
  ffi.Pointer<ffi.Int32> __clock_id,
);

typedef _dart_clock_getcpuclockid = int Function(
  int __pid,
  ffi.Pointer<ffi.Int32> __clock_id,
);

typedef _c_timer_create = ffi.Int32 Function(
  ffi.Int32 __clock_id,
  ffi.Pointer<sigevent> __evp,
  ffi.Pointer<ffi.Pointer<ffi.Void>> __timerid,
);

typedef _dart_timer_create = int Function(
  int __clock_id,
  ffi.Pointer<sigevent> __evp,
  ffi.Pointer<ffi.Pointer<ffi.Void>> __timerid,
);

typedef _c_timer_delete = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> __timerid,
);

typedef _dart_timer_delete = int Function(
  ffi.Pointer<ffi.Void> __timerid,
);

typedef _c_timer_settime = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> __timerid,
  ffi.Int32 __flags,
  ffi.Pointer<itimerspec> __value,
  ffi.Pointer<itimerspec> __ovalue,
);

typedef _dart_timer_settime = int Function(
  ffi.Pointer<ffi.Void> __timerid,
  int __flags,
  ffi.Pointer<itimerspec> __value,
  ffi.Pointer<itimerspec> __ovalue,
);

typedef _c_timer_gettime = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> __timerid,
  ffi.Pointer<itimerspec> __value,
);

typedef _dart_timer_gettime = int Function(
  ffi.Pointer<ffi.Void> __timerid,
  ffi.Pointer<itimerspec> __value,
);

typedef _c_timer_getoverrun = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> __timerid,
);

typedef _dart_timer_getoverrun = int Function(
  ffi.Pointer<ffi.Void> __timerid,
);

typedef _c_timespec_get = ffi.Int32 Function(
  ffi.Pointer<timespec> __ts,
  ffi.Int32 __base,
);

typedef _dart_timespec_get = int Function(
  ffi.Pointer<timespec> __ts,
  int __base,
);

typedef _c___ctype_get_mb_cur_max = ffi.Int32 Function();

typedef _dart___ctype_get_mb_cur_max = int Function();

typedef _c_atof = ffi.Double Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _dart_atof = double Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _c_atoi = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _dart_atoi = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _c_atol = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _dart_atol = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _c_atoll = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _dart_atoll = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
);

typedef _c_strtod = ffi.Double Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
);

typedef _dart_strtod = double Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
);

typedef _c_strtof = ffi.Float Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
);

typedef _dart_strtof = double Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
);

typedef _c_strtol = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtol = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtoul = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoul = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtoq = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoq = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtouq = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtouq = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtoll = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoll = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtoull = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoull = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_l64a = ffi.Pointer<ffi.Int8> Function(
  ffi.Int64 __n,
);

typedef _dart_l64a = ffi.Pointer<ffi.Int8> Function(
  int __n,
);

typedef _c_a64l = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __s,
);

typedef _dart_a64l = int Function(
  ffi.Pointer<ffi.Int8> __s,
);

typedef _c_select = ffi.Int32 Function(
  ffi.Int32 __nfds,
  ffi.Pointer<fd_set> __readfds,
  ffi.Pointer<fd_set> __writefds,
  ffi.Pointer<fd_set> __exceptfds,
  ffi.Pointer<timeval> __timeout,
);

typedef _dart_select = int Function(
  int __nfds,
  ffi.Pointer<fd_set> __readfds,
  ffi.Pointer<fd_set> __writefds,
  ffi.Pointer<fd_set> __exceptfds,
  ffi.Pointer<timeval> __timeout,
);

typedef _c_pselect = ffi.Int32 Function(
  ffi.Int32 __nfds,
  ffi.Pointer<fd_set> __readfds,
  ffi.Pointer<fd_set> __writefds,
  ffi.Pointer<fd_set> __exceptfds,
  ffi.Pointer<timespec> __timeout,
  ffi.Pointer<__sigset_t> __sigmask,
);

typedef _dart_pselect = int Function(
  int __nfds,
  ffi.Pointer<fd_set> __readfds,
  ffi.Pointer<fd_set> __writefds,
  ffi.Pointer<fd_set> __exceptfds,
  ffi.Pointer<timespec> __timeout,
  ffi.Pointer<__sigset_t> __sigmask,
);

typedef _c_random = ffi.Int64 Function();

typedef _dart_random = int Function();

typedef _c_srandom = ffi.Void Function(
  ffi.Uint32 __seed,
);

typedef _dart_srandom = void Function(
  int __seed,
);

typedef _c_initstate = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint32 __seed,
  ffi.Pointer<ffi.Int8> __statebuf,
  ffi.Int32 __statelen,
);

typedef _dart_initstate = ffi.Pointer<ffi.Int8> Function(
  int __seed,
  ffi.Pointer<ffi.Int8> __statebuf,
  int __statelen,
);

typedef _c_setstate = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __statebuf,
);

typedef _dart_setstate = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __statebuf,
);

typedef _c_random_r = ffi.Int32 Function(
  ffi.Pointer<random_data> __buf,
  ffi.Pointer<ffi.Int32> __result,
);

typedef _dart_random_r = int Function(
  ffi.Pointer<random_data> __buf,
  ffi.Pointer<ffi.Int32> __result,
);

typedef _c_srandom_r = ffi.Int32 Function(
  ffi.Uint32 __seed,
  ffi.Pointer<random_data> __buf,
);

typedef _dart_srandom_r = int Function(
  int __seed,
  ffi.Pointer<random_data> __buf,
);

typedef _c_initstate_r = ffi.Int32 Function(
  ffi.Uint32 __seed,
  ffi.Pointer<ffi.Int8> __statebuf,
  ffi.Int32 __statelen,
  ffi.Pointer<random_data> __buf,
);

typedef _dart_initstate_r = int Function(
  int __seed,
  ffi.Pointer<ffi.Int8> __statebuf,
  int __statelen,
  ffi.Pointer<random_data> __buf,
);

typedef _c_setstate_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __statebuf,
  ffi.Pointer<random_data> __buf,
);

typedef _dart_setstate_r = int Function(
  ffi.Pointer<ffi.Int8> __statebuf,
  ffi.Pointer<random_data> __buf,
);

typedef _c_rand = ffi.Int32 Function();

typedef _dart_rand = int Function();

typedef _c_srand = ffi.Void Function(
  ffi.Uint32 __seed,
);

typedef _dart_srand = void Function(
  int __seed,
);

typedef _c_rand_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint32> __seed,
);

typedef _dart_rand_r = int Function(
  ffi.Pointer<ffi.Uint32> __seed,
);

typedef _c_drand48 = ffi.Double Function();

typedef _dart_drand48 = double Function();

typedef _c_erand48 = ffi.Double Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _dart_erand48 = double Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _c_lrand48 = ffi.Int64 Function();

typedef _dart_lrand48 = int Function();

typedef _c_nrand48 = ffi.Int64 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _dart_nrand48 = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _c_mrand48 = ffi.Int64 Function();

typedef _dart_mrand48 = int Function();

typedef _c_jrand48 = ffi.Int64 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _dart_jrand48 = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
);

typedef _c_srand48 = ffi.Void Function(
  ffi.Int64 __seedval,
);

typedef _dart_srand48 = void Function(
  int __seedval,
);

typedef _c_seed48 = ffi.Pointer<ffi.Uint16> Function(
  ffi.Pointer<ffi.Uint16> __seed16v,
);

typedef _dart_seed48 = ffi.Pointer<ffi.Uint16> Function(
  ffi.Pointer<ffi.Uint16> __seed16v,
);

typedef _c_lcong48 = ffi.Void Function(
  ffi.Pointer<ffi.Uint16> __param,
);

typedef _dart_lcong48 = void Function(
  ffi.Pointer<ffi.Uint16> __param,
);

typedef _c_drand48_r = ffi.Int32 Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Double> __result,
);

typedef _dart_drand48_r = int Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Double> __result,
);

typedef _c_erand48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Double> __result,
);

typedef _dart_erand48_r = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Double> __result,
);

typedef _c_lrand48_r = ffi.Int32 Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _dart_lrand48_r = int Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _c_nrand48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _dart_nrand48_r = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _c_mrand48_r = ffi.Int32 Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _dart_mrand48_r = int Function(
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _c_jrand48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _dart_jrand48_r = int Function(
  ffi.Pointer<ffi.Uint16> __xsubi,
  ffi.Pointer<drand48_data> __buffer,
  ffi.Pointer<ffi.Int64> __result,
);

typedef _c_srand48_r = ffi.Int32 Function(
  ffi.Int64 __seedval,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _dart_srand48_r = int Function(
  int __seedval,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _c_seed48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __seed16v,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _dart_seed48_r = int Function(
  ffi.Pointer<ffi.Uint16> __seed16v,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _c_lcong48_r = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint16> __param,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _dart_lcong48_r = int Function(
  ffi.Pointer<ffi.Uint16> __param,
  ffi.Pointer<drand48_data> __buffer,
);

typedef _c_malloc = ffi.Pointer<ffi.Void> Function(
  ffi.Int32 __size,
);

typedef _dart_malloc = ffi.Pointer<ffi.Void> Function(
  int __size,
);

typedef _c_calloc = ffi.Pointer<ffi.Void> Function(
  ffi.Int32 __nmemb,
  ffi.Int32 __size,
);

typedef _dart_calloc = ffi.Pointer<ffi.Void> Function(
  int __nmemb,
  int __size,
);

typedef _c_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __ptr,
  ffi.Int32 __size,
);

typedef _dart_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __ptr,
  int __size,
);

typedef _c_reallocarray = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __ptr,
  ffi.Int32 __nmemb,
  ffi.Int32 __size,
);

typedef _dart_reallocarray = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __ptr,
  int __nmemb,
  int __size,
);

typedef _c_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> __ptr,
);

typedef _dart_free = void Function(
  ffi.Pointer<ffi.Void> __ptr,
);

typedef _c_alloca = ffi.Pointer<ffi.Void> Function(
  ffi.Int32 __size,
);

typedef _dart_alloca = ffi.Pointer<ffi.Void> Function(
  int __size,
);

typedef _c_valloc = ffi.Pointer<ffi.Void> Function(
  ffi.Int32 __size,
);

typedef _dart_valloc = ffi.Pointer<ffi.Void> Function(
  int __size,
);

typedef _c_posix_memalign = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
  ffi.Int32 __alignment,
  ffi.Int32 __size,
);

typedef _dart_posix_memalign = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
  int __alignment,
  int __size,
);

typedef _c_aligned_alloc = ffi.Pointer<ffi.Void> Function(
  ffi.Int32 __alignment,
  ffi.Int32 __size,
);

typedef _dart_aligned_alloc = ffi.Pointer<ffi.Void> Function(
  int __alignment,
  int __size,
);

typedef _c_abort = ffi.Void Function();

typedef _dart_abort = void Function();

typedef _typedefC_1 = ffi.Void Function();

typedef _c_atexit = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> __func,
);

typedef _dart_atexit = int Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> __func,
);

typedef _typedefC_2 = ffi.Void Function();

typedef _c_at_quick_exit = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_2>> __func,
);

typedef _dart_at_quick_exit = int Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_2>> __func,
);

typedef _typedefC_3 = ffi.Void Function(
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef _c_on_exit = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_3>> __func,
  ffi.Pointer<ffi.Void> __arg,
);

typedef _dart_on_exit = int Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_3>> __func,
  ffi.Pointer<ffi.Void> __arg,
);

typedef _c_exit = ffi.Void Function(
  ffi.Int32 __status,
);

typedef _dart_exit = void Function(
  int __status,
);

typedef _c_quick_exit = ffi.Void Function(
  ffi.Int32 __status,
);

typedef _dart_quick_exit = void Function(
  int __status,
);

typedef _c__Exit = ffi.Void Function(
  ffi.Int32 __status,
);

typedef _dart__Exit = void Function(
  int __status,
);

typedef _c_getenv = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _dart_getenv = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _c_putenv = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __string,
);

typedef _dart_putenv = int Function(
  ffi.Pointer<ffi.Int8> __string,
);

typedef _c_setenv = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Pointer<ffi.Int8> __value,
  ffi.Int32 __replace,
);

typedef _dart_setenv = int Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Pointer<ffi.Int8> __value,
  int __replace,
);

typedef _c_unsetenv = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _dart_unsetenv = int Function(
  ffi.Pointer<ffi.Int8> __name,
);

typedef _c_clearenv = ffi.Int32 Function();

typedef _dart_clearenv = int Function();

typedef _c_mktemp = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _dart_mktemp = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _c_mkstemp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _dart_mkstemp = int Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _c_mkstemps = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __template,
  ffi.Int32 __suffixlen,
);

typedef _dart_mkstemps = int Function(
  ffi.Pointer<ffi.Int8> __template,
  int __suffixlen,
);

typedef _c_mkdtemp = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _dart_mkdtemp = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __template,
);

typedef _c_system = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __command,
);

typedef _dart_system = int Function(
  ffi.Pointer<ffi.Int8> __command,
);

typedef _c_realpath = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Pointer<ffi.Int8> __resolved,
);

typedef _dart_realpath = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> __name,
  ffi.Pointer<ffi.Int8> __resolved,
);

typedef __compar_fn_t = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_bsearch = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __key,
  ffi.Pointer<ffi.Void> __base,
  ffi.Int32 __nmemb,
  ffi.Int32 __size,
  ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
);

typedef _dart_bsearch = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> __key,
  ffi.Pointer<ffi.Void> __base,
  int __nmemb,
  int __size,
  ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
);

typedef _c_qsort = ffi.Void Function(
  ffi.Pointer<ffi.Void> __base,
  ffi.Int32 __nmemb,
  ffi.Int32 __size,
  ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
);

typedef _dart_qsort = void Function(
  ffi.Pointer<ffi.Void> __base,
  int __nmemb,
  int __size,
  ffi.Pointer<ffi.NativeFunction<__compar_fn_t>> __compar,
);

typedef _c_abs = ffi.Int32 Function(
  ffi.Int32 __x,
);

typedef _dart_abs = int Function(
  int __x,
);

typedef _c_labs = ffi.Int64 Function(
  ffi.Int64 __x,
);

typedef _dart_labs = int Function(
  int __x,
);

typedef _c_llabs = ffi.Int64 Function(
  ffi.Int64 __x,
);

typedef _dart_llabs = int Function(
  int __x,
);

typedef _c_div = div_t Function(
  ffi.Int32 __numer,
  ffi.Int32 __denom,
);

typedef _dart_div = div_t Function(
  int __numer,
  int __denom,
);

typedef _c_ldiv = ldiv_t Function(
  ffi.Int64 __numer,
  ffi.Int64 __denom,
);

typedef _dart_ldiv = ldiv_t Function(
  int __numer,
  int __denom,
);

typedef _c_lldiv = lldiv_t Function(
  ffi.Int64 __numer,
  ffi.Int64 __denom,
);

typedef _dart_lldiv = lldiv_t Function(
  int __numer,
  int __denom,
);

typedef _c_ecvt = ffi.Pointer<ffi.Int8> Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
);

typedef _dart_ecvt = ffi.Pointer<ffi.Int8> Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
);

typedef _c_fcvt = ffi.Pointer<ffi.Int8> Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
);

typedef _dart_fcvt = ffi.Pointer<ffi.Int8> Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
);

typedef _c_gcvt = ffi.Pointer<ffi.Int8> Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int8> __buf,
);

typedef _dart_gcvt = ffi.Pointer<ffi.Int8> Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int8> __buf,
);

typedef _c_ecvt_r = ffi.Int32 Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
  ffi.Pointer<ffi.Int8> __buf,
  ffi.Int32 __len,
);

typedef _dart_ecvt_r = int Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
  ffi.Pointer<ffi.Int8> __buf,
  int __len,
);

typedef _c_fcvt_r = ffi.Int32 Function(
  ffi.Double __value,
  ffi.Int32 __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
  ffi.Pointer<ffi.Int8> __buf,
  ffi.Int32 __len,
);

typedef _dart_fcvt_r = int Function(
  double __value,
  int __ndigit,
  ffi.Pointer<ffi.Int32> __decpt,
  ffi.Pointer<ffi.Int32> __sign,
  ffi.Pointer<ffi.Int8> __buf,
  int __len,
);

typedef _c_mblen = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Int32 __n,
);

typedef _dart_mblen = int Function(
  ffi.Pointer<ffi.Int8> __s,
  int __n,
);

typedef _c_mbtowc = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> __pwc,
  ffi.Pointer<ffi.Int8> __s,
  ffi.Int32 __n,
);

typedef _dart_mbtowc = int Function(
  ffi.Pointer<ffi.Int32> __pwc,
  ffi.Pointer<ffi.Int8> __s,
  int __n,
);

typedef _c_wctomb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Int32 __wchar,
);

typedef _dart_wctomb = int Function(
  ffi.Pointer<ffi.Int8> __s,
  int __wchar,
);

typedef _c_mbstowcs = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> __pwcs,
  ffi.Pointer<ffi.Int8> __s,
  ffi.Int32 __n,
);

typedef _dart_mbstowcs = int Function(
  ffi.Pointer<ffi.Int32> __pwcs,
  ffi.Pointer<ffi.Int8> __s,
  int __n,
);

typedef _c_wcstombs = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Pointer<ffi.Int32> __pwcs,
  ffi.Int32 __n,
);

typedef _dart_wcstombs = int Function(
  ffi.Pointer<ffi.Int8> __s,
  ffi.Pointer<ffi.Int32> __pwcs,
  int __n,
);

typedef _c_rpmatch = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> __response,
);

typedef _dart_rpmatch = int Function(
  ffi.Pointer<ffi.Int8> __response,
);

typedef _c_getsubopt = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __optionp,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __tokens,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __valuep,
);

typedef _dart_getsubopt = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __optionp,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __tokens,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __valuep,
);

typedef _c_getloadavg = ffi.Int32 Function(
  ffi.Pointer<ffi.Double> __loadavg,
  ffi.Int32 __nelem,
);

typedef _dart_getloadavg = int Function(
  ffi.Pointer<ffi.Double> __loadavg,
  int __nelem,
);

typedef _c_imaxabs = ffi.Int64 Function(
  ffi.Int64 __n,
);

typedef _dart_imaxabs = int Function(
  int __n,
);

typedef _c_imaxdiv = imaxdiv_t Function(
  ffi.Int64 __numer,
  ffi.Int64 __denom,
);

typedef _dart_imaxdiv = imaxdiv_t Function(
  int __numer,
  int __denom,
);

typedef _c_strtoimax = ffi.Int64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoimax = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_strtoumax = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_strtoumax = int Function(
  ffi.Pointer<ffi.Int8> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> __endptr,
  int __base,
);

typedef _c_wcstoimax = ffi.Int64 Function(
  ffi.Pointer<ffi.Int32> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_wcstoimax = int Function(
  ffi.Pointer<ffi.Int32> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> __endptr,
  int __base,
);

typedef _c_wcstoumax = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int32> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> __endptr,
  ffi.Int32 __base,
);

typedef _dart_wcstoumax = int Function(
  ffi.Pointer<ffi.Int32> __nptr,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> __endptr,
  int __base,
);

typedef _c_git_libgit2_version = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> major,
  ffi.Pointer<ffi.Int32> minor,
  ffi.Pointer<ffi.Int32> rev,
);

typedef _dart_git_libgit2_version = int Function(
  ffi.Pointer<ffi.Int32> major,
  ffi.Pointer<ffi.Int32> minor,
  ffi.Pointer<ffi.Int32> rev,
);

typedef _c_git_libgit2_features = ffi.Int32 Function();

typedef _dart_git_libgit2_features = int Function();

typedef _c_git_libgit2_opts = ffi.Int32 Function(
  ffi.Int32 option,
);

typedef _dart_git_libgit2_opts = int Function(
  int option,
);

typedef _c_git_buf_dispose = ffi.Void Function(
  ffi.Pointer<git_buf> buffer,
);

typedef _dart_git_buf_dispose = void Function(
  ffi.Pointer<git_buf> buffer,
);

typedef _c_git_buf_grow = ffi.Int32 Function(
  ffi.Pointer<git_buf> buffer,
  ffi.Int32 target_size,
);

typedef _dart_git_buf_grow = int Function(
  ffi.Pointer<git_buf> buffer,
  int target_size,
);

typedef _c_git_buf_set = ffi.Int32 Function(
  ffi.Pointer<git_buf> buffer,
  ffi.Pointer<ffi.Void> data,
  ffi.Int32 datalen,
);

typedef _dart_git_buf_set = int Function(
  ffi.Pointer<git_buf> buffer,
  ffi.Pointer<ffi.Void> data,
  int datalen,
);

typedef _c_git_buf_is_binary = ffi.Int32 Function(
  ffi.Pointer<git_buf> buf,
);

typedef _dart_git_buf_is_binary = int Function(
  ffi.Pointer<git_buf> buf,
);

typedef _c_git_buf_contains_nul = ffi.Int32 Function(
  ffi.Pointer<git_buf> buf,
);

typedef _dart_git_buf_contains_nul = int Function(
  ffi.Pointer<git_buf> buf,
);

typedef _c_git_oid_fromstr = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_git_oid_fromstr = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_git_oid_fromstrp = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_git_oid_fromstrp = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_git_oid_fromstrn = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 length,
);

typedef _dart_git_oid_fromstrn = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Int8> str,
  int length,
);

typedef _c_git_oid_fromraw = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Uint8> raw,
);

typedef _dart_git_oid_fromraw = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Uint8> raw,
);

typedef _c_git_oid_fmt = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> out,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_oid_fmt = int Function(
  ffi.Pointer<ffi.Int8> out,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_oid_nfmt = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> out,
  ffi.Int32 n,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_oid_nfmt = int Function(
  ffi.Pointer<ffi.Int8> out,
  int n,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_oid_pathfmt = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> out,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_oid_pathfmt = int Function(
  ffi.Pointer<ffi.Int8> out,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_oid_tostr_s = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_oid> oid,
);

typedef _dart_git_oid_tostr_s = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_oid> oid,
);

typedef _c_git_oid_tostr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> out,
  ffi.Int32 n,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_oid_tostr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> out,
  int n,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_oid_cpy = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_oid> src,
);

typedef _dart_git_oid_cpy = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_oid> src,
);

typedef _c_git_oid_cmp = ffi.Int32 Function(
  ffi.Pointer<git_oid> a,
  ffi.Pointer<git_oid> b,
);

typedef _dart_git_oid_cmp = int Function(
  ffi.Pointer<git_oid> a,
  ffi.Pointer<git_oid> b,
);

typedef _c_git_oid_equal = ffi.Int32 Function(
  ffi.Pointer<git_oid> a,
  ffi.Pointer<git_oid> b,
);

typedef _dart_git_oid_equal = int Function(
  ffi.Pointer<git_oid> a,
  ffi.Pointer<git_oid> b,
);

typedef _c_git_oid_ncmp = ffi.Int32 Function(
  ffi.Pointer<git_oid> a,
  ffi.Pointer<git_oid> b,
  ffi.Int32 len,
);

typedef _dart_git_oid_ncmp = int Function(
  ffi.Pointer<git_oid> a,
  ffi.Pointer<git_oid> b,
  int len,
);

typedef _c_git_oid_streq = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_git_oid_streq = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_git_oid_strcmp = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_git_oid_strcmp = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_git_oid_is_zero = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_oid_is_zero = int Function(
  ffi.Pointer<git_oid> id,
);

typedef _c_git_oid_shorten_new = ffi.Pointer<git_oid_shorten> Function(
  ffi.Int32 min_length,
);

typedef _dart_git_oid_shorten_new = ffi.Pointer<git_oid_shorten> Function(
  int min_length,
);

typedef _c_git_oid_shorten_add = ffi.Int32 Function(
  ffi.Pointer<git_oid_shorten> os,
  ffi.Pointer<ffi.Int8> text_id,
);

typedef _dart_git_oid_shorten_add = int Function(
  ffi.Pointer<git_oid_shorten> os,
  ffi.Pointer<ffi.Int8> text_id,
);

typedef _c_git_oid_shorten_free = ffi.Void Function(
  ffi.Pointer<git_oid_shorten> os,
);

typedef _dart_git_oid_shorten_free = void Function(
  ffi.Pointer<git_oid_shorten> os,
);

typedef _c_git_repository_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_repository_open = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_repository_open_from_worktree = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<git_worktree> wt,
);

typedef _dart_git_repository_open_from_worktree = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<git_worktree> wt,
);

typedef _c_git_repository_wrap_odb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<git_odb> odb,
);

typedef _dart_git_repository_wrap_odb = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<git_odb> odb,
);

typedef _c_git_repository_discover = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<ffi.Int8> start_path,
  ffi.Int32 across_fs,
  ffi.Pointer<ffi.Int8> ceiling_dirs,
);

typedef _dart_git_repository_discover = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<ffi.Int8> start_path,
  int across_fs,
  ffi.Pointer<ffi.Int8> ceiling_dirs,
);

typedef _c_git_repository_open_ext = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 flags,
  ffi.Pointer<ffi.Int8> ceiling_dirs,
);

typedef _dart_git_repository_open_ext = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  int flags,
  ffi.Pointer<ffi.Int8> ceiling_dirs,
);

typedef _c_git_repository_open_bare = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> bare_path,
);

typedef _dart_git_repository_open_bare = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> bare_path,
);

typedef _c_git_repository_free = ffi.Void Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_free = void Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_init = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 is_bare,
);

typedef _dart_git_repository_init = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> path,
  int is_bare,
);

typedef _c_git_repository_init_options_init = ffi.Int32 Function(
  ffi.Pointer<git_repository_init_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_repository_init_options_init = int Function(
  ffi.Pointer<git_repository_init_options> opts,
  int version,
);

typedef _c_git_repository_init_ext = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> repo_path,
  ffi.Pointer<git_repository_init_options> opts,
);

typedef _dart_git_repository_init_ext = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> repo_path,
  ffi.Pointer<git_repository_init_options> opts,
);

typedef _c_git_repository_head = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_head = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_head_for_worktree = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_repository_head_for_worktree = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_repository_head_detached = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_head_detached = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_head_detached_for_worktree = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_repository_head_detached_for_worktree = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_repository_head_unborn = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_head_unborn = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_is_empty = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_is_empty = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_item_path = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Int32 item,
);

typedef _dart_git_repository_item_path = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  int item,
);

typedef _c_git_repository_path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_workdir = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_workdir = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_commondir = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_commondir = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_set_workdir = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> workdir,
  ffi.Int32 update_gitlink,
);

typedef _dart_git_repository_set_workdir = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> workdir,
  int update_gitlink,
);

typedef _c_git_repository_is_bare = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_is_bare = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_is_worktree = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_is_worktree = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_config = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_config = int Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_config_snapshot = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_config_snapshot = int Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_odb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_odb = int Function(
  ffi.Pointer<ffi.Pointer<git_odb>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_refdb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_refdb>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_refdb = int Function(
  ffi.Pointer<ffi.Pointer<git_refdb>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_index = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_index = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_message = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_message = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_message_remove = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_message_remove = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_state_cleanup = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_state_cleanup = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef git_repository_fetchhead_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_oid>,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_repository_fetchhead_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_repository_fetchhead_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_repository_fetchhead_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_repository_fetchhead_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef git_repository_mergehead_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_repository_mergehead_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_repository_mergehead_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_repository_mergehead_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_repository_mergehead_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_repository_hashfile = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 type,
  ffi.Pointer<ffi.Int8> as_path,
);

typedef _dart_git_repository_hashfile = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
  int type,
  ffi.Pointer<ffi.Int8> as_path,
);

typedef _c_git_repository_set_head = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_repository_set_head = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_repository_set_head_detached = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> commitish,
);

typedef _dart_git_repository_set_head_detached = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> commitish,
);

typedef _c_git_repository_set_head_detached_from_annotated = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_annotated_commit> commitish,
);

typedef _dart_git_repository_set_head_detached_from_annotated = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_annotated_commit> commitish,
);

typedef _c_git_repository_detach_head = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_detach_head = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_state = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_state = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_set_namespace = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> nmspace,
);

typedef _dart_git_repository_set_namespace = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> nmspace,
);

typedef _c_git_repository_get_namespace = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_get_namespace = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_is_shallow = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_is_shallow = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_ident = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> name,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> email,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_repository_ident = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> name,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> email,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_repository_set_ident = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
);

typedef _dart_git_repository_set_ident = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
);

typedef _c_git_annotated_commit_from_ref = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_annotated_commit_from_ref = int Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_annotated_commit_from_fetchhead = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> branch_name,
  ffi.Pointer<ffi.Int8> remote_url,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_annotated_commit_from_fetchhead = int Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> branch_name,
  ffi.Pointer<ffi.Int8> remote_url,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_annotated_commit_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_annotated_commit_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_annotated_commit_from_revspec = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> revspec,
);

typedef _dart_git_annotated_commit_from_revspec = int Function(
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> revspec,
);

typedef _c_git_annotated_commit_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _dart_git_annotated_commit_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _c_git_annotated_commit_ref = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _dart_git_annotated_commit_ref = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _c_git_annotated_commit_free = ffi.Void Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _dart_git_annotated_commit_free = void Function(
  ffi.Pointer<git_annotated_commit> commit,
);

typedef _c_git_object_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> object,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  ffi.Int32 type,
);

typedef _dart_git_object_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> object,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  int type,
);

typedef _c_git_object_lookup_prefix = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> object_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  ffi.Int32 len,
  ffi.Int32 type,
);

typedef _dart_git_object_lookup_prefix = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> object_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  int len,
  int type,
);

typedef _c_git_object_lookup_bypath = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> out,
  ffi.Pointer<git_object> treeish,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 type,
);

typedef _dart_git_object_lookup_bypath = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> out,
  ffi.Pointer<git_object> treeish,
  ffi.Pointer<ffi.Int8> path,
  int type,
);

typedef _c_git_object_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_object> obj,
);

typedef _dart_git_object_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_object> obj,
);

typedef _c_git_object_short_id = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_object> obj,
);

typedef _dart_git_object_short_id = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_object> obj,
);

typedef _c_git_object_type = ffi.Int32 Function(
  ffi.Pointer<git_object> obj,
);

typedef _dart_git_object_type = int Function(
  ffi.Pointer<git_object> obj,
);

typedef _c_git_object_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_object> obj,
);

typedef _dart_git_object_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_object> obj,
);

typedef _c_git_object_free = ffi.Void Function(
  ffi.Pointer<git_object> object,
);

typedef _dart_git_object_free = void Function(
  ffi.Pointer<git_object> object,
);

typedef _c_git_object_type2string = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 type,
);

typedef _dart_git_object_type2string = ffi.Pointer<ffi.Int8> Function(
  int type,
);

typedef _c_git_object_string2type = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_git_object_string2type = int Function(
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_git_object_typeisloose = ffi.Int32 Function(
  ffi.Int32 type,
);

typedef _dart_git_object_typeisloose = int Function(
  int type,
);

typedef _c_git_object_peel = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> peeled,
  ffi.Pointer<git_object> object,
  ffi.Int32 target_type,
);

typedef _dart_git_object_peel = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> peeled,
  ffi.Pointer<git_object> object,
  int target_type,
);

typedef _c_git_object_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> dest,
  ffi.Pointer<git_object> source,
);

typedef _dart_git_object_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> dest,
  ffi.Pointer<git_object> source,
);

typedef _c_git_tree_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_tree_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_tree_lookup_prefix = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  ffi.Int32 len,
);

typedef _dart_git_tree_lookup_prefix = int Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  int len,
);

typedef _c_git_tree_free = ffi.Void Function(
  ffi.Pointer<git_tree> tree,
);

typedef _dart_git_tree_free = void Function(
  ffi.Pointer<git_tree> tree,
);

typedef _c_git_tree_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_tree> tree,
);

typedef _dart_git_tree_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_tree> tree,
);

typedef _c_git_tree_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_tree> tree,
);

typedef _dart_git_tree_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_tree> tree,
);

typedef _c_git_tree_entrycount = ffi.Int32 Function(
  ffi.Pointer<git_tree> tree,
);

typedef _dart_git_tree_entrycount = int Function(
  ffi.Pointer<git_tree> tree,
);

typedef _c_git_tree_entry_byname = ffi.Pointer<git_tree_entry> Function(
  ffi.Pointer<git_tree> tree,
  ffi.Pointer<ffi.Int8> filename,
);

typedef _dart_git_tree_entry_byname = ffi.Pointer<git_tree_entry> Function(
  ffi.Pointer<git_tree> tree,
  ffi.Pointer<ffi.Int8> filename,
);

typedef _c_git_tree_entry_byindex = ffi.Pointer<git_tree_entry> Function(
  ffi.Pointer<git_tree> tree,
  ffi.Int32 idx,
);

typedef _dart_git_tree_entry_byindex = ffi.Pointer<git_tree_entry> Function(
  ffi.Pointer<git_tree> tree,
  int idx,
);

typedef _c_git_tree_entry_byid = ffi.Pointer<git_tree_entry> Function(
  ffi.Pointer<git_tree> tree,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_tree_entry_byid = ffi.Pointer<git_tree_entry> Function(
  ffi.Pointer<git_tree> tree,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_tree_entry_bypath = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
  ffi.Pointer<git_tree> root,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_tree_entry_bypath = int Function(
  ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
  ffi.Pointer<git_tree> root,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_tree_entry_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tree_entry>> dest,
  ffi.Pointer<git_tree_entry> source,
);

typedef _dart_git_tree_entry_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_tree_entry>> dest,
  ffi.Pointer<git_tree_entry> source,
);

typedef _c_git_tree_entry_free = ffi.Void Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _dart_git_tree_entry_free = void Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _c_git_tree_entry_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _dart_git_tree_entry_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _c_git_tree_entry_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _dart_git_tree_entry_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _c_git_tree_entry_type = ffi.Int32 Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _dart_git_tree_entry_type = int Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _c_git_tree_entry_filemode = ffi.Int32 Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _dart_git_tree_entry_filemode = int Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _c_git_tree_entry_filemode_raw = ffi.Int32 Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _dart_git_tree_entry_filemode_raw = int Function(
  ffi.Pointer<git_tree_entry> entry,
);

typedef _c_git_tree_entry_cmp = ffi.Int32 Function(
  ffi.Pointer<git_tree_entry> e1,
  ffi.Pointer<git_tree_entry> e2,
);

typedef _dart_git_tree_entry_cmp = int Function(
  ffi.Pointer<git_tree_entry> e1,
  ffi.Pointer<git_tree_entry> e2,
);

typedef _c_git_tree_entry_to_object = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> object_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree_entry> entry,
);

typedef _dart_git_tree_entry_to_object = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> object_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree_entry> entry,
);

typedef _c_git_treebuilder_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_treebuilder>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> source,
);

typedef _dart_git_treebuilder_new = int Function(
  ffi.Pointer<ffi.Pointer<git_treebuilder>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> source,
);

typedef _c_git_treebuilder_clear = ffi.Int32 Function(
  ffi.Pointer<git_treebuilder> bld,
);

typedef _dart_git_treebuilder_clear = int Function(
  ffi.Pointer<git_treebuilder> bld,
);

typedef _c_git_treebuilder_entrycount = ffi.Int32 Function(
  ffi.Pointer<git_treebuilder> bld,
);

typedef _dart_git_treebuilder_entrycount = int Function(
  ffi.Pointer<git_treebuilder> bld,
);

typedef _c_git_treebuilder_free = ffi.Void Function(
  ffi.Pointer<git_treebuilder> bld,
);

typedef _dart_git_treebuilder_free = void Function(
  ffi.Pointer<git_treebuilder> bld,
);

typedef _c_git_treebuilder_get = ffi.Pointer<git_tree_entry> Function(
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<ffi.Int8> filename,
);

typedef _dart_git_treebuilder_get = ffi.Pointer<git_tree_entry> Function(
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<ffi.Int8> filename,
);

typedef _c_git_treebuilder_insert = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<git_oid> id,
  ffi.Int32 filemode,
);

typedef _dart_git_treebuilder_insert = int Function(
  ffi.Pointer<ffi.Pointer<git_tree_entry>> out,
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<git_oid> id,
  int filemode,
);

typedef _c_git_treebuilder_remove = ffi.Int32 Function(
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<ffi.Int8> filename,
);

typedef _dart_git_treebuilder_remove = int Function(
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<ffi.Int8> filename,
);

typedef git_treebuilder_filter_cb = ffi.Int32 Function(
  ffi.Pointer<git_tree_entry>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_treebuilder_filter = ffi.Int32 Function(
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<ffi.NativeFunction<git_treebuilder_filter_cb>> filter,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_treebuilder_filter = int Function(
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<ffi.NativeFunction<git_treebuilder_filter_cb>> filter,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_treebuilder_write = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_treebuilder> bld,
);

typedef _dart_git_treebuilder_write = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_treebuilder> bld,
);

typedef _c_git_treebuilder_write_with_buffer = ffi.Int32 Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<git_buf> tree,
);

typedef _dart_git_treebuilder_write_with_buffer = int Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_treebuilder> bld,
  ffi.Pointer<git_buf> tree,
);

typedef git_treewalk_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_tree_entry>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_tree_walk = ffi.Int32 Function(
  ffi.Pointer<git_tree> tree,
  ffi.Int32 mode,
  ffi.Pointer<ffi.NativeFunction<git_treewalk_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_tree_walk = int Function(
  ffi.Pointer<git_tree> tree,
  int mode,
  ffi.Pointer<ffi.NativeFunction<git_treewalk_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_tree_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_tree> source,
);

typedef _dart_git_tree_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_tree>> out,
  ffi.Pointer<git_tree> source,
);

typedef _c_git_tree_create_updated = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> baseline,
  ffi.Int32 nupdates,
  ffi.Pointer<git_tree_update> updates,
);

typedef _dart_git_tree_create_updated = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> baseline,
  int nupdates,
  ffi.Pointer<git_tree_update> updates,
);

typedef _c_git_strarray_dispose = ffi.Void Function(
  ffi.Pointer<git_strarray> array,
);

typedef _dart_git_strarray_dispose = void Function(
  ffi.Pointer<git_strarray> array,
);

typedef _c_git_strarray_copy = ffi.Int32 Function(
  ffi.Pointer<git_strarray> tgt,
  ffi.Pointer<git_strarray> src,
);

typedef _dart_git_strarray_copy = int Function(
  ffi.Pointer<git_strarray> tgt,
  ffi.Pointer<git_strarray> src,
);

typedef _c_git_reference_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_reference_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_reference_name_to_id = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_reference_name_to_id = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_reference_dwim = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> shorthand,
);

typedef _dart_git_reference_dwim = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> shorthand,
);

typedef _c_git_reference_symbolic_create_matching = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> target,
  ffi.Int32 force,
  ffi.Pointer<ffi.Int8> current_value,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _dart_git_reference_symbolic_create_matching = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> target,
  int force,
  ffi.Pointer<ffi.Int8> current_value,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _c_git_reference_symbolic_create = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> target,
  ffi.Int32 force,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _dart_git_reference_symbolic_create = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> target,
  int force,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _c_git_reference_create = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<git_oid> id,
  ffi.Int32 force,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _dart_git_reference_create = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<git_oid> id,
  int force,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _c_git_reference_create_matching = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<git_oid> id,
  ffi.Int32 force,
  ffi.Pointer<git_oid> current_id,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _dart_git_reference_create_matching = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<git_oid> id,
  int force,
  ffi.Pointer<git_oid> current_id,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _c_git_reference_target = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_target = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_target_peel = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_target_peel = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_symbolic_target = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_symbolic_target = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_type = ffi.Int32 Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_type = int Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_resolve = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_resolve = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_symbolic_set_target = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
  ffi.Pointer<ffi.Int8> target,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _dart_git_reference_symbolic_set_target = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
  ffi.Pointer<ffi.Int8> target,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _c_git_reference_set_target = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _dart_git_reference_set_target = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> ref,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _c_git_reference_rename = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> new_ref,
  ffi.Pointer<git_reference> ref,
  ffi.Pointer<ffi.Int8> new_name,
  ffi.Int32 force,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _dart_git_reference_rename = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> new_ref,
  ffi.Pointer<git_reference> ref,
  ffi.Pointer<ffi.Int8> new_name,
  int force,
  ffi.Pointer<ffi.Int8> log_message,
);

typedef _c_git_reference_delete = ffi.Int32 Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_delete = int Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_remove = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_reference_remove = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_reference_list = ffi.Int32 Function(
  ffi.Pointer<git_strarray> array,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_reference_list = int Function(
  ffi.Pointer<git_strarray> array,
  ffi.Pointer<git_repository> repo,
);

typedef git_reference_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<git_reference>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_reference_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_reference_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_reference_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_reference_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef git_reference_foreach_name_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_reference_foreach_name = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_reference_foreach_name_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_reference_foreach_name = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_reference_foreach_name_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_reference_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> dest,
  ffi.Pointer<git_reference> source,
);

typedef _dart_git_reference_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> dest,
  ffi.Pointer<git_reference> source,
);

typedef _c_git_reference_free = ffi.Void Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_free = void Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_cmp = ffi.Int32 Function(
  ffi.Pointer<git_reference> ref1,
  ffi.Pointer<git_reference> ref2,
);

typedef _dart_git_reference_cmp = int Function(
  ffi.Pointer<git_reference> ref1,
  ffi.Pointer<git_reference> ref2,
);

typedef _c_git_reference_iterator_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_reference_iterator_new = int Function(
  ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_reference_iterator_glob_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> glob,
);

typedef _dart_git_reference_iterator_glob_new = int Function(
  ffi.Pointer<ffi.Pointer<git_reference_iterator>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> glob,
);

typedef _c_git_reference_next = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference_iterator> iter,
);

typedef _dart_git_reference_next = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference_iterator> iter,
);

typedef _c_git_reference_next_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
  ffi.Pointer<git_reference_iterator> iter,
);

typedef _dart_git_reference_next_name = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
  ffi.Pointer<git_reference_iterator> iter,
);

typedef _c_git_reference_iterator_free = ffi.Void Function(
  ffi.Pointer<git_reference_iterator> iter,
);

typedef _dart_git_reference_iterator_free = void Function(
  ffi.Pointer<git_reference_iterator> iter,
);

typedef _c_git_reference_foreach_glob = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> glob,
  ffi.Pointer<ffi.NativeFunction<git_reference_foreach_name_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_reference_foreach_glob = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> glob,
  ffi.Pointer<ffi.NativeFunction<git_reference_foreach_name_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_reference_has_log = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_reference_has_log = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_reference_ensure_log = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_reference_ensure_log = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_reference_is_branch = ffi.Int32 Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_is_branch = int Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_is_remote = ffi.Int32 Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_is_remote = int Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_is_tag = ffi.Int32 Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_is_tag = int Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_is_note = ffi.Int32 Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_is_note = int Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_reference_normalize_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> buffer_out,
  ffi.Int32 buffer_size,
  ffi.Pointer<ffi.Int8> name,
  ffi.Uint32 flags,
);

typedef _dart_git_reference_normalize_name = int Function(
  ffi.Pointer<ffi.Int8> buffer_out,
  int buffer_size,
  ffi.Pointer<ffi.Int8> name,
  int flags,
);

typedef _c_git_reference_peel = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> out,
  ffi.Pointer<git_reference> ref,
  ffi.Int32 type,
);

typedef _dart_git_reference_peel = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> out,
  ffi.Pointer<git_reference> ref,
  int type,
);

typedef _c_git_reference_is_valid_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_reference_is_valid_name = int Function(
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_reference_shorthand = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_reference_shorthand = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_diff_options_init = ffi.Int32 Function(
  ffi.Pointer<git_diff_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_diff_options_init = int Function(
  ffi.Pointer<git_diff_options> opts,
  int version,
);

typedef _c_git_diff_find_options_init = ffi.Int32 Function(
  ffi.Pointer<git_diff_find_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_diff_find_options_init = int Function(
  ffi.Pointer<git_diff_find_options> opts,
  int version,
);

typedef _c_git_diff_free = ffi.Void Function(
  ffi.Pointer<git_diff> diff,
);

typedef _dart_git_diff_free = void Function(
  ffi.Pointer<git_diff> diff,
);

typedef _c_git_diff_tree_to_tree = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> old_tree,
  ffi.Pointer<git_tree> new_tree,
  ffi.Pointer<git_diff_options> opts,
);

typedef _dart_git_diff_tree_to_tree = int Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> old_tree,
  ffi.Pointer<git_tree> new_tree,
  ffi.Pointer<git_diff_options> opts,
);

typedef _c_git_diff_tree_to_index = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> old_tree,
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_diff_options> opts,
);

typedef _dart_git_diff_tree_to_index = int Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> old_tree,
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_diff_options> opts,
);

typedef _c_git_diff_index_to_workdir = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_diff_options> opts,
);

typedef _dart_git_diff_index_to_workdir = int Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_diff_options> opts,
);

typedef _c_git_diff_tree_to_workdir = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> old_tree,
  ffi.Pointer<git_diff_options> opts,
);

typedef _dart_git_diff_tree_to_workdir = int Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> old_tree,
  ffi.Pointer<git_diff_options> opts,
);

typedef _c_git_diff_tree_to_workdir_with_index = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> old_tree,
  ffi.Pointer<git_diff_options> opts,
);

typedef _dart_git_diff_tree_to_workdir_with_index = int Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> old_tree,
  ffi.Pointer<git_diff_options> opts,
);

typedef _c_git_diff_index_to_index = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_index> old_index,
  ffi.Pointer<git_index> new_index,
  ffi.Pointer<git_diff_options> opts,
);

typedef _dart_git_diff_index_to_index = int Function(
  ffi.Pointer<ffi.Pointer<git_diff>> diff,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_index> old_index,
  ffi.Pointer<git_index> new_index,
  ffi.Pointer<git_diff_options> opts,
);

typedef _c_git_diff_merge = ffi.Int32 Function(
  ffi.Pointer<git_diff> onto,
  ffi.Pointer<git_diff> from,
);

typedef _dart_git_diff_merge = int Function(
  ffi.Pointer<git_diff> onto,
  ffi.Pointer<git_diff> from,
);

typedef _c_git_diff_find_similar = ffi.Int32 Function(
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<git_diff_find_options> options,
);

typedef _dart_git_diff_find_similar = int Function(
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<git_diff_find_options> options,
);

typedef _c_git_diff_num_deltas = ffi.Int32 Function(
  ffi.Pointer<git_diff> diff,
);

typedef _dart_git_diff_num_deltas = int Function(
  ffi.Pointer<git_diff> diff,
);

typedef _c_git_diff_num_deltas_of_type = ffi.Int32 Function(
  ffi.Pointer<git_diff> diff,
  ffi.Int32 type,
);

typedef _dart_git_diff_num_deltas_of_type = int Function(
  ffi.Pointer<git_diff> diff,
  int type,
);

typedef _c_git_diff_get_delta = ffi.Pointer<git_diff_delta> Function(
  ffi.Pointer<git_diff> diff,
  ffi.Int32 idx,
);

typedef _dart_git_diff_get_delta = ffi.Pointer<git_diff_delta> Function(
  ffi.Pointer<git_diff> diff,
  int idx,
);

typedef _c_git_diff_is_sorted_icase = ffi.Int32 Function(
  ffi.Pointer<git_diff> diff,
);

typedef _dart_git_diff_is_sorted_icase = int Function(
  ffi.Pointer<git_diff> diff,
);

typedef git_diff_file_cb = ffi.Int32 Function(
  ffi.Pointer<git_diff_delta>,
  ffi.Float,
  ffi.Pointer<ffi.Void>,
);

typedef git_diff_binary_cb = ffi.Int32 Function(
  ffi.Pointer<git_diff_delta>,
  ffi.Pointer<git_diff_binary>,
  ffi.Pointer<ffi.Void>,
);

typedef git_diff_hunk_cb = ffi.Int32 Function(
  ffi.Pointer<git_diff_delta>,
  ffi.Pointer<git_diff_hunk>,
  ffi.Pointer<ffi.Void>,
);

typedef git_diff_line_cb = ffi.Int32 Function(
  ffi.Pointer<git_diff_delta>,
  ffi.Pointer<git_diff_hunk>,
  ffi.Pointer<git_diff_line>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_diff_foreach = ffi.Int32 Function(
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_diff_foreach = int Function(
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_diff_status_char = ffi.Int8 Function(
  ffi.Int32 status,
);

typedef _dart_git_diff_status_char = int Function(
  int status,
);

typedef _c_git_diff_print = ffi.Int32 Function(
  ffi.Pointer<git_diff> diff,
  ffi.Int32 format,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> print_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_diff_print = int Function(
  ffi.Pointer<git_diff> diff,
  int format,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> print_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_diff_to_buf = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_diff> diff,
  ffi.Int32 format,
);

typedef _dart_git_diff_to_buf = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_diff> diff,
  int format,
);

typedef _c_git_diff_blobs = ffi.Int32 Function(
  ffi.Pointer<git_blob> old_blob,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<git_blob> new_blob,
  ffi.Pointer<ffi.Int8> new_as_path,
  ffi.Pointer<git_diff_options> options,
  ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_diff_blobs = int Function(
  ffi.Pointer<git_blob> old_blob,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<git_blob> new_blob,
  ffi.Pointer<ffi.Int8> new_as_path,
  ffi.Pointer<git_diff_options> options,
  ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_diff_blob_to_buffer = ffi.Int32 Function(
  ffi.Pointer<git_blob> old_blob,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Int32 buffer_len,
  ffi.Pointer<ffi.Int8> buffer_as_path,
  ffi.Pointer<git_diff_options> options,
  ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_diff_blob_to_buffer = int Function(
  ffi.Pointer<git_blob> old_blob,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<ffi.Int8> buffer,
  int buffer_len,
  ffi.Pointer<ffi.Int8> buffer_as_path,
  ffi.Pointer<git_diff_options> options,
  ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_diff_buffers = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> old_buffer,
  ffi.Int32 old_len,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<ffi.Void> new_buffer,
  ffi.Int32 new_len,
  ffi.Pointer<ffi.Int8> new_as_path,
  ffi.Pointer<git_diff_options> options,
  ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_diff_buffers = int Function(
  ffi.Pointer<ffi.Void> old_buffer,
  int old_len,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<ffi.Void> new_buffer,
  int new_len,
  ffi.Pointer<ffi.Int8> new_as_path,
  ffi.Pointer<git_diff_options> options,
  ffi.Pointer<ffi.NativeFunction<git_diff_file_cb>> file_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_binary_cb>> binary_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_hunk_cb>> hunk_cb,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> line_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_diff_from_buffer = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff>> out,
  ffi.Pointer<ffi.Int8> content,
  ffi.Int32 content_len,
);

typedef _dart_git_diff_from_buffer = int Function(
  ffi.Pointer<ffi.Pointer<git_diff>> out,
  ffi.Pointer<ffi.Int8> content,
  int content_len,
);

typedef _c_git_diff_get_stats = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff_stats>> out,
  ffi.Pointer<git_diff> diff,
);

typedef _dart_git_diff_get_stats = int Function(
  ffi.Pointer<ffi.Pointer<git_diff_stats>> out,
  ffi.Pointer<git_diff> diff,
);

typedef _c_git_diff_stats_files_changed = ffi.Int32 Function(
  ffi.Pointer<git_diff_stats> stats,
);

typedef _dart_git_diff_stats_files_changed = int Function(
  ffi.Pointer<git_diff_stats> stats,
);

typedef _c_git_diff_stats_insertions = ffi.Int32 Function(
  ffi.Pointer<git_diff_stats> stats,
);

typedef _dart_git_diff_stats_insertions = int Function(
  ffi.Pointer<git_diff_stats> stats,
);

typedef _c_git_diff_stats_deletions = ffi.Int32 Function(
  ffi.Pointer<git_diff_stats> stats,
);

typedef _dart_git_diff_stats_deletions = int Function(
  ffi.Pointer<git_diff_stats> stats,
);

typedef _c_git_diff_stats_to_buf = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_diff_stats> stats,
  ffi.Int32 format,
  ffi.Int32 width,
);

typedef _dart_git_diff_stats_to_buf = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_diff_stats> stats,
  int format,
  int width,
);

typedef _c_git_diff_stats_free = ffi.Void Function(
  ffi.Pointer<git_diff_stats> stats,
);

typedef _dart_git_diff_stats_free = void Function(
  ffi.Pointer<git_diff_stats> stats,
);

typedef _c_git_diff_format_email = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<git_diff_format_email_options> opts,
);

typedef _dart_git_diff_format_email = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<git_diff_format_email_options> opts,
);

typedef _c_git_diff_commit_as_email = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> commit,
  ffi.Int32 patch_no,
  ffi.Int32 total_patches,
  ffi.Uint32 flags,
  ffi.Pointer<git_diff_options> diff_opts,
);

typedef _dart_git_diff_commit_as_email = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> commit,
  int patch_no,
  int total_patches,
  int flags,
  ffi.Pointer<git_diff_options> diff_opts,
);

typedef _c_git_diff_format_email_options_init = ffi.Int32 Function(
  ffi.Pointer<git_diff_format_email_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_diff_format_email_options_init = int Function(
  ffi.Pointer<git_diff_format_email_options> opts,
  int version,
);

typedef _c_git_diff_patchid_options_init = ffi.Int32 Function(
  ffi.Pointer<git_diff_patchid_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_diff_patchid_options_init = int Function(
  ffi.Pointer<git_diff_patchid_options> opts,
  int version,
);

typedef _c_git_diff_patchid = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<git_diff_patchid_options> opts,
);

typedef _dart_git_diff_patchid = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<git_diff_patchid_options> opts,
);

typedef _c_git_apply_options_init = ffi.Int32 Function(
  ffi.Pointer<git_apply_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_apply_options_init = int Function(
  ffi.Pointer<git_apply_options> opts,
  int version,
);

typedef _c_git_apply_to_tree = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> preimage,
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<git_apply_options> options,
);

typedef _dart_git_apply_to_tree = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> preimage,
  ffi.Pointer<git_diff> diff,
  ffi.Pointer<git_apply_options> options,
);

typedef _c_git_apply = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_diff> diff,
  ffi.Int32 location,
  ffi.Pointer<git_apply_options> options,
);

typedef _dart_git_apply = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_diff> diff,
  int location,
  ffi.Pointer<git_apply_options> options,
);

typedef _c_git_attr_value = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> attr,
);

typedef _dart_git_attr_value = int Function(
  ffi.Pointer<ffi.Int8> attr,
);

typedef _c_git_attr_get = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> value_out,
  ffi.Pointer<git_repository> repo,
  ffi.Uint32 flags,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_attr_get = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> value_out,
  ffi.Pointer<git_repository> repo,
  int flags,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_attr_get_many = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> values_out,
  ffi.Pointer<git_repository> repo,
  ffi.Uint32 flags,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 num_attr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> names,
);

typedef _dart_git_attr_get_many = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> values_out,
  ffi.Pointer<git_repository> repo,
  int flags,
  ffi.Pointer<ffi.Int8> path,
  int num_attr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> names,
);

typedef git_attr_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_attr_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Uint32 flags,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.NativeFunction<git_attr_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_attr_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  int flags,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.NativeFunction<git_attr_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_attr_cache_flush = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_attr_cache_flush = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_attr_add_macro = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> values,
);

typedef _dart_git_attr_add_macro = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> values,
);

typedef _c_git_blob_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_blob>> blob,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_blob_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_blob>> blob,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_blob_lookup_prefix = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_blob>> blob,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  ffi.Int32 len,
);

typedef _dart_git_blob_lookup_prefix = int Function(
  ffi.Pointer<ffi.Pointer<git_blob>> blob,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  int len,
);

typedef _c_git_blob_free = ffi.Void Function(
  ffi.Pointer<git_blob> blob,
);

typedef _dart_git_blob_free = void Function(
  ffi.Pointer<git_blob> blob,
);

typedef _c_git_blob_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_blob> blob,
);

typedef _dart_git_blob_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_blob> blob,
);

typedef _c_git_blob_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_blob> blob,
);

typedef _dart_git_blob_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_blob> blob,
);

typedef _c_git_blob_rawcontent = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<git_blob> blob,
);

typedef _dart_git_blob_rawcontent = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<git_blob> blob,
);

typedef _c_git_blob_rawsize = ffi.Uint64 Function(
  ffi.Pointer<git_blob> blob,
);

typedef _dart_git_blob_rawsize = int Function(
  ffi.Pointer<git_blob> blob,
);

typedef _c_git_blob_filter = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_blob> blob,
  ffi.Pointer<ffi.Int8> as_path,
  ffi.Pointer<git_blob_filter_options> opts,
);

typedef _dart_git_blob_filter = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_blob> blob,
  ffi.Pointer<ffi.Int8> as_path,
  ffi.Pointer<git_blob_filter_options> opts,
);

typedef _c_git_blob_create_from_workdir = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> relative_path,
);

typedef _dart_git_blob_create_from_workdir = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> relative_path,
);

typedef _c_git_blob_create_from_disk = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_blob_create_from_disk = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_blob_create_from_stream = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_writestream>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> hintpath,
);

typedef _dart_git_blob_create_from_stream = int Function(
  ffi.Pointer<ffi.Pointer<git_writestream>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> hintpath,
);

typedef _c_git_blob_create_from_stream_commit = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_writestream> stream,
);

typedef _dart_git_blob_create_from_stream_commit = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_writestream> stream,
);

typedef _c_git_blob_create_from_buffer = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Void> buffer,
  ffi.Int32 len,
);

typedef _dart_git_blob_create_from_buffer = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Void> buffer,
  int len,
);

typedef _c_git_blob_is_binary = ffi.Int32 Function(
  ffi.Pointer<git_blob> blob,
);

typedef _dart_git_blob_is_binary = int Function(
  ffi.Pointer<git_blob> blob,
);

typedef _c_git_blob_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_blob>> out,
  ffi.Pointer<git_blob> source,
);

typedef _dart_git_blob_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_blob>> out,
  ffi.Pointer<git_blob> source,
);

typedef _c_git_blame_options_init = ffi.Int32 Function(
  ffi.Pointer<git_blame_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_blame_options_init = int Function(
  ffi.Pointer<git_blame_options> opts,
  int version,
);

typedef _c_git_blame_get_hunk_count = ffi.Uint32 Function(
  ffi.Pointer<git_blame> blame,
);

typedef _dart_git_blame_get_hunk_count = int Function(
  ffi.Pointer<git_blame> blame,
);

typedef _c_git_blame_get_hunk_byindex = ffi.Pointer<git_blame_hunk> Function(
  ffi.Pointer<git_blame> blame,
  ffi.Uint32 index,
);

typedef _dart_git_blame_get_hunk_byindex = ffi.Pointer<git_blame_hunk> Function(
  ffi.Pointer<git_blame> blame,
  int index,
);

typedef _c_git_blame_get_hunk_byline = ffi.Pointer<git_blame_hunk> Function(
  ffi.Pointer<git_blame> blame,
  ffi.Int32 lineno,
);

typedef _dart_git_blame_get_hunk_byline = ffi.Pointer<git_blame_hunk> Function(
  ffi.Pointer<git_blame> blame,
  int lineno,
);

typedef _c_git_blame_file = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_blame>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<git_blame_options> options,
);

typedef _dart_git_blame_file = int Function(
  ffi.Pointer<ffi.Pointer<git_blame>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<git_blame_options> options,
);

typedef _c_git_blame_buffer = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_blame>> out,
  ffi.Pointer<git_blame> reference,
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Int32 buffer_len,
);

typedef _dart_git_blame_buffer = int Function(
  ffi.Pointer<ffi.Pointer<git_blame>> out,
  ffi.Pointer<git_blame> reference,
  ffi.Pointer<ffi.Int8> buffer,
  int buffer_len,
);

typedef _c_git_blame_free = ffi.Void Function(
  ffi.Pointer<git_blame> blame,
);

typedef _dart_git_blame_free = void Function(
  ffi.Pointer<git_blame> blame,
);

typedef _c_git_branch_create = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> branch_name,
  ffi.Pointer<git_commit> target,
  ffi.Int32 force,
);

typedef _dart_git_branch_create = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> branch_name,
  ffi.Pointer<git_commit> target,
  int force,
);

typedef _c_git_branch_create_from_annotated = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> ref_out,
  ffi.Pointer<git_repository> repository,
  ffi.Pointer<ffi.Int8> branch_name,
  ffi.Pointer<git_annotated_commit> commit,
  ffi.Int32 force,
);

typedef _dart_git_branch_create_from_annotated = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> ref_out,
  ffi.Pointer<git_repository> repository,
  ffi.Pointer<ffi.Int8> branch_name,
  ffi.Pointer<git_annotated_commit> commit,
  int force,
);

typedef _c_git_branch_delete = ffi.Int32 Function(
  ffi.Pointer<git_reference> branch,
);

typedef _dart_git_branch_delete = int Function(
  ffi.Pointer<git_reference> branch,
);

typedef _c_git_branch_iterator_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_branch_iterator>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Int32 list_flags,
);

typedef _dart_git_branch_iterator_new = int Function(
  ffi.Pointer<ffi.Pointer<git_branch_iterator>> out,
  ffi.Pointer<git_repository> repo,
  int list_flags,
);

typedef _c_git_branch_next = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<ffi.Int32> out_type,
  ffi.Pointer<git_branch_iterator> iter,
);

typedef _dart_git_branch_next = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<ffi.Int32> out_type,
  ffi.Pointer<git_branch_iterator> iter,
);

typedef _c_git_branch_iterator_free = ffi.Void Function(
  ffi.Pointer<git_branch_iterator> iter,
);

typedef _dart_git_branch_iterator_free = void Function(
  ffi.Pointer<git_branch_iterator> iter,
);

typedef _c_git_branch_move = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> branch,
  ffi.Pointer<ffi.Int8> new_branch_name,
  ffi.Int32 force,
);

typedef _dart_git_branch_move = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> branch,
  ffi.Pointer<ffi.Int8> new_branch_name,
  int force,
);

typedef _c_git_branch_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> branch_name,
  ffi.Int32 branch_type,
);

typedef _dart_git_branch_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> branch_name,
  int branch_type,
);

typedef _c_git_branch_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
  ffi.Pointer<git_reference> ref,
);

typedef _dart_git_branch_name = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
  ffi.Pointer<git_reference> ref,
);

typedef _c_git_branch_upstream = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> branch,
);

typedef _dart_git_branch_upstream = int Function(
  ffi.Pointer<ffi.Pointer<git_reference>> out,
  ffi.Pointer<git_reference> branch,
);

typedef _c_git_branch_set_upstream = ffi.Int32 Function(
  ffi.Pointer<git_reference> branch,
  ffi.Pointer<ffi.Int8> branch_name,
);

typedef _dart_git_branch_set_upstream = int Function(
  ffi.Pointer<git_reference> branch,
  ffi.Pointer<ffi.Int8> branch_name,
);

typedef _c_git_branch_upstream_name = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_branch_upstream_name = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_branch_is_head = ffi.Int32 Function(
  ffi.Pointer<git_reference> branch,
);

typedef _dart_git_branch_is_head = int Function(
  ffi.Pointer<git_reference> branch,
);

typedef _c_git_branch_is_checked_out = ffi.Int32 Function(
  ffi.Pointer<git_reference> branch,
);

typedef _dart_git_branch_is_checked_out = int Function(
  ffi.Pointer<git_reference> branch,
);

typedef _c_git_branch_remote_name = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_branch_remote_name = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_branch_upstream_remote = ffi.Int32 Function(
  ffi.Pointer<git_buf> buf,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_branch_upstream_remote = int Function(
  ffi.Pointer<git_buf> buf,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_checkout_options_init = ffi.Int32 Function(
  ffi.Pointer<git_checkout_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_checkout_options_init = int Function(
  ffi.Pointer<git_checkout_options> opts,
  int version,
);

typedef _c_git_checkout_head = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _dart_git_checkout_head = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _c_git_checkout_index = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _dart_git_checkout_index = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _c_git_checkout_tree = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_object> treeish,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _dart_git_checkout_tree = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_object> treeish,
  ffi.Pointer<git_checkout_options> opts,
);

typedef _c_git_oidarray_free = ffi.Void Function(
  ffi.Pointer<git_oidarray> array,
);

typedef _dart_git_oidarray_free = void Function(
  ffi.Pointer<git_oidarray> array,
);

typedef _c_git_indexer_options_init = ffi.Int32 Function(
  ffi.Pointer<git_indexer_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_indexer_options_init = int Function(
  ffi.Pointer<git_indexer_options> opts,
  int version,
);

typedef _c_git_indexer_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_indexer>> out,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 mode,
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<git_indexer_options> opts,
);

typedef _dart_git_indexer_new = int Function(
  ffi.Pointer<ffi.Pointer<git_indexer>> out,
  ffi.Pointer<ffi.Int8> path,
  int mode,
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<git_indexer_options> opts,
);

typedef _c_git_indexer_append = ffi.Int32 Function(
  ffi.Pointer<git_indexer> idx,
  ffi.Pointer<ffi.Void> data,
  ffi.Int32 size,
  ffi.Pointer<git_indexer_progress> stats,
);

typedef _dart_git_indexer_append = int Function(
  ffi.Pointer<git_indexer> idx,
  ffi.Pointer<ffi.Void> data,
  int size,
  ffi.Pointer<git_indexer_progress> stats,
);

typedef _c_git_indexer_commit = ffi.Int32 Function(
  ffi.Pointer<git_indexer> idx,
  ffi.Pointer<git_indexer_progress> stats,
);

typedef _dart_git_indexer_commit = int Function(
  ffi.Pointer<git_indexer> idx,
  ffi.Pointer<git_indexer_progress> stats,
);

typedef _c_git_indexer_hash = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_indexer> idx,
);

typedef _dart_git_indexer_hash = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_indexer> idx,
);

typedef _c_git_indexer_free = ffi.Void Function(
  ffi.Pointer<git_indexer> idx,
);

typedef _dart_git_indexer_free = void Function(
  ffi.Pointer<git_indexer> idx,
);

typedef _c_git_index_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<ffi.Int8> index_path,
);

typedef _dart_git_index_open = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<ffi.Int8> index_path,
);

typedef _c_git_index_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
);

typedef _dart_git_index_new = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
);

typedef _c_git_index_free = ffi.Void Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_free = void Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_caps = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_caps = int Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_set_caps = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Int32 caps,
);

typedef _dart_git_index_set_caps = int Function(
  ffi.Pointer<git_index> index,
  int caps,
);

typedef _c_git_index_version = ffi.Uint32 Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_version = int Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_set_version = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Uint32 version,
);

typedef _dart_git_index_set_version = int Function(
  ffi.Pointer<git_index> index,
  int version,
);

typedef _c_git_index_read = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Int32 force,
);

typedef _dart_git_index_read = int Function(
  ffi.Pointer<git_index> index,
  int force,
);

typedef _c_git_index_write = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_write = int Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_checksum = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_checksum = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_read_tree = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_tree> tree,
);

typedef _dart_git_index_read_tree = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_tree> tree,
);

typedef _c_git_index_write_tree = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_write_tree = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_write_tree_to = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_index_write_tree_to = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_index_entrycount = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_entrycount = int Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_clear = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_clear = int Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_get_byindex = ffi.Pointer<git_index_entry> Function(
  ffi.Pointer<git_index> index,
  ffi.Int32 n,
);

typedef _dart_git_index_get_byindex = ffi.Pointer<git_index_entry> Function(
  ffi.Pointer<git_index> index,
  int n,
);

typedef _c_git_index_get_bypath = ffi.Pointer<git_index_entry> Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 stage,
);

typedef _dart_git_index_get_bypath = ffi.Pointer<git_index_entry> Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
  int stage,
);

typedef _c_git_index_remove = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 stage,
);

typedef _dart_git_index_remove = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
  int stage,
);

typedef _c_git_index_remove_directory = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> dir,
  ffi.Int32 stage,
);

typedef _dart_git_index_remove_directory = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> dir,
  int stage,
);

typedef _c_git_index_add = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_index_entry> source_entry,
);

typedef _dart_git_index_add = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_index_entry> source_entry,
);

typedef _c_git_index_entry_stage = ffi.Int32 Function(
  ffi.Pointer<git_index_entry> entry,
);

typedef _dart_git_index_entry_stage = int Function(
  ffi.Pointer<git_index_entry> entry,
);

typedef _c_git_index_entry_is_conflict = ffi.Int32 Function(
  ffi.Pointer<git_index_entry> entry,
);

typedef _dart_git_index_entry_is_conflict = int Function(
  ffi.Pointer<git_index_entry> entry,
);

typedef _c_git_index_iterator_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index_iterator>> iterator_out,
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_iterator_new = int Function(
  ffi.Pointer<ffi.Pointer<git_index_iterator>> iterator_out,
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_iterator_next = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index_entry>> out,
  ffi.Pointer<git_index_iterator> iterator,
);

typedef _dart_git_index_iterator_next = int Function(
  ffi.Pointer<ffi.Pointer<git_index_entry>> out,
  ffi.Pointer<git_index_iterator> iterator,
);

typedef _c_git_index_iterator_free = ffi.Void Function(
  ffi.Pointer<git_index_iterator> iterator,
);

typedef _dart_git_index_iterator_free = void Function(
  ffi.Pointer<git_index_iterator> iterator,
);

typedef _c_git_index_add_bypath = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_index_add_bypath = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_index_add_from_buffer = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_index_entry> entry,
  ffi.Pointer<ffi.Void> buffer,
  ffi.Int32 len,
);

typedef _dart_git_index_add_from_buffer = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_index_entry> entry,
  ffi.Pointer<ffi.Void> buffer,
  int len,
);

typedef _c_git_index_remove_bypath = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_index_remove_bypath = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef git_index_matched_path_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_index_add_all = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_strarray> pathspec,
  ffi.Uint32 flags,
  ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_index_add_all = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_strarray> pathspec,
  int flags,
  ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_index_remove_all = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_strarray> pathspec,
  ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_index_remove_all = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_strarray> pathspec,
  ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_index_update_all = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_strarray> pathspec,
  ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_index_update_all = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_strarray> pathspec,
  ffi.Pointer<ffi.NativeFunction<git_index_matched_path_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_index_find = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> at_pos,
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_index_find = int Function(
  ffi.Pointer<ffi.Int32> at_pos,
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_index_find_prefix = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> at_pos,
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> prefix,
);

typedef _dart_git_index_find_prefix = int Function(
  ffi.Pointer<ffi.Int32> at_pos,
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> prefix,
);

typedef _c_git_index_conflict_add = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_index_entry> ancestor_entry,
  ffi.Pointer<git_index_entry> our_entry,
  ffi.Pointer<git_index_entry> their_entry,
);

typedef _dart_git_index_conflict_add = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_index_entry> ancestor_entry,
  ffi.Pointer<git_index_entry> our_entry,
  ffi.Pointer<git_index_entry> their_entry,
);

typedef _c_git_index_conflict_get = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
  ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
  ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_index_conflict_get = int Function(
  ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
  ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
  ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_index_conflict_remove = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_index_conflict_remove = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_index_conflict_cleanup = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_conflict_cleanup = int Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_has_conflicts = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_has_conflicts = int Function(
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_conflict_iterator_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>> iterator_out,
  ffi.Pointer<git_index> index,
);

typedef _dart_git_index_conflict_iterator_new = int Function(
  ffi.Pointer<ffi.Pointer<git_index_conflict_iterator>> iterator_out,
  ffi.Pointer<git_index> index,
);

typedef _c_git_index_conflict_next = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
  ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
  ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
  ffi.Pointer<git_index_conflict_iterator> iterator,
);

typedef _dart_git_index_conflict_next = int Function(
  ffi.Pointer<ffi.Pointer<git_index_entry>> ancestor_out,
  ffi.Pointer<ffi.Pointer<git_index_entry>> our_out,
  ffi.Pointer<ffi.Pointer<git_index_entry>> their_out,
  ffi.Pointer<git_index_conflict_iterator> iterator,
);

typedef _c_git_index_conflict_iterator_free = ffi.Void Function(
  ffi.Pointer<git_index_conflict_iterator> iterator,
);

typedef _dart_git_index_conflict_iterator_free = void Function(
  ffi.Pointer<git_index_conflict_iterator> iterator,
);

typedef _c_git_merge_file_input_init = ffi.Int32 Function(
  ffi.Pointer<git_merge_file_input> opts,
  ffi.Uint32 version,
);

typedef _dart_git_merge_file_input_init = int Function(
  ffi.Pointer<git_merge_file_input> opts,
  int version,
);

typedef _c_git_merge_file_options_init = ffi.Int32 Function(
  ffi.Pointer<git_merge_file_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_merge_file_options_init = int Function(
  ffi.Pointer<git_merge_file_options> opts,
  int version,
);

typedef _c_git_merge_options_init = ffi.Int32 Function(
  ffi.Pointer<git_merge_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_merge_options_init = int Function(
  ffi.Pointer<git_merge_options> opts,
  int version,
);

typedef _c_git_merge_analysis = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> analysis_out,
  ffi.Pointer<ffi.Int32> preference_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  ffi.Int32 their_heads_len,
);

typedef _dart_git_merge_analysis = int Function(
  ffi.Pointer<ffi.Int32> analysis_out,
  ffi.Pointer<ffi.Int32> preference_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  int their_heads_len,
);

typedef _c_git_merge_analysis_for_ref = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> analysis_out,
  ffi.Pointer<ffi.Int32> preference_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_reference> our_ref,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  ffi.Int32 their_heads_len,
);

typedef _dart_git_merge_analysis_for_ref = int Function(
  ffi.Pointer<ffi.Int32> analysis_out,
  ffi.Pointer<ffi.Int32> preference_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_reference> our_ref,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  int their_heads_len,
);

typedef _c_git_merge_base = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> one,
  ffi.Pointer<git_oid> two,
);

typedef _dart_git_merge_base = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> one,
  ffi.Pointer<git_oid> two,
);

typedef _c_git_merge_bases = ffi.Int32 Function(
  ffi.Pointer<git_oidarray> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> one,
  ffi.Pointer<git_oid> two,
);

typedef _dart_git_merge_bases = int Function(
  ffi.Pointer<git_oidarray> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> one,
  ffi.Pointer<git_oid> two,
);

typedef _c_git_merge_base_many = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Int32 length,
  ffi.Pointer<git_oid> input_array,
);

typedef _dart_git_merge_base_many = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  int length,
  ffi.Pointer<git_oid> input_array,
);

typedef _c_git_merge_bases_many = ffi.Int32 Function(
  ffi.Pointer<git_oidarray> out,
  ffi.Pointer<git_repository> repo,
  ffi.Int32 length,
  ffi.Pointer<git_oid> input_array,
);

typedef _dart_git_merge_bases_many = int Function(
  ffi.Pointer<git_oidarray> out,
  ffi.Pointer<git_repository> repo,
  int length,
  ffi.Pointer<git_oid> input_array,
);

typedef _c_git_merge_base_octopus = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Int32 length,
  ffi.Pointer<git_oid> input_array,
);

typedef _dart_git_merge_base_octopus = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  int length,
  ffi.Pointer<git_oid> input_array,
);

typedef _c_git_merge_file = ffi.Int32 Function(
  ffi.Pointer<git_merge_file_result> out,
  ffi.Pointer<git_merge_file_input> ancestor,
  ffi.Pointer<git_merge_file_input> ours,
  ffi.Pointer<git_merge_file_input> theirs,
  ffi.Pointer<git_merge_file_options> opts,
);

typedef _dart_git_merge_file = int Function(
  ffi.Pointer<git_merge_file_result> out,
  ffi.Pointer<git_merge_file_input> ancestor,
  ffi.Pointer<git_merge_file_input> ours,
  ffi.Pointer<git_merge_file_input> theirs,
  ffi.Pointer<git_merge_file_options> opts,
);

typedef _c_git_merge_file_from_index = ffi.Int32 Function(
  ffi.Pointer<git_merge_file_result> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_index_entry> ancestor,
  ffi.Pointer<git_index_entry> ours,
  ffi.Pointer<git_index_entry> theirs,
  ffi.Pointer<git_merge_file_options> opts,
);

typedef _dart_git_merge_file_from_index = int Function(
  ffi.Pointer<git_merge_file_result> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_index_entry> ancestor,
  ffi.Pointer<git_index_entry> ours,
  ffi.Pointer<git_index_entry> theirs,
  ffi.Pointer<git_merge_file_options> opts,
);

typedef _c_git_merge_file_result_free = ffi.Void Function(
  ffi.Pointer<git_merge_file_result> result,
);

typedef _dart_git_merge_file_result_free = void Function(
  ffi.Pointer<git_merge_file_result> result,
);

typedef _c_git_merge_trees = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> ancestor_tree,
  ffi.Pointer<git_tree> our_tree,
  ffi.Pointer<git_tree> their_tree,
  ffi.Pointer<git_merge_options> opts,
);

typedef _dart_git_merge_trees = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_tree> ancestor_tree,
  ffi.Pointer<git_tree> our_tree,
  ffi.Pointer<git_tree> their_tree,
  ffi.Pointer<git_merge_options> opts,
);

typedef _c_git_merge_commits = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> our_commit,
  ffi.Pointer<git_commit> their_commit,
  ffi.Pointer<git_merge_options> opts,
);

typedef _dart_git_merge_commits = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> our_commit,
  ffi.Pointer<git_commit> their_commit,
  ffi.Pointer<git_merge_options> opts,
);

typedef _c_git_merge = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  ffi.Int32 their_heads_len,
  ffi.Pointer<git_merge_options> merge_opts,
  ffi.Pointer<git_checkout_options> checkout_opts,
);

typedef _dart_git_merge = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Pointer<git_annotated_commit>> their_heads,
  int their_heads_len,
  ffi.Pointer<git_merge_options> merge_opts,
  ffi.Pointer<git_checkout_options> checkout_opts,
);

typedef _c_git_cherrypick_options_init = ffi.Int32 Function(
  ffi.Pointer<git_cherrypick_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_cherrypick_options_init = int Function(
  ffi.Pointer<git_cherrypick_options> opts,
  int version,
);

typedef _c_git_cherrypick_commit = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> cherrypick_commit,
  ffi.Pointer<git_commit> our_commit,
  ffi.Uint32 mainline,
  ffi.Pointer<git_merge_options> merge_options,
);

typedef _dart_git_cherrypick_commit = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> cherrypick_commit,
  ffi.Pointer<git_commit> our_commit,
  int mainline,
  ffi.Pointer<git_merge_options> merge_options,
);

typedef _c_git_cherrypick = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<git_cherrypick_options> cherrypick_options,
);

typedef _dart_git_cherrypick = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<git_cherrypick_options> cherrypick_options,
);

typedef _c_git_refspec_parse = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_refspec>> refspec,
  ffi.Pointer<ffi.Int8> input,
  ffi.Int32 is_fetch,
);

typedef _dart_git_refspec_parse = int Function(
  ffi.Pointer<ffi.Pointer<git_refspec>> refspec,
  ffi.Pointer<ffi.Int8> input,
  int is_fetch,
);

typedef _c_git_refspec_free = ffi.Void Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _dart_git_refspec_free = void Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _c_git_refspec_src = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _dart_git_refspec_src = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _c_git_refspec_dst = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _dart_git_refspec_dst = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _c_git_refspec_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _dart_git_refspec_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _c_git_refspec_force = ffi.Int32 Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _dart_git_refspec_force = int Function(
  ffi.Pointer<git_refspec> refspec,
);

typedef _c_git_refspec_direction = ffi.Int32 Function(
  ffi.Pointer<git_refspec> spec,
);

typedef _dart_git_refspec_direction = int Function(
  ffi.Pointer<git_refspec> spec,
);

typedef _c_git_refspec_src_matches = ffi.Int32 Function(
  ffi.Pointer<git_refspec> refspec,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_refspec_src_matches = int Function(
  ffi.Pointer<git_refspec> refspec,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_refspec_dst_matches = ffi.Int32 Function(
  ffi.Pointer<git_refspec> refspec,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_refspec_dst_matches = int Function(
  ffi.Pointer<git_refspec> refspec,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_refspec_transform = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_refspec> spec,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_refspec_transform = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_refspec> spec,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_refspec_rtransform = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_refspec> spec,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_refspec_rtransform = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_refspec> spec,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_credential_free = ffi.Void Function(
  ffi.Pointer<git_credential> cred,
);

typedef _dart_git_credential_free = void Function(
  ffi.Pointer<git_credential> cred,
);

typedef _c_git_credential_has_username = ffi.Int32 Function(
  ffi.Pointer<git_credential> cred,
);

typedef _dart_git_credential_has_username = int Function(
  ffi.Pointer<git_credential> cred,
);

typedef _c_git_credential_get_username = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_credential> cred,
);

typedef _dart_git_credential_get_username = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_credential> cred,
);

typedef _c_git_credential_userpass_plaintext_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_git_credential_userpass_plaintext_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_git_credential_default_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
);

typedef _dart_git_credential_default_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
);

typedef _c_git_credential_username_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
);

typedef _dart_git_credential_username_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
);

typedef _c_git_credential_ssh_key_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Pointer<ffi.Int8> privatekey,
  ffi.Pointer<ffi.Int8> passphrase,
);

typedef _dart_git_credential_ssh_key_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Pointer<ffi.Int8> privatekey,
  ffi.Pointer<ffi.Int8> passphrase,
);

typedef _c_git_credential_ssh_key_memory_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Pointer<ffi.Int8> privatekey,
  ffi.Pointer<ffi.Int8> passphrase,
);

typedef _dart_git_credential_ssh_key_memory_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Pointer<ffi.Int8> privatekey,
  ffi.Pointer<ffi.Int8> passphrase,
);

typedef git_credential_ssh_interactive_cb = ffi.Void Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Int32,
  ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_PROMPT>,
  ffi.Pointer<_LIBSSH2_USERAUTH_KBDINT_RESPONSE>,
  ffi.Pointer<ffi.Pointer<ffi.Void>>,
);

typedef _c_git_credential_ssh_interactive_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.NativeFunction<git_credential_ssh_interactive_cb>>
      prompt_callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_credential_ssh_interactive_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.NativeFunction<git_credential_ssh_interactive_cb>>
      prompt_callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_credential_ssh_key_from_agent = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
);

typedef _dart_git_credential_ssh_key_from_agent = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
);

typedef git_credential_sign_cb = ffi.Int32 Function(
  ffi.Pointer<_LIBSSH2_SESSION>,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
  ffi.Pointer<ffi.Int32>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
  ffi.Pointer<ffi.Pointer<ffi.Void>>,
);

typedef _c_git_credential_ssh_custom_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Int32 publickey_len,
  ffi.Pointer<ffi.NativeFunction<git_credential_sign_cb>> sign_callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_credential_ssh_custom_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  int publickey_len,
  ffi.Pointer<ffi.NativeFunction<git_credential_sign_cb>> sign_callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_packbuilder_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_packbuilder>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_packbuilder_new = int Function(
  ffi.Pointer<ffi.Pointer<git_packbuilder>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_packbuilder_set_threads = ffi.Uint32 Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Uint32 n,
);

typedef _dart_git_packbuilder_set_threads = int Function(
  ffi.Pointer<git_packbuilder> pb,
  int n,
);

typedef _c_git_packbuilder_insert = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_packbuilder_insert = int Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_packbuilder_insert_tree = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_packbuilder_insert_tree = int Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_packbuilder_insert_commit = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_packbuilder_insert_commit = int Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_packbuilder_insert_walk = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_revwalk> walk,
);

typedef _dart_git_packbuilder_insert_walk = int Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_revwalk> walk,
);

typedef _c_git_packbuilder_insert_recur = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_packbuilder_insert_recur = int Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_packbuilder_write_buf = ffi.Int32 Function(
  ffi.Pointer<git_buf> buf,
  ffi.Pointer<git_packbuilder> pb,
);

typedef _dart_git_packbuilder_write_buf = int Function(
  ffi.Pointer<git_buf> buf,
  ffi.Pointer<git_packbuilder> pb,
);

typedef git_indexer_progress_cb = ffi.Int32 Function(
  ffi.Pointer<git_indexer_progress>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_packbuilder_write = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<ffi.Int8> path,
  ffi.Uint32 mode,
  ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>> progress_cb,
  ffi.Pointer<ffi.Void> progress_cb_payload,
);

typedef _dart_git_packbuilder_write = int Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<ffi.Int8> path,
  int mode,
  ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>> progress_cb,
  ffi.Pointer<ffi.Void> progress_cb_payload,
);

typedef _c_git_packbuilder_hash = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_packbuilder> pb,
);

typedef _dart_git_packbuilder_hash = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_packbuilder> pb,
);

typedef git_packbuilder_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_packbuilder_foreach = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<ffi.NativeFunction<git_packbuilder_foreach_cb>> cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_packbuilder_foreach = int Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<ffi.NativeFunction<git_packbuilder_foreach_cb>> cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_packbuilder_object_count = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
);

typedef _dart_git_packbuilder_object_count = int Function(
  ffi.Pointer<git_packbuilder> pb,
);

typedef _c_git_packbuilder_written = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
);

typedef _dart_git_packbuilder_written = int Function(
  ffi.Pointer<git_packbuilder> pb,
);

typedef git_packbuilder_progress = ffi.Int32 Function(
  ffi.Int32,
  ffi.Uint32,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_packbuilder_set_callbacks = ffi.Int32 Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<ffi.NativeFunction<git_packbuilder_progress>> progress_cb,
  ffi.Pointer<ffi.Void> progress_cb_payload,
);

typedef _dart_git_packbuilder_set_callbacks = int Function(
  ffi.Pointer<git_packbuilder> pb,
  ffi.Pointer<ffi.NativeFunction<git_packbuilder_progress>> progress_cb,
  ffi.Pointer<ffi.Void> progress_cb_payload,
);

typedef _c_git_packbuilder_free = ffi.Void Function(
  ffi.Pointer<git_packbuilder> pb,
);

typedef _dart_git_packbuilder_free = void Function(
  ffi.Pointer<git_packbuilder> pb,
);

typedef _c_git_proxy_options_init = ffi.Int32 Function(
  ffi.Pointer<git_proxy_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_proxy_options_init = int Function(
  ffi.Pointer<git_proxy_options> opts,
  int version,
);

typedef _c_git_remote_create = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_git_remote_create = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_git_remote_create_options_init = ffi.Int32 Function(
  ffi.Pointer<git_remote_create_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_remote_create_options_init = int Function(
  ffi.Pointer<git_remote_create_options> opts,
  int version,
);

typedef _c_git_remote_create_with_opts = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<git_remote_create_options> opts,
);

typedef _dart_git_remote_create_with_opts = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<git_remote_create_options> opts,
);

typedef _c_git_remote_create_with_fetchspec = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> fetch,
);

typedef _dart_git_remote_create_with_fetchspec = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> fetch,
);

typedef _c_git_remote_create_anonymous = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_git_remote_create_anonymous = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_git_remote_create_detached = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_git_remote_create_detached = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_git_remote_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_remote_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_remote_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>> dest,
  ffi.Pointer<git_remote> source,
);

typedef _dart_git_remote_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_remote>> dest,
  ffi.Pointer<git_remote> source,
);

typedef _c_git_remote_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_url = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_url = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_pushurl = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_pushurl = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_set_url = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_git_remote_set_url = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_git_remote_set_pushurl = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_git_remote_set_pushurl = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_git_remote_add_fetch = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  ffi.Pointer<ffi.Int8> refspec,
);

typedef _dart_git_remote_add_fetch = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  ffi.Pointer<ffi.Int8> refspec,
);

typedef _c_git_remote_get_fetch_refspecs = ffi.Int32 Function(
  ffi.Pointer<git_strarray> array,
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_get_fetch_refspecs = int Function(
  ffi.Pointer<git_strarray> array,
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_add_push = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  ffi.Pointer<ffi.Int8> refspec,
);

typedef _dart_git_remote_add_push = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  ffi.Pointer<ffi.Int8> refspec,
);

typedef _c_git_remote_get_push_refspecs = ffi.Int32 Function(
  ffi.Pointer<git_strarray> array,
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_get_push_refspecs = int Function(
  ffi.Pointer<git_strarray> array,
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_refspec_count = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_refspec_count = int Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_get_refspec = ffi.Pointer<git_refspec> Function(
  ffi.Pointer<git_remote> remote,
  ffi.Int32 n,
);

typedef _dart_git_remote_get_refspec = ffi.Pointer<git_refspec> Function(
  ffi.Pointer<git_remote> remote,
  int n,
);

typedef _c_git_remote_connect = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Int32 direction,
  ffi.Pointer<git_remote_callbacks> callbacks,
  ffi.Pointer<git_proxy_options> proxy_opts,
  ffi.Pointer<git_strarray> custom_headers,
);

typedef _dart_git_remote_connect = int Function(
  ffi.Pointer<git_remote> remote,
  int direction,
  ffi.Pointer<git_remote_callbacks> callbacks,
  ffi.Pointer<git_proxy_options> proxy_opts,
  ffi.Pointer<git_strarray> custom_headers,
);

typedef _c_git_remote_ls = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>> out,
  ffi.Pointer<ffi.Int32> size,
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_ls = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Pointer<git_remote_head>>> out,
  ffi.Pointer<ffi.Int32> size,
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_connected = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_connected = int Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_stop = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_stop = int Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_disconnect = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_disconnect = int Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_free = ffi.Void Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_free = void Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_list = ffi.Int32 Function(
  ffi.Pointer<git_strarray> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_remote_list = int Function(
  ffi.Pointer<git_strarray> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_remote_init_callbacks = ffi.Int32 Function(
  ffi.Pointer<git_remote_callbacks> opts,
  ffi.Uint32 version,
);

typedef _dart_git_remote_init_callbacks = int Function(
  ffi.Pointer<git_remote_callbacks> opts,
  int version,
);

typedef _c_git_fetch_options_init = ffi.Int32 Function(
  ffi.Pointer<git_fetch_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_fetch_options_init = int Function(
  ffi.Pointer<git_fetch_options> opts,
  int version,
);

typedef _c_git_push_options_init = ffi.Int32 Function(
  ffi.Pointer<git_push_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_push_options_init = int Function(
  ffi.Pointer<git_push_options> opts,
  int version,
);

typedef _c_git_remote_download = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_fetch_options> opts,
);

typedef _dart_git_remote_download = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_fetch_options> opts,
);

typedef _c_git_remote_upload = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_push_options> opts,
);

typedef _dart_git_remote_upload = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_push_options> opts,
);

typedef _c_git_remote_update_tips = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_remote_callbacks> callbacks,
  ffi.Int32 update_fetchhead,
  ffi.Int32 download_tags,
  ffi.Pointer<ffi.Int8> reflog_message,
);

typedef _dart_git_remote_update_tips = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_remote_callbacks> callbacks,
  int update_fetchhead,
  int download_tags,
  ffi.Pointer<ffi.Int8> reflog_message,
);

typedef _c_git_remote_fetch = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_fetch_options> opts,
  ffi.Pointer<ffi.Int8> reflog_message,
);

typedef _dart_git_remote_fetch = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_fetch_options> opts,
  ffi.Pointer<ffi.Int8> reflog_message,
);

typedef _c_git_remote_prune = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_remote_callbacks> callbacks,
);

typedef _dart_git_remote_prune = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_remote_callbacks> callbacks,
);

typedef _c_git_remote_push = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_push_options> opts,
);

typedef _dart_git_remote_push = int Function(
  ffi.Pointer<git_remote> remote,
  ffi.Pointer<git_strarray> refspecs,
  ffi.Pointer<git_push_options> opts,
);

typedef _c_git_remote_stats = ffi.Pointer<git_indexer_progress> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_stats = ffi.Pointer<git_indexer_progress> Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_autotag = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_autotag = int Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_set_autotag = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  ffi.Int32 value,
);

typedef _dart_git_remote_set_autotag = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> remote,
  int value,
);

typedef _c_git_remote_prune_refs = ffi.Int32 Function(
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_prune_refs = int Function(
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_remote_rename = ffi.Int32 Function(
  ffi.Pointer<git_strarray> problems,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> new_name,
);

typedef _dart_git_remote_rename = int Function(
  ffi.Pointer<git_strarray> problems,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> new_name,
);

typedef _c_git_remote_is_valid_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> remote_name,
);

typedef _dart_git_remote_is_valid_name = int Function(
  ffi.Pointer<ffi.Int8> remote_name,
);

typedef _c_git_remote_delete = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_remote_delete = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_remote_default_branch = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_remote> remote,
);

typedef _dart_git_remote_default_branch = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_remote> remote,
);

typedef _c_git_clone_options_init = ffi.Int32 Function(
  ffi.Pointer<git_clone_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_clone_options_init = int Function(
  ffi.Pointer<git_clone_options> opts,
  int version,
);

typedef _c_git_clone = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> local_path,
  ffi.Pointer<git_clone_options> options,
);

typedef _dart_git_clone = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> local_path,
  ffi.Pointer<git_clone_options> options,
);

typedef _c_git_commit_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_commit>> commit,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_commit_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_commit>> commit,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_commit_lookup_prefix = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_commit>> commit,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  ffi.Int32 len,
);

typedef _dart_git_commit_lookup_prefix = int Function(
  ffi.Pointer<ffi.Pointer<git_commit>> commit,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  int len,
);

typedef _c_git_commit_free = ffi.Void Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_free = void Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_message_encoding = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_message_encoding = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_message_raw = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_message_raw = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_summary = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_summary = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_body = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_body = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_time = ffi.Int64 Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_time = int Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_time_offset = ffi.Int32 Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_time_offset = int Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_committer = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_committer = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_author = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_author = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_committer_with_mailmap = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<git_mailmap> mailmap,
);

typedef _dart_git_commit_committer_with_mailmap = int Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<git_mailmap> mailmap,
);

typedef _c_git_commit_author_with_mailmap = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<git_mailmap> mailmap,
);

typedef _dart_git_commit_author_with_mailmap = int Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<git_mailmap> mailmap,
);

typedef _c_git_commit_raw_header = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_raw_header = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_tree = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tree>> tree_out,
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_tree = int Function(
  ffi.Pointer<ffi.Pointer<git_tree>> tree_out,
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_tree_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_tree_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_parentcount = ffi.Uint32 Function(
  ffi.Pointer<git_commit> commit,
);

typedef _dart_git_commit_parentcount = int Function(
  ffi.Pointer<git_commit> commit,
);

typedef _c_git_commit_parent = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_commit>> out,
  ffi.Pointer<git_commit> commit,
  ffi.Uint32 n,
);

typedef _dart_git_commit_parent = int Function(
  ffi.Pointer<ffi.Pointer<git_commit>> out,
  ffi.Pointer<git_commit> commit,
  int n,
);

typedef _c_git_commit_parent_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_commit> commit,
  ffi.Uint32 n,
);

typedef _dart_git_commit_parent_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_commit> commit,
  int n,
);

typedef _c_git_commit_nth_gen_ancestor = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_commit>> ancestor,
  ffi.Pointer<git_commit> commit,
  ffi.Uint32 n,
);

typedef _dart_git_commit_nth_gen_ancestor = int Function(
  ffi.Pointer<ffi.Pointer<git_commit>> ancestor,
  ffi.Pointer<git_commit> commit,
  int n,
);

typedef _c_git_commit_header_field = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<ffi.Int8> field,
);

typedef _dart_git_commit_header_field = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<ffi.Int8> field,
);

typedef _c_git_commit_extract_signature = ffi.Int32 Function(
  ffi.Pointer<git_buf> signature,
  ffi.Pointer<git_buf> signed_data,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> commit_id,
  ffi.Pointer<ffi.Int8> field,
);

typedef _dart_git_commit_extract_signature = int Function(
  ffi.Pointer<git_buf> signature,
  ffi.Pointer<git_buf> signed_data,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> commit_id,
  ffi.Pointer<ffi.Int8> field,
);

typedef _c_git_commit_create = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> update_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
  ffi.Int32 parent_count,
  ffi.Pointer<ffi.Pointer<git_commit>> parents,
);

typedef _dart_git_commit_create = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> update_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
  int parent_count,
  ffi.Pointer<ffi.Pointer<git_commit>> parents,
);

typedef _c_git_commit_create_v = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> update_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
  ffi.Int32 parent_count,
);

typedef _dart_git_commit_create_v = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> update_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
  int parent_count,
);

typedef _c_git_commit_amend = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_commit> commit_to_amend,
  ffi.Pointer<ffi.Int8> update_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
);

typedef _dart_git_commit_amend = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_commit> commit_to_amend,
  ffi.Pointer<ffi.Int8> update_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
);

typedef _c_git_commit_create_buffer = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
  ffi.Int32 parent_count,
  ffi.Pointer<ffi.Pointer<git_commit>> parents,
);

typedef _dart_git_commit_create_buffer = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
  ffi.Pointer<git_tree> tree,
  int parent_count,
  ffi.Pointer<ffi.Pointer<git_commit>> parents,
);

typedef _c_git_commit_create_with_signature = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> commit_content,
  ffi.Pointer<ffi.Int8> signature,
  ffi.Pointer<ffi.Int8> signature_field,
);

typedef _dart_git_commit_create_with_signature = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> commit_content,
  ffi.Pointer<ffi.Int8> signature,
  ffi.Pointer<ffi.Int8> signature_field,
);

typedef _c_git_commit_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_commit>> out,
  ffi.Pointer<git_commit> source,
);

typedef _dart_git_commit_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_commit>> out,
  ffi.Pointer<git_commit> source,
);

typedef _c_git_config_entry_free = ffi.Void Function(
  ffi.Pointer<git_config_entry> arg0,
);

typedef _dart_git_config_entry_free = void Function(
  ffi.Pointer<git_config_entry> arg0,
);

typedef _c_git_config_find_global = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
);

typedef _dart_git_config_find_global = int Function(
  ffi.Pointer<git_buf> out,
);

typedef _c_git_config_find_xdg = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
);

typedef _dart_git_config_find_xdg = int Function(
  ffi.Pointer<git_buf> out,
);

typedef _c_git_config_find_system = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
);

typedef _dart_git_config_find_system = int Function(
  ffi.Pointer<git_buf> out,
);

typedef _c_git_config_find_programdata = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
);

typedef _dart_git_config_find_programdata = int Function(
  ffi.Pointer<git_buf> out,
);

typedef _c_git_config_open_default = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
);

typedef _dart_git_config_open_default = int Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
);

typedef _c_git_config_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
);

typedef _dart_git_config_new = int Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
);

typedef _c_git_config_add_file_ondisk = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 level,
  ffi.Pointer<git_repository> repo,
  ffi.Int32 force,
);

typedef _dart_git_config_add_file_ondisk = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> path,
  int level,
  ffi.Pointer<git_repository> repo,
  int force,
);

typedef _c_git_config_open_ondisk = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_config_open_ondisk = int Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_config_open_level = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_config> parent,
  ffi.Int32 level,
);

typedef _dart_git_config_open_level = int Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_config> parent,
  int level,
);

typedef _c_git_config_open_global = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_config> config,
);

typedef _dart_git_config_open_global = int Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_config> config,
);

typedef _c_git_config_snapshot = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_config> config,
);

typedef _dart_git_config_snapshot = int Function(
  ffi.Pointer<ffi.Pointer<git_config>> out,
  ffi.Pointer<git_config> config,
);

typedef _c_git_config_free = ffi.Void Function(
  ffi.Pointer<git_config> cfg,
);

typedef _dart_git_config_free = void Function(
  ffi.Pointer<git_config> cfg,
);

typedef _c_git_config_get_entry = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config_entry>> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_config_get_entry = int Function(
  ffi.Pointer<ffi.Pointer<git_config_entry>> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_config_get_int32 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_config_get_int32 = int Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_config_get_int64 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_config_get_int64 = int Function(
  ffi.Pointer<ffi.Int64> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_config_get_bool = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_config_get_bool = int Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_config_get_path = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_config_get_path = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_config_get_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_config_get_string = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_config_get_string_buf = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_config_get_string_buf = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef git_config_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<git_config_entry>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_config_get_multivar_foreach = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> regexp,
  ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_config_get_multivar_foreach = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> regexp,
  ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_config_multivar_iterator_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> regexp,
);

typedef _dart_git_config_multivar_iterator_new = int Function(
  ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> regexp,
);

typedef _c_git_config_next = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config_entry>> entry,
  ffi.Pointer<git_config_iterator> iter,
);

typedef _dart_git_config_next = int Function(
  ffi.Pointer<ffi.Pointer<git_config_entry>> entry,
  ffi.Pointer<git_config_iterator> iter,
);

typedef _c_git_config_iterator_free = ffi.Void Function(
  ffi.Pointer<git_config_iterator> iter,
);

typedef _dart_git_config_iterator_free = void Function(
  ffi.Pointer<git_config_iterator> iter,
);

typedef _c_git_config_set_int32 = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 value,
);

typedef _dart_git_config_set_int32 = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  int value,
);

typedef _c_git_config_set_int64 = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int64 value,
);

typedef _dart_git_config_set_int64 = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  int value,
);

typedef _c_git_config_set_bool = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 value,
);

typedef _dart_git_config_set_bool = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  int value,
);

typedef _c_git_config_set_string = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_git_config_set_string = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_git_config_set_multivar = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> regexp,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_git_config_set_multivar = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> regexp,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_git_config_delete_entry = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_config_delete_entry = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_config_delete_multivar = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> regexp,
);

typedef _dart_git_config_delete_multivar = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> regexp,
);

typedef _c_git_config_foreach = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_config_foreach = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_config_iterator_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
  ffi.Pointer<git_config> cfg,
);

typedef _dart_git_config_iterator_new = int Function(
  ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
  ffi.Pointer<git_config> cfg,
);

typedef _c_git_config_iterator_glob_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> regexp,
);

typedef _dart_git_config_iterator_glob_new = int Function(
  ffi.Pointer<ffi.Pointer<git_config_iterator>> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> regexp,
);

typedef _c_git_config_foreach_match = ffi.Int32 Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> regexp,
  ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_config_foreach_match = int Function(
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> regexp,
  ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_config_get_mapped = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<git_configmap> maps,
  ffi.Int32 map_n,
);

typedef _dart_git_config_get_mapped = int Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<git_config> cfg,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<git_configmap> maps,
  int map_n,
);

typedef _c_git_config_lookup_map_value = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<git_configmap> maps,
  ffi.Int32 map_n,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_git_config_lookup_map_value = int Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<git_configmap> maps,
  int map_n,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_git_config_parse_bool = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_git_config_parse_bool = int Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_git_config_parse_int32 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_git_config_parse_int32 = int Function(
  ffi.Pointer<ffi.Int32> out,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_git_config_parse_int64 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> out,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_git_config_parse_int64 = int Function(
  ffi.Pointer<ffi.Int64> out,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_git_config_parse_path = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<ffi.Int8> value,
);

typedef _dart_git_config_parse_path = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<ffi.Int8> value,
);

typedef _c_git_config_backend_foreach_match = ffi.Int32 Function(
  ffi.Pointer<git_config_backend> backend,
  ffi.Pointer<ffi.Int8> regexp,
  ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_config_backend_foreach_match = int Function(
  ffi.Pointer<git_config_backend> backend,
  ffi.Pointer<ffi.Int8> regexp,
  ffi.Pointer<ffi.NativeFunction<git_config_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_config_lock = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_transaction>> tx,
  ffi.Pointer<git_config> cfg,
);

typedef _dart_git_config_lock = int Function(
  ffi.Pointer<ffi.Pointer<git_transaction>> tx,
  ffi.Pointer<git_config> cfg,
);

typedef _c_git_describe_options_init = ffi.Int32 Function(
  ffi.Pointer<git_describe_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_describe_options_init = int Function(
  ffi.Pointer<git_describe_options> opts,
  int version,
);

typedef _c_git_describe_format_options_init = ffi.Int32 Function(
  ffi.Pointer<git_describe_format_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_describe_format_options_init = int Function(
  ffi.Pointer<git_describe_format_options> opts,
  int version,
);

typedef _c_git_describe_commit = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_describe_result>> result,
  ffi.Pointer<git_object> committish,
  ffi.Pointer<git_describe_options> opts,
);

typedef _dart_git_describe_commit = int Function(
  ffi.Pointer<ffi.Pointer<git_describe_result>> result,
  ffi.Pointer<git_object> committish,
  ffi.Pointer<git_describe_options> opts,
);

typedef _c_git_describe_workdir = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_describe_result>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_describe_options> opts,
);

typedef _dart_git_describe_workdir = int Function(
  ffi.Pointer<ffi.Pointer<git_describe_result>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_describe_options> opts,
);

typedef _c_git_describe_format = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_describe_result> result,
  ffi.Pointer<git_describe_format_options> opts,
);

typedef _dart_git_describe_format = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_describe_result> result,
  ffi.Pointer<git_describe_format_options> opts,
);

typedef _c_git_describe_result_free = ffi.Void Function(
  ffi.Pointer<git_describe_result> result,
);

typedef _dart_git_describe_result_free = void Function(
  ffi.Pointer<git_describe_result> result,
);

typedef _c_git_error_last = ffi.Pointer<git_error> Function();

typedef _dart_git_error_last = ffi.Pointer<git_error> Function();

typedef _c_git_error_clear = ffi.Void Function();

typedef _dart_git_error_clear = void Function();

typedef _c_git_error_set_str = ffi.Int32 Function(
  ffi.Int32 error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _dart_git_error_set_str = int Function(
  int error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _c_git_error_set_oom = ffi.Void Function();

typedef _dart_git_error_set_oom = void Function();

typedef _c_git_rebase_options_init = ffi.Int32 Function(
  ffi.Pointer<git_rebase_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_rebase_options_init = int Function(
  ffi.Pointer<git_rebase_options> opts,
  int version,
);

typedef _c_git_rebase_init = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_rebase>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_annotated_commit> branch,
  ffi.Pointer<git_annotated_commit> upstream,
  ffi.Pointer<git_annotated_commit> onto,
  ffi.Pointer<git_rebase_options> opts,
);

typedef _dart_git_rebase_init = int Function(
  ffi.Pointer<ffi.Pointer<git_rebase>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_annotated_commit> branch,
  ffi.Pointer<git_annotated_commit> upstream,
  ffi.Pointer<git_annotated_commit> onto,
  ffi.Pointer<git_rebase_options> opts,
);

typedef _c_git_rebase_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_rebase>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_rebase_options> opts,
);

typedef _dart_git_rebase_open = int Function(
  ffi.Pointer<ffi.Pointer<git_rebase>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_rebase_options> opts,
);

typedef _c_git_rebase_orig_head_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_orig_head_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _c_git_rebase_orig_head_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_orig_head_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _c_git_rebase_onto_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_onto_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _c_git_rebase_onto_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_onto_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _c_git_rebase_operation_entrycount = ffi.Int32 Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_operation_entrycount = int Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _c_git_rebase_operation_current = ffi.Int32 Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_operation_current = int Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _c_git_rebase_operation_byindex = ffi.Pointer<git_rebase_operation>
    Function(
  ffi.Pointer<git_rebase> rebase,
  ffi.Int32 idx,
);

typedef _dart_git_rebase_operation_byindex = ffi.Pointer<git_rebase_operation>
    Function(
  ffi.Pointer<git_rebase> rebase,
  int idx,
);

typedef _c_git_rebase_next = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_rebase_operation>> operation,
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_next = int Function(
  ffi.Pointer<ffi.Pointer<git_rebase_operation>> operation,
  ffi.Pointer<git_rebase> rebase,
);

typedef _c_git_rebase_inmemory_index = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> index,
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_inmemory_index = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> index,
  ffi.Pointer<git_rebase> rebase,
);

typedef _c_git_rebase_commit = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_rebase> rebase,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
);

typedef _dart_git_rebase_commit = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_rebase> rebase,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> message_encoding,
  ffi.Pointer<ffi.Int8> message,
);

typedef _c_git_rebase_abort = ffi.Int32 Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_abort = int Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _c_git_rebase_finish = ffi.Int32 Function(
  ffi.Pointer<git_rebase> rebase,
  ffi.Pointer<git_signature> signature,
);

typedef _dart_git_rebase_finish = int Function(
  ffi.Pointer<git_rebase> rebase,
  ffi.Pointer<git_signature> signature,
);

typedef _c_git_rebase_free = ffi.Void Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef _dart_git_rebase_free = void Function(
  ffi.Pointer<git_rebase> rebase,
);

typedef git_trace_cb = ffi.Void Function(
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
);

typedef _c_git_trace_set = ffi.Int32 Function(
  ffi.Int32 level,
  ffi.Pointer<ffi.NativeFunction<git_trace_cb>> cb,
);

typedef _dart_git_trace_set = int Function(
  int level,
  ffi.Pointer<ffi.NativeFunction<git_trace_cb>> cb,
);

typedef _c_git_revert_options_init = ffi.Int32 Function(
  ffi.Pointer<git_revert_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_revert_options_init = int Function(
  ffi.Pointer<git_revert_options> opts,
  int version,
);

typedef _c_git_revert_commit = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> revert_commit,
  ffi.Pointer<git_commit> our_commit,
  ffi.Uint32 mainline,
  ffi.Pointer<git_merge_options> merge_options,
);

typedef _dart_git_revert_commit = int Function(
  ffi.Pointer<ffi.Pointer<git_index>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> revert_commit,
  ffi.Pointer<git_commit> our_commit,
  int mainline,
  ffi.Pointer<git_merge_options> merge_options,
);

typedef _c_git_revert = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<git_revert_options> given_opts,
);

typedef _dart_git_revert = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> commit,
  ffi.Pointer<git_revert_options> given_opts,
);

typedef _c_git_stash_save = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_signature> stasher,
  ffi.Pointer<ffi.Int8> message,
  ffi.Uint32 flags,
);

typedef _dart_git_stash_save = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_signature> stasher,
  ffi.Pointer<ffi.Int8> message,
  int flags,
);

typedef _c_git_stash_apply_options_init = ffi.Int32 Function(
  ffi.Pointer<git_stash_apply_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_stash_apply_options_init = int Function(
  ffi.Pointer<git_stash_apply_options> opts,
  int version,
);

typedef _c_git_stash_apply = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Int32 index,
  ffi.Pointer<git_stash_apply_options> options,
);

typedef _dart_git_stash_apply = int Function(
  ffi.Pointer<git_repository> repo,
  int index,
  ffi.Pointer<git_stash_apply_options> options,
);

typedef git_stash_cb = ffi.Int32 Function(
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_stash_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_stash_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_stash_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_stash_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_stash_drop = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Int32 index,
);

typedef _dart_git_stash_drop = int Function(
  ffi.Pointer<git_repository> repo,
  int index,
);

typedef _c_git_stash_pop = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Int32 index,
  ffi.Pointer<git_stash_apply_options> options,
);

typedef _dart_git_stash_pop = int Function(
  ffi.Pointer<git_repository> repo,
  int index,
  ffi.Pointer<git_stash_apply_options> options,
);

typedef _c_git_status_options_init = ffi.Int32 Function(
  ffi.Pointer<git_status_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_status_options_init = int Function(
  ffi.Pointer<git_status_options> opts,
  int version,
);

typedef git_status_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_status_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_status_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_status_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_status_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_status_foreach_ext = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_status_options> opts,
  ffi.Pointer<ffi.NativeFunction<git_status_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_status_foreach_ext = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_status_options> opts,
  ffi.Pointer<ffi.NativeFunction<git_status_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_status_file = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint32> status_flags,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_status_file = int Function(
  ffi.Pointer<ffi.Uint32> status_flags,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_status_list_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_status_list>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_status_options> opts,
);

typedef _dart_git_status_list_new = int Function(
  ffi.Pointer<ffi.Pointer<git_status_list>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_status_options> opts,
);

typedef _c_git_status_list_entrycount = ffi.Int32 Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _dart_git_status_list_entrycount = int Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _c_git_status_byindex = ffi.Pointer<git_status_entry> Function(
  ffi.Pointer<git_status_list> statuslist,
  ffi.Int32 idx,
);

typedef _dart_git_status_byindex = ffi.Pointer<git_status_entry> Function(
  ffi.Pointer<git_status_list> statuslist,
  int idx,
);

typedef _c_git_status_list_free = ffi.Void Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _dart_git_status_list_free = void Function(
  ffi.Pointer<git_status_list> statuslist,
);

typedef _c_git_status_should_ignore = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> ignored,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_status_should_ignore = int Function(
  ffi.Pointer<ffi.Int32> ignored,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_submodule_update_options_init = ffi.Int32 Function(
  ffi.Pointer<git_submodule_update_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_submodule_update_options_init = int Function(
  ffi.Pointer<git_submodule_update_options> opts,
  int version,
);

typedef _c_git_submodule_update = ffi.Int32 Function(
  ffi.Pointer<git_submodule> submodule,
  ffi.Int32 init,
  ffi.Pointer<git_submodule_update_options> options,
);

typedef _dart_git_submodule_update = int Function(
  ffi.Pointer<git_submodule> submodule,
  int init,
  ffi.Pointer<git_submodule_update_options> options,
);

typedef _c_git_submodule_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_submodule>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_submodule_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_submodule>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_submodule_free = ffi.Void Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_free = void Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef git_submodule_cb = ffi.Int32 Function(
  ffi.Pointer<git_submodule>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_submodule_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_submodule_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_submodule_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_submodule_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_submodule_add_setup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_submodule>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 use_gitlink,
);

typedef _dart_git_submodule_add_setup = int Function(
  ffi.Pointer<ffi.Pointer<git_submodule>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> path,
  int use_gitlink,
);

typedef _c_git_submodule_clone = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<git_submodule> submodule,
  ffi.Pointer<git_submodule_update_options> opts,
);

typedef _dart_git_submodule_clone = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<git_submodule> submodule,
  ffi.Pointer<git_submodule_update_options> opts,
);

typedef _c_git_submodule_add_finalize = ffi.Int32 Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_add_finalize = int Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_add_to_index = ffi.Int32 Function(
  ffi.Pointer<git_submodule> submodule,
  ffi.Int32 write_index,
);

typedef _dart_git_submodule_add_to_index = int Function(
  ffi.Pointer<git_submodule> submodule,
  int write_index,
);

typedef _c_git_submodule_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_url = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_url = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_resolve_url = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_git_submodule_resolve_url = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_git_submodule_branch = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_branch = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_set_branch = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> branch,
);

typedef _dart_git_submodule_set_branch = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> branch,
);

typedef _c_git_submodule_set_url = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_git_submodule_set_url = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_git_submodule_index_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_index_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_head_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_head_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_wd_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_wd_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_ignore = ffi.Int32 Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_ignore = int Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_set_ignore = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 ignore,
);

typedef _dart_git_submodule_set_ignore = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  int ignore,
);

typedef _c_git_submodule_update_strategy = ffi.Int32 Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_update_strategy = int Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_set_update = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 update,
);

typedef _dart_git_submodule_set_update = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  int update,
);

typedef _c_git_submodule_fetch_recurse_submodules = ffi.Int32 Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_fetch_recurse_submodules = int Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_set_fetch_recurse_submodules = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 fetch_recurse_submodules,
);

typedef _dart_git_submodule_set_fetch_recurse_submodules = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  int fetch_recurse_submodules,
);

typedef _c_git_submodule_init = ffi.Int32 Function(
  ffi.Pointer<git_submodule> submodule,
  ffi.Int32 overwrite,
);

typedef _dart_git_submodule_init = int Function(
  ffi.Pointer<git_submodule> submodule,
  int overwrite,
);

typedef _c_git_submodule_repo_init = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<git_submodule> sm,
  ffi.Int32 use_gitlink,
);

typedef _dart_git_submodule_repo_init = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> out,
  ffi.Pointer<git_submodule> sm,
  int use_gitlink,
);

typedef _c_git_submodule_sync = ffi.Int32 Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_sync = int Function(
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>> repo,
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_open = int Function(
  ffi.Pointer<ffi.Pointer<git_repository>> repo,
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_submodule_reload = ffi.Int32 Function(
  ffi.Pointer<git_submodule> submodule,
  ffi.Int32 force,
);

typedef _dart_git_submodule_reload = int Function(
  ffi.Pointer<git_submodule> submodule,
  int force,
);

typedef _c_git_submodule_status = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint32> status,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 ignore,
);

typedef _dart_git_submodule_status = int Function(
  ffi.Pointer<ffi.Uint32> status,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  int ignore,
);

typedef _c_git_submodule_location = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint32> location_status,
  ffi.Pointer<git_submodule> submodule,
);

typedef _dart_git_submodule_location = int Function(
  ffi.Pointer<ffi.Uint32> location_status,
  ffi.Pointer<git_submodule> submodule,
);

typedef _c_git_worktree_list = ffi.Int32 Function(
  ffi.Pointer<git_strarray> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_worktree_list = int Function(
  ffi.Pointer<git_strarray> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_worktree_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_worktree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_worktree_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_worktree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_worktree_open_from_repository = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_worktree>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_worktree_open_from_repository = int Function(
  ffi.Pointer<ffi.Pointer<git_worktree>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_worktree_free = ffi.Void Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _dart_git_worktree_free = void Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _c_git_worktree_validate = ffi.Int32 Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _dart_git_worktree_validate = int Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _c_git_worktree_add_options_init = ffi.Int32 Function(
  ffi.Pointer<git_worktree_add_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_worktree_add_options_init = int Function(
  ffi.Pointer<git_worktree_add_options> opts,
  int version,
);

typedef _c_git_worktree_add = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_worktree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<git_worktree_add_options> opts,
);

typedef _dart_git_worktree_add = int Function(
  ffi.Pointer<ffi.Pointer<git_worktree>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<git_worktree_add_options> opts,
);

typedef _c_git_worktree_lock = ffi.Int32 Function(
  ffi.Pointer<git_worktree> wt,
  ffi.Pointer<ffi.Int8> reason,
);

typedef _dart_git_worktree_lock = int Function(
  ffi.Pointer<git_worktree> wt,
  ffi.Pointer<ffi.Int8> reason,
);

typedef _c_git_worktree_unlock = ffi.Int32 Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _dart_git_worktree_unlock = int Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _c_git_worktree_is_locked = ffi.Int32 Function(
  ffi.Pointer<git_buf> reason,
  ffi.Pointer<git_worktree> wt,
);

typedef _dart_git_worktree_is_locked = int Function(
  ffi.Pointer<git_buf> reason,
  ffi.Pointer<git_worktree> wt,
);

typedef _c_git_worktree_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _dart_git_worktree_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _c_git_worktree_path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _dart_git_worktree_path = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_worktree> wt,
);

typedef _c_git_worktree_prune_options_init = ffi.Int32 Function(
  ffi.Pointer<git_worktree_prune_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_worktree_prune_options_init = int Function(
  ffi.Pointer<git_worktree_prune_options> opts,
  int version,
);

typedef _c_git_worktree_is_prunable = ffi.Int32 Function(
  ffi.Pointer<git_worktree> wt,
  ffi.Pointer<git_worktree_prune_options> opts,
);

typedef _dart_git_worktree_is_prunable = int Function(
  ffi.Pointer<git_worktree> wt,
  ffi.Pointer<git_worktree_prune_options> opts,
);

typedef _c_git_worktree_prune = ffi.Int32 Function(
  ffi.Pointer<git_worktree> wt,
  ffi.Pointer<git_worktree_prune_options> opts,
);

typedef _dart_git_worktree_prune = int Function(
  ffi.Pointer<git_worktree> wt,
  ffi.Pointer<git_worktree_prune_options> opts,
);

typedef _c_git_credential_userpass = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> user_from_url,
  ffi.Uint32 allowed_types,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_credential_userpass = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> user_from_url,
  int allowed_types,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_blob_create_fromworkdir = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> relative_path,
);

typedef _dart_git_blob_create_fromworkdir = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> relative_path,
);

typedef _c_git_blob_create_fromdisk = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_blob_create_fromdisk = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_blob_create_fromstream = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_writestream>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> hintpath,
);

typedef _dart_git_blob_create_fromstream = int Function(
  ffi.Pointer<ffi.Pointer<git_writestream>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> hintpath,
);

typedef _c_git_blob_create_fromstream_commit = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_writestream> stream,
);

typedef _dart_git_blob_create_fromstream_commit = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_writestream> stream,
);

typedef _c_git_blob_create_frombuffer = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Void> buffer,
  ffi.Int32 len,
);

typedef _dart_git_blob_create_frombuffer = int Function(
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Void> buffer,
  int len,
);

typedef _c_git_blob_filtered_content = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_blob> blob,
  ffi.Pointer<ffi.Int8> as_path,
  ffi.Int32 check_for_binary_data,
);

typedef _dart_git_blob_filtered_content = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_blob> blob,
  ffi.Pointer<ffi.Int8> as_path,
  int check_for_binary_data,
);

typedef _c_git_buf_free = ffi.Void Function(
  ffi.Pointer<git_buf> buffer,
);

typedef _dart_git_buf_free = void Function(
  ffi.Pointer<git_buf> buffer,
);

typedef _c_giterr_last = ffi.Pointer<git_error> Function();

typedef _dart_giterr_last = ffi.Pointer<git_error> Function();

typedef _c_giterr_clear = ffi.Void Function();

typedef _dart_giterr_clear = void Function();

typedef _c_giterr_set_str = ffi.Void Function(
  ffi.Int32 error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _dart_giterr_set_str = void Function(
  int error_class,
  ffi.Pointer<ffi.Int8> string,
);

typedef _c_giterr_set_oom = ffi.Void Function();

typedef _dart_giterr_set_oom = void Function();

typedef _c_git_index_add_frombuffer = ffi.Int32 Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_index_entry> entry,
  ffi.Pointer<ffi.Void> buffer,
  ffi.Int32 len,
);

typedef _dart_git_index_add_frombuffer = int Function(
  ffi.Pointer<git_index> index,
  ffi.Pointer<git_index_entry> entry,
  ffi.Pointer<ffi.Void> buffer,
  int len,
);

typedef _c_git_object__size = ffi.Int32 Function(
  ffi.Int32 type,
);

typedef _dart_git_object__size = int Function(
  int type,
);

typedef _c_git_tag_create_frombuffer = ffi.Int32 Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Int32 force,
);

typedef _dart_git_tag_create_frombuffer = int Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> buffer,
  int force,
);

typedef _c_git_cred_free = ffi.Void Function(
  ffi.Pointer<git_credential> cred,
);

typedef _dart_git_cred_free = void Function(
  ffi.Pointer<git_credential> cred,
);

typedef _c_git_cred_has_username = ffi.Int32 Function(
  ffi.Pointer<git_credential> cred,
);

typedef _dart_git_cred_has_username = int Function(
  ffi.Pointer<git_credential> cred,
);

typedef _c_git_cred_get_username = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_credential> cred,
);

typedef _dart_git_cred_get_username = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_credential> cred,
);

typedef _c_git_cred_userpass_plaintext_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> password,
);

typedef _dart_git_cred_userpass_plaintext_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> password,
);

typedef _c_git_cred_default_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
);

typedef _dart_git_cred_default_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
);

typedef _c_git_cred_username_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
);

typedef _dart_git_cred_username_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
);

typedef _c_git_cred_ssh_key_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Pointer<ffi.Int8> privatekey,
  ffi.Pointer<ffi.Int8> passphrase,
);

typedef _dart_git_cred_ssh_key_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Pointer<ffi.Int8> privatekey,
  ffi.Pointer<ffi.Int8> passphrase,
);

typedef _c_git_cred_ssh_key_memory_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Pointer<ffi.Int8> privatekey,
  ffi.Pointer<ffi.Int8> passphrase,
);

typedef _dart_git_cred_ssh_key_memory_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Pointer<ffi.Int8> privatekey,
  ffi.Pointer<ffi.Int8> passphrase,
);

typedef _c_git_cred_ssh_interactive_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.NativeFunction<git_credential_ssh_interactive_cb>>
      prompt_callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_cred_ssh_interactive_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.NativeFunction<git_credential_ssh_interactive_cb>>
      prompt_callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_cred_ssh_key_from_agent = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
);

typedef _dart_git_cred_ssh_key_from_agent = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
);

typedef _c_git_cred_ssh_custom_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  ffi.Int32 publickey_len,
  ffi.Pointer<ffi.NativeFunction<git_credential_sign_cb>> sign_callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_cred_ssh_custom_new = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> username,
  ffi.Pointer<ffi.Int8> publickey,
  int publickey_len,
  ffi.Pointer<ffi.NativeFunction<git_credential_sign_cb>> sign_callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_cred_userpass = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> user_from_url,
  ffi.Uint32 allowed_types,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_cred_userpass = int Function(
  ffi.Pointer<ffi.Pointer<git_credential>> out,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Int8> user_from_url,
  int allowed_types,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_oid_iszero = ffi.Int32 Function(
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_oid_iszero = int Function(
  ffi.Pointer<git_oid> id,
);

typedef _c_git_strarray_free = ffi.Void Function(
  ffi.Pointer<git_strarray> array,
);

typedef _dart_git_strarray_free = void Function(
  ffi.Pointer<git_strarray> array,
);

typedef _c_git_blame_init_options = ffi.Int32 Function(
  ffi.Pointer<git_blame_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_blame_init_options = int Function(
  ffi.Pointer<git_blame_options> opts,
  int version,
);

typedef _c_git_checkout_init_options = ffi.Int32 Function(
  ffi.Pointer<git_checkout_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_checkout_init_options = int Function(
  ffi.Pointer<git_checkout_options> opts,
  int version,
);

typedef _c_git_cherrypick_init_options = ffi.Int32 Function(
  ffi.Pointer<git_cherrypick_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_cherrypick_init_options = int Function(
  ffi.Pointer<git_cherrypick_options> opts,
  int version,
);

typedef _c_git_clone_init_options = ffi.Int32 Function(
  ffi.Pointer<git_clone_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_clone_init_options = int Function(
  ffi.Pointer<git_clone_options> opts,
  int version,
);

typedef _c_git_describe_init_options = ffi.Int32 Function(
  ffi.Pointer<git_describe_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_describe_init_options = int Function(
  ffi.Pointer<git_describe_options> opts,
  int version,
);

typedef _c_git_describe_init_format_options = ffi.Int32 Function(
  ffi.Pointer<git_describe_format_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_describe_init_format_options = int Function(
  ffi.Pointer<git_describe_format_options> opts,
  int version,
);

typedef _c_git_diff_init_options = ffi.Int32 Function(
  ffi.Pointer<git_diff_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_diff_init_options = int Function(
  ffi.Pointer<git_diff_options> opts,
  int version,
);

typedef _c_git_diff_find_init_options = ffi.Int32 Function(
  ffi.Pointer<git_diff_find_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_diff_find_init_options = int Function(
  ffi.Pointer<git_diff_find_options> opts,
  int version,
);

typedef _c_git_diff_format_email_init_options = ffi.Int32 Function(
  ffi.Pointer<git_diff_format_email_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_diff_format_email_init_options = int Function(
  ffi.Pointer<git_diff_format_email_options> opts,
  int version,
);

typedef _c_git_diff_patchid_init_options = ffi.Int32 Function(
  ffi.Pointer<git_diff_patchid_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_diff_patchid_init_options = int Function(
  ffi.Pointer<git_diff_patchid_options> opts,
  int version,
);

typedef _c_git_fetch_init_options = ffi.Int32 Function(
  ffi.Pointer<git_fetch_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_fetch_init_options = int Function(
  ffi.Pointer<git_fetch_options> opts,
  int version,
);

typedef _c_git_indexer_init_options = ffi.Int32 Function(
  ffi.Pointer<git_indexer_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_indexer_init_options = int Function(
  ffi.Pointer<git_indexer_options> opts,
  int version,
);

typedef _c_git_merge_init_options = ffi.Int32 Function(
  ffi.Pointer<git_merge_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_merge_init_options = int Function(
  ffi.Pointer<git_merge_options> opts,
  int version,
);

typedef _c_git_merge_file_init_input = ffi.Int32 Function(
  ffi.Pointer<git_merge_file_input> input,
  ffi.Uint32 version,
);

typedef _dart_git_merge_file_init_input = int Function(
  ffi.Pointer<git_merge_file_input> input,
  int version,
);

typedef _c_git_merge_file_init_options = ffi.Int32 Function(
  ffi.Pointer<git_merge_file_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_merge_file_init_options = int Function(
  ffi.Pointer<git_merge_file_options> opts,
  int version,
);

typedef _c_git_proxy_init_options = ffi.Int32 Function(
  ffi.Pointer<git_proxy_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_proxy_init_options = int Function(
  ffi.Pointer<git_proxy_options> opts,
  int version,
);

typedef _c_git_push_init_options = ffi.Int32 Function(
  ffi.Pointer<git_push_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_push_init_options = int Function(
  ffi.Pointer<git_push_options> opts,
  int version,
);

typedef _c_git_rebase_init_options = ffi.Int32 Function(
  ffi.Pointer<git_rebase_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_rebase_init_options = int Function(
  ffi.Pointer<git_rebase_options> opts,
  int version,
);

typedef _c_git_remote_create_init_options = ffi.Int32 Function(
  ffi.Pointer<git_remote_create_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_remote_create_init_options = int Function(
  ffi.Pointer<git_remote_create_options> opts,
  int version,
);

typedef _c_git_repository_init_init_options = ffi.Int32 Function(
  ffi.Pointer<git_repository_init_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_repository_init_init_options = int Function(
  ffi.Pointer<git_repository_init_options> opts,
  int version,
);

typedef _c_git_revert_init_options = ffi.Int32 Function(
  ffi.Pointer<git_revert_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_revert_init_options = int Function(
  ffi.Pointer<git_revert_options> opts,
  int version,
);

typedef _c_git_stash_apply_init_options = ffi.Int32 Function(
  ffi.Pointer<git_stash_apply_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_stash_apply_init_options = int Function(
  ffi.Pointer<git_stash_apply_options> opts,
  int version,
);

typedef _c_git_status_init_options = ffi.Int32 Function(
  ffi.Pointer<git_status_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_status_init_options = int Function(
  ffi.Pointer<git_status_options> opts,
  int version,
);

typedef _c_git_submodule_update_init_options = ffi.Int32 Function(
  ffi.Pointer<git_submodule_update_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_submodule_update_init_options = int Function(
  ffi.Pointer<git_submodule_update_options> opts,
  int version,
);

typedef _c_git_worktree_add_init_options = ffi.Int32 Function(
  ffi.Pointer<git_worktree_add_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_worktree_add_init_options = int Function(
  ffi.Pointer<git_worktree_add_options> opts,
  int version,
);

typedef _c_git_worktree_prune_init_options = ffi.Int32 Function(
  ffi.Pointer<git_worktree_prune_options> opts,
  ffi.Uint32 version,
);

typedef _dart_git_worktree_prune_init_options = int Function(
  ffi.Pointer<git_worktree_prune_options> opts,
  int version,
);

typedef _c_git_filter_list_load = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_blob> blob,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 mode,
  ffi.Uint32 flags,
);

typedef _dart_git_filter_list_load = int Function(
  ffi.Pointer<ffi.Pointer<git_filter_list>> filters,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_blob> blob,
  ffi.Pointer<ffi.Int8> path,
  int mode,
  int flags,
);

typedef _c_git_filter_list_contains = ffi.Int32 Function(
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_filter_list_contains = int Function(
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_filter_list_apply_to_data = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_buf> in_1,
);

typedef _dart_git_filter_list_apply_to_data = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_buf> in_1,
);

typedef _c_git_filter_list_apply_to_file = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_filter_list_apply_to_file = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_filter_list_apply_to_blob = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_blob> blob,
);

typedef _dart_git_filter_list_apply_to_blob = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_blob> blob,
);

typedef _c_git_filter_list_stream_data = ffi.Int32 Function(
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_buf> data,
  ffi.Pointer<git_writestream> target,
);

typedef _dart_git_filter_list_stream_data = int Function(
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_buf> data,
  ffi.Pointer<git_writestream> target,
);

typedef _c_git_filter_list_stream_file = ffi.Int32 Function(
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<git_writestream> target,
);

typedef _dart_git_filter_list_stream_file = int Function(
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<git_writestream> target,
);

typedef _c_git_filter_list_stream_blob = ffi.Int32 Function(
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_blob> blob,
  ffi.Pointer<git_writestream> target,
);

typedef _dart_git_filter_list_stream_blob = int Function(
  ffi.Pointer<git_filter_list> filters,
  ffi.Pointer<git_blob> blob,
  ffi.Pointer<git_writestream> target,
);

typedef _c_git_filter_list_free = ffi.Void Function(
  ffi.Pointer<git_filter_list> filters,
);

typedef _dart_git_filter_list_free = void Function(
  ffi.Pointer<git_filter_list> filters,
);

typedef _c_git_libgit2_init = ffi.Int32 Function();

typedef _dart_git_libgit2_init = int Function();

typedef _c_git_libgit2_shutdown = ffi.Int32 Function();

typedef _dart_git_libgit2_shutdown = int Function();

typedef _c_git_graph_ahead_behind = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> ahead,
  ffi.Pointer<ffi.Int32> behind,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> local,
  ffi.Pointer<git_oid> upstream,
);

typedef _dart_git_graph_ahead_behind = int Function(
  ffi.Pointer<ffi.Int32> ahead,
  ffi.Pointer<ffi.Int32> behind,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> local,
  ffi.Pointer<git_oid> upstream,
);

typedef _c_git_graph_descendant_of = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> commit,
  ffi.Pointer<git_oid> ancestor,
);

typedef _dart_git_graph_descendant_of = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> commit,
  ffi.Pointer<git_oid> ancestor,
);

typedef _c_git_ignore_add_rule = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> rules,
);

typedef _dart_git_ignore_add_rule = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> rules,
);

typedef _c_git_ignore_clear_internal_rules = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_ignore_clear_internal_rules = int Function(
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_ignore_path_is_ignored = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> ignored,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_ignore_path_is_ignored = int Function(
  ffi.Pointer<ffi.Int32> ignored,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_mailmap_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_mailmap>> out,
);

typedef _dart_git_mailmap_new = int Function(
  ffi.Pointer<ffi.Pointer<git_mailmap>> out,
);

typedef _c_git_mailmap_free = ffi.Void Function(
  ffi.Pointer<git_mailmap> mm,
);

typedef _dart_git_mailmap_free = void Function(
  ffi.Pointer<git_mailmap> mm,
);

typedef _c_git_mailmap_add_entry = ffi.Int32 Function(
  ffi.Pointer<git_mailmap> mm,
  ffi.Pointer<ffi.Int8> real_name,
  ffi.Pointer<ffi.Int8> real_email,
  ffi.Pointer<ffi.Int8> replace_name,
  ffi.Pointer<ffi.Int8> replace_email,
);

typedef _dart_git_mailmap_add_entry = int Function(
  ffi.Pointer<git_mailmap> mm,
  ffi.Pointer<ffi.Int8> real_name,
  ffi.Pointer<ffi.Int8> real_email,
  ffi.Pointer<ffi.Int8> replace_name,
  ffi.Pointer<ffi.Int8> replace_email,
);

typedef _c_git_mailmap_from_buffer = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_mailmap>> out,
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 len,
);

typedef _dart_git_mailmap_from_buffer = int Function(
  ffi.Pointer<ffi.Pointer<git_mailmap>> out,
  ffi.Pointer<ffi.Int8> buf,
  int len,
);

typedef _c_git_mailmap_from_repository = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_mailmap>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_mailmap_from_repository = int Function(
  ffi.Pointer<ffi.Pointer<git_mailmap>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_mailmap_resolve = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> real_name,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> real_email,
  ffi.Pointer<git_mailmap> mm,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
);

typedef _dart_git_mailmap_resolve = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> real_name,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> real_email,
  ffi.Pointer<git_mailmap> mm,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
);

typedef _c_git_mailmap_resolve_signature = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<git_mailmap> mm,
  ffi.Pointer<git_signature> sig,
);

typedef _dart_git_mailmap_resolve_signature = int Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<git_mailmap> mm,
  ffi.Pointer<git_signature> sig,
);

typedef _c_git_message_prettify = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<ffi.Int8> message,
  ffi.Int32 strip_comments,
  ffi.Int8 comment_char,
);

typedef _dart_git_message_prettify = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<ffi.Int8> message,
  int strip_comments,
  int comment_char,
);

typedef _c_git_message_trailers = ffi.Int32 Function(
  ffi.Pointer<git_message_trailer_array> arr,
  ffi.Pointer<ffi.Int8> message,
);

typedef _dart_git_message_trailers = int Function(
  ffi.Pointer<git_message_trailer_array> arr,
  ffi.Pointer<ffi.Int8> message,
);

typedef _c_git_message_trailer_array_free = ffi.Void Function(
  ffi.Pointer<git_message_trailer_array> arr,
);

typedef _dart_git_message_trailer_array_free = void Function(
  ffi.Pointer<git_message_trailer_array> arr,
);

typedef _c_git_note_iterator_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_iterator>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
);

typedef _dart_git_note_iterator_new = int Function(
  ffi.Pointer<ffi.Pointer<git_iterator>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
);

typedef _c_git_note_commit_iterator_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_iterator>> out,
  ffi.Pointer<git_commit> notes_commit,
);

typedef _dart_git_note_commit_iterator_new = int Function(
  ffi.Pointer<ffi.Pointer<git_iterator>> out,
  ffi.Pointer<git_commit> notes_commit,
);

typedef _c_git_note_iterator_free = ffi.Void Function(
  ffi.Pointer<git_iterator> it,
);

typedef _dart_git_note_iterator_free = void Function(
  ffi.Pointer<git_iterator> it,
);

typedef _c_git_note_next = ffi.Int32 Function(
  ffi.Pointer<git_oid> note_id,
  ffi.Pointer<git_oid> annotated_id,
  ffi.Pointer<git_iterator> it,
);

typedef _dart_git_note_next = int Function(
  ffi.Pointer<git_oid> note_id,
  ffi.Pointer<git_oid> annotated_id,
  ffi.Pointer<git_iterator> it,
);

typedef _c_git_note_read = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_note>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
  ffi.Pointer<git_oid> oid,
);

typedef _dart_git_note_read = int Function(
  ffi.Pointer<ffi.Pointer<git_note>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
  ffi.Pointer<git_oid> oid,
);

typedef _c_git_note_commit_read = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_note>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> notes_commit,
  ffi.Pointer<git_oid> oid,
);

typedef _dart_git_note_commit_read = int Function(
  ffi.Pointer<ffi.Pointer<git_note>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> notes_commit,
  ffi.Pointer<git_oid> oid,
);

typedef _c_git_note_author = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_note> note,
);

typedef _dart_git_note_author = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_note> note,
);

typedef _c_git_note_committer = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_note> note,
);

typedef _dart_git_note_committer = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_note> note,
);

typedef _c_git_note_message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_note> note,
);

typedef _dart_git_note_message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_note> note,
);

typedef _c_git_note_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_note> note,
);

typedef _dart_git_note_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_note> note,
);

typedef _c_git_note_create = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<ffi.Int8> note,
  ffi.Int32 force,
);

typedef _dart_git_note_create = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<ffi.Int8> note,
  int force,
);

typedef _c_git_note_commit_create = ffi.Int32 Function(
  ffi.Pointer<git_oid> notes_commit_out,
  ffi.Pointer<git_oid> notes_blob_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> parent,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<ffi.Int8> note,
  ffi.Int32 allow_note_overwrite,
);

typedef _dart_git_note_commit_create = int Function(
  ffi.Pointer<git_oid> notes_commit_out,
  ffi.Pointer<git_oid> notes_blob_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> parent,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<ffi.Int8> note,
  int allow_note_overwrite,
);

typedef _c_git_note_remove = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<git_oid> oid,
);

typedef _dart_git_note_remove = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<git_oid> oid,
);

typedef _c_git_note_commit_remove = ffi.Int32 Function(
  ffi.Pointer<git_oid> notes_commit_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> notes_commit,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<git_oid> oid,
);

typedef _dart_git_note_commit_remove = int Function(
  ffi.Pointer<git_oid> notes_commit_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_commit> notes_commit,
  ffi.Pointer<git_signature> author,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<git_oid> oid,
);

typedef _c_git_note_free = ffi.Void Function(
  ffi.Pointer<git_note> note,
);

typedef _dart_git_note_free = void Function(
  ffi.Pointer<git_note> note,
);

typedef _c_git_note_default_ref = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_note_default_ref = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_repository> repo,
);

typedef git_note_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<git_oid>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_note_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
  ffi.Pointer<ffi.NativeFunction<git_note_foreach_cb>> note_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_note_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> notes_ref,
  ffi.Pointer<ffi.NativeFunction<git_note_foreach_cb>> note_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_odb_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb>> out,
);

typedef _dart_git_odb_new = int Function(
  ffi.Pointer<ffi.Pointer<git_odb>> out,
);

typedef _c_git_odb_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb>> out,
  ffi.Pointer<ffi.Int8> objects_dir,
);

typedef _dart_git_odb_open = int Function(
  ffi.Pointer<ffi.Pointer<git_odb>> out,
  ffi.Pointer<ffi.Int8> objects_dir,
);

typedef _c_git_odb_add_disk_alternate = ffi.Int32 Function(
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_odb_add_disk_alternate = int Function(
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_odb_free = ffi.Void Function(
  ffi.Pointer<git_odb> db,
);

typedef _dart_git_odb_free = void Function(
  ffi.Pointer<git_odb> db,
);

typedef _c_git_odb_read = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_object>> out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_odb_read = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_object>> out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_odb_read_prefix = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_object>> out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> short_id,
  ffi.Int32 len,
);

typedef _dart_git_odb_read_prefix = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_object>> out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> short_id,
  int len,
);

typedef _c_git_odb_read_header = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> len_out,
  ffi.Pointer<ffi.Int32> type_out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_odb_read_header = int Function(
  ffi.Pointer<ffi.Int32> len_out,
  ffi.Pointer<ffi.Int32> type_out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_odb_exists = ffi.Int32 Function(
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_odb_exists = int Function(
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_odb_exists_prefix = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> short_id,
  ffi.Int32 len,
);

typedef _dart_git_odb_exists_prefix = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> short_id,
  int len,
);

typedef _c_git_odb_expand_ids = ffi.Int32 Function(
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_odb_expand_id> ids,
  ffi.Int32 count,
);

typedef _dart_git_odb_expand_ids = int Function(
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_odb_expand_id> ids,
  int count,
);

typedef _c_git_odb_refresh = ffi.Int32 Function(
  ffi.Pointer<git_odb> db,
);

typedef _dart_git_odb_refresh = int Function(
  ffi.Pointer<git_odb> db,
);

typedef git_odb_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_odb_foreach = ffi.Int32 Function(
  ffi.Pointer<git_odb> db,
  ffi.Pointer<ffi.NativeFunction<git_odb_foreach_cb>> cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_odb_foreach = int Function(
  ffi.Pointer<git_odb> db,
  ffi.Pointer<ffi.NativeFunction<git_odb_foreach_cb>> cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_odb_write = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<ffi.Void> data,
  ffi.Int32 len,
  ffi.Int32 type,
);

typedef _dart_git_odb_write = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<ffi.Void> data,
  int len,
  int type,
);

typedef _c_git_odb_open_wstream = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
  ffi.Pointer<git_odb> db,
  ffi.Uint64 size,
  ffi.Int32 type,
);

typedef _dart_git_odb_open_wstream = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
  ffi.Pointer<git_odb> db,
  int size,
  int type,
);

typedef _c_git_odb_stream_write = ffi.Int32 Function(
  ffi.Pointer<git_odb_stream> stream,
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Int32 len,
);

typedef _dart_git_odb_stream_write = int Function(
  ffi.Pointer<git_odb_stream> stream,
  ffi.Pointer<ffi.Int8> buffer,
  int len,
);

typedef _c_git_odb_stream_finalize_write = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_odb_stream> stream,
);

typedef _dart_git_odb_stream_finalize_write = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_odb_stream> stream,
);

typedef _c_git_odb_stream_read = ffi.Int32 Function(
  ffi.Pointer<git_odb_stream> stream,
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Int32 len,
);

typedef _dart_git_odb_stream_read = int Function(
  ffi.Pointer<git_odb_stream> stream,
  ffi.Pointer<ffi.Int8> buffer,
  int len,
);

typedef _c_git_odb_stream_free = ffi.Void Function(
  ffi.Pointer<git_odb_stream> stream,
);

typedef _dart_git_odb_stream_free = void Function(
  ffi.Pointer<git_odb_stream> stream,
);

typedef _c_git_odb_open_rstream = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
  ffi.Pointer<ffi.Int32> len,
  ffi.Pointer<ffi.Int32> type,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> oid,
);

typedef _dart_git_odb_open_rstream = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_stream>> out,
  ffi.Pointer<ffi.Int32> len,
  ffi.Pointer<ffi.Int32> type,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<git_oid> oid,
);

typedef _c_git_odb_write_pack = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_writepack>> out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>> progress_cb,
  ffi.Pointer<ffi.Void> progress_payload,
);

typedef _dart_git_odb_write_pack = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_writepack>> out,
  ffi.Pointer<git_odb> db,
  ffi.Pointer<ffi.NativeFunction<git_indexer_progress_cb>> progress_cb,
  ffi.Pointer<ffi.Void> progress_payload,
);

typedef _c_git_odb_hash = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Void> data,
  ffi.Int32 len,
  ffi.Int32 type,
);

typedef _dart_git_odb_hash = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Void> data,
  int len,
  int type,
);

typedef _c_git_odb_hashfile = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 type,
);

typedef _dart_git_odb_hashfile = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<ffi.Int8> path,
  int type,
);

typedef _c_git_odb_object_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_object>> dest,
  ffi.Pointer<git_odb_object> source,
);

typedef _dart_git_odb_object_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_object>> dest,
  ffi.Pointer<git_odb_object> source,
);

typedef _c_git_odb_object_free = ffi.Void Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _dart_git_odb_object_free = void Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _c_git_odb_object_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _dart_git_odb_object_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _c_git_odb_object_data = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _dart_git_odb_object_data = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _c_git_odb_object_size = ffi.Int32 Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _dart_git_odb_object_size = int Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _c_git_odb_object_type = ffi.Int32 Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _dart_git_odb_object_type = int Function(
  ffi.Pointer<git_odb_object> object,
);

typedef _c_git_odb_add_backend = ffi.Int32 Function(
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<git_odb_backend> backend,
  ffi.Int32 priority,
);

typedef _dart_git_odb_add_backend = int Function(
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<git_odb_backend> backend,
  int priority,
);

typedef _c_git_odb_add_alternate = ffi.Int32 Function(
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<git_odb_backend> backend,
  ffi.Int32 priority,
);

typedef _dart_git_odb_add_alternate = int Function(
  ffi.Pointer<git_odb> odb,
  ffi.Pointer<git_odb_backend> backend,
  int priority,
);

typedef _c_git_odb_num_backends = ffi.Int32 Function(
  ffi.Pointer<git_odb> odb,
);

typedef _dart_git_odb_num_backends = int Function(
  ffi.Pointer<git_odb> odb,
);

typedef _c_git_odb_get_backend = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
  ffi.Pointer<git_odb> odb,
  ffi.Int32 pos,
);

typedef _dart_git_odb_get_backend = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
  ffi.Pointer<git_odb> odb,
  int pos,
);

typedef _c_git_odb_backend_pack = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
  ffi.Pointer<ffi.Int8> objects_dir,
);

typedef _dart_git_odb_backend_pack = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
  ffi.Pointer<ffi.Int8> objects_dir,
);

typedef _c_git_odb_backend_loose = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
  ffi.Pointer<ffi.Int8> objects_dir,
  ffi.Int32 compression_level,
  ffi.Int32 do_fsync,
  ffi.Uint32 dir_mode,
  ffi.Uint32 file_mode,
);

typedef _dart_git_odb_backend_loose = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
  ffi.Pointer<ffi.Int8> objects_dir,
  int compression_level,
  int do_fsync,
  int dir_mode,
  int file_mode,
);

typedef _c_git_odb_backend_one_pack = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
  ffi.Pointer<ffi.Int8> index_file,
);

typedef _dart_git_odb_backend_one_pack = int Function(
  ffi.Pointer<ffi.Pointer<git_odb_backend>> out,
  ffi.Pointer<ffi.Int8> index_file,
);

typedef _c_git_patch_from_diff = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_patch>> out,
  ffi.Pointer<git_diff> diff,
  ffi.Int32 idx,
);

typedef _dart_git_patch_from_diff = int Function(
  ffi.Pointer<ffi.Pointer<git_patch>> out,
  ffi.Pointer<git_diff> diff,
  int idx,
);

typedef _c_git_patch_from_blobs = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_patch>> out,
  ffi.Pointer<git_blob> old_blob,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<git_blob> new_blob,
  ffi.Pointer<ffi.Int8> new_as_path,
  ffi.Pointer<git_diff_options> opts,
);

typedef _dart_git_patch_from_blobs = int Function(
  ffi.Pointer<ffi.Pointer<git_patch>> out,
  ffi.Pointer<git_blob> old_blob,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<git_blob> new_blob,
  ffi.Pointer<ffi.Int8> new_as_path,
  ffi.Pointer<git_diff_options> opts,
);

typedef _c_git_patch_from_blob_and_buffer = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_patch>> out,
  ffi.Pointer<git_blob> old_blob,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<ffi.Void> buffer,
  ffi.Int32 buffer_len,
  ffi.Pointer<ffi.Int8> buffer_as_path,
  ffi.Pointer<git_diff_options> opts,
);

typedef _dart_git_patch_from_blob_and_buffer = int Function(
  ffi.Pointer<ffi.Pointer<git_patch>> out,
  ffi.Pointer<git_blob> old_blob,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<ffi.Void> buffer,
  int buffer_len,
  ffi.Pointer<ffi.Int8> buffer_as_path,
  ffi.Pointer<git_diff_options> opts,
);

typedef _c_git_patch_from_buffers = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_patch>> out,
  ffi.Pointer<ffi.Void> old_buffer,
  ffi.Int32 old_len,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<ffi.Void> new_buffer,
  ffi.Int32 new_len,
  ffi.Pointer<ffi.Int8> new_as_path,
  ffi.Pointer<git_diff_options> opts,
);

typedef _dart_git_patch_from_buffers = int Function(
  ffi.Pointer<ffi.Pointer<git_patch>> out,
  ffi.Pointer<ffi.Void> old_buffer,
  int old_len,
  ffi.Pointer<ffi.Int8> old_as_path,
  ffi.Pointer<ffi.Void> new_buffer,
  int new_len,
  ffi.Pointer<ffi.Int8> new_as_path,
  ffi.Pointer<git_diff_options> opts,
);

typedef _c_git_patch_free = ffi.Void Function(
  ffi.Pointer<git_patch> patch,
);

typedef _dart_git_patch_free = void Function(
  ffi.Pointer<git_patch> patch,
);

typedef _c_git_patch_get_delta = ffi.Pointer<git_diff_delta> Function(
  ffi.Pointer<git_patch> patch,
);

typedef _dart_git_patch_get_delta = ffi.Pointer<git_diff_delta> Function(
  ffi.Pointer<git_patch> patch,
);

typedef _c_git_patch_num_hunks = ffi.Int32 Function(
  ffi.Pointer<git_patch> patch,
);

typedef _dart_git_patch_num_hunks = int Function(
  ffi.Pointer<git_patch> patch,
);

typedef _c_git_patch_line_stats = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> total_context,
  ffi.Pointer<ffi.Int32> total_additions,
  ffi.Pointer<ffi.Int32> total_deletions,
  ffi.Pointer<git_patch> patch,
);

typedef _dart_git_patch_line_stats = int Function(
  ffi.Pointer<ffi.Int32> total_context,
  ffi.Pointer<ffi.Int32> total_additions,
  ffi.Pointer<ffi.Int32> total_deletions,
  ffi.Pointer<git_patch> patch,
);

typedef _c_git_patch_get_hunk = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff_hunk>> out,
  ffi.Pointer<ffi.Int32> lines_in_hunk,
  ffi.Pointer<git_patch> patch,
  ffi.Int32 hunk_idx,
);

typedef _dart_git_patch_get_hunk = int Function(
  ffi.Pointer<ffi.Pointer<git_diff_hunk>> out,
  ffi.Pointer<ffi.Int32> lines_in_hunk,
  ffi.Pointer<git_patch> patch,
  int hunk_idx,
);

typedef _c_git_patch_num_lines_in_hunk = ffi.Int32 Function(
  ffi.Pointer<git_patch> patch,
  ffi.Int32 hunk_idx,
);

typedef _dart_git_patch_num_lines_in_hunk = int Function(
  ffi.Pointer<git_patch> patch,
  int hunk_idx,
);

typedef _c_git_patch_get_line_in_hunk = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_diff_line>> out,
  ffi.Pointer<git_patch> patch,
  ffi.Int32 hunk_idx,
  ffi.Int32 line_of_hunk,
);

typedef _dart_git_patch_get_line_in_hunk = int Function(
  ffi.Pointer<ffi.Pointer<git_diff_line>> out,
  ffi.Pointer<git_patch> patch,
  int hunk_idx,
  int line_of_hunk,
);

typedef _c_git_patch_size = ffi.Int32 Function(
  ffi.Pointer<git_patch> patch,
  ffi.Int32 include_context,
  ffi.Int32 include_hunk_headers,
  ffi.Int32 include_file_headers,
);

typedef _dart_git_patch_size = int Function(
  ffi.Pointer<git_patch> patch,
  int include_context,
  int include_hunk_headers,
  int include_file_headers,
);

typedef _c_git_patch_print = ffi.Int32 Function(
  ffi.Pointer<git_patch> patch,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> print_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_patch_print = int Function(
  ffi.Pointer<git_patch> patch,
  ffi.Pointer<ffi.NativeFunction<git_diff_line_cb>> print_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_patch_to_buf = ffi.Int32 Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_patch> patch,
);

typedef _dart_git_patch_to_buf = int Function(
  ffi.Pointer<git_buf> out,
  ffi.Pointer<git_patch> patch,
);

typedef _c_git_pathspec_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_pathspec>> out,
  ffi.Pointer<git_strarray> pathspec,
);

typedef _dart_git_pathspec_new = int Function(
  ffi.Pointer<ffi.Pointer<git_pathspec>> out,
  ffi.Pointer<git_strarray> pathspec,
);

typedef _c_git_pathspec_free = ffi.Void Function(
  ffi.Pointer<git_pathspec> ps,
);

typedef _dart_git_pathspec_free = void Function(
  ffi.Pointer<git_pathspec> ps,
);

typedef _c_git_pathspec_matches_path = ffi.Int32 Function(
  ffi.Pointer<git_pathspec> ps,
  ffi.Uint32 flags,
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_git_pathspec_matches_path = int Function(
  ffi.Pointer<git_pathspec> ps,
  int flags,
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_git_pathspec_match_workdir = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Uint32 flags,
  ffi.Pointer<git_pathspec> ps,
);

typedef _dart_git_pathspec_match_workdir = int Function(
  ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
  ffi.Pointer<git_repository> repo,
  int flags,
  ffi.Pointer<git_pathspec> ps,
);

typedef _c_git_pathspec_match_index = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
  ffi.Pointer<git_index> index,
  ffi.Uint32 flags,
  ffi.Pointer<git_pathspec> ps,
);

typedef _dart_git_pathspec_match_index = int Function(
  ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
  ffi.Pointer<git_index> index,
  int flags,
  ffi.Pointer<git_pathspec> ps,
);

typedef _c_git_pathspec_match_tree = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
  ffi.Pointer<git_tree> tree,
  ffi.Uint32 flags,
  ffi.Pointer<git_pathspec> ps,
);

typedef _dart_git_pathspec_match_tree = int Function(
  ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
  ffi.Pointer<git_tree> tree,
  int flags,
  ffi.Pointer<git_pathspec> ps,
);

typedef _c_git_pathspec_match_diff = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
  ffi.Pointer<git_diff> diff,
  ffi.Uint32 flags,
  ffi.Pointer<git_pathspec> ps,
);

typedef _dart_git_pathspec_match_diff = int Function(
  ffi.Pointer<ffi.Pointer<git_pathspec_match_list>> out,
  ffi.Pointer<git_diff> diff,
  int flags,
  ffi.Pointer<git_pathspec> ps,
);

typedef _c_git_pathspec_match_list_free = ffi.Void Function(
  ffi.Pointer<git_pathspec_match_list> m,
);

typedef _dart_git_pathspec_match_list_free = void Function(
  ffi.Pointer<git_pathspec_match_list> m,
);

typedef _c_git_pathspec_match_list_entrycount = ffi.Int32 Function(
  ffi.Pointer<git_pathspec_match_list> m,
);

typedef _dart_git_pathspec_match_list_entrycount = int Function(
  ffi.Pointer<git_pathspec_match_list> m,
);

typedef _c_git_pathspec_match_list_entry = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_pathspec_match_list> m,
  ffi.Int32 pos,
);

typedef _dart_git_pathspec_match_list_entry = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_pathspec_match_list> m,
  int pos,
);

typedef _c_git_pathspec_match_list_diff_entry = ffi.Pointer<git_diff_delta>
    Function(
  ffi.Pointer<git_pathspec_match_list> m,
  ffi.Int32 pos,
);

typedef _dart_git_pathspec_match_list_diff_entry = ffi.Pointer<git_diff_delta>
    Function(
  ffi.Pointer<git_pathspec_match_list> m,
  int pos,
);

typedef _c_git_pathspec_match_list_failed_entrycount = ffi.Int32 Function(
  ffi.Pointer<git_pathspec_match_list> m,
);

typedef _dart_git_pathspec_match_list_failed_entrycount = int Function(
  ffi.Pointer<git_pathspec_match_list> m,
);

typedef _c_git_pathspec_match_list_failed_entry = ffi.Pointer<ffi.Int8>
    Function(
  ffi.Pointer<git_pathspec_match_list> m,
  ffi.Int32 pos,
);

typedef _dart_git_pathspec_match_list_failed_entry = ffi.Pointer<ffi.Int8>
    Function(
  ffi.Pointer<git_pathspec_match_list> m,
  int pos,
);

typedef _c_git_refdb_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_refdb>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_refdb_new = int Function(
  ffi.Pointer<ffi.Pointer<git_refdb>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_refdb_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_refdb>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_refdb_open = int Function(
  ffi.Pointer<ffi.Pointer<git_refdb>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_refdb_compress = ffi.Int32 Function(
  ffi.Pointer<git_refdb> refdb,
);

typedef _dart_git_refdb_compress = int Function(
  ffi.Pointer<git_refdb> refdb,
);

typedef _c_git_refdb_free = ffi.Void Function(
  ffi.Pointer<git_refdb> refdb,
);

typedef _dart_git_refdb_free = void Function(
  ffi.Pointer<git_refdb> refdb,
);

typedef _c_git_reflog_read = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_reflog>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_reflog_read = int Function(
  ffi.Pointer<ffi.Pointer<git_reflog>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_reflog_write = ffi.Int32 Function(
  ffi.Pointer<git_reflog> reflog,
);

typedef _dart_git_reflog_write = int Function(
  ffi.Pointer<git_reflog> reflog,
);

typedef _c_git_reflog_append = ffi.Int32 Function(
  ffi.Pointer<git_reflog> reflog,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> msg,
);

typedef _dart_git_reflog_append = int Function(
  ffi.Pointer<git_reflog> reflog,
  ffi.Pointer<git_oid> id,
  ffi.Pointer<git_signature> committer,
  ffi.Pointer<ffi.Int8> msg,
);

typedef _c_git_reflog_rename = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> old_name,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_reflog_rename = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> old_name,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_reflog_delete = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_git_reflog_delete = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_git_reflog_entrycount = ffi.Int32 Function(
  ffi.Pointer<git_reflog> reflog,
);

typedef _dart_git_reflog_entrycount = int Function(
  ffi.Pointer<git_reflog> reflog,
);

typedef _c_git_reflog_entry_byindex = ffi.Pointer<git_reflog_entry> Function(
  ffi.Pointer<git_reflog> reflog,
  ffi.Int32 idx,
);

typedef _dart_git_reflog_entry_byindex = ffi.Pointer<git_reflog_entry> Function(
  ffi.Pointer<git_reflog> reflog,
  int idx,
);

typedef _c_git_reflog_drop = ffi.Int32 Function(
  ffi.Pointer<git_reflog> reflog,
  ffi.Int32 idx,
  ffi.Int32 rewrite_previous_entry,
);

typedef _dart_git_reflog_drop = int Function(
  ffi.Pointer<git_reflog> reflog,
  int idx,
  int rewrite_previous_entry,
);

typedef _c_git_reflog_entry_id_old = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reflog_entry> entry,
);

typedef _dart_git_reflog_entry_id_old = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reflog_entry> entry,
);

typedef _c_git_reflog_entry_id_new = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reflog_entry> entry,
);

typedef _dart_git_reflog_entry_id_new = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_reflog_entry> entry,
);

typedef _c_git_reflog_entry_committer = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_reflog_entry> entry,
);

typedef _dart_git_reflog_entry_committer = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_reflog_entry> entry,
);

typedef _c_git_reflog_entry_message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reflog_entry> entry,
);

typedef _dart_git_reflog_entry_message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_reflog_entry> entry,
);

typedef _c_git_reflog_free = ffi.Void Function(
  ffi.Pointer<git_reflog> reflog,
);

typedef _dart_git_reflog_free = void Function(
  ffi.Pointer<git_reflog> reflog,
);

typedef _c_git_reset = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_object> target,
  ffi.Int32 reset_type,
  ffi.Pointer<git_checkout_options> checkout_opts,
);

typedef _dart_git_reset = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_object> target,
  int reset_type,
  ffi.Pointer<git_checkout_options> checkout_opts,
);

typedef _c_git_reset_from_annotated = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_annotated_commit> commit,
  ffi.Int32 reset_type,
  ffi.Pointer<git_checkout_options> checkout_opts,
);

typedef _dart_git_reset_from_annotated = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_annotated_commit> commit,
  int reset_type,
  ffi.Pointer<git_checkout_options> checkout_opts,
);

typedef _c_git_reset_default = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_object> target,
  ffi.Pointer<git_strarray> pathspecs,
);

typedef _dart_git_reset_default = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_object> target,
  ffi.Pointer<git_strarray> pathspecs,
);

typedef _c_git_revparse_single = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> spec,
);

typedef _dart_git_revparse_single = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> spec,
);

typedef _c_git_revparse_ext = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> object_out,
  ffi.Pointer<ffi.Pointer<git_reference>> reference_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> spec,
);

typedef _dart_git_revparse_ext = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> object_out,
  ffi.Pointer<ffi.Pointer<git_reference>> reference_out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> spec,
);

typedef _c_git_revparse = ffi.Int32 Function(
  ffi.Pointer<git_revspec> revspec,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> spec,
);

typedef _dart_git_revparse = int Function(
  ffi.Pointer<git_revspec> revspec,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> spec,
);

typedef _c_git_revwalk_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_revwalk>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_revwalk_new = int Function(
  ffi.Pointer<ffi.Pointer<git_revwalk>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_revwalk_reset = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walker,
);

typedef _dart_git_revwalk_reset = int Function(
  ffi.Pointer<git_revwalk> walker,
);

typedef _c_git_revwalk_push = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_revwalk_push = int Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_revwalk_push_glob = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> glob,
);

typedef _dart_git_revwalk_push_glob = int Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> glob,
);

typedef _c_git_revwalk_push_head = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef _dart_git_revwalk_push_head = int Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef _c_git_revwalk_hide = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<git_oid> commit_id,
);

typedef _dart_git_revwalk_hide = int Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<git_oid> commit_id,
);

typedef _c_git_revwalk_hide_glob = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> glob,
);

typedef _dart_git_revwalk_hide_glob = int Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> glob,
);

typedef _c_git_revwalk_hide_head = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef _dart_git_revwalk_hide_head = int Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef _c_git_revwalk_push_ref = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_revwalk_push_ref = int Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_revwalk_hide_ref = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_revwalk_hide_ref = int Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_revwalk_next = ffi.Int32 Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_revwalk> walk,
);

typedef _dart_git_revwalk_next = int Function(
  ffi.Pointer<git_oid> out,
  ffi.Pointer<git_revwalk> walk,
);

typedef _c_git_revwalk_sorting = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Uint32 sort_mode,
);

typedef _dart_git_revwalk_sorting = int Function(
  ffi.Pointer<git_revwalk> walk,
  int sort_mode,
);

typedef _c_git_revwalk_push_range = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> range,
);

typedef _dart_git_revwalk_push_range = int Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.Int8> range,
);

typedef _c_git_revwalk_simplify_first_parent = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef _dart_git_revwalk_simplify_first_parent = int Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef _c_git_revwalk_free = ffi.Void Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef _dart_git_revwalk_free = void Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef _c_git_revwalk_repository = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef _dart_git_revwalk_repository = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_revwalk> walk,
);

typedef git_revwalk_hide_cb = ffi.Int32 Function(
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_revwalk_add_hide_cb = ffi.Int32 Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.NativeFunction<git_revwalk_hide_cb>> hide_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_revwalk_add_hide_cb = int Function(
  ffi.Pointer<git_revwalk> walk,
  ffi.Pointer<ffi.NativeFunction<git_revwalk_hide_cb>> hide_cb,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_signature_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
  ffi.Int64 time,
  ffi.Int32 offset,
);

typedef _dart_git_signature_new = int Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
  int time,
  int offset,
);

typedef _c_git_signature_now = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
);

typedef _dart_git_signature_now = int Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> email,
);

typedef _c_git_signature_default = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_signature_default = int Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_signature_from_buffer = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<ffi.Int8> buf,
);

typedef _dart_git_signature_from_buffer = int Function(
  ffi.Pointer<ffi.Pointer<git_signature>> out,
  ffi.Pointer<ffi.Int8> buf,
);

typedef _c_git_signature_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_signature>> dest,
  ffi.Pointer<git_signature> sig,
);

typedef _dart_git_signature_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_signature>> dest,
  ffi.Pointer<git_signature> sig,
);

typedef _c_git_signature_free = ffi.Void Function(
  ffi.Pointer<git_signature> sig,
);

typedef _dart_git_signature_free = void Function(
  ffi.Pointer<git_signature> sig,
);

typedef _c_git_tag_lookup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tag>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _dart_git_tag_lookup = int Function(
  ffi.Pointer<ffi.Pointer<git_tag>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
);

typedef _c_git_tag_lookup_prefix = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tag>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  ffi.Int32 len,
);

typedef _dart_git_tag_lookup_prefix = int Function(
  ffi.Pointer<ffi.Pointer<git_tag>> out,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<git_oid> id,
  int len,
);

typedef _c_git_tag_free = ffi.Void Function(
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_free = void Function(
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_owner = ffi.Pointer<git_repository> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_target = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> target_out,
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_target = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> target_out,
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_target_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_target_id = ffi.Pointer<git_oid> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_target_type = ffi.Int32 Function(
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_target_type = int Function(
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_tagger = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_tagger = ffi.Pointer<git_signature> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_message = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_create = ffi.Int32 Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> tag_name,
  ffi.Pointer<git_object> target,
  ffi.Pointer<git_signature> tagger,
  ffi.Pointer<ffi.Int8> message,
  ffi.Int32 force,
);

typedef _dart_git_tag_create = int Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> tag_name,
  ffi.Pointer<git_object> target,
  ffi.Pointer<git_signature> tagger,
  ffi.Pointer<ffi.Int8> message,
  int force,
);

typedef _c_git_tag_annotation_create = ffi.Int32 Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> tag_name,
  ffi.Pointer<git_object> target,
  ffi.Pointer<git_signature> tagger,
  ffi.Pointer<ffi.Int8> message,
);

typedef _dart_git_tag_annotation_create = int Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> tag_name,
  ffi.Pointer<git_object> target,
  ffi.Pointer<git_signature> tagger,
  ffi.Pointer<ffi.Int8> message,
);

typedef _c_git_tag_create_from_buffer = ffi.Int32 Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Int32 force,
);

typedef _dart_git_tag_create_from_buffer = int Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> buffer,
  int force,
);

typedef _c_git_tag_create_lightweight = ffi.Int32 Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> tag_name,
  ffi.Pointer<git_object> target,
  ffi.Int32 force,
);

typedef _dart_git_tag_create_lightweight = int Function(
  ffi.Pointer<git_oid> oid,
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> tag_name,
  ffi.Pointer<git_object> target,
  int force,
);

typedef _c_git_tag_delete = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> tag_name,
);

typedef _dart_git_tag_delete = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.Int8> tag_name,
);

typedef _c_git_tag_list = ffi.Int32 Function(
  ffi.Pointer<git_strarray> tag_names,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_tag_list = int Function(
  ffi.Pointer<git_strarray> tag_names,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_tag_list_match = ffi.Int32 Function(
  ffi.Pointer<git_strarray> tag_names,
  ffi.Pointer<ffi.Int8> pattern,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_tag_list_match = int Function(
  ffi.Pointer<git_strarray> tag_names,
  ffi.Pointer<ffi.Int8> pattern,
  ffi.Pointer<git_repository> repo,
);

typedef git_tag_foreach_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_git_tag_foreach = ffi.Int32 Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_tag_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _dart_git_tag_foreach = int Function(
  ffi.Pointer<git_repository> repo,
  ffi.Pointer<ffi.NativeFunction<git_tag_foreach_cb>> callback,
  ffi.Pointer<ffi.Void> payload,
);

typedef _c_git_tag_peel = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_object>> tag_target_out,
  ffi.Pointer<git_tag> tag,
);

typedef _dart_git_tag_peel = int Function(
  ffi.Pointer<ffi.Pointer<git_object>> tag_target_out,
  ffi.Pointer<git_tag> tag,
);

typedef _c_git_tag_dup = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_tag>> out,
  ffi.Pointer<git_tag> source,
);

typedef _dart_git_tag_dup = int Function(
  ffi.Pointer<ffi.Pointer<git_tag>> out,
  ffi.Pointer<git_tag> source,
);

typedef _c_git_transaction_new = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_transaction>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _dart_git_transaction_new = int Function(
  ffi.Pointer<ffi.Pointer<git_transaction>> out,
  ffi.Pointer<git_repository> repo,
);

typedef _c_git_transaction_lock_ref = ffi.Int32 Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_transaction_lock_ref = int Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_transaction_set_target = ffi.Int32 Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
  ffi.Pointer<git_oid> target,
  ffi.Pointer<git_signature> sig,
  ffi.Pointer<ffi.Int8> msg,
);

typedef _dart_git_transaction_set_target = int Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
  ffi.Pointer<git_oid> target,
  ffi.Pointer<git_signature> sig,
  ffi.Pointer<ffi.Int8> msg,
);

typedef _c_git_transaction_set_symbolic_target = ffi.Int32 Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
  ffi.Pointer<ffi.Int8> target,
  ffi.Pointer<git_signature> sig,
  ffi.Pointer<ffi.Int8> msg,
);

typedef _dart_git_transaction_set_symbolic_target = int Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
  ffi.Pointer<ffi.Int8> target,
  ffi.Pointer<git_signature> sig,
  ffi.Pointer<ffi.Int8> msg,
);

typedef _c_git_transaction_set_reflog = ffi.Int32 Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
  ffi.Pointer<git_reflog> reflog,
);

typedef _dart_git_transaction_set_reflog = int Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
  ffi.Pointer<git_reflog> reflog,
);

typedef _c_git_transaction_remove = ffi.Int32 Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _dart_git_transaction_remove = int Function(
  ffi.Pointer<git_transaction> tx,
  ffi.Pointer<ffi.Int8> refname,
);

typedef _c_git_transaction_commit = ffi.Int32 Function(
  ffi.Pointer<git_transaction> tx,
);

typedef _dart_git_transaction_commit = int Function(
  ffi.Pointer<git_transaction> tx,
);

typedef _c_git_transaction_free = ffi.Void Function(
  ffi.Pointer<git_transaction> tx,
);

typedef _dart_git_transaction_free = void Function(
  ffi.Pointer<git_transaction> tx,
);

typedef _typedefC_4 = ffi.Int32 Function(
  ffi.Pointer<git_odb_stream>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
);

typedef _typedefC_5 = ffi.Int32 Function(
  ffi.Pointer<git_odb_stream>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
);

typedef _typedefC_6 = ffi.Int32 Function(
  ffi.Pointer<git_odb_stream>,
  ffi.Pointer<git_oid>,
);

typedef _typedefC_7 = ffi.Void Function(
  ffi.Pointer<git_odb_stream>,
);

typedef _typedefC_8 = ffi.Int32 Function(
  ffi.Pointer<git_odb_writepack>,
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
  ffi.Pointer<git_indexer_progress>,
);

typedef _typedefC_9 = ffi.Int32 Function(
  ffi.Pointer<git_odb_writepack>,
  ffi.Pointer<git_indexer_progress>,
);

typedef _typedefC_10 = ffi.Void Function(
  ffi.Pointer<git_odb_writepack>,
);

typedef _typedefC_12 = ffi.Void Function(
  ffi.Pointer<git_credential>,
);

typedef git_transport_message_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_11 = ffi.Int32 Function(
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_credential_acquire_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_credential>>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Uint32,
  ffi.Pointer<ffi.Void>,
);

typedef git_transport_certificate_check_cb = ffi.Int32 Function(
  ffi.Pointer<git_cert>,
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_13 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<git_oid>,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_transfer_progress_cb = ffi.Int32 Function(
  ffi.Uint32,
  ffi.Uint32,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_update_reference_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef git_push_negotiation = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_push_update>>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_transport_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_transport>>,
  ffi.Pointer<git_remote>,
  ffi.Pointer<ffi.Void>,
);

typedef git_url_resolve_cb = ffi.Int32 Function(
  ffi.Pointer<git_buf>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_14 = ffi.Int32 Function(
  ffi.Pointer<git_writestream>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
);

typedef _typedefC_15 = ffi.Int32 Function(
  ffi.Pointer<git_writestream>,
);

typedef _typedefC_16 = ffi.Void Function(
  ffi.Pointer<git_writestream>,
);

typedef git_diff_notify_cb = ffi.Int32 Function(
  ffi.Pointer<git_diff>,
  ffi.Pointer<git_diff_delta>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef git_diff_progress_cb = ffi.Int32 Function(
  ffi.Pointer<git_diff>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_17 = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>>,
  ffi.Pointer<git_diff_file>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_18 = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>>,
  ffi.Pointer<git_diff_file>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_19 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_20 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32>,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef git_apply_delta_cb = ffi.Int32 Function(
  ffi.Pointer<git_diff_delta>,
  ffi.Pointer<ffi.Void>,
);

typedef git_apply_hunk_cb = ffi.Int32 Function(
  ffi.Pointer<git_diff_hunk>,
  ffi.Pointer<ffi.Void>,
);

typedef git_checkout_notify_cb = ffi.Int32 Function(
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<git_diff_file>,
  ffi.Pointer<git_diff_file>,
  ffi.Pointer<git_diff_file>,
  ffi.Pointer<ffi.Void>,
);

typedef git_checkout_progress_cb = ffi.Void Function(
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_checkout_perfdata_cb = ffi.Void Function(
  ffi.Pointer<git_checkout_perfdata>,
  ffi.Pointer<ffi.Void>,
);

typedef git_repository_create_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_repository>>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);

typedef git_remote_create_cb = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<git_remote>>,
  ffi.Pointer<git_repository>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_21 = ffi.Void Function(
  ffi.Pointer<git_config_entry>,
);

typedef git_commit_signing_cb = ffi.Int32 Function(
  ffi.Pointer<git_buf>,
  ffi.Pointer<git_buf>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Void>,
);

typedef git_stash_apply_progress_cb = ffi.Int32 Function(
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
);
